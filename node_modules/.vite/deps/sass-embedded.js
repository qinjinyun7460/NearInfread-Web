import { a as __toCommonJS, i as __require, n as __esm, o as __toESM, r as __export, t as __commonJS } from "./chunk-DGlK_Vub.js";

//#region node_modules/sass-embedded/dist/package.json
var require_package = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/package.json": ((exports, module) => {
	module.exports = {
		"name": "sass-embedded",
		"version": "1.93.3",
		"protocol-version": "3.2.0",
		"compiler-version": "1.93.3",
		"description": "Node.js library that communicates with Embedded Dart Sass using the Embedded Sass protocol",
		"repository": "sass/embedded-host-node",
		"author": "Google Inc.",
		"license": "MIT",
		"exports": {
			"import": {
				"types": "./dist/types/index.m.d.ts",
				"default": "./dist/lib/index.mjs"
			},
			"types": "./dist/types/index.d.ts",
			"default": "./dist/lib/index.js"
		},
		"main": "dist/lib/index.js",
		"types": "dist/types/index.d.ts",
		"files": ["dist/**/*"],
		"engines": { "node": ">=16.0.0" },
		"bin": { "sass": "dist/bin/sass.js" },
		"scripts": {
			"init": "ts-node ./tool/init.ts",
			"check": "npm-run-all check:gts check:tsc check:mjs",
			"check:gts": "gts check",
			"check:tsc": "tsc --noEmit",
			"check:mjs": "prettier -0check **/*.mjs",
			"clean": "gts clean",
			"compile": "tsc -p tsconfig.build.json && cp lib/index.mjs dist/lib/index.mjs && cp -r lib/src/vendor/sass/ dist/lib/src/vendor/sass && cp dist/lib/src/vendor/sass/index.d.ts dist/lib/src/vendor/sass/index.m.d.ts",
			"fix": "npm-run-all fix:ts fix:mjs",
			"fix:ts": "gts fix",
			"fix:mjs": "prettier --write **/*.mjs",
			"prepublishOnly": "npm run clean && ts-node ./tool/prepare-release.ts",
			"test": "jest"
		},
		"optionalDependencies": {
			"sass-embedded-all-unknown": "1.93.3",
			"sass-embedded-android-arm": "1.93.3",
			"sass-embedded-android-arm64": "1.93.3",
			"sass-embedded-android-riscv64": "1.93.3",
			"sass-embedded-android-x64": "1.93.3",
			"sass-embedded-darwin-arm64": "1.93.3",
			"sass-embedded-darwin-x64": "1.93.3",
			"sass-embedded-linux-arm": "1.93.3",
			"sass-embedded-linux-arm64": "1.93.3",
			"sass-embedded-linux-musl-arm": "1.93.3",
			"sass-embedded-linux-musl-arm64": "1.93.3",
			"sass-embedded-linux-musl-riscv64": "1.93.3",
			"sass-embedded-linux-musl-x64": "1.93.3",
			"sass-embedded-linux-riscv64": "1.93.3",
			"sass-embedded-linux-x64": "1.93.3",
			"sass-embedded-unknown-all": "1.93.3",
			"sass-embedded-win32-arm64": "1.93.3",
			"sass-embedded-win32-x64": "1.93.3"
		},
		"dependencies": {
			"@bufbuild/protobuf": "^2.5.0",
			"buffer-builder": "^0.2.0",
			"colorjs.io": "^0.5.0",
			"immutable": "^5.0.2",
			"rxjs": "^7.4.0",
			"supports-color": "^8.1.1",
			"sync-child-process": "^1.0.2",
			"varint": "^6.0.0"
		},
		"devDependencies": {
			"@bufbuild/buf": "^1.54.0",
			"@bufbuild/protoc-gen-es": "^2.5.0",
			"@types/buffer-builder": "^0.2.0",
			"@types/google-protobuf": "^3.7.2",
			"@types/jest": "^30.0.0",
			"@types/node": "^24.0.3",
			"@types/shelljs": "^0.8.8",
			"@types/supports-color": "^8.1.1",
			"@types/tar": "^6.1.0",
			"@types/varint": "^6.0.1",
			"@types/yargs": "^17.0.4",
			"extract-zip": "^2.0.1",
			"gts": "^6.0.2",
			"jest": "^30.0.3",
			"npm-run-all": "^4.1.5",
			"shelljs": "^0.10.0",
			"simple-git": "^3.15.1",
			"source-map-js": "^1.0.2",
			"tar": "^7.4.3",
			"ts-jest": "^29.0.5",
			"ts-node": "^10.2.1",
			"typescript": "^5.0.2",
			"yaml": "^2.2.1",
			"yargs": "^17.2.1"
		}
	};
}) });

//#endregion
//#region node_modules/immutable/dist/immutable.es.js
var immutable_es_exports = /* @__PURE__ */ __export({
	Collection: () => Collection,
	Iterable: () => Iterable,
	List: () => List,
	Map: () => Map$1,
	OrderedMap: () => OrderedMap,
	OrderedSet: () => OrderedSet,
	PairSorting: () => PairSorting,
	Range: () => Range,
	Record: () => Record,
	Repeat: () => Repeat,
	Seq: () => Seq,
	Set: () => Set$1,
	Stack: () => Stack,
	fromJS: () => fromJS,
	get: () => get$1,
	getIn: () => getIn$1,
	has: () => has,
	hasIn: () => hasIn$1,
	hash: () => hash,
	is: () => is,
	isAssociative: () => isAssociative,
	isCollection: () => isCollection,
	isImmutable: () => isImmutable,
	isIndexed: () => isIndexed,
	isKeyed: () => isKeyed,
	isList: () => isList,
	isMap: () => isMap,
	isOrdered: () => isOrdered,
	isOrderedMap: () => isOrderedMap,
	isOrderedSet: () => isOrderedSet,
	isPlainObject: () => isPlainObject,
	isRecord: () => isRecord,
	isSeq: () => isSeq,
	isSet: () => isSet,
	isStack: () => isStack,
	isValueObject: () => isValueObject,
	merge: () => merge$3,
	mergeDeep: () => mergeDeep$1,
	mergeDeepWith: () => mergeDeepWith$1,
	mergeWith: () => mergeWith$2,
	remove: () => remove,
	removeIn: () => removeIn,
	set: () => set$1,
	setIn: () => setIn$1,
	update: () => update$1,
	updateIn: () => updateIn,
	version: () => version
});
/**
* True if `maybeIndexed` is a Collection.Indexed, or any of its subclasses.
*
* ```js
* import { isIndexed, Map, List, Stack, Set } from 'immutable';
*
* isIndexed([]); // false
* isIndexed({}); // false
* isIndexed(Map()); // false
* isIndexed(List()); // true
* isIndexed(Stack()); // true
* isIndexed(Set()); // false
* ```
*/
function isIndexed(maybeIndexed) {
	return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}
/**
* True if `maybeKeyed` is a Collection.Keyed, or any of its subclasses.
*
* ```js
* import { isKeyed, Map, List, Stack } from 'immutable';
*
* isKeyed([]); // false
* isKeyed({}); // false
* isKeyed(Map()); // true
* isKeyed(List()); // false
* isKeyed(Stack()); // false
* ```
*/
function isKeyed(maybeKeyed) {
	return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}
/**
* True if `maybeAssociative` is either a Keyed or Indexed Collection.
*
* ```js
* import { isAssociative, Map, List, Stack, Set } from 'immutable';
*
* isAssociative([]); // false
* isAssociative({}); // false
* isAssociative(Map()); // true
* isAssociative(List()); // true
* isAssociative(Stack()); // true
* isAssociative(Set()); // false
* ```
*/
function isAssociative(maybeAssociative) {
	return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
/**
* True if `maybeCollection` is a Collection, or any of its subclasses.
*
* ```js
* import { isCollection, Map, List, Stack } from 'immutable';
*
* isCollection([]); // false
* isCollection({}); // false
* isCollection(Map()); // true
* isCollection(List()); // true
* isCollection(Stack()); // true
* ```
*/
function isCollection(maybeCollection) {
	return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}
function iteratorValue(type$1, k, v, iteratorResult) {
	var value = type$1 === ITERATE_KEYS ? k : type$1 === ITERATE_VALUES ? v : [k, v];
	iteratorResult ? iteratorResult.value = value : iteratorResult = {
		value,
		done: false
	};
	return iteratorResult;
}
function iteratorDone() {
	return {
		value: void 0,
		done: true
	};
}
function hasIterator(maybeIterable) {
	if (Array.isArray(maybeIterable)) return true;
	return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
	return !!(maybeIterator && typeof maybeIterator.next === "function");
}
function getIterator(iterable) {
	var iteratorFn = getIteratorFn(iterable);
	return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
	var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
	if (typeof iteratorFn === "function") return iteratorFn;
}
function isEntriesIterable(maybeIterable) {
	var iteratorFn = getIteratorFn(maybeIterable);
	return iteratorFn && iteratorFn === maybeIterable.entries;
}
function isKeysIterable(maybeIterable) {
	var iteratorFn = getIteratorFn(maybeIterable);
	return iteratorFn && iteratorFn === maybeIterable.keys;
}
function MakeRef() {
	return { value: false };
}
function SetRef(ref) {
	if (ref) ref.value = true;
}
function OwnerID() {}
function ensureSize(iter) {
	if (iter.size === void 0) iter.size = iter.__iterate(returnTrue);
	return iter.size;
}
function wrapIndex(iter, index) {
	if (typeof index !== "number") {
		var uint32Index = index >>> 0;
		if ("" + uint32Index !== index || uint32Index === 4294967295) return NaN;
		index = uint32Index;
	}
	return index < 0 ? ensureSize(iter) + index : index;
}
function returnTrue() {
	return true;
}
function wholeSlice(begin, end, size) {
	return (begin === 0 && !isNeg(begin) || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
}
function resolveBegin(begin, size) {
	return resolveIndex(begin, size, 0);
}
function resolveEnd(end, size) {
	return resolveIndex(end, size, size);
}
function resolveIndex(index, size, defaultIndex) {
	return index === void 0 ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === void 0 || size === index ? index : Math.min(size, index) | 0;
}
function isNeg(value) {
	return value < 0 || value === 0 && 1 / value === -Infinity;
}
/**
* True if `maybeRecord` is a Record.
*/
function isRecord(maybeRecord) {
	return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}
/**
* True if `maybeImmutable` is an Immutable Collection or Record.
*
* Note: Still returns true even if the collections is within a `withMutations()`.
*
* ```js
* import { isImmutable, Map, List, Stack } from 'immutable';
* isImmutable([]); // false
* isImmutable({}); // false
* isImmutable(Map()); // true
* isImmutable(List()); // true
* isImmutable(Stack()); // true
* isImmutable(Map().asMutable()); // true
* ```
*/
function isImmutable(maybeImmutable) {
	return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
function isOrdered(maybeOrdered) {
	return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}
/**
* True if `maybeSeq` is a Seq.
*/
function isSeq(maybeSeq) {
	return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}
function isArrayLike(value) {
	if (Array.isArray(value) || typeof value === "string") return true;
	return value && typeof value === "object" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? Object.keys(value).length === 1 : value.hasOwnProperty(value.length - 1));
}
function emptySequence() {
	return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value) {
	var seq = maybeIndexedSeqFromValue(value);
	if (seq) return seq.fromEntrySeq();
	if (typeof value === "object") return new ObjectSeq(value);
	throw new TypeError("Expected Array or collection object of [k, v] entries, or keyed object: " + value);
}
function indexedSeqFromValue(value) {
	var seq = maybeIndexedSeqFromValue(value);
	if (seq) return seq;
	throw new TypeError("Expected Array or collection object of values: " + value);
}
function seqFromValue(value) {
	var seq = maybeIndexedSeqFromValue(value);
	if (seq) return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
	if (typeof value === "object") return new ObjectSeq(value);
	throw new TypeError("Expected Array or collection object of values, or keyed object: " + value);
}
function maybeIndexedSeqFromValue(value) {
	return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : void 0;
}
function asImmutable() {
	return this.__ensureOwner();
}
function asMutable() {
	return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
function smi(i32) {
	return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
function hash(o) {
	if (o == null) return hashNullish(o);
	if (typeof o.hashCode === "function") return smi(o.hashCode(o));
	var v = valueOf(o);
	if (v == null) return hashNullish(v);
	switch (typeof v) {
		case "boolean": return v ? 1108378657 : 1108378656;
		case "number": return hashNumber(v);
		case "string": return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
		case "object":
		case "function": return hashJSObj(v);
		case "symbol": return hashSymbol(v);
		default:
			if (typeof v.toString === "function") return hashString(v.toString());
			throw new Error("Value type " + typeof v + " cannot be hashed.");
	}
}
function hashNullish(nullish) {
	return nullish === null ? 1108378658 : 1108378659;
}
function hashNumber(n$2) {
	if (n$2 !== n$2 || n$2 === Infinity) return 0;
	var hash$1 = n$2 | 0;
	if (hash$1 !== n$2) hash$1 ^= n$2 * 4294967295;
	while (n$2 > 4294967295) {
		n$2 /= 4294967295;
		hash$1 ^= n$2;
	}
	return smi(hash$1);
}
function cachedHashString(string) {
	var hashed = stringHashCache[string];
	if (hashed === void 0) {
		hashed = hashString(string);
		if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
			STRING_HASH_CACHE_SIZE = 0;
			stringHashCache = {};
		}
		STRING_HASH_CACHE_SIZE++;
		stringHashCache[string] = hashed;
	}
	return hashed;
}
function hashString(string) {
	var hashed = 0;
	for (var ii = 0; ii < string.length; ii++) hashed = 31 * hashed + string.charCodeAt(ii) | 0;
	return smi(hashed);
}
function hashSymbol(sym) {
	var hashed = symbolMap[sym];
	if (hashed !== void 0) return hashed;
	hashed = nextHash();
	symbolMap[sym] = hashed;
	return hashed;
}
function hashJSObj(obj) {
	var hashed;
	if (usingWeakMap) {
		hashed = weakMap.get(obj);
		if (hashed !== void 0) return hashed;
	}
	hashed = obj[UID_HASH_KEY];
	if (hashed !== void 0) return hashed;
	if (!canDefineProperty) {
		hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
		if (hashed !== void 0) return hashed;
		hashed = getIENodeHash(obj);
		if (hashed !== void 0) return hashed;
	}
	hashed = nextHash();
	if (usingWeakMap) weakMap.set(obj, hashed);
	else if (isExtensible !== void 0 && isExtensible(obj) === false) throw new Error("Non-extensible objects are not allowed as keys.");
	else if (canDefineProperty) Object.defineProperty(obj, UID_HASH_KEY, {
		enumerable: false,
		configurable: false,
		writable: false,
		value: hashed
	});
	else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
		obj.propertyIsEnumerable = function() {
			return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
		};
		obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
	} else if (obj.nodeType !== void 0) obj[UID_HASH_KEY] = hashed;
	else throw new Error("Unable to set a non-enumerable property on object.");
	return hashed;
}
function getIENodeHash(node) {
	if (node && node.nodeType > 0) switch (node.nodeType) {
		case 1: return node.uniqueID;
		case 9: return node.documentElement && node.documentElement.uniqueID;
	}
}
function valueOf(obj) {
	return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
	var nextHash$1 = ++_objHashUID;
	if (_objHashUID & 1073741824) _objHashUID = 0;
	return nextHash$1;
}
function flipFactory(collection) {
	var flipSequence = makeSequence(collection);
	flipSequence._iter = collection;
	flipSequence.size = collection.size;
	flipSequence.flip = function() {
		return collection;
	};
	flipSequence.reverse = function() {
		var reversedSequence = collection.reverse.apply(this);
		reversedSequence.flip = function() {
			return collection.reverse();
		};
		return reversedSequence;
	};
	flipSequence.has = function(key) {
		return collection.includes(key);
	};
	flipSequence.includes = function(key) {
		return collection.has(key);
	};
	flipSequence.cacheResult = cacheResultThrough;
	flipSequence.__iterateUncached = function(fn, reverse) {
		var this$1$1 = this;
		return collection.__iterate(function(v, k) {
			return fn(k, v, this$1$1) !== false;
		}, reverse);
	};
	flipSequence.__iteratorUncached = function(type$1, reverse) {
		if (type$1 === ITERATE_ENTRIES) {
			var iterator = collection.__iterator(type$1, reverse);
			return new Iterator(function() {
				var step = iterator.next();
				if (!step.done) {
					var k = step.value[0];
					step.value[0] = step.value[1];
					step.value[1] = k;
				}
				return step;
			});
		}
		return collection.__iterator(type$1 === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
	};
	return flipSequence;
}
function mapFactory(collection, mapper, context$1) {
	var mappedSequence = makeSequence(collection);
	mappedSequence.size = collection.size;
	mappedSequence.has = function(key) {
		return collection.has(key);
	};
	mappedSequence.get = function(key, notSetValue) {
		var v = collection.get(key, NOT_SET);
		return v === NOT_SET ? notSetValue : mapper.call(context$1, v, key, collection);
	};
	mappedSequence.__iterateUncached = function(fn, reverse) {
		var this$1$1 = this;
		return collection.__iterate(function(v, k, c$1) {
			return fn(mapper.call(context$1, v, k, c$1), k, this$1$1) !== false;
		}, reverse);
	};
	mappedSequence.__iteratorUncached = function(type$1, reverse) {
		var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
		return new Iterator(function() {
			var step = iterator.next();
			if (step.done) return step;
			var entry = step.value;
			var key = entry[0];
			return iteratorValue(type$1, key, mapper.call(context$1, entry[1], key, collection), step);
		});
	};
	return mappedSequence;
}
function reverseFactory(collection, useKeys) {
	var this$1$1 = this;
	var reversedSequence = makeSequence(collection);
	reversedSequence._iter = collection;
	reversedSequence.size = collection.size;
	reversedSequence.reverse = function() {
		return collection;
	};
	if (collection.flip) reversedSequence.flip = function() {
		var flipSequence = flipFactory(collection);
		flipSequence.reverse = function() {
			return collection.flip();
		};
		return flipSequence;
	};
	reversedSequence.get = function(key, notSetValue) {
		return collection.get(useKeys ? key : -1 - key, notSetValue);
	};
	reversedSequence.has = function(key) {
		return collection.has(useKeys ? key : -1 - key);
	};
	reversedSequence.includes = function(value) {
		return collection.includes(value);
	};
	reversedSequence.cacheResult = cacheResultThrough;
	reversedSequence.__iterate = function(fn, reverse) {
		var this$1$1$1 = this;
		var i = 0;
		reverse && ensureSize(collection);
		return collection.__iterate(function(v, k) {
			return fn(v, useKeys ? k : reverse ? this$1$1$1.size - ++i : i++, this$1$1$1);
		}, !reverse);
	};
	reversedSequence.__iterator = function(type$1, reverse) {
		var i = 0;
		reverse && ensureSize(collection);
		var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
		return new Iterator(function() {
			var step = iterator.next();
			if (step.done) return step;
			var entry = step.value;
			return iteratorValue(type$1, useKeys ? entry[0] : reverse ? this$1$1.size - ++i : i++, entry[1], step);
		});
	};
	return reversedSequence;
}
function filterFactory(collection, predicate, context$1, useKeys) {
	var filterSequence = makeSequence(collection);
	if (useKeys) {
		filterSequence.has = function(key) {
			var v = collection.get(key, NOT_SET);
			return v !== NOT_SET && !!predicate.call(context$1, v, key, collection);
		};
		filterSequence.get = function(key, notSetValue) {
			var v = collection.get(key, NOT_SET);
			return v !== NOT_SET && predicate.call(context$1, v, key, collection) ? v : notSetValue;
		};
	}
	filterSequence.__iterateUncached = function(fn, reverse) {
		var this$1$1 = this;
		var iterations = 0;
		collection.__iterate(function(v, k, c$1) {
			if (predicate.call(context$1, v, k, c$1)) {
				iterations++;
				return fn(v, useKeys ? k : iterations - 1, this$1$1);
			}
		}, reverse);
		return iterations;
	};
	filterSequence.__iteratorUncached = function(type$1, reverse) {
		var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
		var iterations = 0;
		return new Iterator(function() {
			while (true) {
				var step = iterator.next();
				if (step.done) return step;
				var entry = step.value;
				var key = entry[0];
				var value = entry[1];
				if (predicate.call(context$1, value, key, collection)) return iteratorValue(type$1, useKeys ? key : iterations++, value, step);
			}
		});
	};
	return filterSequence;
}
function countByFactory(collection, grouper, context$1) {
	var groups = Map$1().asMutable();
	collection.__iterate(function(v, k) {
		groups.update(grouper.call(context$1, v, k, collection), 0, function(a$1) {
			return a$1 + 1;
		});
	});
	return groups.asImmutable();
}
function groupByFactory(collection, grouper, context$1) {
	var isKeyedIter = isKeyed(collection);
	var groups = (isOrdered(collection) ? OrderedMap() : Map$1()).asMutable();
	collection.__iterate(function(v, k) {
		groups.update(grouper.call(context$1, v, k, collection), function(a$1) {
			return a$1 = a$1 || [], a$1.push(isKeyedIter ? [k, v] : v), a$1;
		});
	});
	var coerce = collectionClass(collection);
	return groups.map(function(arr) {
		return reify(collection, coerce(arr));
	}).asImmutable();
}
function partitionFactory(collection, predicate, context$1) {
	var isKeyedIter = isKeyed(collection);
	var groups = [[], []];
	collection.__iterate(function(v, k) {
		groups[predicate.call(context$1, v, k, collection) ? 1 : 0].push(isKeyedIter ? [k, v] : v);
	});
	var coerce = collectionClass(collection);
	return groups.map(function(arr) {
		return reify(collection, coerce(arr));
	});
}
function sliceFactory(collection, begin, end, useKeys) {
	var originalSize = collection.size;
	if (wholeSlice(begin, end, originalSize)) return collection;
	if (typeof originalSize === "undefined" && (begin < 0 || end < 0)) return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
	var resolvedBegin = resolveBegin(begin, originalSize);
	var resolvedSize = resolveEnd(end, originalSize) - resolvedBegin;
	var sliceSize;
	if (resolvedSize === resolvedSize) sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	var sliceSeq = makeSequence(collection);
	sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || void 0;
	if (!useKeys && isSeq(collection) && sliceSize >= 0) sliceSeq.get = function(index, notSetValue) {
		index = wrapIndex(this, index);
		return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
	};
	sliceSeq.__iterateUncached = function(fn, reverse) {
		var this$1$1 = this;
		if (sliceSize === 0) return 0;
		if (reverse) return this.cacheResult().__iterate(fn, reverse);
		var skipped = 0;
		var isSkipping = true;
		var iterations = 0;
		collection.__iterate(function(v, k) {
			if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
				iterations++;
				return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
			}
		});
		return iterations;
	};
	sliceSeq.__iteratorUncached = function(type$1, reverse) {
		if (sliceSize !== 0 && reverse) return this.cacheResult().__iterator(type$1, reverse);
		if (sliceSize === 0) return new Iterator(iteratorDone);
		var iterator = collection.__iterator(type$1, reverse);
		var skipped = 0;
		var iterations = 0;
		return new Iterator(function() {
			while (skipped++ < resolvedBegin) iterator.next();
			if (++iterations > sliceSize) return iteratorDone();
			var step = iterator.next();
			if (useKeys || type$1 === ITERATE_VALUES || step.done) return step;
			if (type$1 === ITERATE_KEYS) return iteratorValue(type$1, iterations - 1, void 0, step);
			return iteratorValue(type$1, iterations - 1, step.value[1], step);
		});
	};
	return sliceSeq;
}
function takeWhileFactory(collection, predicate, context$1) {
	var takeSequence = makeSequence(collection);
	takeSequence.__iterateUncached = function(fn, reverse) {
		var this$1$1 = this;
		if (reverse) return this.cacheResult().__iterate(fn, reverse);
		var iterations = 0;
		collection.__iterate(function(v, k, c$1) {
			return predicate.call(context$1, v, k, c$1) && ++iterations && fn(v, k, this$1$1);
		});
		return iterations;
	};
	takeSequence.__iteratorUncached = function(type$1, reverse) {
		var this$1$1 = this;
		if (reverse) return this.cacheResult().__iterator(type$1, reverse);
		var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
		var iterating = true;
		return new Iterator(function() {
			if (!iterating) return iteratorDone();
			var step = iterator.next();
			if (step.done) return step;
			var entry = step.value;
			var k = entry[0];
			var v = entry[1];
			if (!predicate.call(context$1, v, k, this$1$1)) {
				iterating = false;
				return iteratorDone();
			}
			return type$1 === ITERATE_ENTRIES ? step : iteratorValue(type$1, k, v, step);
		});
	};
	return takeSequence;
}
function skipWhileFactory(collection, predicate, context$1, useKeys) {
	var skipSequence = makeSequence(collection);
	skipSequence.__iterateUncached = function(fn, reverse) {
		var this$1$1 = this;
		if (reverse) return this.cacheResult().__iterate(fn, reverse);
		var isSkipping = true;
		var iterations = 0;
		collection.__iterate(function(v, k, c$1) {
			if (!(isSkipping && (isSkipping = predicate.call(context$1, v, k, c$1)))) {
				iterations++;
				return fn(v, useKeys ? k : iterations - 1, this$1$1);
			}
		});
		return iterations;
	};
	skipSequence.__iteratorUncached = function(type$1, reverse) {
		var this$1$1 = this;
		if (reverse) return this.cacheResult().__iterator(type$1, reverse);
		var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
		var skipping = true;
		var iterations = 0;
		return new Iterator(function() {
			var step;
			var k;
			var v;
			do {
				step = iterator.next();
				if (step.done) {
					if (useKeys || type$1 === ITERATE_VALUES) return step;
					if (type$1 === ITERATE_KEYS) return iteratorValue(type$1, iterations++, void 0, step);
					return iteratorValue(type$1, iterations++, step.value[1], step);
				}
				var entry = step.value;
				k = entry[0];
				v = entry[1];
				skipping && (skipping = predicate.call(context$1, v, k, this$1$1));
			} while (skipping);
			return type$1 === ITERATE_ENTRIES ? step : iteratorValue(type$1, k, v, step);
		});
	};
	return skipSequence;
}
function concatFactory(collection, values) {
	var isKeyedCollection = isKeyed(collection);
	var iters = [collection].concat(values).map(function(v) {
		if (!isCollection(v)) v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
		else if (isKeyedCollection) v = KeyedCollection(v);
		return v;
	}).filter(function(v) {
		return v.size !== 0;
	});
	if (iters.length === 0) return collection;
	if (iters.length === 1) {
		var singleton = iters[0];
		if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) return singleton;
	}
	return new ConcatSeq(iters);
}
function flattenFactory(collection, depth, useKeys) {
	var flatSequence = makeSequence(collection);
	flatSequence.__iterateUncached = function(fn, reverse) {
		if (reverse) return this.cacheResult().__iterate(fn, reverse);
		var iterations = 0;
		var stopped = false;
		function flatDeep(iter, currentDepth) {
			iter.__iterate(function(v, k) {
				if ((!depth || currentDepth < depth) && isCollection(v)) flatDeep(v, currentDepth + 1);
				else {
					iterations++;
					if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) stopped = true;
				}
				return !stopped;
			}, reverse);
		}
		flatDeep(collection, 0);
		return iterations;
	};
	flatSequence.__iteratorUncached = function(type$1, reverse) {
		if (reverse) return this.cacheResult().__iterator(type$1, reverse);
		var iterator = collection.__iterator(type$1, reverse);
		var stack = [];
		var iterations = 0;
		return new Iterator(function() {
			while (iterator) {
				var step = iterator.next();
				if (step.done !== false) {
					iterator = stack.pop();
					continue;
				}
				var v = step.value;
				if (type$1 === ITERATE_ENTRIES) v = v[1];
				if ((!depth || stack.length < depth) && isCollection(v)) {
					stack.push(iterator);
					iterator = v.__iterator(type$1, reverse);
				} else return useKeys ? step : iteratorValue(type$1, iterations++, v, step);
			}
			return iteratorDone();
		});
	};
	return flatSequence;
}
function flatMapFactory(collection, mapper, context$1) {
	var coerce = collectionClass(collection);
	return collection.toSeq().map(function(v, k) {
		return coerce(mapper.call(context$1, v, k, collection));
	}).flatten(true);
}
function interposeFactory(collection, separator) {
	var interposedSequence = makeSequence(collection);
	interposedSequence.size = collection.size && collection.size * 2 - 1;
	interposedSequence.__iterateUncached = function(fn, reverse) {
		var this$1$1 = this;
		var iterations = 0;
		collection.__iterate(function(v) {
			return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
		}, reverse);
		return iterations;
	};
	interposedSequence.__iteratorUncached = function(type$1, reverse) {
		var iterator = collection.__iterator(ITERATE_VALUES, reverse);
		var iterations = 0;
		var step;
		return new Iterator(function() {
			if (!step || iterations % 2) {
				step = iterator.next();
				if (step.done) return step;
			}
			return iterations % 2 ? iteratorValue(type$1, iterations++, separator) : iteratorValue(type$1, iterations++, step.value, step);
		});
	};
	return interposedSequence;
}
function sortFactory(collection, comparator, mapper) {
	if (!comparator) comparator = defaultComparator;
	var isKeyedCollection = isKeyed(collection);
	var index = 0;
	var entries = collection.toSeq().map(function(v, k) {
		return [
			k,
			v,
			index++,
			mapper ? mapper(v, k, collection) : v
		];
	}).valueSeq().toArray();
	entries.sort(function(a$1, b$2) {
		return comparator(a$1[3], b$2[3]) || a$1[2] - b$2[2];
	}).forEach(isKeyedCollection ? function(v, i) {
		entries[i].length = 2;
	} : function(v, i) {
		entries[i] = v[1];
	});
	return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);
}
function maxFactory(collection, comparator, mapper) {
	if (!comparator) comparator = defaultComparator;
	if (mapper) {
		var entry = collection.toSeq().map(function(v, k) {
			return [v, mapper(v, k, collection)];
		}).reduce(function(a$1, b$2) {
			return maxCompare(comparator, a$1[1], b$2[1]) ? b$2 : a$1;
		});
		return entry && entry[0];
	}
	return collection.reduce(function(a$1, b$2) {
		return maxCompare(comparator, a$1, b$2) ? b$2 : a$1;
	});
}
function maxCompare(comparator, a$1, b$2) {
	var comp = comparator(b$2, a$1);
	return comp === 0 && b$2 !== a$1 && (b$2 === void 0 || b$2 === null || b$2 !== b$2) || comp > 0;
}
function zipWithFactory(keyIter, zipper, iters, zipAll$1) {
	var zipSequence = makeSequence(keyIter);
	var sizes = new ArraySeq(iters).map(function(i) {
		return i.size;
	});
	zipSequence.size = zipAll$1 ? sizes.max() : sizes.min();
	zipSequence.__iterate = function(fn, reverse) {
		var iterator = this.__iterator(ITERATE_VALUES, reverse);
		var step;
		var iterations = 0;
		while (!(step = iterator.next()).done) if (fn(step.value, iterations++, this) === false) break;
		return iterations;
	};
	zipSequence.__iteratorUncached = function(type$1, reverse) {
		var iterators = iters.map(function(i) {
			return i = Collection(i), getIterator(reverse ? i.reverse() : i);
		});
		var iterations = 0;
		var isDone = false;
		return new Iterator(function() {
			var steps$1;
			if (!isDone) {
				steps$1 = iterators.map(function(i) {
					return i.next();
				});
				isDone = zipAll$1 ? steps$1.every(function(s) {
					return s.done;
				}) : steps$1.some(function(s) {
					return s.done;
				});
			}
			if (isDone) return iteratorDone();
			return iteratorValue(type$1, iterations++, zipper.apply(null, steps$1.map(function(s) {
				return s.value;
			})));
		});
	};
	return zipSequence;
}
function reify(iter, seq) {
	return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
function validateEntry(entry) {
	if (entry !== Object(entry)) throw new TypeError("Expected [K, V] tuple: " + entry);
}
function collectionClass(collection) {
	return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}
function makeSequence(collection) {
	return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);
}
function cacheResultThrough() {
	if (this._iter.cacheResult) {
		this._iter.cacheResult();
		this.size = this._iter.size;
		return this;
	}
	return Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a$1, b$2) {
	if (a$1 === void 0 && b$2 === void 0) return 0;
	if (a$1 === void 0) return 1;
	if (b$2 === void 0) return -1;
	return a$1 > b$2 ? 1 : a$1 < b$2 ? -1 : 0;
}
/**
* True if `maybeValue` is a JavaScript Object which has *both* `equals()`
* and `hashCode()` methods.
*
* Any two instances of *value objects* can be compared for value equality with
* `Immutable.is()` and can be used as keys in a `Map` or members in a `Set`.
*/
function isValueObject(maybeValue) {
	return Boolean(maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function");
}
/**
* An extension of the "same-value" algorithm as [described for use by ES6 Map
* and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
*
* NaN is considered the same as NaN, however -0 and 0 are considered the same
* value, which is different from the algorithm described by
* [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
*
* This is extended further to allow Objects to describe the values they
* represent, by way of `valueOf` or `equals` (and `hashCode`).
*
* Note: because of this extension, the key equality of Immutable.Map and the
* value equality of Immutable.Set will differ from ES6 Map and Set.
*
* ### Defining custom values
*
* The easiest way to describe the value an object represents is by implementing
* `valueOf`. For example, `Date` represents a value by returning a unix
* timestamp for `valueOf`:
*
*     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
*     var date2 = new Date(1234567890000);
*     date1.valueOf(); // 1234567890000
*     assert( date1 !== date2 );
*     assert( Immutable.is( date1, date2 ) );
*
* Note: overriding `valueOf` may have other implications if you use this object
* where JavaScript expects a primitive, such as implicit string coercion.
*
* For more complex types, especially collections, implementing `valueOf` may
* not be performant. An alternative is to implement `equals` and `hashCode`.
*
* `equals` takes another object, presumably of similar type, and returns true
* if it is equal. Equality is symmetrical, so the same result should be
* returned if this and the argument are flipped.
*
*     assert( a.equals(b) === b.equals(a) );
*
* `hashCode` returns a 32bit integer number representing the object which will
* be used to determine how to store the value object in a Map or Set. You must
* provide both or neither methods, one must not exist without the other.
*
* Also, an important relationship between these methods must be upheld: if two
* values are equal, they *must* return the same hashCode. If the values are not
* equal, they might have the same hashCode; this is called a hash collision,
* and while undesirable for performance reasons, it is acceptable.
*
*     if (a.equals(b)) {
*       assert( a.hashCode() === b.hashCode() );
*     }
*
* All Immutable collections are Value Objects: they implement `equals()`
* and `hashCode()`.
*/
function is(valueA, valueB) {
	if (valueA === valueB || valueA !== valueA && valueB !== valueB) return true;
	if (!valueA || !valueB) return false;
	if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
		valueA = valueA.valueOf();
		valueB = valueB.valueOf();
		if (valueA === valueB || valueA !== valueA && valueB !== valueB) return true;
		if (!valueA || !valueB) return false;
	}
	return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}
function update$1(collection, key, notSetValue, updater) {
	return updateIn(collection, [key], notSetValue, updater);
}
function merge$1$1() {
	var iters = [], len = arguments.length;
	while (len--) iters[len] = arguments[len];
	return mergeIntoKeyedWith(this, iters);
}
function mergeWith$1(merger) {
	var iters = [], len = arguments.length - 1;
	while (len-- > 0) iters[len] = arguments[len + 1];
	if (typeof merger !== "function") throw new TypeError("Invalid merger function: " + merger);
	return mergeIntoKeyedWith(this, iters, merger);
}
function mergeIntoKeyedWith(collection, collections, merger) {
	var iters = [];
	for (var ii = 0; ii < collections.length; ii++) {
		var collection$1 = KeyedCollection(collections[ii]);
		if (collection$1.size !== 0) iters.push(collection$1);
	}
	if (iters.length === 0) return collection;
	if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) return isRecord(collection) ? collection : collection.constructor(iters[0]);
	return collection.withMutations(function(collection$2) {
		var mergeIntoCollection = merger ? function(value, key) {
			update$1(collection$2, key, NOT_SET, function(oldVal) {
				return oldVal === NOT_SET ? value : merger(oldVal, value, key);
			});
		} : function(value, key) {
			collection$2.set(key, value);
		};
		for (var ii$1 = 0; ii$1 < iters.length; ii$1++) iters[ii$1].forEach(mergeIntoCollection);
	});
}
function isPlainObject(value) {
	if (!value || typeof value !== "object" || toString.call(value) !== "[object Object]") return false;
	var proto$6 = Object.getPrototypeOf(value);
	if (proto$6 === null) return true;
	var parentProto = proto$6;
	var nextProto = Object.getPrototypeOf(proto$6);
	while (nextProto !== null) {
		parentProto = nextProto;
		nextProto = Object.getPrototypeOf(parentProto);
	}
	return parentProto === proto$6;
}
/**
* Returns true if the value is a potentially-persistent data structure, either
* provided by Immutable.js or a plain Array or Object.
*/
function isDataStructure(value) {
	return typeof value === "object" && (isImmutable(value) || Array.isArray(value) || isPlainObject(value));
}
function arrCopy(arr, offset) {
	offset = offset || 0;
	var len = Math.max(0, arr.length - offset);
	var newArr = new Array(len);
	for (var ii = 0; ii < len; ii++) newArr[ii] = arr[ii + offset];
	return newArr;
}
function shallowCopy(from$1) {
	if (Array.isArray(from$1)) return arrCopy(from$1);
	var to$1 = {};
	for (var key in from$1) if (hasOwnProperty.call(from$1, key)) to$1[key] = from$1[key];
	return to$1;
}
function merge$3(collection) {
	var sources = [], len = arguments.length - 1;
	while (len-- > 0) sources[len] = arguments[len + 1];
	return mergeWithSources(collection, sources);
}
function mergeWith$2(merger, collection) {
	var sources = [], len = arguments.length - 2;
	while (len-- > 0) sources[len] = arguments[len + 2];
	return mergeWithSources(collection, sources, merger);
}
function mergeDeep$1(collection) {
	var sources = [], len = arguments.length - 1;
	while (len-- > 0) sources[len] = arguments[len + 1];
	return mergeDeepWithSources(collection, sources);
}
function mergeDeepWith$1(merger, collection) {
	var sources = [], len = arguments.length - 2;
	while (len-- > 0) sources[len] = arguments[len + 2];
	return mergeDeepWithSources(collection, sources, merger);
}
function mergeDeepWithSources(collection, sources, merger) {
	return mergeWithSources(collection, sources, deepMergerWith(merger));
}
function mergeWithSources(collection, sources, merger) {
	if (!isDataStructure(collection)) throw new TypeError("Cannot merge into non-data-structure value: " + collection);
	if (isImmutable(collection)) return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
	var isArray$3 = Array.isArray(collection);
	var merged = collection;
	var Collection$1 = isArray$3 ? IndexedCollection : KeyedCollection;
	var mergeItem = isArray$3 ? function(value) {
		if (merged === collection) merged = shallowCopy(merged);
		merged.push(value);
	} : function(value, key) {
		var hasVal = hasOwnProperty.call(merged, key);
		var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
		if (!hasVal || nextVal !== merged[key]) {
			if (merged === collection) merged = shallowCopy(merged);
			merged[key] = nextVal;
		}
	};
	for (var i = 0; i < sources.length; i++) Collection$1(sources[i]).forEach(mergeItem);
	return merged;
}
function deepMergerWith(merger) {
	function deepMerger(oldValue, newValue, key) {
		return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
	}
	return deepMerger;
}
/**
* It's unclear what the desired behavior is for merging two collections that
* fall into separate categories between keyed, indexed, or set-like, so we only
* consider them mergeable if they fall into the same category.
*/
function areMergeable(oldDataStructure, newDataStructure) {
	var oldSeq = Seq(oldDataStructure);
	var newSeq = Seq(newDataStructure);
	return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
}
function mergeDeep() {
	var iters = [], len = arguments.length;
	while (len--) iters[len] = arguments[len];
	return mergeDeepWithSources(this, iters);
}
function mergeDeepWith(merger) {
	var iters = [], len = arguments.length - 1;
	while (len-- > 0) iters[len] = arguments[len + 1];
	return mergeDeepWithSources(this, iters, merger);
}
function mergeDeepIn(keyPath) {
	var iters = [], len = arguments.length - 1;
	while (len-- > 0) iters[len] = arguments[len + 1];
	return updateIn(this, keyPath, emptyMap(), function(m$1) {
		return mergeDeepWithSources(m$1, iters);
	});
}
function mergeIn(keyPath) {
	var iters = [], len = arguments.length - 1;
	while (len-- > 0) iters[len] = arguments[len + 1];
	return updateIn(this, keyPath, emptyMap(), function(m$1) {
		return mergeWithSources(m$1, iters);
	});
}
/**
* Returns a copy of the collection with the value at the key path set to the
* provided value.
*
* A functional alternative to `collection.setIn(keypath)` which will also
* work with plain Objects and Arrays.
*/
function setIn$1(collection, keyPath, value) {
	return updateIn(collection, keyPath, NOT_SET, function() {
		return value;
	});
}
function setIn(keyPath, v) {
	return setIn$1(this, keyPath, v);
}
function update(key, notSetValue, updater) {
	return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
}
function updateIn$1(keyPath, notSetValue, updater) {
	return updateIn(this, keyPath, notSetValue, updater);
}
function wasAltered() {
	return this.__altered;
}
function withMutations(fn) {
	var mutable = this.asMutable();
	fn(mutable);
	return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
/**
* True if `maybeMap` is a Map.
*
* Also true for OrderedMaps.
*/
function isMap(maybeMap) {
	return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}
function invariant(condition, error) {
	if (!condition) throw new Error(error);
}
function assertNotInfinite(size) {
	invariant(size !== Infinity, "Cannot perform this action with an infinite size.");
}
function mapIteratorValue(type$1, entry) {
	return iteratorValue(type$1, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
	return {
		node,
		index: 0,
		__prev: prev
	};
}
function makeMap(size, root, ownerID, hash$1) {
	var map$1 = Object.create(MapPrototype);
	map$1.size = size;
	map$1._root = root;
	map$1.__ownerID = ownerID;
	map$1.__hash = hash$1;
	map$1.__altered = false;
	return map$1;
}
function emptyMap() {
	return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map$1, k, v) {
	var newRoot;
	var newSize;
	if (!map$1._root) {
		if (v === NOT_SET) return map$1;
		newSize = 1;
		newRoot = new ArrayMapNode(map$1.__ownerID, [[k, v]]);
	} else {
		var didChangeSize = MakeRef();
		var didAlter = MakeRef();
		newRoot = updateNode(map$1._root, map$1.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
		if (!didAlter.value) return map$1;
		newSize = map$1.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	}
	if (map$1.__ownerID) {
		map$1.size = newSize;
		map$1._root = newRoot;
		map$1.__hash = void 0;
		map$1.__altered = true;
		return map$1;
	}
	return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	if (!node) {
		if (value === NOT_SET) return node;
		SetRef(didAlter);
		SetRef(didChangeSize);
		return new ValueNode(ownerID, keyHash, [key, value]);
	}
	return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
}
function isLeafNode(node) {
	return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	if (node.keyHash === keyHash) return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	var newNode;
	var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
	return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries, key, value) {
	if (!ownerID) ownerID = new OwnerID();
	var node = new ValueNode(ownerID, hash(key), [key, value]);
	for (var ii = 0; ii < entries.length; ii++) {
		var entry = entries[ii];
		node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
	}
	return node;
}
function packNodes(ownerID, nodes, count$1, excluding) {
	var bitmap = 0;
	var packedII = 0;
	var packedNodes = new Array(count$1);
	for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
		var node = nodes[ii];
		if (node !== void 0 && ii !== excluding) {
			bitmap |= bit;
			packedNodes[packedII++] = node;
		}
	}
	return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
	var count$1 = 0;
	var expandedNodes = new Array(SIZE);
	for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) expandedNodes[ii] = bitmap & 1 ? nodes[count$1++] : void 0;
	expandedNodes[including] = node;
	return new HashArrayMapNode(ownerID, count$1 + 1, expandedNodes);
}
function popCount(x) {
	x -= x >> 1 & 1431655765;
	x = (x & 858993459) + (x >> 2 & 858993459);
	x = x + (x >> 4) & 252645135;
	x += x >> 8;
	x += x >> 16;
	return x & 127;
}
function setAt(array, idx, val, canEdit) {
	var newArray = canEdit ? array : arrCopy(array);
	newArray[idx] = val;
	return newArray;
}
function spliceIn(array, idx, val, canEdit) {
	var newLen = array.length + 1;
	if (canEdit && idx + 1 === newLen) {
		array[idx] = val;
		return array;
	}
	var newArray = new Array(newLen);
	var after = 0;
	for (var ii = 0; ii < newLen; ii++) if (ii === idx) {
		newArray[ii] = val;
		after = -1;
	} else newArray[ii] = array[ii + after];
	return newArray;
}
function spliceOut(array, idx, canEdit) {
	var newLen = array.length - 1;
	if (canEdit && idx === newLen) {
		array.pop();
		return array;
	}
	var newArray = new Array(newLen);
	var after = 0;
	for (var ii = 0; ii < newLen; ii++) {
		if (ii === idx) after = 1;
		newArray[ii] = array[ii + after];
	}
	return newArray;
}
function coerceKeyPath(keyPath) {
	if (isArrayLike(keyPath) && typeof keyPath !== "string") return keyPath;
	if (isOrdered(keyPath)) return keyPath.toArray();
	throw new TypeError("Invalid keyPath: expected Ordered Collection or Array: " + keyPath);
}
/**
* Converts a value to a string, adding quotes if a string was provided.
*/
function quoteString(value) {
	try {
		return typeof value === "string" ? JSON.stringify(value) : String(value);
	} catch (_ignoreError) {
		return JSON.stringify(value);
	}
}
/**
* Returns true if the key is defined in the provided collection.
*
* A functional alternative to `collection.has(key)` which will also work with
* plain Objects and Arrays as an alternative for
* `collection.hasOwnProperty(key)`.
*/
function has(collection, key) {
	return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);
}
function get$1(collection, key, notSetValue) {
	return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
}
function remove(collection, key) {
	if (!isDataStructure(collection)) throw new TypeError("Cannot update non-data-structure value: " + collection);
	if (isImmutable(collection)) {
		if (!collection.remove) throw new TypeError("Cannot update immutable value without .remove() method: " + collection);
		return collection.remove(key);
	}
	if (!hasOwnProperty.call(collection, key)) return collection;
	var collectionCopy = shallowCopy(collection);
	if (Array.isArray(collectionCopy)) collectionCopy.splice(key, 1);
	else delete collectionCopy[key];
	return collectionCopy;
}
function set$1(collection, key, value) {
	if (!isDataStructure(collection)) throw new TypeError("Cannot update non-data-structure value: " + collection);
	if (isImmutable(collection)) {
		if (!collection.set) throw new TypeError("Cannot update immutable value without .set() method: " + collection);
		return collection.set(key, value);
	}
	if (hasOwnProperty.call(collection, key) && value === collection[key]) return collection;
	var collectionCopy = shallowCopy(collection);
	collectionCopy[key] = value;
	return collectionCopy;
}
function updateIn(collection, keyPath, notSetValue, updater) {
	if (!updater) {
		updater = notSetValue;
		notSetValue = void 0;
	}
	var updatedValue = updateInDeeply(isImmutable(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);
	return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
	var wasNotSet = existing === NOT_SET;
	if (i === keyPath.length) {
		var existingValue = wasNotSet ? notSetValue : existing;
		var newValue = updater(existingValue);
		return newValue === existingValue ? existing : newValue;
	}
	if (!wasNotSet && !isDataStructure(existing)) throw new TypeError("Cannot update within non-data-structure value in path [" + Array.from(keyPath).slice(0, i).map(quoteString) + "]: " + existing);
	var key = keyPath[i];
	var nextExisting = wasNotSet ? NOT_SET : get$1(existing, key, NOT_SET);
	var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);
	return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set$1(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key, nextUpdated);
}
/**
* Returns a copy of the collection with the value at the key path removed.
*
* A functional alternative to `collection.removeIn(keypath)` which will also
* work with plain Objects and Arrays.
*/
function removeIn(collection, keyPath) {
	return updateIn(collection, keyPath, function() {
		return NOT_SET;
	});
}
function deleteIn(keyPath) {
	return removeIn(this, keyPath);
}
/**
* True if `maybeList` is a List.
*/
function isList(maybeList) {
	return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}
function iterateList(list, reverse) {
	var left = list._origin;
	var right = list._capacity;
	var tailPos = getTailOffset(right);
	var tail = list._tail;
	return iterateNodeOrLeaf(list._root, list._level, 0);
	function iterateNodeOrLeaf(node, level, offset) {
		return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
	}
	function iterateLeaf(node, offset) {
		var array = offset === tailPos ? tail && tail.array : node && node.array;
		var from$1 = offset > left ? 0 : left - offset;
		var to$1 = right - offset;
		if (to$1 > SIZE) to$1 = SIZE;
		return function() {
			if (from$1 === to$1) return DONE;
			var idx = reverse ? --to$1 : from$1++;
			return array && array[idx];
		};
	}
	function iterateNode(node, level, offset) {
		var values;
		var array = node && node.array;
		var from$1 = offset > left ? 0 : left - offset >> level;
		var to$1 = (right - offset >> level) + 1;
		if (to$1 > SIZE) to$1 = SIZE;
		return function() {
			while (true) {
				if (values) {
					var value = values();
					if (value !== DONE) return value;
					values = null;
				}
				if (from$1 === to$1) return DONE;
				var idx = reverse ? --to$1 : from$1++;
				values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
			}
		};
	}
}
function makeList(origin, capacity, level, root, tail, ownerID, hash$1) {
	var list = Object.create(ListPrototype);
	list.size = capacity - origin;
	list._origin = origin;
	list._capacity = capacity;
	list._level = level;
	list._root = root;
	list._tail = tail;
	list.__ownerID = ownerID;
	list.__hash = hash$1;
	list.__altered = false;
	return list;
}
function emptyList() {
	return makeList(0, 0, SHIFT);
}
function updateList(list, index, value) {
	index = wrapIndex(list, index);
	if (index !== index) return list;
	if (index >= list.size || index < 0) return list.withMutations(function(list$1) {
		index < 0 ? setListBounds(list$1, index).set(0, value) : setListBounds(list$1, 0, index + 1).set(index, value);
	});
	index += list._origin;
	var newTail = list._tail;
	var newRoot = list._root;
	var didAlter = MakeRef();
	if (index >= getTailOffset(list._capacity)) newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	else newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	if (!didAlter.value) return list;
	if (list.__ownerID) {
		list._root = newRoot;
		list._tail = newTail;
		list.__hash = void 0;
		list.__altered = true;
		return list;
	}
	return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index, value, didAlter) {
	var idx = index >>> level & MASK;
	var nodeHas = node && idx < node.array.length;
	if (!nodeHas && value === void 0) return node;
	var newNode;
	if (level > 0) {
		var lowerNode = node && node.array[idx];
		var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
		if (newLowerNode === lowerNode) return node;
		newNode = editableVNode(node, ownerID);
		newNode.array[idx] = newLowerNode;
		return newNode;
	}
	if (nodeHas && node.array[idx] === value) return node;
	if (didAlter) SetRef(didAlter);
	newNode = editableVNode(node, ownerID);
	if (value === void 0 && idx === newNode.array.length - 1) newNode.array.pop();
	else newNode.array[idx] = value;
	return newNode;
}
function editableVNode(node, ownerID) {
	if (ownerID && node && ownerID === node.ownerID) return node;
	return new VNode(node ? node.array.slice() : [], ownerID);
}
function listNodeFor(list, rawIndex) {
	if (rawIndex >= getTailOffset(list._capacity)) return list._tail;
	if (rawIndex < 1 << list._level + SHIFT) {
		var node = list._root;
		var level = list._level;
		while (node && level > 0) {
			node = node.array[rawIndex >>> level & MASK];
			level -= SHIFT;
		}
		return node;
	}
}
function setListBounds(list, begin, end) {
	if (begin !== void 0) begin |= 0;
	if (end !== void 0) end |= 0;
	var owner = list.__ownerID || new OwnerID();
	var oldOrigin = list._origin;
	var oldCapacity = list._capacity;
	var newOrigin = oldOrigin + begin;
	var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	if (newOrigin === oldOrigin && newCapacity === oldCapacity) return list;
	if (newOrigin >= newCapacity) return list.clear();
	var newLevel = list._level;
	var newRoot = list._root;
	var offsetShift = 0;
	while (newOrigin + offsetShift < 0) {
		newRoot = new VNode(newRoot && newRoot.array.length ? [void 0, newRoot] : [], owner);
		newLevel += SHIFT;
		offsetShift += 1 << newLevel;
	}
	if (offsetShift) {
		newOrigin += offsetShift;
		oldOrigin += offsetShift;
		newCapacity += offsetShift;
		oldCapacity += offsetShift;
	}
	var oldTailOffset = getTailOffset(oldCapacity);
	var newTailOffset = getTailOffset(newCapacity);
	while (newTailOffset >= 1 << newLevel + SHIFT) {
		newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
		newLevel += SHIFT;
	}
	var oldTail = list._tail;
	var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
	if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
		newRoot = editableVNode(newRoot, owner);
		var node = newRoot;
		for (var level = newLevel; level > SHIFT; level -= SHIFT) {
			var idx = oldTailOffset >>> level & MASK;
			node = node.array[idx] = editableVNode(node.array[idx], owner);
		}
		node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
	}
	if (newCapacity < oldCapacity) newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	if (newOrigin >= newTailOffset) {
		newOrigin -= newTailOffset;
		newCapacity -= newTailOffset;
		newLevel = SHIFT;
		newRoot = null;
		newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
	} else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
		offsetShift = 0;
		while (newRoot) {
			var beginIndex = newOrigin >>> newLevel & MASK;
			if (beginIndex !== newTailOffset >>> newLevel & MASK) break;
			if (beginIndex) offsetShift += (1 << newLevel) * beginIndex;
			newLevel -= SHIFT;
			newRoot = newRoot.array[beginIndex];
		}
		if (newRoot && newOrigin > oldOrigin) newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
		if (newRoot && newTailOffset < oldTailOffset) newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
		if (offsetShift) {
			newOrigin -= offsetShift;
			newCapacity -= offsetShift;
		}
	}
	if (list.__ownerID) {
		list.size = newCapacity - newOrigin;
		list._origin = newOrigin;
		list._capacity = newCapacity;
		list._level = newLevel;
		list._root = newRoot;
		list._tail = newTail;
		list.__hash = void 0;
		list.__altered = true;
		return list;
	}
	return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function getTailOffset(size) {
	return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}
/**
* True if `maybeOrderedMap` is an OrderedMap.
*/
function isOrderedMap(maybeOrderedMap) {
	return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
function makeOrderedMap(map$1, list, ownerID, hash$1) {
	var omap = Object.create(OrderedMap.prototype);
	omap.size = map$1 ? map$1.size : 0;
	omap._map = map$1;
	omap._list = list;
	omap.__ownerID = ownerID;
	omap.__hash = hash$1;
	omap.__altered = false;
	return omap;
}
function emptyOrderedMap() {
	return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
function updateOrderedMap(omap, k, v) {
	var map$1 = omap._map;
	var list = omap._list;
	var i = map$1.get(k);
	var has$1 = i !== void 0;
	var newMap;
	var newList;
	if (v === NOT_SET) {
		if (!has$1) return omap;
		if (list.size >= SIZE && list.size >= map$1.size * 2) {
			newList = list.filter(function(entry, idx) {
				return entry !== void 0 && i !== idx;
			});
			newMap = newList.toKeyedSeq().map(function(entry) {
				return entry[0];
			}).flip().toMap();
			if (omap.__ownerID) newMap.__ownerID = newList.__ownerID = omap.__ownerID;
		} else {
			newMap = map$1.remove(k);
			newList = i === list.size - 1 ? list.pop() : list.set(i, void 0);
		}
	} else if (has$1) {
		if (v === list.get(i)[1]) return omap;
		newMap = map$1;
		newList = list.set(i, [k, v]);
	} else {
		newMap = map$1.set(k, list.size);
		newList = list.set(list.size, [k, v]);
	}
	if (omap.__ownerID) {
		omap.size = newMap.size;
		omap._map = newMap;
		omap._list = newList;
		omap.__hash = void 0;
		omap.__altered = true;
		return omap;
	}
	return makeOrderedMap(newMap, newList);
}
/**
* True if `maybeStack` is a Stack.
*/
function isStack(maybeStack) {
	return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}
function makeStack(size, head, ownerID, hash$1) {
	var map$1 = Object.create(StackPrototype);
	map$1.size = size;
	map$1._head = head;
	map$1.__ownerID = ownerID;
	map$1.__hash = hash$1;
	map$1.__altered = false;
	return map$1;
}
function emptyStack() {
	return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
function reduce$1(collection, reducer, reduction, context$1, useFirst, reverse) {
	assertNotInfinite(collection.size);
	collection.__iterate(function(v, k, c$1) {
		if (useFirst) {
			useFirst = false;
			reduction = v;
		} else reduction = reducer.call(context$1, reduction, v, k, c$1);
	}, reverse);
	return reduction;
}
function keyMapper(v, k) {
	return k;
}
function entryMapper(v, k) {
	return [k, v];
}
function not$1(predicate) {
	return function() {
		var args = [], len = arguments.length;
		while (len--) args[len] = arguments[len];
		return !predicate.apply(this, args);
	};
}
function neg(predicate) {
	return function() {
		var args = [], len = arguments.length;
		while (len--) args[len] = arguments[len];
		return -predicate.apply(this, args);
	};
}
function defaultNegComparator(a$1, b$2) {
	return a$1 < b$2 ? 1 : a$1 > b$2 ? -1 : 0;
}
function deepEqual(a$1, b$2) {
	if (a$1 === b$2) return true;
	if (!isCollection(b$2) || a$1.size !== void 0 && b$2.size !== void 0 && a$1.size !== b$2.size || a$1.__hash !== void 0 && b$2.__hash !== void 0 && a$1.__hash !== b$2.__hash || isKeyed(a$1) !== isKeyed(b$2) || isIndexed(a$1) !== isIndexed(b$2) || isOrdered(a$1) !== isOrdered(b$2)) return false;
	if (a$1.size === 0 && b$2.size === 0) return true;
	var notAssociative = !isAssociative(a$1);
	if (isOrdered(a$1)) {
		var entries = a$1.entries();
		return b$2.every(function(v, k) {
			var entry = entries.next().value;
			return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
		}) && entries.next().done;
	}
	var flipped = false;
	if (a$1.size === void 0) if (b$2.size === void 0) {
		if (typeof a$1.cacheResult === "function") a$1.cacheResult();
	} else {
		flipped = true;
		var _ = a$1;
		a$1 = b$2;
		b$2 = _;
	}
	var allEqual = true;
	var bSize = b$2.__iterate(function(v, k) {
		if (notAssociative ? !a$1.has(v) : flipped ? !is(v, a$1.get(k, NOT_SET)) : !is(a$1.get(k, NOT_SET), v)) {
			allEqual = false;
			return false;
		}
	});
	return allEqual && a$1.size === bSize;
}
/**
* True if `maybeSet` is a Set.
*
* Also true for OrderedSets.
*/
function isSet(maybeSet) {
	return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}
function updateSet(set$2, newMap) {
	if (set$2.__ownerID) {
		set$2.size = newMap.size;
		set$2._map = newMap;
		return set$2;
	}
	return newMap === set$2._map ? set$2 : newMap.size === 0 ? set$2.__empty() : set$2.__make(newMap);
}
function makeSet(map$1, ownerID) {
	var set$2 = Object.create(SetPrototype);
	set$2.size = map$1 ? map$1.size : 0;
	set$2._map = map$1;
	set$2.__ownerID = ownerID;
	return set$2;
}
function emptySet() {
	return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
/**
* Returns the value at the provided key path starting at the provided
* collection, or notSetValue if the key path is not defined.
*
* A functional alternative to `collection.getIn(keypath)` which will also
* work with plain Objects and Arrays.
*/
function getIn$1(collection, searchKeyPath, notSetValue) {
	var keyPath = coerceKeyPath(searchKeyPath);
	var i = 0;
	while (i !== keyPath.length) {
		collection = get$1(collection, keyPath[i++], NOT_SET);
		if (collection === NOT_SET) return notSetValue;
	}
	return collection;
}
function getIn(searchKeyPath, notSetValue) {
	return getIn$1(this, searchKeyPath, notSetValue);
}
/**
* Returns true if the key path is defined in the provided collection.
*
* A functional alternative to `collection.hasIn(keypath)` which will also
* work with plain Objects and Arrays.
*/
function hasIn$1(collection, keyPath) {
	return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}
function hasIn(searchKeyPath) {
	return hasIn$1(this, searchKeyPath);
}
function toObject() {
	assertNotInfinite(this.size);
	var object = {};
	this.__iterate(function(v, k) {
		object[k] = v;
	});
	return object;
}
function toJS(value) {
	if (!value || typeof value !== "object") return value;
	if (!isCollection(value)) {
		if (!isDataStructure(value)) return value;
		value = Seq(value);
	}
	if (isKeyed(value)) {
		var result$1 = {};
		value.__iterate(function(v, k) {
			result$1[k] = toJS(v);
		});
		return result$1;
	}
	var result = [];
	value.__iterate(function(v) {
		result.push(toJS(v));
	});
	return result;
}
function hashCollection(collection) {
	if (collection.size === Infinity) return 0;
	var ordered = isOrdered(collection);
	var keyed = isKeyed(collection);
	var h = ordered ? 1 : 0;
	collection.__iterate(keyed ? ordered ? function(v, k) {
		h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
	} : function(v, k) {
		h = h + hashMerge(hash(v), hash(k)) | 0;
	} : ordered ? function(v) {
		h = 31 * h + hash(v) | 0;
	} : function(v) {
		h = h + hash(v) | 0;
	});
	return murmurHashOfSize(collection.size, h);
}
function murmurHashOfSize(size, h) {
	h = imul(h, 3432918353);
	h = imul(h << 15 | h >>> -15, 461845907);
	h = imul(h << 13 | h >>> -13, 5);
	h = (h + 3864292196 | 0) ^ size;
	h = imul(h ^ h >>> 16, 2246822507);
	h = imul(h ^ h >>> 13, 3266489909);
	h = smi(h ^ h >>> 16);
	return h;
}
function hashMerge(a$1, b$2) {
	return a$1 ^ b$2 + 2654435769 + (a$1 << 6) + (a$1 >> 2) | 0;
}
/**
* Contributes additional methods to a constructor
*/
function mixin(ctor, methods) {
	var keyCopier = function(key) {
		ctor.prototype[key] = methods[key];
	};
	Object.keys(methods).forEach(keyCopier);
	Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	return ctor;
}
function defaultZipper() {
	return arrCopy(arguments);
}
/**
* True if `maybeOrderedSet` is an OrderedSet.
*/
function isOrderedSet(maybeOrderedSet) {
	return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
function makeOrderedSet(map$1, ownerID) {
	var set$2 = Object.create(OrderedSetPrototype);
	set$2.size = map$1 ? map$1.size : 0;
	set$2._map = map$1;
	set$2.__ownerID = ownerID;
	return set$2;
}
function emptyOrderedSet() {
	return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
function throwOnInvalidDefaultValues(defaultValues) {
	if (isRecord(defaultValues)) throw new Error("Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead.");
	if (isImmutable(defaultValues)) throw new Error("Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead.");
	if (defaultValues === null || typeof defaultValues !== "object") throw new Error("Can not call `Record` with a non-object as default values. Use a plain javascript object instead.");
}
function makeRecord(likeRecord, values, ownerID) {
	var record = Object.create(Object.getPrototypeOf(likeRecord));
	record._values = values;
	record.__ownerID = ownerID;
	return record;
}
function recordName(record) {
	return record.constructor.displayName || record.constructor.name || "Record";
}
function recordSeq(record) {
	return keyedSeqFromValue(record._keys.map(function(k) {
		return [k, record.get(k)];
	}));
}
function setProp(prototype, name) {
	try {
		Object.defineProperty(prototype, name, {
			get: function() {
				return this.get(name);
			},
			set: function(value) {
				invariant(this.__ownerID, "Cannot set on an immutable record.");
				this.set(name, value);
			}
		});
	} catch (error) {}
}
function fromJS(value, converter) {
	return fromJSWith([], converter || defaultConverter, value, "", converter && converter.length > 2 ? [] : void 0, { "": value });
}
function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
	if (typeof value !== "string" && !isImmutable(value) && (isArrayLike(value) || hasIterator(value) || isPlainObject(value))) {
		if (~stack.indexOf(value)) throw new TypeError("Cannot convert circular structure to Immutable");
		stack.push(value);
		keyPath && key !== "" && keyPath.push(key);
		var converted = converter.call(parentValue, key, Seq(value).map(function(v, k) {
			return fromJSWith(stack, converter, v, k, keyPath, value);
		}), keyPath && keyPath.slice());
		stack.pop();
		keyPath && keyPath.pop();
		return converted;
	}
	return value;
}
function defaultConverter(k, v) {
	return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();
}
var IS_INDEXED_SYMBOL, IS_KEYED_SYMBOL, IS_COLLECTION_SYMBOL, Collection, KeyedCollection, IndexedCollection, SetCollection, ITERATE_KEYS, ITERATE_VALUES, ITERATE_ENTRIES, REAL_ITERATOR_SYMBOL, FAUX_ITERATOR_SYMBOL, ITERATOR_SYMBOL, Iterator, DELETE, SHIFT, SIZE, MASK, NOT_SET, IS_RECORD_SYMBOL, IS_ORDERED_SYMBOL, IS_SEQ_SYMBOL, hasOwnProperty, Seq, KeyedSeq, IndexedSeq, SetSeq, ArraySeq, ObjectSeq, CollectionSeq, EMPTY_SEQ, imul, defaultValueOf, isExtensible, canDefineProperty, usingWeakMap, weakMap, symbolMap, _objHashUID, UID_HASH_KEY, STRING_HASH_CACHE_MIN_STRLEN, STRING_HASH_CACHE_MAX_SIZE, STRING_HASH_CACHE_SIZE, stringHashCache, ToKeyedSequence, ToIndexedSequence, ToSetSequence, FromEntriesSequence, ConcatSeq, toString, IS_MAP_SYMBOL, Map$1, MapPrototype, ArrayMapNode, BitmapIndexedNode, HashArrayMapNode, HashCollisionNode, ValueNode, MapIterator, EMPTY_MAP, MAX_ARRAY_MAP_SIZE, MAX_BITMAP_INDEXED_SIZE, MIN_HASH_ARRAY_MAP_SIZE, IS_LIST_SYMBOL, List, ListPrototype, VNode, DONE, OrderedMap, EMPTY_ORDERED_MAP, IS_STACK_SYMBOL, Stack, StackPrototype, EMPTY_STACK, Range, EMPTY_RANGE, IS_SET_SYMBOL, Set$1, SetPrototype, EMPTY_SET, CollectionPrototype, KeyedCollectionPrototype, IndexedCollectionPrototype, SetCollectionPrototype, OrderedSet, OrderedSetPrototype, EMPTY_ORDERED_SET, PairSorting, Record, RecordPrototype, Repeat, EMPTY_REPEAT, version, Iterable;
var init_immutable_es = __esm({ "node_modules/immutable/dist/immutable.es.js": (() => {
	IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
	IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
	IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
	Collection = function Collection$1(value) {
		return isCollection(value) ? value : Seq(value);
	};
	KeyedCollection = /* @__PURE__ */ function(Collection$1) {
		function KeyedCollection$1(value) {
			return isKeyed(value) ? value : KeyedSeq(value);
		}
		if (Collection$1) KeyedCollection$1.__proto__ = Collection$1;
		KeyedCollection$1.prototype = Object.create(Collection$1 && Collection$1.prototype);
		KeyedCollection$1.prototype.constructor = KeyedCollection$1;
		return KeyedCollection$1;
	}(Collection);
	IndexedCollection = /* @__PURE__ */ function(Collection$1) {
		function IndexedCollection$1(value) {
			return isIndexed(value) ? value : IndexedSeq(value);
		}
		if (Collection$1) IndexedCollection$1.__proto__ = Collection$1;
		IndexedCollection$1.prototype = Object.create(Collection$1 && Collection$1.prototype);
		IndexedCollection$1.prototype.constructor = IndexedCollection$1;
		return IndexedCollection$1;
	}(Collection);
	SetCollection = /* @__PURE__ */ function(Collection$1) {
		function SetCollection$1(value) {
			return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
		}
		if (Collection$1) SetCollection$1.__proto__ = Collection$1;
		SetCollection$1.prototype = Object.create(Collection$1 && Collection$1.prototype);
		SetCollection$1.prototype.constructor = SetCollection$1;
		return SetCollection$1;
	}(Collection);
	Collection.Keyed = KeyedCollection;
	Collection.Indexed = IndexedCollection;
	Collection.Set = SetCollection;
	ITERATE_KEYS = 0;
	ITERATE_VALUES = 1;
	ITERATE_ENTRIES = 2;
	REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
	FAUX_ITERATOR_SYMBOL = "@@iterator";
	ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
	Iterator = function Iterator$1(next) {
		this.next = next;
	};
	Iterator.prototype.toString = function toString$1() {
		return "[Iterator]";
	};
	Iterator.KEYS = ITERATE_KEYS;
	Iterator.VALUES = ITERATE_VALUES;
	Iterator.ENTRIES = ITERATE_ENTRIES;
	Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
		return this.toString();
	};
	Iterator.prototype[ITERATOR_SYMBOL] = function() {
		return this;
	};
	DELETE = "delete";
	SHIFT = 5;
	SIZE = 1 << SHIFT;
	MASK = SIZE - 1;
	NOT_SET = {};
	IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
	IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
	IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
	hasOwnProperty = Object.prototype.hasOwnProperty;
	Seq = /* @__PURE__ */ function(Collection$1) {
		function Seq$1(value) {
			return value === void 0 || value === null ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
		}
		if (Collection$1) Seq$1.__proto__ = Collection$1;
		Seq$1.prototype = Object.create(Collection$1 && Collection$1.prototype);
		Seq$1.prototype.constructor = Seq$1;
		Seq$1.prototype.toSeq = function toSeq() {
			return this;
		};
		Seq$1.prototype.toString = function toString$1() {
			return this.__toString("Seq {", "}");
		};
		Seq$1.prototype.cacheResult = function cacheResult() {
			if (!this._cache && this.__iterateUncached) {
				this._cache = this.entrySeq().toArray();
				this.size = this._cache.length;
			}
			return this;
		};
		Seq$1.prototype.__iterate = function __iterate(fn, reverse) {
			var cache = this._cache;
			if (cache) {
				var size = cache.length;
				var i = 0;
				while (i !== size) {
					var entry = cache[reverse ? size - ++i : i++];
					if (fn(entry[1], entry[0], this) === false) break;
				}
				return i;
			}
			return this.__iterateUncached(fn, reverse);
		};
		Seq$1.prototype.__iterator = function __iterator(type$1, reverse) {
			var cache = this._cache;
			if (cache) {
				var size = cache.length;
				var i = 0;
				return new Iterator(function() {
					if (i === size) return iteratorDone();
					var entry = cache[reverse ? size - ++i : i++];
					return iteratorValue(type$1, entry[0], entry[1]);
				});
			}
			return this.__iteratorUncached(type$1, reverse);
		};
		return Seq$1;
	}(Collection);
	KeyedSeq = /* @__PURE__ */ function(Seq$1) {
		function KeyedSeq$1(value) {
			return value === void 0 || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
		}
		if (Seq$1) KeyedSeq$1.__proto__ = Seq$1;
		KeyedSeq$1.prototype = Object.create(Seq$1 && Seq$1.prototype);
		KeyedSeq$1.prototype.constructor = KeyedSeq$1;
		KeyedSeq$1.prototype.toKeyedSeq = function toKeyedSeq() {
			return this;
		};
		return KeyedSeq$1;
	}(Seq);
	IndexedSeq = /* @__PURE__ */ function(Seq$1) {
		function IndexedSeq$1(value) {
			return value === void 0 || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
		}
		if (Seq$1) IndexedSeq$1.__proto__ = Seq$1;
		IndexedSeq$1.prototype = Object.create(Seq$1 && Seq$1.prototype);
		IndexedSeq$1.prototype.constructor = IndexedSeq$1;
		IndexedSeq$1.of = function of$1() {
			return IndexedSeq$1(arguments);
		};
		IndexedSeq$1.prototype.toIndexedSeq = function toIndexedSeq() {
			return this;
		};
		IndexedSeq$1.prototype.toString = function toString$1() {
			return this.__toString("Seq [", "]");
		};
		return IndexedSeq$1;
	}(Seq);
	SetSeq = /* @__PURE__ */ function(Seq$1) {
		function SetSeq$1(value) {
			return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
		}
		if (Seq$1) SetSeq$1.__proto__ = Seq$1;
		SetSeq$1.prototype = Object.create(Seq$1 && Seq$1.prototype);
		SetSeq$1.prototype.constructor = SetSeq$1;
		SetSeq$1.of = function of$1() {
			return SetSeq$1(arguments);
		};
		SetSeq$1.prototype.toSetSeq = function toSetSeq() {
			return this;
		};
		return SetSeq$1;
	}(Seq);
	Seq.isSeq = isSeq;
	Seq.Keyed = KeyedSeq;
	Seq.Set = SetSeq;
	Seq.Indexed = IndexedSeq;
	Seq.prototype[IS_SEQ_SYMBOL] = true;
	ArraySeq = /* @__PURE__ */ function(IndexedSeq$1) {
		function ArraySeq$1(array) {
			this._array = array;
			this.size = array.length;
		}
		if (IndexedSeq$1) ArraySeq$1.__proto__ = IndexedSeq$1;
		ArraySeq$1.prototype = Object.create(IndexedSeq$1 && IndexedSeq$1.prototype);
		ArraySeq$1.prototype.constructor = ArraySeq$1;
		ArraySeq$1.prototype.get = function get$2(index, notSetValue) {
			return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
		};
		ArraySeq$1.prototype.__iterate = function __iterate(fn, reverse) {
			var array = this._array;
			var size = array.length;
			var i = 0;
			while (i !== size) {
				var ii = reverse ? size - ++i : i++;
				if (fn(array[ii], ii, this) === false) break;
			}
			return i;
		};
		ArraySeq$1.prototype.__iterator = function __iterator(type$1, reverse) {
			var array = this._array;
			var size = array.length;
			var i = 0;
			return new Iterator(function() {
				if (i === size) return iteratorDone();
				var ii = reverse ? size - ++i : i++;
				return iteratorValue(type$1, ii, array[ii]);
			});
		};
		return ArraySeq$1;
	}(IndexedSeq);
	ObjectSeq = /* @__PURE__ */ function(KeyedSeq$1) {
		function ObjectSeq$1(object) {
			var keys = Object.keys(object).concat(Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []);
			this._object = object;
			this._keys = keys;
			this.size = keys.length;
		}
		if (KeyedSeq$1) ObjectSeq$1.__proto__ = KeyedSeq$1;
		ObjectSeq$1.prototype = Object.create(KeyedSeq$1 && KeyedSeq$1.prototype);
		ObjectSeq$1.prototype.constructor = ObjectSeq$1;
		ObjectSeq$1.prototype.get = function get$2(key, notSetValue) {
			if (notSetValue !== void 0 && !this.has(key)) return notSetValue;
			return this._object[key];
		};
		ObjectSeq$1.prototype.has = function has$1(key) {
			return hasOwnProperty.call(this._object, key);
		};
		ObjectSeq$1.prototype.__iterate = function __iterate(fn, reverse) {
			var object = this._object;
			var keys = this._keys;
			var size = keys.length;
			var i = 0;
			while (i !== size) {
				var key = keys[reverse ? size - ++i : i++];
				if (fn(object[key], key, this) === false) break;
			}
			return i;
		};
		ObjectSeq$1.prototype.__iterator = function __iterator(type$1, reverse) {
			var object = this._object;
			var keys = this._keys;
			var size = keys.length;
			var i = 0;
			return new Iterator(function() {
				if (i === size) return iteratorDone();
				var key = keys[reverse ? size - ++i : i++];
				return iteratorValue(type$1, key, object[key]);
			});
		};
		return ObjectSeq$1;
	}(KeyedSeq);
	ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
	CollectionSeq = /* @__PURE__ */ function(IndexedSeq$1) {
		function CollectionSeq$1(collection) {
			this._collection = collection;
			this.size = collection.length || collection.size;
		}
		if (IndexedSeq$1) CollectionSeq$1.__proto__ = IndexedSeq$1;
		CollectionSeq$1.prototype = Object.create(IndexedSeq$1 && IndexedSeq$1.prototype);
		CollectionSeq$1.prototype.constructor = CollectionSeq$1;
		CollectionSeq$1.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
			if (reverse) return this.cacheResult().__iterate(fn, reverse);
			var collection = this._collection;
			var iterator = getIterator(collection);
			var iterations = 0;
			if (isIterator(iterator)) {
				var step;
				while (!(step = iterator.next()).done) if (fn(step.value, iterations++, this) === false) break;
			}
			return iterations;
		};
		CollectionSeq$1.prototype.__iteratorUncached = function __iteratorUncached(type$1, reverse) {
			if (reverse) return this.cacheResult().__iterator(type$1, reverse);
			var collection = this._collection;
			var iterator = getIterator(collection);
			if (!isIterator(iterator)) return new Iterator(iteratorDone);
			var iterations = 0;
			return new Iterator(function() {
				var step = iterator.next();
				return step.done ? step : iteratorValue(type$1, iterations++, step.value);
			});
		};
		return CollectionSeq$1;
	}(IndexedSeq);
	;
	imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul$1(a$1, b$2) {
		a$1 |= 0;
		b$2 |= 0;
		var c$1 = a$1 & 65535;
		var d$1 = b$2 & 65535;
		return c$1 * d$1 + ((a$1 >>> 16) * d$1 + c$1 * (b$2 >>> 16) << 16 >>> 0) | 0;
	};
	defaultValueOf = Object.prototype.valueOf;
	isExtensible = Object.isExtensible;
	canDefineProperty = (function() {
		try {
			Object.defineProperty({}, "@", {});
			return true;
		} catch (e) {
			return false;
		}
	})();
	usingWeakMap = typeof WeakMap === "function";
	;
	if (usingWeakMap) weakMap = /* @__PURE__ */ new WeakMap();
	symbolMap = Object.create(null);
	_objHashUID = 0;
	UID_HASH_KEY = "__immutablehash__";
	if (typeof Symbol === "function") UID_HASH_KEY = Symbol(UID_HASH_KEY);
	STRING_HASH_CACHE_MIN_STRLEN = 16;
	STRING_HASH_CACHE_MAX_SIZE = 255;
	STRING_HASH_CACHE_SIZE = 0;
	stringHashCache = {};
	ToKeyedSequence = /* @__PURE__ */ function(KeyedSeq$1) {
		function ToKeyedSequence$1(indexed, useKeys) {
			this._iter = indexed;
			this._useKeys = useKeys;
			this.size = indexed.size;
		}
		if (KeyedSeq$1) ToKeyedSequence$1.__proto__ = KeyedSeq$1;
		ToKeyedSequence$1.prototype = Object.create(KeyedSeq$1 && KeyedSeq$1.prototype);
		ToKeyedSequence$1.prototype.constructor = ToKeyedSequence$1;
		ToKeyedSequence$1.prototype.get = function get$2(key, notSetValue) {
			return this._iter.get(key, notSetValue);
		};
		ToKeyedSequence$1.prototype.has = function has$1(key) {
			return this._iter.has(key);
		};
		ToKeyedSequence$1.prototype.valueSeq = function valueSeq() {
			return this._iter.valueSeq();
		};
		ToKeyedSequence$1.prototype.reverse = function reverse() {
			var this$1$1 = this;
			var reversedSequence = reverseFactory(this, true);
			if (!this._useKeys) reversedSequence.valueSeq = function() {
				return this$1$1._iter.toSeq().reverse();
			};
			return reversedSequence;
		};
		ToKeyedSequence$1.prototype.map = function map$1(mapper, context$1) {
			var this$1$1 = this;
			var mappedSequence = mapFactory(this, mapper, context$1);
			if (!this._useKeys) mappedSequence.valueSeq = function() {
				return this$1$1._iter.toSeq().map(mapper, context$1);
			};
			return mappedSequence;
		};
		ToKeyedSequence$1.prototype.__iterate = function __iterate(fn, reverse) {
			var this$1$1 = this;
			return this._iter.__iterate(function(v, k) {
				return fn(v, k, this$1$1);
			}, reverse);
		};
		ToKeyedSequence$1.prototype.__iterator = function __iterator(type$1, reverse) {
			return this._iter.__iterator(type$1, reverse);
		};
		return ToKeyedSequence$1;
	}(KeyedSeq);
	ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
	ToIndexedSequence = /* @__PURE__ */ function(IndexedSeq$1) {
		function ToIndexedSequence$1(iter) {
			this._iter = iter;
			this.size = iter.size;
		}
		if (IndexedSeq$1) ToIndexedSequence$1.__proto__ = IndexedSeq$1;
		ToIndexedSequence$1.prototype = Object.create(IndexedSeq$1 && IndexedSeq$1.prototype);
		ToIndexedSequence$1.prototype.constructor = ToIndexedSequence$1;
		ToIndexedSequence$1.prototype.includes = function includes(value) {
			return this._iter.includes(value);
		};
		ToIndexedSequence$1.prototype.__iterate = function __iterate(fn, reverse) {
			var this$1$1 = this;
			var i = 0;
			reverse && ensureSize(this);
			return this._iter.__iterate(function(v) {
				return fn(v, reverse ? this$1$1.size - ++i : i++, this$1$1);
			}, reverse);
		};
		ToIndexedSequence$1.prototype.__iterator = function __iterator(type$1, reverse) {
			var this$1$1 = this;
			var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
			var i = 0;
			reverse && ensureSize(this);
			return new Iterator(function() {
				var step = iterator.next();
				return step.done ? step : iteratorValue(type$1, reverse ? this$1$1.size - ++i : i++, step.value, step);
			});
		};
		return ToIndexedSequence$1;
	}(IndexedSeq);
	ToSetSequence = /* @__PURE__ */ function(SetSeq$1) {
		function ToSetSequence$1(iter) {
			this._iter = iter;
			this.size = iter.size;
		}
		if (SetSeq$1) ToSetSequence$1.__proto__ = SetSeq$1;
		ToSetSequence$1.prototype = Object.create(SetSeq$1 && SetSeq$1.prototype);
		ToSetSequence$1.prototype.constructor = ToSetSequence$1;
		ToSetSequence$1.prototype.has = function has$1(key) {
			return this._iter.includes(key);
		};
		ToSetSequence$1.prototype.__iterate = function __iterate(fn, reverse) {
			var this$1$1 = this;
			return this._iter.__iterate(function(v) {
				return fn(v, v, this$1$1);
			}, reverse);
		};
		ToSetSequence$1.prototype.__iterator = function __iterator(type$1, reverse) {
			var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
			return new Iterator(function() {
				var step = iterator.next();
				return step.done ? step : iteratorValue(type$1, step.value, step.value, step);
			});
		};
		return ToSetSequence$1;
	}(SetSeq);
	FromEntriesSequence = /* @__PURE__ */ function(KeyedSeq$1) {
		function FromEntriesSequence$1(entries) {
			this._iter = entries;
			this.size = entries.size;
		}
		if (KeyedSeq$1) FromEntriesSequence$1.__proto__ = KeyedSeq$1;
		FromEntriesSequence$1.prototype = Object.create(KeyedSeq$1 && KeyedSeq$1.prototype);
		FromEntriesSequence$1.prototype.constructor = FromEntriesSequence$1;
		FromEntriesSequence$1.prototype.entrySeq = function entrySeq() {
			return this._iter.toSeq();
		};
		FromEntriesSequence$1.prototype.__iterate = function __iterate(fn, reverse) {
			var this$1$1 = this;
			return this._iter.__iterate(function(entry) {
				if (entry) {
					validateEntry(entry);
					var indexedCollection = isCollection(entry);
					return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1$1);
				}
			}, reverse);
		};
		FromEntriesSequence$1.prototype.__iterator = function __iterator(type$1, reverse) {
			var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
			return new Iterator(function() {
				while (true) {
					var step = iterator.next();
					if (step.done) return step;
					var entry = step.value;
					if (entry) {
						validateEntry(entry);
						var indexedCollection = isCollection(entry);
						return iteratorValue(type$1, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);
					}
				}
			});
		};
		return FromEntriesSequence$1;
	}(KeyedSeq);
	ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
	ConcatSeq = /* @__PURE__ */ function(Seq$1) {
		function ConcatSeq$1(iterables) {
			this._wrappedIterables = iterables.flatMap(function(iterable) {
				if (iterable._wrappedIterables) return iterable._wrappedIterables;
				return [iterable];
			});
			this.size = this._wrappedIterables.reduce(function(sum, iterable) {
				if (sum !== void 0) {
					var size = iterable.size;
					if (size !== void 0) return sum + size;
				}
			}, 0);
			this[IS_KEYED_SYMBOL] = this._wrappedIterables[0][IS_KEYED_SYMBOL];
			this[IS_INDEXED_SYMBOL] = this._wrappedIterables[0][IS_INDEXED_SYMBOL];
			this[IS_ORDERED_SYMBOL] = this._wrappedIterables[0][IS_ORDERED_SYMBOL];
		}
		if (Seq$1) ConcatSeq$1.__proto__ = Seq$1;
		ConcatSeq$1.prototype = Object.create(Seq$1 && Seq$1.prototype);
		ConcatSeq$1.prototype.constructor = ConcatSeq$1;
		ConcatSeq$1.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
			if (this._wrappedIterables.length === 0) return;
			if (reverse) return this.cacheResult().__iterate(fn, reverse);
			var iterableIndex = 0;
			var useKeys = isKeyed(this);
			var iteratorType = useKeys ? ITERATE_ENTRIES : ITERATE_VALUES;
			var currentIterator = this._wrappedIterables[iterableIndex].__iterator(iteratorType, reverse);
			var keepGoing = true;
			var index = 0;
			while (keepGoing) {
				var next = currentIterator.next();
				while (next.done) {
					iterableIndex++;
					if (iterableIndex === this._wrappedIterables.length) return index;
					currentIterator = this._wrappedIterables[iterableIndex].__iterator(iteratorType, reverse);
					next = currentIterator.next();
				}
				keepGoing = (useKeys ? fn(next.value[1], next.value[0], this) : fn(next.value, index, this)) !== false;
				index++;
			}
			return index;
		};
		ConcatSeq$1.prototype.__iteratorUncached = function __iteratorUncached(type$1, reverse) {
			var this$1$1 = this;
			if (this._wrappedIterables.length === 0) return new Iterator(iteratorDone);
			if (reverse) return this.cacheResult().__iterator(type$1, reverse);
			var iterableIndex = 0;
			var currentIterator = this._wrappedIterables[iterableIndex].__iterator(type$1, reverse);
			return new Iterator(function() {
				var next = currentIterator.next();
				while (next.done) {
					iterableIndex++;
					if (iterableIndex === this$1$1._wrappedIterables.length) return next;
					currentIterator = this$1$1._wrappedIterables[iterableIndex].__iterator(type$1, reverse);
					next = currentIterator.next();
				}
				return next;
			});
		};
		return ConcatSeq$1;
	}(Seq);
	toString = Object.prototype.toString;
	IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
	Map$1 = /* @__PURE__ */ function(KeyedCollection$1) {
		function Map$2(value) {
			return value === void 0 || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map$1) {
				var iter = KeyedCollection$1(value);
				assertNotInfinite(iter.size);
				iter.forEach(function(v, k) {
					return map$1.set(k, v);
				});
			});
		}
		if (KeyedCollection$1) Map$2.__proto__ = KeyedCollection$1;
		Map$2.prototype = Object.create(KeyedCollection$1 && KeyedCollection$1.prototype);
		Map$2.prototype.constructor = Map$2;
		Map$2.prototype.toString = function toString$1() {
			return this.__toString("Map {", "}");
		};
		Map$2.prototype.get = function get$2(k, notSetValue) {
			return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
		};
		Map$2.prototype.set = function set$2(k, v) {
			return updateMap(this, k, v);
		};
		Map$2.prototype.remove = function remove$1(k) {
			return updateMap(this, k, NOT_SET);
		};
		Map$2.prototype.deleteAll = function deleteAll(keys) {
			var collection = Collection(keys);
			if (collection.size === 0) return this;
			return this.withMutations(function(map$1) {
				collection.forEach(function(key) {
					return map$1.remove(key);
				});
			});
		};
		Map$2.prototype.clear = function clear() {
			if (this.size === 0) return this;
			if (this.__ownerID) {
				this.size = 0;
				this._root = null;
				this.__hash = void 0;
				this.__altered = true;
				return this;
			}
			return emptyMap();
		};
		Map$2.prototype.sort = function sort(comparator) {
			return OrderedMap(sortFactory(this, comparator));
		};
		Map$2.prototype.sortBy = function sortBy(mapper, comparator) {
			return OrderedMap(sortFactory(this, comparator, mapper));
		};
		Map$2.prototype.map = function map$1(mapper, context$1) {
			var this$1$1 = this;
			return this.withMutations(function(map$2) {
				map$2.forEach(function(value, key) {
					map$2.set(key, mapper.call(context$1, value, key, this$1$1));
				});
			});
		};
		Map$2.prototype.__iterator = function __iterator(type$1, reverse) {
			return new MapIterator(this, type$1, reverse);
		};
		Map$2.prototype.__iterate = function __iterate(fn, reverse) {
			var this$1$1 = this;
			var iterations = 0;
			this._root && this._root.iterate(function(entry) {
				iterations++;
				return fn(entry[1], entry[0], this$1$1);
			}, reverse);
			return iterations;
		};
		Map$2.prototype.__ensureOwner = function __ensureOwner(ownerID) {
			if (ownerID === this.__ownerID) return this;
			if (!ownerID) {
				if (this.size === 0) return emptyMap();
				this.__ownerID = ownerID;
				this.__altered = false;
				return this;
			}
			return makeMap(this.size, this._root, ownerID, this.__hash);
		};
		return Map$2;
	}(KeyedCollection);
	Map$1.isMap = isMap;
	MapPrototype = Map$1.prototype;
	MapPrototype[IS_MAP_SYMBOL] = true;
	MapPrototype[DELETE] = MapPrototype.remove;
	MapPrototype.removeAll = MapPrototype.deleteAll;
	MapPrototype.setIn = setIn;
	MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
	MapPrototype.update = update;
	MapPrototype.updateIn = updateIn$1;
	MapPrototype.merge = MapPrototype.concat = merge$1$1;
	MapPrototype.mergeWith = mergeWith$1;
	MapPrototype.mergeDeep = mergeDeep;
	MapPrototype.mergeDeepWith = mergeDeepWith;
	MapPrototype.mergeIn = mergeIn;
	MapPrototype.mergeDeepIn = mergeDeepIn;
	MapPrototype.withMutations = withMutations;
	MapPrototype.wasAltered = wasAltered;
	MapPrototype.asImmutable = asImmutable;
	MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
	MapPrototype["@@transducer/step"] = function(result, arr) {
		return result.set(arr[0], arr[1]);
	};
	MapPrototype["@@transducer/result"] = function(obj) {
		return obj.asImmutable();
	};
	ArrayMapNode = function ArrayMapNode$1(ownerID, entries) {
		this.ownerID = ownerID;
		this.entries = entries;
	};
	ArrayMapNode.prototype.get = function get$2(shift, keyHash, key, notSetValue) {
		var entries = this.entries;
		for (var ii = 0, len = entries.length; ii < len; ii++) if (is(key, entries[ii][0])) return entries[ii][1];
		return notSetValue;
	};
	ArrayMapNode.prototype.update = function update$2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		var removed = value === NOT_SET;
		var entries = this.entries;
		var idx = 0;
		var len = entries.length;
		for (; idx < len; idx++) if (is(key, entries[idx][0])) break;
		var exists = idx < len;
		if (exists ? entries[idx][1] === value : removed) return this;
		SetRef(didAlter);
		(removed || !exists) && SetRef(didChangeSize);
		if (removed && entries.length === 1) return;
		if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) return createNodes(ownerID, entries, key, value);
		var isEditable = ownerID && ownerID === this.ownerID;
		var newEntries = isEditable ? entries : arrCopy(entries);
		if (exists) if (removed) idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
		else newEntries[idx] = [key, value];
		else newEntries.push([key, value]);
		if (isEditable) {
			this.entries = newEntries;
			return this;
		}
		return new ArrayMapNode(ownerID, newEntries);
	};
	BitmapIndexedNode = function BitmapIndexedNode$1(ownerID, bitmap, nodes) {
		this.ownerID = ownerID;
		this.bitmap = bitmap;
		this.nodes = nodes;
	};
	BitmapIndexedNode.prototype.get = function get$2(shift, keyHash, key, notSetValue) {
		if (keyHash === void 0) keyHash = hash(key);
		var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
		var bitmap = this.bitmap;
		return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
	};
	BitmapIndexedNode.prototype.update = function update$2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		if (keyHash === void 0) keyHash = hash(key);
		var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		var bit = 1 << keyHashFrag;
		var bitmap = this.bitmap;
		var exists = (bitmap & bit) !== 0;
		if (!exists && value === NOT_SET) return this;
		var idx = popCount(bitmap & bit - 1);
		var nodes = this.nodes;
		var node = exists ? nodes[idx] : void 0;
		var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
		if (newNode === node) return this;
		if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
		if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) return nodes[idx ^ 1];
		if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) return newNode;
		var isEditable = ownerID && ownerID === this.ownerID;
		var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
		var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
		if (isEditable) {
			this.bitmap = newBitmap;
			this.nodes = newNodes;
			return this;
		}
		return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	};
	HashArrayMapNode = function HashArrayMapNode$1(ownerID, count$1, nodes) {
		this.ownerID = ownerID;
		this.count = count$1;
		this.nodes = nodes;
	};
	HashArrayMapNode.prototype.get = function get$2(shift, keyHash, key, notSetValue) {
		if (keyHash === void 0) keyHash = hash(key);
		var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		var node = this.nodes[idx];
		return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	};
	HashArrayMapNode.prototype.update = function update$2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		if (keyHash === void 0) keyHash = hash(key);
		var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		var removed = value === NOT_SET;
		var nodes = this.nodes;
		var node = nodes[idx];
		if (removed && !node) return this;
		var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
		if (newNode === node) return this;
		var newCount = this.count;
		if (!node) newCount++;
		else if (!newNode) {
			newCount--;
			if (newCount < MIN_HASH_ARRAY_MAP_SIZE) return packNodes(ownerID, nodes, newCount, idx);
		}
		var isEditable = ownerID && ownerID === this.ownerID;
		var newNodes = setAt(nodes, idx, newNode, isEditable);
		if (isEditable) {
			this.count = newCount;
			this.nodes = newNodes;
			return this;
		}
		return new HashArrayMapNode(ownerID, newCount, newNodes);
	};
	HashCollisionNode = function HashCollisionNode$1(ownerID, keyHash, entries) {
		this.ownerID = ownerID;
		this.keyHash = keyHash;
		this.entries = entries;
	};
	HashCollisionNode.prototype.get = function get$2(shift, keyHash, key, notSetValue) {
		var entries = this.entries;
		for (var ii = 0, len = entries.length; ii < len; ii++) if (is(key, entries[ii][0])) return entries[ii][1];
		return notSetValue;
	};
	HashCollisionNode.prototype.update = function update$2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		if (keyHash === void 0) keyHash = hash(key);
		var removed = value === NOT_SET;
		if (keyHash !== this.keyHash) {
			if (removed) return this;
			SetRef(didAlter);
			SetRef(didChangeSize);
			return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
		}
		var entries = this.entries;
		var idx = 0;
		var len = entries.length;
		for (; idx < len; idx++) if (is(key, entries[idx][0])) break;
		var exists = idx < len;
		if (exists ? entries[idx][1] === value : removed) return this;
		SetRef(didAlter);
		(removed || !exists) && SetRef(didChangeSize);
		if (removed && len === 2) return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
		var isEditable = ownerID && ownerID === this.ownerID;
		var newEntries = isEditable ? entries : arrCopy(entries);
		if (exists) if (removed) idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
		else newEntries[idx] = [key, value];
		else newEntries.push([key, value]);
		if (isEditable) {
			this.entries = newEntries;
			return this;
		}
		return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	};
	ValueNode = function ValueNode$1(ownerID, keyHash, entry) {
		this.ownerID = ownerID;
		this.keyHash = keyHash;
		this.entry = entry;
	};
	ValueNode.prototype.get = function get$2(shift, keyHash, key, notSetValue) {
		return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	};
	ValueNode.prototype.update = function update$2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		var removed = value === NOT_SET;
		var keyMatch = is(key, this.entry[0]);
		if (keyMatch ? value === this.entry[1] : removed) return this;
		SetRef(didAlter);
		if (removed) {
			SetRef(didChangeSize);
			return;
		}
		if (keyMatch) {
			if (ownerID && ownerID === this.ownerID) {
				this.entry[1] = value;
				return this;
			}
			return new ValueNode(ownerID, this.keyHash, [key, value]);
		}
		SetRef(didChangeSize);
		return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	};
	ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse) {
		var entries = this.entries;
		for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) if (fn(entries[reverse ? maxIndex - ii : ii]) === false) return false;
	};
	BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse) {
		var nodes = this.nodes;
		for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
			var node = nodes[reverse ? maxIndex - ii : ii];
			if (node && node.iterate(fn, reverse) === false) return false;
		}
	};
	ValueNode.prototype.iterate = function(fn, reverse) {
		return fn(this.entry);
	};
	MapIterator = /* @__PURE__ */ function(Iterator$1) {
		function MapIterator$1(map$1, type$1, reverse) {
			this._type = type$1;
			this._reverse = reverse;
			this._stack = map$1._root && mapIteratorFrame(map$1._root);
		}
		if (Iterator$1) MapIterator$1.__proto__ = Iterator$1;
		MapIterator$1.prototype = Object.create(Iterator$1 && Iterator$1.prototype);
		MapIterator$1.prototype.constructor = MapIterator$1;
		MapIterator$1.prototype.next = function next() {
			var type$1 = this._type;
			var stack = this._stack;
			while (stack) {
				var node = stack.node;
				var index = stack.index++;
				var maxIndex = void 0;
				if (node.entry) {
					if (index === 0) return mapIteratorValue(type$1, node.entry);
				} else if (node.entries) {
					maxIndex = node.entries.length - 1;
					if (index <= maxIndex) return mapIteratorValue(type$1, node.entries[this._reverse ? maxIndex - index : index]);
				} else {
					maxIndex = node.nodes.length - 1;
					if (index <= maxIndex) {
						var subNode = node.nodes[this._reverse ? maxIndex - index : index];
						if (subNode) {
							if (subNode.entry) return mapIteratorValue(type$1, subNode.entry);
							stack = this._stack = mapIteratorFrame(subNode, stack);
						}
						continue;
					}
				}
				stack = this._stack = this._stack.__prev;
			}
			return iteratorDone();
		};
		return MapIterator$1;
	}(Iterator);
	;
	MAX_ARRAY_MAP_SIZE = SIZE / 4;
	MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
	IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
	List = /* @__PURE__ */ function(IndexedCollection$1) {
		function List$1(value) {
			var empty$1 = emptyList();
			if (value === void 0 || value === null) return empty$1;
			if (isList(value)) return value;
			var iter = IndexedCollection$1(value);
			var size = iter.size;
			if (size === 0) return empty$1;
			assertNotInfinite(size);
			if (size > 0 && size < SIZE) return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
			return empty$1.withMutations(function(list) {
				list.setSize(size);
				iter.forEach(function(v, i) {
					return list.set(i, v);
				});
			});
		}
		if (IndexedCollection$1) List$1.__proto__ = IndexedCollection$1;
		List$1.prototype = Object.create(IndexedCollection$1 && IndexedCollection$1.prototype);
		List$1.prototype.constructor = List$1;
		List$1.of = function of$1() {
			return this(arguments);
		};
		List$1.prototype.toString = function toString$1() {
			return this.__toString("List [", "]");
		};
		List$1.prototype.get = function get$2(index, notSetValue) {
			index = wrapIndex(this, index);
			if (index >= 0 && index < this.size) {
				index += this._origin;
				var node = listNodeFor(this, index);
				return node && node.array[index & MASK];
			}
			return notSetValue;
		};
		List$1.prototype.set = function set$2(index, value) {
			return updateList(this, index, value);
		};
		List$1.prototype.remove = function remove$1(index) {
			return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
		};
		List$1.prototype.insert = function insert(index, value) {
			return this.splice(index, 0, value);
		};
		List$1.prototype.clear = function clear() {
			if (this.size === 0) return this;
			if (this.__ownerID) {
				this.size = this._origin = this._capacity = 0;
				this._level = SHIFT;
				this._root = this._tail = this.__hash = void 0;
				this.__altered = true;
				return this;
			}
			return emptyList();
		};
		List$1.prototype.push = function push() {
			var values = arguments;
			var oldSize = this.size;
			return this.withMutations(function(list) {
				setListBounds(list, 0, oldSize + values.length);
				for (var ii = 0; ii < values.length; ii++) list.set(oldSize + ii, values[ii]);
			});
		};
		List$1.prototype.pop = function pop() {
			return setListBounds(this, 0, -1);
		};
		List$1.prototype.unshift = function unshift() {
			var values = arguments;
			return this.withMutations(function(list) {
				setListBounds(list, -values.length);
				for (var ii = 0; ii < values.length; ii++) list.set(ii, values[ii]);
			});
		};
		List$1.prototype.shift = function shift() {
			return setListBounds(this, 1);
		};
		List$1.prototype.shuffle = function shuffle(random) {
			if (random === void 0) random = Math.random;
			return this.withMutations(function(mutable) {
				var current = mutable.size;
				var destination;
				var tmp;
				while (current) {
					destination = Math.floor(random() * current--);
					tmp = mutable.get(destination);
					mutable.set(destination, mutable.get(current));
					mutable.set(current, tmp);
				}
			});
		};
		List$1.prototype.concat = function concat$2() {
			var arguments$1 = arguments;
			var seqs = [];
			for (var i = 0; i < arguments.length; i++) {
				var argument = arguments$1[i];
				var seq = IndexedCollection$1(typeof argument !== "string" && hasIterator(argument) ? argument : [argument]);
				if (seq.size !== 0) seqs.push(seq);
			}
			if (seqs.length === 0) return this;
			if (this.size === 0 && !this.__ownerID && seqs.length === 1) return this.constructor(seqs[0]);
			return this.withMutations(function(list) {
				seqs.forEach(function(seq$1) {
					return seq$1.forEach(function(value) {
						return list.push(value);
					});
				});
			});
		};
		List$1.prototype.setSize = function setSize(size) {
			return setListBounds(this, 0, size);
		};
		List$1.prototype.map = function map$1(mapper, context$1) {
			var this$1$1 = this;
			return this.withMutations(function(list) {
				for (var i = 0; i < this$1$1.size; i++) list.set(i, mapper.call(context$1, list.get(i), i, this$1$1));
			});
		};
		List$1.prototype.slice = function slice(begin, end) {
			var size = this.size;
			if (wholeSlice(begin, end, size)) return this;
			return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
		};
		List$1.prototype.__iterator = function __iterator(type$1, reverse) {
			var index = reverse ? this.size : 0;
			var values = iterateList(this, reverse);
			return new Iterator(function() {
				var value = values();
				return value === DONE ? iteratorDone() : iteratorValue(type$1, reverse ? --index : index++, value);
			});
		};
		List$1.prototype.__iterate = function __iterate(fn, reverse) {
			var index = reverse ? this.size : 0;
			var values = iterateList(this, reverse);
			var value;
			while ((value = values()) !== DONE) if (fn(value, reverse ? --index : index++, this) === false) break;
			return index;
		};
		List$1.prototype.__ensureOwner = function __ensureOwner(ownerID) {
			if (ownerID === this.__ownerID) return this;
			if (!ownerID) {
				if (this.size === 0) return emptyList();
				this.__ownerID = ownerID;
				this.__altered = false;
				return this;
			}
			return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
		};
		return List$1;
	}(IndexedCollection);
	List.isList = isList;
	ListPrototype = List.prototype;
	ListPrototype[IS_LIST_SYMBOL] = true;
	ListPrototype[DELETE] = ListPrototype.remove;
	ListPrototype.merge = ListPrototype.concat;
	ListPrototype.setIn = setIn;
	ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
	ListPrototype.update = update;
	ListPrototype.updateIn = updateIn$1;
	ListPrototype.mergeIn = mergeIn;
	ListPrototype.mergeDeepIn = mergeDeepIn;
	ListPrototype.withMutations = withMutations;
	ListPrototype.wasAltered = wasAltered;
	ListPrototype.asImmutable = asImmutable;
	ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
	ListPrototype["@@transducer/step"] = function(result, arr) {
		return result.push(arr);
	};
	ListPrototype["@@transducer/result"] = function(obj) {
		return obj.asImmutable();
	};
	VNode = function VNode$1(array, ownerID) {
		this.array = array;
		this.ownerID = ownerID;
	};
	VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
		if ((index & (1 << level + SHIFT) - 1) === 0 || this.array.length === 0) return this;
		var originIndex = index >>> level & MASK;
		if (originIndex >= this.array.length) return new VNode([], ownerID);
		var removingFirst = originIndex === 0;
		var newChild;
		if (level > 0) {
			var oldChild = this.array[originIndex];
			newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
			if (newChild === oldChild && removingFirst) return this;
		}
		if (removingFirst && !newChild) return this;
		var editable = editableVNode(this, ownerID);
		if (!removingFirst) for (var ii = 0; ii < originIndex; ii++) editable.array[ii] = void 0;
		if (newChild) editable.array[originIndex] = newChild;
		return editable;
	};
	VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
		if (index === (level ? 1 << level + SHIFT : SIZE) || this.array.length === 0) return this;
		var sizeIndex = index - 1 >>> level & MASK;
		if (sizeIndex >= this.array.length) return this;
		var newChild;
		if (level > 0) {
			var oldChild = this.array[sizeIndex];
			newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
			if (newChild === oldChild && sizeIndex === this.array.length - 1) return this;
		}
		var editable = editableVNode(this, ownerID);
		editable.array.splice(sizeIndex + 1);
		if (newChild) editable.array[sizeIndex] = newChild;
		return editable;
	};
	DONE = {};
	OrderedMap = /* @__PURE__ */ function(Map$2) {
		function OrderedMap$1(value) {
			return value === void 0 || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map$1) {
				var iter = KeyedCollection(value);
				assertNotInfinite(iter.size);
				iter.forEach(function(v, k) {
					return map$1.set(k, v);
				});
			});
		}
		if (Map$2) OrderedMap$1.__proto__ = Map$2;
		OrderedMap$1.prototype = Object.create(Map$2 && Map$2.prototype);
		OrderedMap$1.prototype.constructor = OrderedMap$1;
		OrderedMap$1.of = function of$1() {
			return this(arguments);
		};
		OrderedMap$1.prototype.toString = function toString$1() {
			return this.__toString("OrderedMap {", "}");
		};
		OrderedMap$1.prototype.get = function get$2(k, notSetValue) {
			var index = this._map.get(k);
			return index !== void 0 ? this._list.get(index)[1] : notSetValue;
		};
		OrderedMap$1.prototype.clear = function clear() {
			if (this.size === 0) return this;
			if (this.__ownerID) {
				this.size = 0;
				this._map.clear();
				this._list.clear();
				this.__altered = true;
				return this;
			}
			return emptyOrderedMap();
		};
		OrderedMap$1.prototype.set = function set$2(k, v) {
			return updateOrderedMap(this, k, v);
		};
		OrderedMap$1.prototype.remove = function remove$1(k) {
			return updateOrderedMap(this, k, NOT_SET);
		};
		OrderedMap$1.prototype.__iterate = function __iterate(fn, reverse) {
			var this$1$1 = this;
			return this._list.__iterate(function(entry) {
				return entry && fn(entry[1], entry[0], this$1$1);
			}, reverse);
		};
		OrderedMap$1.prototype.__iterator = function __iterator(type$1, reverse) {
			return this._list.fromEntrySeq().__iterator(type$1, reverse);
		};
		OrderedMap$1.prototype.__ensureOwner = function __ensureOwner(ownerID) {
			if (ownerID === this.__ownerID) return this;
			var newMap = this._map.__ensureOwner(ownerID);
			var newList = this._list.__ensureOwner(ownerID);
			if (!ownerID) {
				if (this.size === 0) return emptyOrderedMap();
				this.__ownerID = ownerID;
				this.__altered = false;
				this._map = newMap;
				this._list = newList;
				return this;
			}
			return makeOrderedMap(newMap, newList, ownerID, this.__hash);
		};
		return OrderedMap$1;
	}(Map$1);
	OrderedMap.isOrderedMap = isOrderedMap;
	OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
	OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
	;
	IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
	Stack = /* @__PURE__ */ function(IndexedCollection$1) {
		function Stack$1(value) {
			return value === void 0 || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
		}
		if (IndexedCollection$1) Stack$1.__proto__ = IndexedCollection$1;
		Stack$1.prototype = Object.create(IndexedCollection$1 && IndexedCollection$1.prototype);
		Stack$1.prototype.constructor = Stack$1;
		Stack$1.of = function of$1() {
			return this(arguments);
		};
		Stack$1.prototype.toString = function toString$1() {
			return this.__toString("Stack [", "]");
		};
		Stack$1.prototype.get = function get$2(index, notSetValue) {
			var head = this._head;
			index = wrapIndex(this, index);
			while (head && index--) head = head.next;
			return head ? head.value : notSetValue;
		};
		Stack$1.prototype.peek = function peek() {
			return this._head && this._head.value;
		};
		Stack$1.prototype.push = function push() {
			var arguments$1 = arguments;
			if (arguments.length === 0) return this;
			var newSize = this.size + arguments.length;
			var head = this._head;
			for (var ii = arguments.length - 1; ii >= 0; ii--) head = {
				value: arguments$1[ii],
				next: head
			};
			if (this.__ownerID) {
				this.size = newSize;
				this._head = head;
				this.__hash = void 0;
				this.__altered = true;
				return this;
			}
			return makeStack(newSize, head);
		};
		Stack$1.prototype.pushAll = function pushAll(iter) {
			iter = IndexedCollection$1(iter);
			if (iter.size === 0) return this;
			if (this.size === 0 && isStack(iter)) return iter;
			assertNotInfinite(iter.size);
			var newSize = this.size;
			var head = this._head;
			iter.__iterate(function(value) {
				newSize++;
				head = {
					value,
					next: head
				};
			}, true);
			if (this.__ownerID) {
				this.size = newSize;
				this._head = head;
				this.__hash = void 0;
				this.__altered = true;
				return this;
			}
			return makeStack(newSize, head);
		};
		Stack$1.prototype.pop = function pop() {
			return this.slice(1);
		};
		Stack$1.prototype.clear = function clear() {
			if (this.size === 0) return this;
			if (this.__ownerID) {
				this.size = 0;
				this._head = void 0;
				this.__hash = void 0;
				this.__altered = true;
				return this;
			}
			return emptyStack();
		};
		Stack$1.prototype.slice = function slice(begin, end) {
			if (wholeSlice(begin, end, this.size)) return this;
			var resolvedBegin = resolveBegin(begin, this.size);
			if (resolveEnd(end, this.size) !== this.size) return IndexedCollection$1.prototype.slice.call(this, begin, end);
			var newSize = this.size - resolvedBegin;
			var head = this._head;
			while (resolvedBegin--) head = head.next;
			if (this.__ownerID) {
				this.size = newSize;
				this._head = head;
				this.__hash = void 0;
				this.__altered = true;
				return this;
			}
			return makeStack(newSize, head);
		};
		Stack$1.prototype.__ensureOwner = function __ensureOwner(ownerID) {
			if (ownerID === this.__ownerID) return this;
			if (!ownerID) {
				if (this.size === 0) return emptyStack();
				this.__ownerID = ownerID;
				this.__altered = false;
				return this;
			}
			return makeStack(this.size, this._head, ownerID, this.__hash);
		};
		Stack$1.prototype.__iterate = function __iterate(fn, reverse) {
			var this$1$1 = this;
			if (reverse) return new ArraySeq(this.toArray()).__iterate(function(v, k) {
				return fn(v, k, this$1$1);
			}, reverse);
			var iterations = 0;
			var node = this._head;
			while (node) {
				if (fn(node.value, iterations++, this) === false) break;
				node = node.next;
			}
			return iterations;
		};
		Stack$1.prototype.__iterator = function __iterator(type$1, reverse) {
			if (reverse) return new ArraySeq(this.toArray()).__iterator(type$1, reverse);
			var iterations = 0;
			var node = this._head;
			return new Iterator(function() {
				if (node) {
					var value = node.value;
					node = node.next;
					return iteratorValue(type$1, iterations++, value);
				}
				return iteratorDone();
			});
		};
		return Stack$1;
	}(IndexedCollection);
	Stack.isStack = isStack;
	StackPrototype = Stack.prototype;
	StackPrototype[IS_STACK_SYMBOL] = true;
	StackPrototype.shift = StackPrototype.pop;
	StackPrototype.unshift = StackPrototype.push;
	StackPrototype.unshiftAll = StackPrototype.pushAll;
	StackPrototype.withMutations = withMutations;
	StackPrototype.wasAltered = wasAltered;
	StackPrototype.asImmutable = asImmutable;
	StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
	StackPrototype["@@transducer/step"] = function(result, arr) {
		return result.unshift(arr);
	};
	StackPrototype["@@transducer/result"] = function(obj) {
		return obj.asImmutable();
	};
	;
	Range = /* @__PURE__ */ function(IndexedSeq$1) {
		function Range$1(start, end, step) {
			if (step === void 0) step = 1;
			if (!(this instanceof Range$1)) return new Range$1(start, end, step);
			invariant(step !== 0, "Cannot step a Range by 0");
			invariant(start !== void 0, "You must define a start value when using Range");
			invariant(end !== void 0, "You must define an end value when using Range");
			step = Math.abs(step);
			if (end < start) step = -step;
			this._start = start;
			this._end = end;
			this._step = step;
			this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
			if (this.size === 0) {
				if (EMPTY_RANGE) return EMPTY_RANGE;
				EMPTY_RANGE = this;
			}
		}
		if (IndexedSeq$1) Range$1.__proto__ = IndexedSeq$1;
		Range$1.prototype = Object.create(IndexedSeq$1 && IndexedSeq$1.prototype);
		Range$1.prototype.constructor = Range$1;
		Range$1.prototype.toString = function toString$1() {
			return this.size === 0 ? "Range []" : "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
		};
		Range$1.prototype.get = function get$2(index, notSetValue) {
			return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
		};
		Range$1.prototype.includes = function includes(searchValue) {
			var possibleIndex = (searchValue - this._start) / this._step;
			return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
		};
		Range$1.prototype.slice = function slice(begin, end) {
			if (wholeSlice(begin, end, this.size)) return this;
			begin = resolveBegin(begin, this.size);
			end = resolveEnd(end, this.size);
			if (end <= begin) return new Range$1(0, 0);
			return new Range$1(this.get(begin, this._end), this.get(end, this._end), this._step);
		};
		Range$1.prototype.indexOf = function indexOf(searchValue) {
			var offsetValue = searchValue - this._start;
			if (offsetValue % this._step === 0) {
				var index = offsetValue / this._step;
				if (index >= 0 && index < this.size) return index;
			}
			return -1;
		};
		Range$1.prototype.lastIndexOf = function lastIndexOf(searchValue) {
			return this.indexOf(searchValue);
		};
		Range$1.prototype.__iterate = function __iterate(fn, reverse) {
			var size = this.size;
			var step = this._step;
			var value = reverse ? this._start + (size - 1) * step : this._start;
			var i = 0;
			while (i !== size) {
				if (fn(value, reverse ? size - ++i : i++, this) === false) break;
				value += reverse ? -step : step;
			}
			return i;
		};
		Range$1.prototype.__iterator = function __iterator(type$1, reverse) {
			var size = this.size;
			var step = this._step;
			var value = reverse ? this._start + (size - 1) * step : this._start;
			var i = 0;
			return new Iterator(function() {
				if (i === size) return iteratorDone();
				var v = value;
				value += reverse ? -step : step;
				return iteratorValue(type$1, reverse ? size - ++i : i++, v);
			});
		};
		Range$1.prototype.equals = function equals$2(other) {
			return other instanceof Range$1 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
		};
		return Range$1;
	}(IndexedSeq);
	;
	IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
	Set$1 = /* @__PURE__ */ function(SetCollection$1) {
		function Set$2(value) {
			return value === void 0 || value === null ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set$2) {
				var iter = SetCollection$1(value);
				assertNotInfinite(iter.size);
				iter.forEach(function(v) {
					return set$2.add(v);
				});
			});
		}
		if (SetCollection$1) Set$2.__proto__ = SetCollection$1;
		Set$2.prototype = Object.create(SetCollection$1 && SetCollection$1.prototype);
		Set$2.prototype.constructor = Set$2;
		Set$2.of = function of$1() {
			return this(arguments);
		};
		Set$2.fromKeys = function fromKeys(value) {
			return this(KeyedCollection(value).keySeq());
		};
		Set$2.intersect = function intersect(sets) {
			sets = Collection(sets).toArray();
			return sets.length ? SetPrototype.intersect.apply(Set$2(sets.pop()), sets) : emptySet();
		};
		Set$2.union = function union(sets) {
			sets = Collection(sets).toArray();
			return sets.length ? SetPrototype.union.apply(Set$2(sets.pop()), sets) : emptySet();
		};
		Set$2.prototype.toString = function toString$1() {
			return this.__toString("Set {", "}");
		};
		Set$2.prototype.has = function has$1(value) {
			return this._map.has(value);
		};
		Set$2.prototype.add = function add(value) {
			return updateSet(this, this._map.set(value, value));
		};
		Set$2.prototype.remove = function remove$1(value) {
			return updateSet(this, this._map.remove(value));
		};
		Set$2.prototype.clear = function clear() {
			return updateSet(this, this._map.clear());
		};
		Set$2.prototype.map = function map$1(mapper, context$1) {
			var this$1$1 = this;
			var didChanges = false;
			var newMap = updateSet(this, this._map.mapEntries(function(ref) {
				var v = ref[1];
				var mapped = mapper.call(context$1, v, v, this$1$1);
				if (mapped !== v) didChanges = true;
				return [mapped, mapped];
			}, context$1));
			return didChanges ? newMap : this;
		};
		Set$2.prototype.union = function union() {
			var iters = [], len = arguments.length;
			while (len--) iters[len] = arguments[len];
			iters = iters.filter(function(x) {
				return x.size !== 0;
			});
			if (iters.length === 0) return this;
			if (this.size === 0 && !this.__ownerID && iters.length === 1) return this.constructor(iters[0]);
			return this.withMutations(function(set$2) {
				for (var ii = 0; ii < iters.length; ii++) if (typeof iters[ii] === "string") set$2.add(iters[ii]);
				else SetCollection$1(iters[ii]).forEach(function(value) {
					return set$2.add(value);
				});
			});
		};
		Set$2.prototype.intersect = function intersect() {
			var iters = [], len = arguments.length;
			while (len--) iters[len] = arguments[len];
			if (iters.length === 0) return this;
			iters = iters.map(function(iter) {
				return SetCollection$1(iter);
			});
			var toRemove = [];
			this.forEach(function(value) {
				if (!iters.every(function(iter) {
					return iter.includes(value);
				})) toRemove.push(value);
			});
			return this.withMutations(function(set$2) {
				toRemove.forEach(function(value) {
					set$2.remove(value);
				});
			});
		};
		Set$2.prototype.subtract = function subtract() {
			var iters = [], len = arguments.length;
			while (len--) iters[len] = arguments[len];
			if (iters.length === 0) return this;
			iters = iters.map(function(iter) {
				return SetCollection$1(iter);
			});
			var toRemove = [];
			this.forEach(function(value) {
				if (iters.some(function(iter) {
					return iter.includes(value);
				})) toRemove.push(value);
			});
			return this.withMutations(function(set$2) {
				toRemove.forEach(function(value) {
					set$2.remove(value);
				});
			});
		};
		Set$2.prototype.sort = function sort(comparator) {
			return OrderedSet(sortFactory(this, comparator));
		};
		Set$2.prototype.sortBy = function sortBy(mapper, comparator) {
			return OrderedSet(sortFactory(this, comparator, mapper));
		};
		Set$2.prototype.wasAltered = function wasAltered$1() {
			return this._map.wasAltered();
		};
		Set$2.prototype.__iterate = function __iterate(fn, reverse) {
			var this$1$1 = this;
			return this._map.__iterate(function(k) {
				return fn(k, k, this$1$1);
			}, reverse);
		};
		Set$2.prototype.__iterator = function __iterator(type$1, reverse) {
			return this._map.__iterator(type$1, reverse);
		};
		Set$2.prototype.__ensureOwner = function __ensureOwner(ownerID) {
			if (ownerID === this.__ownerID) return this;
			var newMap = this._map.__ensureOwner(ownerID);
			if (!ownerID) {
				if (this.size === 0) return this.__empty();
				this.__ownerID = ownerID;
				this._map = newMap;
				return this;
			}
			return this.__make(newMap, ownerID);
		};
		return Set$2;
	}(SetCollection);
	Set$1.isSet = isSet;
	SetPrototype = Set$1.prototype;
	SetPrototype[IS_SET_SYMBOL] = true;
	SetPrototype[DELETE] = SetPrototype.remove;
	SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
	SetPrototype.withMutations = withMutations;
	SetPrototype.asImmutable = asImmutable;
	SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
	SetPrototype["@@transducer/step"] = function(result, arr) {
		return result.add(arr);
	};
	SetPrototype["@@transducer/result"] = function(obj) {
		return obj.asImmutable();
	};
	SetPrototype.__empty = emptySet;
	SetPrototype.__make = makeSet;
	;
	Collection.Iterator = Iterator;
	mixin(Collection, {
		toArray: function toArray$1() {
			assertNotInfinite(this.size);
			var array = new Array(this.size || 0);
			var useTuples = isKeyed(this);
			var i = 0;
			this.__iterate(function(v, k) {
				array[i++] = useTuples ? [k, v] : v;
			});
			return array;
		},
		toIndexedSeq: function toIndexedSeq() {
			return new ToIndexedSequence(this);
		},
		toJS: function toJS$1() {
			return toJS(this);
		},
		toKeyedSeq: function toKeyedSeq() {
			return new ToKeyedSequence(this, true);
		},
		toMap: function toMap() {
			return Map$1(this.toKeyedSeq());
		},
		toObject,
		toOrderedMap: function toOrderedMap() {
			return OrderedMap(this.toKeyedSeq());
		},
		toOrderedSet: function toOrderedSet() {
			return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
		},
		toSet: function toSet() {
			return Set$1(isKeyed(this) ? this.valueSeq() : this);
		},
		toSetSeq: function toSetSeq() {
			return new ToSetSequence(this);
		},
		toSeq: function toSeq() {
			return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
		},
		toStack: function toStack() {
			return Stack(isKeyed(this) ? this.valueSeq() : this);
		},
		toList: function toList() {
			return List(isKeyed(this) ? this.valueSeq() : this);
		},
		toString: function toString$1() {
			return "[Collection]";
		},
		__toString: function __toString(head, tail) {
			if (this.size === 0) return head + tail;
			return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
		},
		concat: function concat$2() {
			var values = [], len = arguments.length;
			while (len--) values[len] = arguments[len];
			return reify(this, concatFactory(this, values));
		},
		includes: function includes(searchValue) {
			return this.some(function(value) {
				return is(value, searchValue);
			});
		},
		entries: function entries() {
			return this.__iterator(ITERATE_ENTRIES);
		},
		every: function every$1(predicate, context$1) {
			assertNotInfinite(this.size);
			var returnValue = true;
			this.__iterate(function(v, k, c$1) {
				if (!predicate.call(context$1, v, k, c$1)) {
					returnValue = false;
					return false;
				}
			});
			return returnValue;
		},
		filter: function filter$1(predicate, context$1) {
			return reify(this, filterFactory(this, predicate, context$1, true));
		},
		partition: function partition$2(predicate, context$1) {
			return partitionFactory(this, predicate, context$1);
		},
		find: function find$1(predicate, context$1, notSetValue) {
			var entry = this.findEntry(predicate, context$1);
			return entry ? entry[1] : notSetValue;
		},
		forEach: function forEach(sideEffect, context$1) {
			assertNotInfinite(this.size);
			return this.__iterate(context$1 ? sideEffect.bind(context$1) : sideEffect);
		},
		join: function join(separator) {
			assertNotInfinite(this.size);
			separator = separator !== void 0 ? "" + separator : ",";
			var joined = "";
			var isFirst = true;
			this.__iterate(function(v) {
				isFirst ? isFirst = false : joined += separator;
				joined += v !== null && v !== void 0 ? v.toString() : "";
			});
			return joined;
		},
		keys: function keys() {
			return this.__iterator(ITERATE_KEYS);
		},
		map: function map$1(mapper, context$1) {
			return reify(this, mapFactory(this, mapper, context$1));
		},
		reduce: function reduce$1$1(reducer, initialReduction, context$1) {
			return reduce$1(this, reducer, initialReduction, context$1, arguments.length < 2, false);
		},
		reduceRight: function reduceRight(reducer, initialReduction, context$1) {
			return reduce$1(this, reducer, initialReduction, context$1, arguments.length < 2, true);
		},
		reverse: function reverse() {
			return reify(this, reverseFactory(this, true));
		},
		slice: function slice(begin, end) {
			return reify(this, sliceFactory(this, begin, end, true));
		},
		some: function some(predicate, context$1) {
			assertNotInfinite(this.size);
			var returnValue = false;
			this.__iterate(function(v, k, c$1) {
				if (predicate.call(context$1, v, k, c$1)) {
					returnValue = true;
					return false;
				}
			});
			return returnValue;
		},
		sort: function sort(comparator) {
			return reify(this, sortFactory(this, comparator));
		},
		values: function values() {
			return this.__iterator(ITERATE_VALUES);
		},
		butLast: function butLast() {
			return this.slice(0, -1);
		},
		isEmpty: function isEmpty$1() {
			return this.size !== void 0 ? this.size === 0 : !this.some(function() {
				return true;
			});
		},
		count: function count$1(predicate, context$1) {
			return ensureSize(predicate ? this.toSeq().filter(predicate, context$1) : this);
		},
		countBy: function countBy(grouper, context$1) {
			return countByFactory(this, grouper, context$1);
		},
		equals: function equals$2(other) {
			return deepEqual(this, other);
		},
		entrySeq: function entrySeq() {
			var collection = this;
			if (collection._cache) return new ArraySeq(collection._cache);
			var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
			entriesSequence.fromEntrySeq = function() {
				return collection.toSeq();
			};
			return entriesSequence;
		},
		filterNot: function filterNot(predicate, context$1) {
			return this.filter(not$1(predicate), context$1);
		},
		findEntry: function findEntry(predicate, context$1, notSetValue) {
			var found = notSetValue;
			this.__iterate(function(v, k, c$1) {
				if (predicate.call(context$1, v, k, c$1)) {
					found = [k, v];
					return false;
				}
			});
			return found;
		},
		findKey: function findKey(predicate, context$1) {
			var entry = this.findEntry(predicate, context$1);
			return entry && entry[0];
		},
		findLast: function findLast(predicate, context$1, notSetValue) {
			return this.toKeyedSeq().reverse().find(predicate, context$1, notSetValue);
		},
		findLastEntry: function findLastEntry(predicate, context$1, notSetValue) {
			return this.toKeyedSeq().reverse().findEntry(predicate, context$1, notSetValue);
		},
		findLastKey: function findLastKey(predicate, context$1) {
			return this.toKeyedSeq().reverse().findKey(predicate, context$1);
		},
		first: function first$1(notSetValue) {
			return this.find(returnTrue, null, notSetValue);
		},
		flatMap: function flatMap(mapper, context$1) {
			return reify(this, flatMapFactory(this, mapper, context$1));
		},
		flatten: function flatten(depth) {
			return reify(this, flattenFactory(this, depth, true));
		},
		fromEntrySeq: function fromEntrySeq() {
			return new FromEntriesSequence(this);
		},
		get: function get$2(searchKey, notSetValue) {
			return this.find(function(_, key) {
				return is(key, searchKey);
			}, void 0, notSetValue);
		},
		getIn,
		groupBy: function groupBy$1(grouper, context$1) {
			return groupByFactory(this, grouper, context$1);
		},
		has: function has$1(searchKey) {
			return this.get(searchKey, NOT_SET) !== NOT_SET;
		},
		hasIn,
		isSubset: function isSubset(iter) {
			iter = typeof iter.includes === "function" ? iter : Collection(iter);
			return this.every(function(value) {
				return iter.includes(value);
			});
		},
		isSuperset: function isSuperset(iter) {
			iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
			return iter.isSubset(this);
		},
		keyOf: function keyOf(searchValue) {
			return this.findKey(function(value) {
				return is(value, searchValue);
			});
		},
		keySeq: function keySeq() {
			return this.toSeq().map(keyMapper).toIndexedSeq();
		},
		last: function last$3(notSetValue) {
			return this.toSeq().reverse().first(notSetValue);
		},
		lastKeyOf: function lastKeyOf(searchValue) {
			return this.toKeyedSeq().reverse().keyOf(searchValue);
		},
		max: function max$2(comparator) {
			return maxFactory(this, comparator);
		},
		maxBy: function maxBy(mapper, comparator) {
			return maxFactory(this, comparator, mapper);
		},
		min: function min$1(comparator) {
			return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
		},
		minBy: function minBy(mapper, comparator) {
			return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
		},
		rest: function rest() {
			return this.slice(1);
		},
		skip: function skip$1(amount) {
			return amount === 0 ? this : this.slice(Math.max(0, amount));
		},
		skipLast: function skipLast$1(amount) {
			return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
		},
		skipWhile: function skipWhile$1(predicate, context$1) {
			return reify(this, skipWhileFactory(this, predicate, context$1, true));
		},
		skipUntil: function skipUntil$1(predicate, context$1) {
			return this.skipWhile(not$1(predicate), context$1);
		},
		sortBy: function sortBy(mapper, comparator) {
			return reify(this, sortFactory(this, comparator, mapper));
		},
		take: function take$1(amount) {
			return this.slice(0, Math.max(0, amount));
		},
		takeLast: function takeLast$1(amount) {
			return this.slice(-Math.max(0, amount));
		},
		takeWhile: function takeWhile$1(predicate, context$1) {
			return reify(this, takeWhileFactory(this, predicate, context$1));
		},
		takeUntil: function takeUntil$1(predicate, context$1) {
			return this.takeWhile(not$1(predicate), context$1);
		},
		update: function update$2(fn) {
			return fn(this);
		},
		valueSeq: function valueSeq() {
			return this.toIndexedSeq();
		},
		hashCode: function hashCode$1() {
			return this.__hash || (this.__hash = hashCollection(this));
		}
	});
	CollectionPrototype = Collection.prototype;
	CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
	CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
	CollectionPrototype.toJSON = CollectionPrototype.toArray;
	CollectionPrototype.__toStringMapper = quoteString;
	CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
		return this.toString();
	};
	CollectionPrototype.chain = CollectionPrototype.flatMap;
	CollectionPrototype.contains = CollectionPrototype.includes;
	mixin(KeyedCollection, {
		flip: function flip() {
			return reify(this, flipFactory(this));
		},
		mapEntries: function mapEntries(mapper, context$1) {
			var this$1$1 = this;
			var iterations = 0;
			return reify(this, this.toSeq().map(function(v, k) {
				return mapper.call(context$1, [k, v], iterations++, this$1$1);
			}).fromEntrySeq());
		},
		mapKeys: function mapKeys(mapper, context$1) {
			var this$1$1 = this;
			return reify(this, this.toSeq().flip().map(function(k, v) {
				return mapper.call(context$1, k, v, this$1$1);
			}).flip());
		}
	});
	KeyedCollectionPrototype = KeyedCollection.prototype;
	KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
	KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
	KeyedCollectionPrototype.toJSON = toObject;
	KeyedCollectionPrototype.__toStringMapper = function(v, k) {
		return quoteString(k) + ": " + quoteString(v);
	};
	mixin(IndexedCollection, {
		toKeyedSeq: function toKeyedSeq() {
			return new ToKeyedSequence(this, false);
		},
		filter: function filter$1(predicate, context$1) {
			return reify(this, filterFactory(this, predicate, context$1, false));
		},
		findIndex: function findIndex$1(predicate, context$1) {
			var entry = this.findEntry(predicate, context$1);
			return entry ? entry[0] : -1;
		},
		indexOf: function indexOf(searchValue) {
			var key = this.keyOf(searchValue);
			return key === void 0 ? -1 : key;
		},
		lastIndexOf: function lastIndexOf(searchValue) {
			var key = this.lastKeyOf(searchValue);
			return key === void 0 ? -1 : key;
		},
		reverse: function reverse() {
			return reify(this, reverseFactory(this, false));
		},
		slice: function slice(begin, end) {
			return reify(this, sliceFactory(this, begin, end, false));
		},
		splice: function splice(index, removeNum) {
			var numArgs = arguments.length;
			removeNum = Math.max(removeNum || 0, 0);
			if (numArgs === 0 || numArgs === 2 && !removeNum) return this;
			index = resolveBegin(index, index < 0 ? this.count() : this.size);
			var spliced = this.slice(0, index);
			return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
		},
		findLastIndex: function findLastIndex(predicate, context$1) {
			var entry = this.findLastEntry(predicate, context$1);
			return entry ? entry[0] : -1;
		},
		first: function first$1(notSetValue) {
			return this.get(0, notSetValue);
		},
		flatten: function flatten(depth) {
			return reify(this, flattenFactory(this, depth, false));
		},
		get: function get$2(index, notSetValue) {
			index = wrapIndex(this, index);
			return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function(_, key) {
				return key === index;
			}, void 0, notSetValue);
		},
		has: function has$1(index) {
			index = wrapIndex(this, index);
			return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
		},
		interpose: function interpose(separator) {
			return reify(this, interposeFactory(this, separator));
		},
		interleave: function interleave() {
			var collections = [this].concat(arrCopy(arguments));
			var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
			var interleaved = zipped.flatten(true);
			if (zipped.size) interleaved.size = zipped.size * collections.length;
			return reify(this, interleaved);
		},
		keySeq: function keySeq() {
			return Range(0, this.size);
		},
		last: function last$3(notSetValue) {
			return this.get(-1, notSetValue);
		},
		skipWhile: function skipWhile$1(predicate, context$1) {
			return reify(this, skipWhileFactory(this, predicate, context$1, false));
		},
		zip: function zip$2() {
			var collections = [this].concat(arrCopy(arguments));
			return reify(this, zipWithFactory(this, defaultZipper, collections));
		},
		zipAll: function zipAll$1() {
			var collections = [this].concat(arrCopy(arguments));
			return reify(this, zipWithFactory(this, defaultZipper, collections, true));
		},
		zipWith: function zipWith$1(zipper) {
			var collections = arrCopy(arguments);
			collections[0] = this;
			return reify(this, zipWithFactory(this, zipper, collections));
		}
	});
	IndexedCollectionPrototype = IndexedCollection.prototype;
	IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
	IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
	mixin(SetCollection, {
		get: function get$2(value, notSetValue) {
			return this.has(value) ? value : notSetValue;
		},
		includes: function includes(value) {
			return this.has(value);
		},
		keySeq: function keySeq() {
			return this.valueSeq();
		}
	});
	SetCollectionPrototype = SetCollection.prototype;
	SetCollectionPrototype.has = CollectionPrototype.includes;
	SetCollectionPrototype.contains = SetCollectionPrototype.includes;
	SetCollectionPrototype.keys = SetCollectionPrototype.values;
	mixin(KeyedSeq, KeyedCollectionPrototype);
	mixin(IndexedSeq, IndexedCollectionPrototype);
	mixin(SetSeq, SetCollectionPrototype);
	OrderedSet = /* @__PURE__ */ function(Set$2) {
		function OrderedSet$1(value) {
			return value === void 0 || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set$2) {
				var iter = SetCollection(value);
				assertNotInfinite(iter.size);
				iter.forEach(function(v) {
					return set$2.add(v);
				});
			});
		}
		if (Set$2) OrderedSet$1.__proto__ = Set$2;
		OrderedSet$1.prototype = Object.create(Set$2 && Set$2.prototype);
		OrderedSet$1.prototype.constructor = OrderedSet$1;
		OrderedSet$1.of = function of$1() {
			return this(arguments);
		};
		OrderedSet$1.fromKeys = function fromKeys(value) {
			return this(KeyedCollection(value).keySeq());
		};
		OrderedSet$1.prototype.toString = function toString$1() {
			return this.__toString("OrderedSet {", "}");
		};
		return OrderedSet$1;
	}(Set$1);
	OrderedSet.isOrderedSet = isOrderedSet;
	OrderedSetPrototype = OrderedSet.prototype;
	OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
	OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
	OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
	OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
	OrderedSetPrototype.__empty = emptyOrderedSet;
	OrderedSetPrototype.__make = makeOrderedSet;
	;
	PairSorting = {
		LeftThenRight: -1,
		RightThenLeft: 1
	};
	Record = function Record$1(defaultValues, name) {
		var hasInitialized;
		throwOnInvalidDefaultValues(defaultValues);
		var RecordType = function Record$2(values) {
			var this$1$1 = this;
			if (values instanceof RecordType) return values;
			if (!(this instanceof RecordType)) return new RecordType(values);
			if (!hasInitialized) {
				hasInitialized = true;
				var keys = Object.keys(defaultValues);
				var indices = RecordTypePrototype._indices = {};
				RecordTypePrototype._name = name;
				RecordTypePrototype._keys = keys;
				RecordTypePrototype._defaultValues = defaultValues;
				for (var i = 0; i < keys.length; i++) {
					var propName = keys[i];
					indices[propName] = i;
					if (RecordTypePrototype[propName]) typeof console === "object" && console.warn && console.warn("Cannot define " + recordName(this) + " with property \"" + propName + "\" since that property name is part of the Record API.");
					else setProp(RecordTypePrototype, propName);
				}
			}
			this.__ownerID = void 0;
			this._values = List().withMutations(function(l) {
				l.setSize(this$1$1._keys.length);
				KeyedCollection(values).forEach(function(v, k) {
					l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? void 0 : v);
				});
			});
			return this;
		};
		var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
		RecordTypePrototype.constructor = RecordType;
		if (name) RecordType.displayName = name;
		return RecordType;
	};
	Record.prototype.toString = function toString$1() {
		var str = recordName(this) + " { ";
		var keys = this._keys;
		var k;
		for (var i = 0, l = keys.length; i !== l; i++) {
			k = keys[i];
			str += (i ? ", " : "") + k + ": " + quoteString(this.get(k));
		}
		return str + " }";
	};
	Record.prototype.equals = function equals$2(other) {
		return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
	};
	Record.prototype.hashCode = function hashCode$1() {
		return recordSeq(this).hashCode();
	};
	Record.prototype.has = function has$1(k) {
		return this._indices.hasOwnProperty(k);
	};
	Record.prototype.get = function get$2(k, notSetValue) {
		if (!this.has(k)) return notSetValue;
		var index = this._indices[k];
		var value = this._values.get(index);
		return value === void 0 ? this._defaultValues[k] : value;
	};
	Record.prototype.set = function set$2(k, v) {
		if (this.has(k)) {
			var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? void 0 : v);
			if (newValues !== this._values && !this.__ownerID) return makeRecord(this, newValues);
		}
		return this;
	};
	Record.prototype.remove = function remove$1(k) {
		return this.set(k);
	};
	Record.prototype.clear = function clear() {
		var newValues = this._values.clear().setSize(this._keys.length);
		return this.__ownerID ? this : makeRecord(this, newValues);
	};
	Record.prototype.wasAltered = function wasAltered$1() {
		return this._values.wasAltered();
	};
	Record.prototype.toSeq = function toSeq() {
		return recordSeq(this);
	};
	Record.prototype.toJS = function toJS$1() {
		return toJS(this);
	};
	Record.prototype.entries = function entries() {
		return this.__iterator(ITERATE_ENTRIES);
	};
	Record.prototype.__iterator = function __iterator(type$1, reverse) {
		return recordSeq(this).__iterator(type$1, reverse);
	};
	Record.prototype.__iterate = function __iterate(fn, reverse) {
		return recordSeq(this).__iterate(fn, reverse);
	};
	Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
		if (ownerID === this.__ownerID) return this;
		var newValues = this._values.__ensureOwner(ownerID);
		if (!ownerID) {
			this.__ownerID = ownerID;
			this._values = newValues;
			return this;
		}
		return makeRecord(this, newValues, ownerID);
	};
	Record.isRecord = isRecord;
	Record.getDescriptiveName = recordName;
	RecordPrototype = Record.prototype;
	RecordPrototype[IS_RECORD_SYMBOL] = true;
	RecordPrototype[DELETE] = RecordPrototype.remove;
	RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
	RecordPrototype.getIn = getIn;
	RecordPrototype.hasIn = CollectionPrototype.hasIn;
	RecordPrototype.merge = merge$1$1;
	RecordPrototype.mergeWith = mergeWith$1;
	RecordPrototype.mergeIn = mergeIn;
	RecordPrototype.mergeDeep = mergeDeep;
	RecordPrototype.mergeDeepWith = mergeDeepWith;
	RecordPrototype.mergeDeepIn = mergeDeepIn;
	RecordPrototype.setIn = setIn;
	RecordPrototype.update = update;
	RecordPrototype.updateIn = updateIn$1;
	RecordPrototype.withMutations = withMutations;
	RecordPrototype.asMutable = asMutable;
	RecordPrototype.asImmutable = asImmutable;
	RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
	RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
	RecordPrototype.inspect = RecordPrototype.toSource = function() {
		return this.toString();
	};
	Repeat = /* @__PURE__ */ function(IndexedSeq$1) {
		function Repeat$1(value, times) {
			if (!(this instanceof Repeat$1)) return new Repeat$1(value, times);
			this._value = value;
			this.size = times === void 0 ? Infinity : Math.max(0, times);
			if (this.size === 0) {
				if (EMPTY_REPEAT) return EMPTY_REPEAT;
				EMPTY_REPEAT = this;
			}
		}
		if (IndexedSeq$1) Repeat$1.__proto__ = IndexedSeq$1;
		Repeat$1.prototype = Object.create(IndexedSeq$1 && IndexedSeq$1.prototype);
		Repeat$1.prototype.constructor = Repeat$1;
		Repeat$1.prototype.toString = function toString$1() {
			if (this.size === 0) return "Repeat []";
			return "Repeat [ " + this._value + " " + this.size + " times ]";
		};
		Repeat$1.prototype.get = function get$2(index, notSetValue) {
			return this.has(index) ? this._value : notSetValue;
		};
		Repeat$1.prototype.includes = function includes(searchValue) {
			return is(this._value, searchValue);
		};
		Repeat$1.prototype.slice = function slice(begin, end) {
			var size = this.size;
			return wholeSlice(begin, end, size) ? this : new Repeat$1(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
		};
		Repeat$1.prototype.reverse = function reverse() {
			return this;
		};
		Repeat$1.prototype.indexOf = function indexOf(searchValue) {
			if (is(this._value, searchValue)) return 0;
			return -1;
		};
		Repeat$1.prototype.lastIndexOf = function lastIndexOf(searchValue) {
			if (is(this._value, searchValue)) return this.size;
			return -1;
		};
		Repeat$1.prototype.__iterate = function __iterate(fn, reverse) {
			var size = this.size;
			var i = 0;
			while (i !== size) if (fn(this._value, reverse ? size - ++i : i++, this) === false) break;
			return i;
		};
		Repeat$1.prototype.__iterator = function __iterator(type$1, reverse) {
			var this$1$1 = this;
			var size = this.size;
			var i = 0;
			return new Iterator(function() {
				return i === size ? iteratorDone() : iteratorValue(type$1, reverse ? size - ++i : i++, this$1$1._value);
			});
		};
		Repeat$1.prototype.equals = function equals$2(other) {
			return other instanceof Repeat$1 ? is(this._value, other._value) : deepEqual(this, other);
		};
		return Repeat$1;
	}(IndexedSeq);
	;
	version = "5.1.4";
	Iterable = Collection;
}) });

//#endregion
//#region browser-external:path
var require_browser_external_path = /* @__PURE__ */ __commonJS({ "browser-external:path": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region browser-external:url
var require_browser_external_url = /* @__PURE__ */ __commonJS({ "browser-external:url": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/reflect/names.js
var require_names = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/reflect/names.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.qualifiedName = qualifiedName;
	exports.protoCamelCase = protoCamelCase;
	exports.safeObjectProperty = safeObjectProperty;
	/**
	* Return a fully-qualified name for a Protobuf descriptor.
	* For a file descriptor, return the original file path.
	*
	* See https://protobuf.com/docs/language-spec#fully-qualified-names
	*/
	function qualifiedName(desc) {
		switch (desc.kind) {
			case "field":
			case "oneof":
			case "rpc": return desc.parent.typeName + "." + desc.name;
			case "enum_value": {
				const p$10 = desc.parent.parent ? desc.parent.parent.typeName : desc.parent.file.proto.package;
				return p$10 + (p$10.length > 0 ? "." : "") + desc.name;
			}
			case "service":
			case "message":
			case "enum":
			case "extension": return desc.typeName;
			case "file": return desc.proto.name;
		}
	}
	/**
	* Converts snake_case to protoCamelCase according to the convention
	* used by protoc to convert a field name to a JSON name.
	*/
	function protoCamelCase(snakeCase) {
		let capNext = false;
		const b$2 = [];
		for (let i = 0; i < snakeCase.length; i++) {
			let c$1 = snakeCase.charAt(i);
			switch (c$1) {
				case "_":
					capNext = true;
					break;
				case "0":
				case "1":
				case "2":
				case "3":
				case "4":
				case "5":
				case "6":
				case "7":
				case "8":
				case "9":
					b$2.push(c$1);
					capNext = false;
					break;
				default:
					if (capNext) {
						capNext = false;
						c$1 = c$1.toUpperCase();
					}
					b$2.push(c$1);
					break;
			}
		}
		return b$2.join("");
	}
	/**
	* Names that cannot be used for object properties because they are reserved
	* by built-in JavaScript properties.
	*/
	var reservedObjectProperties = new Set([
		"constructor",
		"toString",
		"toJSON",
		"valueOf"
	]);
	/**
	* Escapes names that are reserved for ECMAScript built-in object properties.
	*
	* Also see safeIdentifier() from @bufbuild/protoplugin.
	*/
	function safeObjectProperty(name) {
		return reservedObjectProperties.has(name) ? name + "$" : name;
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wire/varint.js
var require_varint$1 = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wire/varint.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.varint64read = varint64read;
	exports.varint64write = varint64write;
	exports.int64FromString = int64FromString;
	exports.int64ToString = int64ToString;
	exports.uInt64ToString = uInt64ToString;
	exports.varint32write = varint32write;
	exports.varint32read = varint32read;
	/**
	* Read a 64 bit varint as two JS numbers.
	*
	* Returns tuple:
	* [0]: low bits
	* [1]: high bits
	*
	* Copyright 2008 Google Inc.  All rights reserved.
	*
	* See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
	*/
	function varint64read() {
		let lowBits = 0;
		let highBits = 0;
		for (let shift = 0; shift < 28; shift += 7) {
			let b$2 = this.buf[this.pos++];
			lowBits |= (b$2 & 127) << shift;
			if ((b$2 & 128) == 0) {
				this.assertBounds();
				return [lowBits, highBits];
			}
		}
		let middleByte = this.buf[this.pos++];
		lowBits |= (middleByte & 15) << 28;
		highBits = (middleByte & 112) >> 4;
		if ((middleByte & 128) == 0) {
			this.assertBounds();
			return [lowBits, highBits];
		}
		for (let shift = 3; shift <= 31; shift += 7) {
			let b$2 = this.buf[this.pos++];
			highBits |= (b$2 & 127) << shift;
			if ((b$2 & 128) == 0) {
				this.assertBounds();
				return [lowBits, highBits];
			}
		}
		throw new Error("invalid varint");
	}
	/**
	* Write a 64 bit varint, given as two JS numbers, to the given bytes array.
	*
	* Copyright 2008 Google Inc.  All rights reserved.
	*
	* See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
	*/
	function varint64write(lo, hi, bytes) {
		for (let i = 0; i < 28; i = i + 7) {
			const shift = lo >>> i;
			const hasNext = !(shift >>> 7 == 0 && hi == 0);
			const byte = (hasNext ? shift | 128 : shift) & 255;
			bytes.push(byte);
			if (!hasNext) return;
		}
		const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
		const hasMoreBits = !(hi >> 3 == 0);
		bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
		if (!hasMoreBits) return;
		for (let i = 3; i < 31; i = i + 7) {
			const shift = hi >>> i;
			const hasNext = !(shift >>> 7 == 0);
			const byte = (hasNext ? shift | 128 : shift) & 255;
			bytes.push(byte);
			if (!hasNext) return;
		}
		bytes.push(hi >>> 31 & 1);
	}
	var TWO_PWR_32_DBL = 4294967296;
	/**
	* Parse decimal string of 64 bit integer value as two JS numbers.
	*
	* Copyright 2008 Google Inc.  All rights reserved.
	*
	* See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
	*/
	function int64FromString(dec) {
		const minus = dec[0] === "-";
		if (minus) dec = dec.slice(1);
		const base = 1e6;
		let lowBits = 0;
		let highBits = 0;
		function add1e6digit(begin, end) {
			const digit1e6 = Number(dec.slice(begin, end));
			highBits *= base;
			lowBits = lowBits * base + digit1e6;
			if (lowBits >= TWO_PWR_32_DBL) {
				highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
				lowBits = lowBits % TWO_PWR_32_DBL;
			}
		}
		add1e6digit(-24, -18);
		add1e6digit(-18, -12);
		add1e6digit(-12, -6);
		add1e6digit(-6);
		return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
	}
	/**
	* Losslessly converts a 64-bit signed integer in 32:32 split representation
	* into a decimal string.
	*
	* Copyright 2008 Google Inc.  All rights reserved.
	*
	* See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
	*/
	function int64ToString(lo, hi) {
		let bits = newBits(lo, hi);
		const negative = bits.hi & 2147483648;
		if (negative) bits = negate(bits.lo, bits.hi);
		const result = uInt64ToString(bits.lo, bits.hi);
		return negative ? "-" + result : result;
	}
	/**
	* Losslessly converts a 64-bit unsigned integer in 32:32 split representation
	* into a decimal string.
	*
	* Copyright 2008 Google Inc.  All rights reserved.
	*
	* See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
	*/
	function uInt64ToString(lo, hi) {
		({lo, hi} = toUnsigned(lo, hi));
		if (hi <= 2097151) return String(TWO_PWR_32_DBL * hi + lo);
		const low = lo & 16777215;
		const mid = (lo >>> 24 | hi << 8) & 16777215;
		const high = hi >> 16 & 65535;
		let digitA = low + mid * 6777216 + high * 6710656;
		let digitB = mid + high * 8147497;
		let digitC = high * 2;
		const base = 1e7;
		if (digitA >= base) {
			digitB += Math.floor(digitA / base);
			digitA %= base;
		}
		if (digitB >= base) {
			digitC += Math.floor(digitB / base);
			digitB %= base;
		}
		return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
	}
	function toUnsigned(lo, hi) {
		return {
			lo: lo >>> 0,
			hi: hi >>> 0
		};
	}
	function newBits(lo, hi) {
		return {
			lo: lo | 0,
			hi: hi | 0
		};
	}
	/**
	* Returns two's compliment negation of input.
	* @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers
	*/
	function negate(lowBits, highBits) {
		highBits = ~highBits;
		if (lowBits) lowBits = ~lowBits + 1;
		else highBits += 1;
		return newBits(lowBits, highBits);
	}
	/**
	* Returns decimal representation of digit1e7 with leading zeros.
	*/
	var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
		const partial = String(digit1e7);
		return "0000000".slice(partial.length) + partial;
	};
	/**
	* Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
	*
	* Copyright 2008 Google Inc.  All rights reserved.
	*
	* See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
	*/
	function varint32write(value, bytes) {
		if (value >= 0) {
			while (value > 127) {
				bytes.push(value & 127 | 128);
				value = value >>> 7;
			}
			bytes.push(value);
		} else {
			for (let i = 0; i < 9; i++) {
				bytes.push(value & 127 | 128);
				value = value >> 7;
			}
			bytes.push(1);
		}
	}
	/**
	* Read an unsigned 32 bit varint.
	*
	* See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
	*/
	function varint32read() {
		let b$2 = this.buf[this.pos++];
		let result = b$2 & 127;
		if ((b$2 & 128) == 0) {
			this.assertBounds();
			return result;
		}
		b$2 = this.buf[this.pos++];
		result |= (b$2 & 127) << 7;
		if ((b$2 & 128) == 0) {
			this.assertBounds();
			return result;
		}
		b$2 = this.buf[this.pos++];
		result |= (b$2 & 127) << 14;
		if ((b$2 & 128) == 0) {
			this.assertBounds();
			return result;
		}
		b$2 = this.buf[this.pos++];
		result |= (b$2 & 127) << 21;
		if ((b$2 & 128) == 0) {
			this.assertBounds();
			return result;
		}
		b$2 = this.buf[this.pos++];
		result |= (b$2 & 15) << 28;
		for (let readBytes = 5; (b$2 & 128) !== 0 && readBytes < 10; readBytes++) b$2 = this.buf[this.pos++];
		if ((b$2 & 128) != 0) throw new Error("invalid varint");
		this.assertBounds();
		return result >>> 0;
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/proto-int64.js
var require_proto_int64 = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/proto-int64.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var varint_js_1$2 = require_varint$1();
	/**
	* Int64Support for the current environment.
	*/
	exports.protoInt64 = makeInt64Support();
	function makeInt64Support() {
		const dv = /* @__PURE__ */ new DataView(/* @__PURE__ */ new ArrayBuffer(8));
		if (typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (!!globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
			const MIN = BigInt("-9223372036854775808");
			const MAX = BigInt("9223372036854775807");
			const UMIN = BigInt("0");
			const UMAX = BigInt("18446744073709551615");
			return {
				zero: BigInt(0),
				supported: true,
				parse(value) {
					const bi = typeof value == "bigint" ? value : BigInt(value);
					if (bi > MAX || bi < MIN) throw new Error(`invalid int64: ${value}`);
					return bi;
				},
				uParse(value) {
					const bi = typeof value == "bigint" ? value : BigInt(value);
					if (bi > UMAX || bi < UMIN) throw new Error(`invalid uint64: ${value}`);
					return bi;
				},
				enc(value) {
					dv.setBigInt64(0, this.parse(value), true);
					return {
						lo: dv.getInt32(0, true),
						hi: dv.getInt32(4, true)
					};
				},
				uEnc(value) {
					dv.setBigInt64(0, this.uParse(value), true);
					return {
						lo: dv.getInt32(0, true),
						hi: dv.getInt32(4, true)
					};
				},
				dec(lo, hi) {
					dv.setInt32(0, lo, true);
					dv.setInt32(4, hi, true);
					return dv.getBigInt64(0, true);
				},
				uDec(lo, hi) {
					dv.setInt32(0, lo, true);
					dv.setInt32(4, hi, true);
					return dv.getBigUint64(0, true);
				}
			};
		}
		return {
			zero: "0",
			supported: false,
			parse(value) {
				if (typeof value != "string") value = value.toString();
				assertInt64String(value);
				return value;
			},
			uParse(value) {
				if (typeof value != "string") value = value.toString();
				assertUInt64String(value);
				return value;
			},
			enc(value) {
				if (typeof value != "string") value = value.toString();
				assertInt64String(value);
				return (0, varint_js_1$2.int64FromString)(value);
			},
			uEnc(value) {
				if (typeof value != "string") value = value.toString();
				assertUInt64String(value);
				return (0, varint_js_1$2.int64FromString)(value);
			},
			dec(lo, hi) {
				return (0, varint_js_1$2.int64ToString)(lo, hi);
			},
			uDec(lo, hi) {
				return (0, varint_js_1$2.uInt64ToString)(lo, hi);
			}
		};
	}
	function assertInt64String(value) {
		if (!/^-?[0-9]+$/.test(value)) throw new Error("invalid int64: " + value);
	}
	function assertUInt64String(value) {
		if (!/^[0-9]+$/.test(value)) throw new Error("invalid uint64: " + value);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/descriptors.js
var require_descriptors = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/descriptors.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* Scalar value types. This is a subset of field types declared by protobuf
	* enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
	* are omitted, but the numerical values are identical.
	*/
	var ScalarType;
	(function(ScalarType$1) {
		ScalarType$1[ScalarType$1["DOUBLE"] = 1] = "DOUBLE";
		ScalarType$1[ScalarType$1["FLOAT"] = 2] = "FLOAT";
		ScalarType$1[ScalarType$1["INT64"] = 3] = "INT64";
		ScalarType$1[ScalarType$1["UINT64"] = 4] = "UINT64";
		ScalarType$1[ScalarType$1["INT32"] = 5] = "INT32";
		ScalarType$1[ScalarType$1["FIXED64"] = 6] = "FIXED64";
		ScalarType$1[ScalarType$1["FIXED32"] = 7] = "FIXED32";
		ScalarType$1[ScalarType$1["BOOL"] = 8] = "BOOL";
		ScalarType$1[ScalarType$1["STRING"] = 9] = "STRING";
		ScalarType$1[ScalarType$1["BYTES"] = 12] = "BYTES";
		ScalarType$1[ScalarType$1["UINT32"] = 13] = "UINT32";
		ScalarType$1[ScalarType$1["SFIXED32"] = 15] = "SFIXED32";
		ScalarType$1[ScalarType$1["SFIXED64"] = 16] = "SFIXED64";
		ScalarType$1[ScalarType$1["SINT32"] = 17] = "SINT32";
		ScalarType$1[ScalarType$1["SINT64"] = 18] = "SINT64";
	})(ScalarType || (exports.ScalarType = ScalarType = {}));
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/reflect/scalar.js
var require_scalar$1 = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/reflect/scalar.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.scalarEquals = scalarEquals;
	exports.scalarZeroValue = scalarZeroValue;
	exports.isScalarZeroValue = isScalarZeroValue;
	var proto_int64_js_1$7 = require_proto_int64();
	var descriptors_js_1$12 = require_descriptors();
	/**
	* Returns true if both scalar values are equal.
	*/
	function scalarEquals(type$1, a$1, b$2) {
		if (a$1 === b$2) return true;
		if (type$1 == descriptors_js_1$12.ScalarType.BYTES) {
			if (!(a$1 instanceof Uint8Array) || !(b$2 instanceof Uint8Array)) return false;
			if (a$1.length !== b$2.length) return false;
			for (let i = 0; i < a$1.length; i++) if (a$1[i] !== b$2[i]) return false;
			return true;
		}
		switch (type$1) {
			case descriptors_js_1$12.ScalarType.UINT64:
			case descriptors_js_1$12.ScalarType.FIXED64:
			case descriptors_js_1$12.ScalarType.INT64:
			case descriptors_js_1$12.ScalarType.SFIXED64:
			case descriptors_js_1$12.ScalarType.SINT64: return a$1 == b$2;
		}
		return false;
	}
	/**
	* Returns the zero value for the given scalar type.
	*/
	function scalarZeroValue(type$1, longAsString) {
		switch (type$1) {
			case descriptors_js_1$12.ScalarType.STRING: return "";
			case descriptors_js_1$12.ScalarType.BOOL: return false;
			case descriptors_js_1$12.ScalarType.DOUBLE:
			case descriptors_js_1$12.ScalarType.FLOAT: return 0;
			case descriptors_js_1$12.ScalarType.INT64:
			case descriptors_js_1$12.ScalarType.UINT64:
			case descriptors_js_1$12.ScalarType.SFIXED64:
			case descriptors_js_1$12.ScalarType.FIXED64:
			case descriptors_js_1$12.ScalarType.SINT64: return longAsString ? "0" : proto_int64_js_1$7.protoInt64.zero;
			case descriptors_js_1$12.ScalarType.BYTES: return new Uint8Array(0);
			default: return 0;
		}
	}
	/**
	* Returns true for a zero-value. For example, an integer has the zero-value `0`,
	* a boolean is `false`, a string is `""`, and bytes is an empty Uint8Array.
	*
	* In proto3, zero-values are not written to the wire, unless the field is
	* optional or repeated.
	*/
	function isScalarZeroValue(type$1, value) {
		switch (type$1) {
			case descriptors_js_1$12.ScalarType.BOOL: return value === false;
			case descriptors_js_1$12.ScalarType.STRING: return value === "";
			case descriptors_js_1$12.ScalarType.BYTES: return value instanceof Uint8Array && !value.byteLength;
			default: return value == 0;
		}
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/reflect/unsafe.js
var require_unsafe = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/reflect/unsafe.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.unsafeOneofCase = unsafeOneofCase;
	exports.unsafeIsSet = unsafeIsSet;
	exports.unsafeIsSetExplicit = unsafeIsSetExplicit;
	exports.unsafeGet = unsafeGet;
	exports.unsafeSet = unsafeSet;
	exports.unsafeClear = unsafeClear;
	var scalar_js_1$6 = require_scalar$1();
	var IMPLICIT$3 = 2;
	exports.unsafeLocal = Symbol.for("reflect unsafe local");
	/**
	* Return the selected field of a oneof group.
	*
	* @private
	*/
	function unsafeOneofCase(target, oneof) {
		const c$1 = target[oneof.localName].case;
		if (c$1 === void 0) return c$1;
		return oneof.fields.find((f) => f.localName === c$1);
	}
	/**
	* Returns true if the field is set.
	*
	* @private
	*/
	function unsafeIsSet(target, field) {
		const name = field.localName;
		if (field.oneof) return target[field.oneof.localName].case === name;
		if (field.presence != IMPLICIT$3) return target[name] !== void 0 && Object.prototype.hasOwnProperty.call(target, name);
		switch (field.fieldKind) {
			case "list": return target[name].length > 0;
			case "map": return Object.keys(target[name]).length > 0;
			case "scalar": return !(0, scalar_js_1$6.isScalarZeroValue)(field.scalar, target[name]);
			case "enum": return target[name] !== field.enum.values[0].number;
		}
		throw new Error("message field with implicit presence");
	}
	/**
	* Returns true if the field is set, but only for singular fields with explicit
	* presence (proto2).
	*
	* @private
	*/
	function unsafeIsSetExplicit(target, localName) {
		return Object.prototype.hasOwnProperty.call(target, localName) && target[localName] !== void 0;
	}
	/**
	* Return a field value, respecting oneof groups.
	*
	* @private
	*/
	function unsafeGet(target, field) {
		if (field.oneof) {
			const oneof = target[field.oneof.localName];
			if (oneof.case === field.localName) return oneof.value;
			return;
		}
		return target[field.localName];
	}
	/**
	* Set a field value, respecting oneof groups.
	*
	* @private
	*/
	function unsafeSet(target, field, value) {
		if (field.oneof) target[field.oneof.localName] = {
			case: field.localName,
			value
		};
		else target[field.localName] = value;
	}
	/**
	* Resets the field, so that unsafeIsSet() will return false.
	*
	* @private
	*/
	function unsafeClear(target, field) {
		const name = field.localName;
		if (field.oneof) {
			const oneofLocalName = field.oneof.localName;
			if (target[oneofLocalName].case === name) target[oneofLocalName] = { case: void 0 };
		} else if (field.presence != IMPLICIT$3) delete target[name];
		else switch (field.fieldKind) {
			case "map":
				target[name] = {};
				break;
			case "list":
				target[name] = [];
				break;
			case "enum":
				target[name] = field.enum.values[0].number;
				break;
			case "scalar":
				target[name] = (0, scalar_js_1$6.scalarZeroValue)(field.scalar, field.longAsString);
				break;
		}
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/restore-json-names.js
var require_restore_json_names = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/restore-json-names.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.restoreJsonNames = restoreJsonNames;
	var names_js_1$3 = require_names();
	var unsafe_js_1$5 = require_unsafe();
	/**
	* @private
	*/
	function restoreJsonNames(message) {
		for (const f of message.field) if (!(0, unsafe_js_1$5.unsafeIsSetExplicit)(f, "jsonName")) f.jsonName = (0, names_js_1$3.protoCamelCase)(f.name);
		message.nestedType.forEach(restoreJsonNames);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wire/text-format.js
var require_text_format = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wire/text-format.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseTextFormatEnumValue = parseTextFormatEnumValue;
	exports.parseTextFormatScalarValue = parseTextFormatScalarValue;
	var descriptors_js_1$11 = require_descriptors();
	var proto_int64_js_1$6 = require_proto_int64();
	/**
	* Parse an enum value from the Protobuf text format.
	*
	* @private
	*/
	function parseTextFormatEnumValue(descEnum, value) {
		const enumValue = descEnum.values.find((v) => v.name === value);
		if (!enumValue) throw new Error(`cannot parse ${descEnum} default value: ${value}`);
		return enumValue.number;
	}
	/**
	* Parse a scalar value from the Protobuf text format.
	*
	* @private
	*/
	function parseTextFormatScalarValue(type$1, value) {
		switch (type$1) {
			case descriptors_js_1$11.ScalarType.STRING: return value;
			case descriptors_js_1$11.ScalarType.BYTES: {
				const u = unescapeBytesDefaultValue(value);
				if (u === false) throw new Error(`cannot parse ${descriptors_js_1$11.ScalarType[type$1]} default value: ${value}`);
				return u;
			}
			case descriptors_js_1$11.ScalarType.INT64:
			case descriptors_js_1$11.ScalarType.SFIXED64:
			case descriptors_js_1$11.ScalarType.SINT64: return proto_int64_js_1$6.protoInt64.parse(value);
			case descriptors_js_1$11.ScalarType.UINT64:
			case descriptors_js_1$11.ScalarType.FIXED64: return proto_int64_js_1$6.protoInt64.uParse(value);
			case descriptors_js_1$11.ScalarType.DOUBLE:
			case descriptors_js_1$11.ScalarType.FLOAT: switch (value) {
				case "inf": return Number.POSITIVE_INFINITY;
				case "-inf": return Number.NEGATIVE_INFINITY;
				case "nan": return NaN;
				default: return parseFloat(value);
			}
			case descriptors_js_1$11.ScalarType.BOOL: return value === "true";
			case descriptors_js_1$11.ScalarType.INT32:
			case descriptors_js_1$11.ScalarType.UINT32:
			case descriptors_js_1$11.ScalarType.SINT32:
			case descriptors_js_1$11.ScalarType.FIXED32:
			case descriptors_js_1$11.ScalarType.SFIXED32: return parseInt(value, 10);
		}
	}
	/**
	* Parses a text-encoded default value (proto2) of a BYTES field.
	*/
	function unescapeBytesDefaultValue(str) {
		const b$2 = [];
		const input = {
			tail: str,
			c: "",
			next() {
				if (this.tail.length == 0) return false;
				this.c = this.tail[0];
				this.tail = this.tail.substring(1);
				return true;
			},
			take(n$2) {
				if (this.tail.length >= n$2) {
					const r = this.tail.substring(0, n$2);
					this.tail = this.tail.substring(n$2);
					return r;
				}
				return false;
			}
		};
		while (input.next()) switch (input.c) {
			case "\\":
				if (input.next()) switch (input.c) {
					case "\\":
						b$2.push(input.c.charCodeAt(0));
						break;
					case "b":
						b$2.push(8);
						break;
					case "f":
						b$2.push(12);
						break;
					case "n":
						b$2.push(10);
						break;
					case "r":
						b$2.push(13);
						break;
					case "t":
						b$2.push(9);
						break;
					case "v":
						b$2.push(11);
						break;
					case "0":
					case "1":
					case "2":
					case "3":
					case "4":
					case "5":
					case "6":
					case "7": {
						const s = input.c;
						const t = input.take(2);
						if (t === false) return false;
						const n$2 = parseInt(s + t, 8);
						if (Number.isNaN(n$2)) return false;
						b$2.push(n$2);
						break;
					}
					case "x": {
						const s = input.c;
						const t = input.take(2);
						if (t === false) return false;
						const n$2 = parseInt(s + t, 16);
						if (Number.isNaN(n$2)) return false;
						b$2.push(n$2);
						break;
					}
					case "u": {
						const s = input.c;
						const t = input.take(4);
						if (t === false) return false;
						const n$2 = parseInt(s + t, 16);
						if (Number.isNaN(n$2)) return false;
						const chunk = new Uint8Array(4);
						new DataView(chunk.buffer).setInt32(0, n$2, true);
						b$2.push(chunk[0], chunk[1], chunk[2], chunk[3]);
						break;
					}
					case "U": {
						const s = input.c;
						const t = input.take(8);
						if (t === false) return false;
						const tc = proto_int64_js_1$6.protoInt64.uEnc(s + t);
						const chunk = new Uint8Array(8);
						const view = new DataView(chunk.buffer);
						view.setInt32(0, tc.lo, true);
						view.setInt32(4, tc.hi, true);
						b$2.push(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4], chunk[5], chunk[6], chunk[7]);
						break;
					}
				}
				break;
			default: b$2.push(input.c.charCodeAt(0));
		}
		return new Uint8Array(b$2);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/reflect/nested-types.js
var require_nested_types = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/reflect/nested-types.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.nestedTypes = nestedTypes;
	exports.usedTypes = usedTypes;
	exports.parentTypes = parentTypes;
	/**
	* Iterate over all types - enumerations, extensions, services, messages -
	* and enumerations, extensions and messages nested in messages.
	*/
	function* nestedTypes(desc) {
		switch (desc.kind) {
			case "file":
				for (const message of desc.messages) {
					yield message;
					yield* nestedTypes(message);
				}
				yield* desc.enums;
				yield* desc.services;
				yield* desc.extensions;
				break;
			case "message":
				for (const message of desc.nestedMessages) {
					yield message;
					yield* nestedTypes(message);
				}
				yield* desc.nestedEnums;
				yield* desc.nestedExtensions;
				break;
		}
	}
	/**
	* Iterate over types referenced by fields of the given message.
	*
	* For example:
	*
	* ```proto
	* syntax="proto3";
	*
	* message Example {
	*   Msg singular = 1;
	*   repeated Level list = 2;
	* }
	*
	* message Msg {}
	*
	* enum Level {
	*   LEVEL_UNSPECIFIED = 0;
	* }
	* ```
	*
	* The message Example references the message Msg, and the enum Level.
	*/
	function usedTypes(descMessage) {
		return usedTypesInternal(descMessage, /* @__PURE__ */ new Set());
	}
	function* usedTypesInternal(descMessage, seen) {
		var _a, _b;
		for (const field of descMessage.fields) {
			const ref = (_b = (_a = field.enum) !== null && _a !== void 0 ? _a : field.message) !== null && _b !== void 0 ? _b : void 0;
			if (!ref || seen.has(ref.typeName)) continue;
			seen.add(ref.typeName);
			yield ref;
			if (ref.kind == "message") yield* usedTypesInternal(ref, seen);
		}
	}
	/**
	* Returns the ancestors of a given Protobuf element, up to the file.
	*/
	function parentTypes(desc) {
		const parents = [];
		while (desc.kind !== "file") {
			const p$10 = parent(desc);
			desc = p$10;
			parents.push(p$10);
		}
		return parents;
	}
	function parent(desc) {
		var _a;
		switch (desc.kind) {
			case "enum_value":
			case "field":
			case "oneof":
			case "rpc": return desc.parent;
			case "service": return desc.file;
			case "extension":
			case "enum":
			case "message": return (_a = desc.parent) !== null && _a !== void 0 ? _a : desc.file;
		}
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/registry.js
var require_registry = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/registry.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createRegistry = createRegistry;
	exports.createMutableRegistry = createMutableRegistry;
	exports.createFileRegistry = createFileRegistry;
	var descriptors_js_1$10 = require_descriptors();
	var text_format_js_1 = require_text_format();
	var nested_types_js_1 = require_nested_types();
	var unsafe_js_1$4 = require_unsafe();
	var names_js_1$2 = require_names();
	/**
	* Create a registry from the given inputs.
	*
	* An input can be:
	* - Any message, enum, service, or extension descriptor, which adds just the
	*   descriptor for this type.
	* - A file descriptor, which adds all typed defined in this file.
	* - A registry, which adds all types from the registry.
	*
	* For duplicate descriptors (same type name), the one given last wins.
	*/
	function createRegistry(...input) {
		return initBaseRegistry(input);
	}
	/**
	* Create a registry that allows adding and removing descriptors.
	*/
	function createMutableRegistry(...input) {
		const reg = initBaseRegistry(input);
		return Object.assign(Object.assign({}, reg), { remove(desc) {
			var _a;
			if (desc.kind == "extension") (_a = reg.extendees.get(desc.extendee.typeName)) === null || _a === void 0 || _a.delete(desc.number);
			reg.types.delete(desc.typeName);
		} });
	}
	function createFileRegistry(...args) {
		const registry = createBaseRegistry();
		if (!args.length) return registry;
		if ("$typeName" in args[0] && args[0].$typeName == "google.protobuf.FileDescriptorSet") {
			for (const file of args[0].file) addFile(file, registry);
			return registry;
		}
		if ("$typeName" in args[0]) {
			const input = args[0];
			const resolve = args[1];
			const seen = /* @__PURE__ */ new Set();
			function recurseDeps(file) {
				const deps = [];
				for (const protoFileName of file.dependency) {
					if (registry.getFile(protoFileName) != void 0) continue;
					if (seen.has(protoFileName)) continue;
					const dep = resolve(protoFileName);
					if (!dep) throw new Error(`Unable to resolve ${protoFileName}, imported by ${file.name}`);
					if ("kind" in dep) registry.addFile(dep, false, true);
					else {
						seen.add(dep.name);
						deps.push(dep);
					}
				}
				return deps.concat(...deps.map(recurseDeps));
			}
			for (const file of [input, ...recurseDeps(input)].reverse()) addFile(file, registry);
		} else for (const fileReg of args) for (const file of fileReg.files) registry.addFile(file);
		return registry;
	}
	/**
	* @private
	*/
	function createBaseRegistry() {
		const types$1 = /* @__PURE__ */ new Map();
		const extendees = /* @__PURE__ */ new Map();
		const files = /* @__PURE__ */ new Map();
		return {
			kind: "registry",
			types: types$1,
			extendees,
			[Symbol.iterator]() {
				return types$1.values();
			},
			get files() {
				return files.values();
			},
			addFile(file, skipTypes, withDeps) {
				files.set(file.proto.name, file);
				if (!skipTypes) for (const type$1 of (0, nested_types_js_1.nestedTypes)(file)) this.add(type$1);
				if (withDeps) for (const f of file.dependencies) this.addFile(f, skipTypes, withDeps);
			},
			add(desc) {
				if (desc.kind == "extension") {
					let numberToExt = extendees.get(desc.extendee.typeName);
					if (!numberToExt) extendees.set(desc.extendee.typeName, numberToExt = /* @__PURE__ */ new Map());
					numberToExt.set(desc.number, desc);
				}
				types$1.set(desc.typeName, desc);
			},
			get(typeName) {
				return types$1.get(typeName);
			},
			getFile(fileName) {
				return files.get(fileName);
			},
			getMessage(typeName) {
				const t = types$1.get(typeName);
				return (t === null || t === void 0 ? void 0 : t.kind) == "message" ? t : void 0;
			},
			getEnum(typeName) {
				const t = types$1.get(typeName);
				return (t === null || t === void 0 ? void 0 : t.kind) == "enum" ? t : void 0;
			},
			getExtension(typeName) {
				const t = types$1.get(typeName);
				return (t === null || t === void 0 ? void 0 : t.kind) == "extension" ? t : void 0;
			},
			getExtensionFor(extendee, no) {
				var _a;
				return (_a = extendees.get(extendee.typeName)) === null || _a === void 0 ? void 0 : _a.get(no);
			},
			getService(typeName) {
				const t = types$1.get(typeName);
				return (t === null || t === void 0 ? void 0 : t.kind) == "service" ? t : void 0;
			}
		};
	}
	/**
	* @private
	*/
	function initBaseRegistry(inputs) {
		const registry = createBaseRegistry();
		for (const input of inputs) switch (input.kind) {
			case "registry":
				for (const n$2 of input) registry.add(n$2);
				break;
			case "file":
				registry.addFile(input);
				break;
			default:
				registry.add(input);
				break;
		}
		return registry;
	}
	var EDITION_PROTO2$1 = 998;
	var EDITION_PROTO3$1 = 999;
	var TYPE_STRING = 9;
	var TYPE_GROUP = 10;
	var TYPE_MESSAGE = 11;
	var TYPE_BYTES = 12;
	var TYPE_ENUM = 14;
	var LABEL_REPEATED = 3;
	var LABEL_REQUIRED = 2;
	var JS_STRING = 1;
	var IDEMPOTENCY_UNKNOWN = 0;
	var EXPLICIT = 1;
	var IMPLICIT$2 = 2;
	var LEGACY_REQUIRED$2 = 3;
	var PACKED = 1;
	var DELIMITED = 2;
	var OPEN = 1;
	exports.minimumEdition = 998, exports.maximumEdition = 1001;
	var featureDefaults = {
		998: {
			fieldPresence: 1,
			enumType: 2,
			repeatedFieldEncoding: 2,
			utf8Validation: 3,
			messageEncoding: 1,
			jsonFormat: 2,
			enforceNamingStyle: 2,
			defaultSymbolVisibility: 1
		},
		999: {
			fieldPresence: 2,
			enumType: 1,
			repeatedFieldEncoding: 1,
			utf8Validation: 2,
			messageEncoding: 1,
			jsonFormat: 1,
			enforceNamingStyle: 2,
			defaultSymbolVisibility: 1
		},
		1e3: {
			fieldPresence: 1,
			enumType: 1,
			repeatedFieldEncoding: 1,
			utf8Validation: 2,
			messageEncoding: 1,
			jsonFormat: 1,
			enforceNamingStyle: 2,
			defaultSymbolVisibility: 1
		},
		1001: {
			fieldPresence: 1,
			enumType: 1,
			repeatedFieldEncoding: 1,
			utf8Validation: 2,
			messageEncoding: 1,
			jsonFormat: 1,
			enforceNamingStyle: 1,
			defaultSymbolVisibility: 2
		}
	};
	/**
	* Create a descriptor for a file, add it to the registry.
	*/
	function addFile(proto$6, reg) {
		var _a, _b;
		const file = {
			kind: "file",
			proto: proto$6,
			deprecated: (_b = (_a = proto$6.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
			edition: getFileEdition(proto$6),
			name: proto$6.name.replace(/\.proto$/, ""),
			dependencies: findFileDependencies(proto$6, reg),
			enums: [],
			messages: [],
			extensions: [],
			services: [],
			toString() {
				return `file ${proto$6.name}`;
			}
		};
		const mapEntriesStore = /* @__PURE__ */ new Map();
		const mapEntries = {
			get(typeName) {
				return mapEntriesStore.get(typeName);
			},
			add(desc) {
				var _a$1;
				assert$1(((_a$1 = desc.proto.options) === null || _a$1 === void 0 ? void 0 : _a$1.mapEntry) === true);
				mapEntriesStore.set(desc.typeName, desc);
			}
		};
		for (const enumProto of proto$6.enumType) addEnum(enumProto, file, void 0, reg);
		for (const messageProto of proto$6.messageType) addMessage(messageProto, file, void 0, reg, mapEntries);
		for (const serviceProto of proto$6.service) addService(serviceProto, file, reg);
		addExtensions(file, reg);
		for (const mapEntry of mapEntriesStore.values()) addFields(mapEntry, reg, mapEntries);
		for (const message of file.messages) {
			addFields(message, reg, mapEntries);
			addExtensions(message, reg);
		}
		reg.addFile(file, true);
	}
	/**
	* Create descriptors for extensions, and add them to the message / file,
	* and to our cart.
	* Recurses into nested types.
	*/
	function addExtensions(desc, reg) {
		switch (desc.kind) {
			case "file":
				for (const proto$6 of desc.proto.extension) {
					const ext = newField(proto$6, desc, reg);
					desc.extensions.push(ext);
					reg.add(ext);
				}
				break;
			case "message":
				for (const proto$6 of desc.proto.extension) {
					const ext = newField(proto$6, desc, reg);
					desc.nestedExtensions.push(ext);
					reg.add(ext);
				}
				for (const message of desc.nestedMessages) addExtensions(message, reg);
				break;
		}
	}
	/**
	* Create descriptors for fields and oneof groups, and add them to the message.
	* Recurses into nested types.
	*/
	function addFields(message, reg, mapEntries) {
		const allOneofs = message.proto.oneofDecl.map((proto$6) => newOneof(proto$6, message));
		const oneofsSeen = /* @__PURE__ */ new Set();
		for (const proto$6 of message.proto.field) {
			const oneof = findOneof(proto$6, allOneofs);
			const field = newField(proto$6, message, reg, oneof, mapEntries);
			message.fields.push(field);
			message.field[field.localName] = field;
			if (oneof === void 0) message.members.push(field);
			else {
				oneof.fields.push(field);
				if (!oneofsSeen.has(oneof)) {
					oneofsSeen.add(oneof);
					message.members.push(oneof);
				}
			}
		}
		for (const oneof of allOneofs.filter((o) => oneofsSeen.has(o))) message.oneofs.push(oneof);
		for (const child of message.nestedMessages) addFields(child, reg, mapEntries);
	}
	/**
	* Create a descriptor for an enumeration, and add it our cart and to the
	* parent type, if any.
	*/
	function addEnum(proto$6, file, parent$1, reg) {
		var _a, _b, _c, _d, _e;
		const sharedPrefix = findEnumSharedPrefix(proto$6.name, proto$6.value);
		const desc = {
			kind: "enum",
			proto: proto$6,
			deprecated: (_b = (_a = proto$6.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
			file,
			parent: parent$1,
			open: true,
			name: proto$6.name,
			typeName: makeTypeName(proto$6, parent$1, file),
			value: {},
			values: [],
			sharedPrefix,
			toString() {
				return `enum ${this.typeName}`;
			}
		};
		desc.open = isEnumOpen(desc);
		reg.add(desc);
		for (const p$10 of proto$6.value) {
			const name = p$10.name;
			desc.values.push(desc.value[p$10.number] = {
				kind: "enum_value",
				proto: p$10,
				deprecated: (_d = (_c = p$10.options) === null || _c === void 0 ? void 0 : _c.deprecated) !== null && _d !== void 0 ? _d : false,
				parent: desc,
				name,
				localName: (0, names_js_1$2.safeObjectProperty)(sharedPrefix == void 0 ? name : name.substring(sharedPrefix.length)),
				number: p$10.number,
				toString() {
					return `enum value ${desc.typeName}.${name}`;
				}
			});
		}
		((_e = parent$1 === null || parent$1 === void 0 ? void 0 : parent$1.nestedEnums) !== null && _e !== void 0 ? _e : file.enums).push(desc);
	}
	/**
	* Create a descriptor for a message, including nested types, and add it to our
	* cart. Note that this does not create descriptors fields.
	*/
	function addMessage(proto$6, file, parent$1, reg, mapEntries) {
		var _a, _b, _c, _d;
		const desc = {
			kind: "message",
			proto: proto$6,
			deprecated: (_b = (_a = proto$6.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
			file,
			parent: parent$1,
			name: proto$6.name,
			typeName: makeTypeName(proto$6, parent$1, file),
			fields: [],
			field: {},
			oneofs: [],
			members: [],
			nestedEnums: [],
			nestedMessages: [],
			nestedExtensions: [],
			toString() {
				return `message ${this.typeName}`;
			}
		};
		if (((_c = proto$6.options) === null || _c === void 0 ? void 0 : _c.mapEntry) === true) mapEntries.add(desc);
		else {
			((_d = parent$1 === null || parent$1 === void 0 ? void 0 : parent$1.nestedMessages) !== null && _d !== void 0 ? _d : file.messages).push(desc);
			reg.add(desc);
		}
		for (const enumProto of proto$6.enumType) addEnum(enumProto, file, desc, reg);
		for (const messageProto of proto$6.nestedType) addMessage(messageProto, file, desc, reg, mapEntries);
	}
	/**
	* Create a descriptor for a service, including methods, and add it to our
	* cart.
	*/
	function addService(proto$6, file, reg) {
		var _a, _b;
		const desc = {
			kind: "service",
			proto: proto$6,
			deprecated: (_b = (_a = proto$6.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
			file,
			name: proto$6.name,
			typeName: makeTypeName(proto$6, void 0, file),
			methods: [],
			method: {},
			toString() {
				return `service ${this.typeName}`;
			}
		};
		file.services.push(desc);
		reg.add(desc);
		for (const methodProto of proto$6.method) {
			const method = newMethod(methodProto, desc, reg);
			desc.methods.push(method);
			desc.method[method.localName] = method;
		}
	}
	/**
	* Create a descriptor for a method.
	*/
	function newMethod(proto$6, parent$1, reg) {
		var _a, _b, _c, _d;
		let methodKind;
		if (proto$6.clientStreaming && proto$6.serverStreaming) methodKind = "bidi_streaming";
		else if (proto$6.clientStreaming) methodKind = "client_streaming";
		else if (proto$6.serverStreaming) methodKind = "server_streaming";
		else methodKind = "unary";
		const input = reg.getMessage(trimLeadingDot(proto$6.inputType));
		const output = reg.getMessage(trimLeadingDot(proto$6.outputType));
		assert$1(input, `invalid MethodDescriptorProto: input_type ${proto$6.inputType} not found`);
		assert$1(output, `invalid MethodDescriptorProto: output_type ${proto$6.inputType} not found`);
		const name = proto$6.name;
		return {
			kind: "rpc",
			proto: proto$6,
			deprecated: (_b = (_a = proto$6.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
			parent: parent$1,
			name,
			localName: (0, names_js_1$2.safeObjectProperty)(name.length ? (0, names_js_1$2.safeObjectProperty)(name[0].toLowerCase() + name.substring(1)) : name),
			methodKind,
			input,
			output,
			idempotency: (_d = (_c = proto$6.options) === null || _c === void 0 ? void 0 : _c.idempotencyLevel) !== null && _d !== void 0 ? _d : IDEMPOTENCY_UNKNOWN,
			toString() {
				return `rpc ${parent$1.typeName}.${name}`;
			}
		};
	}
	/**
	* Create a descriptor for a oneof group.
	*/
	function newOneof(proto$6, parent$1) {
		return {
			kind: "oneof",
			proto: proto$6,
			deprecated: false,
			parent: parent$1,
			fields: [],
			name: proto$6.name,
			localName: (0, names_js_1$2.safeObjectProperty)((0, names_js_1$2.protoCamelCase)(proto$6.name)),
			toString() {
				return `oneof ${parent$1.typeName}.${this.name}`;
			}
		};
	}
	function newField(proto$6, parentOrFile, reg, oneof, mapEntries) {
		var _a, _b, _c;
		const isExtension = mapEntries === void 0;
		const field = {
			kind: "field",
			proto: proto$6,
			deprecated: (_b = (_a = proto$6.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
			name: proto$6.name,
			number: proto$6.number,
			scalar: void 0,
			message: void 0,
			enum: void 0,
			presence: getFieldPresence(proto$6, oneof, isExtension, parentOrFile),
			listKind: void 0,
			mapKind: void 0,
			mapKey: void 0,
			delimitedEncoding: void 0,
			packed: void 0,
			longAsString: false,
			getDefaultValue: void 0
		};
		if (isExtension) {
			const file = parentOrFile.kind == "file" ? parentOrFile : parentOrFile.file;
			const parent$1 = parentOrFile.kind == "file" ? void 0 : parentOrFile;
			const typeName = makeTypeName(proto$6, parent$1, file);
			field.kind = "extension";
			field.file = file;
			field.parent = parent$1;
			field.oneof = void 0;
			field.typeName = typeName;
			field.jsonName = `[${typeName}]`;
			field.toString = () => `extension ${typeName}`;
			const extendee = reg.getMessage(trimLeadingDot(proto$6.extendee));
			assert$1(extendee, `invalid FieldDescriptorProto: extendee ${proto$6.extendee} not found`);
			field.extendee = extendee;
		} else {
			const parent$1 = parentOrFile;
			assert$1(parent$1.kind == "message");
			field.parent = parent$1;
			field.oneof = oneof;
			field.localName = oneof ? (0, names_js_1$2.protoCamelCase)(proto$6.name) : (0, names_js_1$2.safeObjectProperty)((0, names_js_1$2.protoCamelCase)(proto$6.name));
			field.jsonName = proto$6.jsonName;
			field.toString = () => `field ${parent$1.typeName}.${proto$6.name}`;
		}
		const label = proto$6.label;
		const type$1 = proto$6.type;
		const jstype = (_c = proto$6.options) === null || _c === void 0 ? void 0 : _c.jstype;
		if (label === LABEL_REPEATED) {
			const mapEntry = type$1 == TYPE_MESSAGE ? mapEntries === null || mapEntries === void 0 ? void 0 : mapEntries.get(trimLeadingDot(proto$6.typeName)) : void 0;
			if (mapEntry) {
				field.fieldKind = "map";
				const { key, value } = findMapEntryFields(mapEntry);
				field.mapKey = key.scalar;
				field.mapKind = value.fieldKind;
				field.message = value.message;
				field.delimitedEncoding = false;
				field.enum = value.enum;
				field.scalar = value.scalar;
				return field;
			}
			field.fieldKind = "list";
			switch (type$1) {
				case TYPE_MESSAGE:
				case TYPE_GROUP:
					field.listKind = "message";
					field.message = reg.getMessage(trimLeadingDot(proto$6.typeName));
					assert$1(field.message);
					field.delimitedEncoding = isDelimitedEncoding(proto$6, parentOrFile);
					break;
				case TYPE_ENUM:
					field.listKind = "enum";
					field.enum = reg.getEnum(trimLeadingDot(proto$6.typeName));
					assert$1(field.enum);
					break;
				default:
					field.listKind = "scalar";
					field.scalar = type$1;
					field.longAsString = jstype == JS_STRING;
					break;
			}
			field.packed = isPackedField(proto$6, parentOrFile);
			return field;
		}
		switch (type$1) {
			case TYPE_MESSAGE:
			case TYPE_GROUP:
				field.fieldKind = "message";
				field.message = reg.getMessage(trimLeadingDot(proto$6.typeName));
				assert$1(field.message, `invalid FieldDescriptorProto: type_name ${proto$6.typeName} not found`);
				field.delimitedEncoding = isDelimitedEncoding(proto$6, parentOrFile);
				field.getDefaultValue = () => void 0;
				break;
			case TYPE_ENUM: {
				const enumeration = reg.getEnum(trimLeadingDot(proto$6.typeName));
				assert$1(enumeration !== void 0, `invalid FieldDescriptorProto: type_name ${proto$6.typeName} not found`);
				field.fieldKind = "enum";
				field.enum = reg.getEnum(trimLeadingDot(proto$6.typeName));
				field.getDefaultValue = () => {
					return (0, unsafe_js_1$4.unsafeIsSetExplicit)(proto$6, "defaultValue") ? (0, text_format_js_1.parseTextFormatEnumValue)(enumeration, proto$6.defaultValue) : void 0;
				};
				break;
			}
			default:
				field.fieldKind = "scalar";
				field.scalar = type$1;
				field.longAsString = jstype == JS_STRING;
				field.getDefaultValue = () => {
					return (0, unsafe_js_1$4.unsafeIsSetExplicit)(proto$6, "defaultValue") ? (0, text_format_js_1.parseTextFormatScalarValue)(type$1, proto$6.defaultValue) : void 0;
				};
				break;
		}
		return field;
	}
	/**
	* Parse the "syntax" and "edition" fields, returning one of the supported
	* editions.
	*/
	function getFileEdition(proto$6) {
		switch (proto$6.syntax) {
			case "":
			case "proto2": return EDITION_PROTO2$1;
			case "proto3": return EDITION_PROTO3$1;
			case "editions":
				if (proto$6.edition in featureDefaults) return proto$6.edition;
				throw new Error(`${proto$6.name}: unsupported edition`);
			default: throw new Error(`${proto$6.name}: unsupported syntax "${proto$6.syntax}"`);
		}
	}
	/**
	* Resolve dependencies of FileDescriptorProto to DescFile.
	*/
	function findFileDependencies(proto$6, reg) {
		return proto$6.dependency.map((wantName) => {
			const dep = reg.getFile(wantName);
			if (!dep) throw new Error(`Cannot find ${wantName}, imported by ${proto$6.name}`);
			return dep;
		});
	}
	/**
	* Finds a prefix shared by enum values, for example `my_enum_` for
	* `enum MyEnum {MY_ENUM_A=0; MY_ENUM_B=1;}`.
	*/
	function findEnumSharedPrefix(enumName, values) {
		const prefix = camelToSnakeCase(enumName) + "_";
		for (const value of values) {
			if (!value.name.toLowerCase().startsWith(prefix)) return;
			const shortName = value.name.substring(prefix.length);
			if (shortName.length == 0) return;
			if (/^\d/.test(shortName)) return;
		}
		return prefix;
	}
	/**
	* Converts lowerCamelCase or UpperCamelCase into lower_snake_case.
	* This is used to find shared prefixes in an enum.
	*/
	function camelToSnakeCase(camel) {
		return (camel.substring(0, 1) + camel.substring(1).replace(/[A-Z]/g, (c$1) => "_" + c$1)).toLowerCase();
	}
	/**
	* Create a fully qualified name for a protobuf type or extension field.
	*
	* The fully qualified name for messages, enumerations, and services is
	* constructed by concatenating the package name (if present), parent
	* message names (for nested types), and the type name. We omit the leading
	* dot added by protobuf compilers. Examples:
	* - mypackage.MyMessage
	* - mypackage.MyMessage.NestedMessage
	*
	* The fully qualified name for extension fields is constructed by
	* concatenating the package name (if present), parent message names (for
	* extensions declared within a message), and the field name. Examples:
	* - mypackage.extfield
	* - mypackage.MyMessage.extfield
	*/
	function makeTypeName(proto$6, parent$1, file) {
		let typeName;
		if (parent$1) typeName = `${parent$1.typeName}.${proto$6.name}`;
		else if (file.proto.package.length > 0) typeName = `${file.proto.package}.${proto$6.name}`;
		else typeName = `${proto$6.name}`;
		return typeName;
	}
	/**
	* Remove the leading dot from a fully qualified type name.
	*/
	function trimLeadingDot(typeName) {
		return typeName.startsWith(".") ? typeName.substring(1) : typeName;
	}
	/**
	* Did the user put the field in a oneof group?
	* Synthetic oneofs for proto3 optionals are ignored.
	*/
	function findOneof(proto$6, allOneofs) {
		if (!(0, unsafe_js_1$4.unsafeIsSetExplicit)(proto$6, "oneofIndex")) return;
		if (proto$6.proto3Optional) return;
		const oneof = allOneofs[proto$6.oneofIndex];
		assert$1(oneof, `invalid FieldDescriptorProto: oneof #${proto$6.oneofIndex} for field #${proto$6.number} not found`);
		return oneof;
	}
	/**
	* Presence of the field.
	* See https://protobuf.dev/programming-guides/field_presence/
	*/
	function getFieldPresence(proto$6, oneof, isExtension, parent$1) {
		if (proto$6.label == LABEL_REQUIRED) return LEGACY_REQUIRED$2;
		if (proto$6.label == LABEL_REPEATED) return IMPLICIT$2;
		if (!!oneof || proto$6.proto3Optional) return EXPLICIT;
		if (isExtension) return EXPLICIT;
		const resolved$1 = resolveFeature("fieldPresence", {
			proto: proto$6,
			parent: parent$1
		});
		if (resolved$1 == IMPLICIT$2 && (proto$6.type == TYPE_MESSAGE || proto$6.type == TYPE_GROUP)) return EXPLICIT;
		return resolved$1;
	}
	/**
	* Pack this repeated field?
	*/
	function isPackedField(proto$6, parent$1) {
		if (proto$6.label != LABEL_REPEATED) return false;
		switch (proto$6.type) {
			case TYPE_STRING:
			case TYPE_BYTES:
			case TYPE_GROUP:
			case TYPE_MESSAGE: return false;
		}
		const o = proto$6.options;
		if (o && (0, unsafe_js_1$4.unsafeIsSetExplicit)(o, "packed")) return o.packed;
		return PACKED == resolveFeature("repeatedFieldEncoding", {
			proto: proto$6,
			parent: parent$1
		});
	}
	/**
	* Find the key and value fields of a synthetic map entry message.
	*/
	function findMapEntryFields(mapEntry) {
		const key = mapEntry.fields.find((f) => f.number === 1);
		const value = mapEntry.fields.find((f) => f.number === 2);
		assert$1(key && key.fieldKind == "scalar" && key.scalar != descriptors_js_1$10.ScalarType.BYTES && key.scalar != descriptors_js_1$10.ScalarType.FLOAT && key.scalar != descriptors_js_1$10.ScalarType.DOUBLE && value && value.fieldKind != "list" && value.fieldKind != "map");
		return {
			key,
			value
		};
	}
	/**
	* Enumerations can be open or closed.
	* See https://protobuf.dev/programming-guides/enum/
	*/
	function isEnumOpen(desc) {
		var _a;
		return OPEN == resolveFeature("enumType", {
			proto: desc.proto,
			parent: (_a = desc.parent) !== null && _a !== void 0 ? _a : desc.file
		});
	}
	/**
	* Encode the message delimited (a.k.a. proto2 group encoding), or
	* length-prefixed?
	*/
	function isDelimitedEncoding(proto$6, parent$1) {
		if (proto$6.type == TYPE_GROUP) return true;
		return DELIMITED == resolveFeature("messageEncoding", {
			proto: proto$6,
			parent: parent$1
		});
	}
	function resolveFeature(name, ref) {
		var _a, _b;
		const featureSet = (_a = ref.proto.options) === null || _a === void 0 ? void 0 : _a.features;
		if (featureSet) {
			const val = featureSet[name];
			if (val != 0) return val;
		}
		if ("kind" in ref) {
			if (ref.kind == "message") return resolveFeature(name, (_b = ref.parent) !== null && _b !== void 0 ? _b : ref.file);
			const editionDefaults = featureDefaults[ref.edition];
			if (!editionDefaults) throw new Error(`feature default for edition ${ref.edition} not found`);
			return editionDefaults[name];
		}
		return resolveFeature(name, ref.parent);
	}
	/**
	* Assert that condition is truthy or throw error (with message)
	*/
	function assert$1(condition, msg) {
		if (!condition) throw new Error(msg);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/boot.js
var require_boot = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/boot.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.boot = boot;
	exports.bootFileDescriptorProto = bootFileDescriptorProto;
	var restore_json_names_js_1$1 = require_restore_json_names();
	var registry_js_1$1 = require_registry();
	/**
	* Hydrate a file descriptor for google/protobuf/descriptor.proto from a plain
	* object.
	*
	* See createFileDescriptorProtoBoot() for details.
	*
	* @private
	*/
	function boot(boot$1) {
		const root = bootFileDescriptorProto(boot$1);
		root.messageType.forEach(restore_json_names_js_1$1.restoreJsonNames);
		return (0, registry_js_1$1.createFileRegistry)(root, () => void 0).getFile(root.name);
	}
	/**
	* Creates the message google.protobuf.FileDescriptorProto from an object literal.
	*
	* See createFileDescriptorProtoBoot() for details.
	*
	* @private
	*/
	function bootFileDescriptorProto(init) {
		const proto$6 = Object.create({
			syntax: "",
			edition: 0
		});
		return Object.assign(proto$6, Object.assign(Object.assign({
			$typeName: "google.protobuf.FileDescriptorProto",
			dependency: [],
			publicDependency: [],
			weakDependency: [],
			optionDependency: [],
			service: [],
			extension: []
		}, init), {
			messageType: init.messageType.map(bootDescriptorProto),
			enumType: init.enumType.map(bootEnumDescriptorProto)
		}));
	}
	function bootDescriptorProto(init) {
		var _a, _b, _c, _d, _e, _f, _g, _h;
		const proto$6 = Object.create({ visibility: 0 });
		return Object.assign(proto$6, {
			$typeName: "google.protobuf.DescriptorProto",
			name: init.name,
			field: (_b = (_a = init.field) === null || _a === void 0 ? void 0 : _a.map(bootFieldDescriptorProto)) !== null && _b !== void 0 ? _b : [],
			extension: [],
			nestedType: (_d = (_c = init.nestedType) === null || _c === void 0 ? void 0 : _c.map(bootDescriptorProto)) !== null && _d !== void 0 ? _d : [],
			enumType: (_f = (_e = init.enumType) === null || _e === void 0 ? void 0 : _e.map(bootEnumDescriptorProto)) !== null && _f !== void 0 ? _f : [],
			extensionRange: (_h = (_g = init.extensionRange) === null || _g === void 0 ? void 0 : _g.map((e) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, e))) !== null && _h !== void 0 ? _h : [],
			oneofDecl: [],
			reservedRange: [],
			reservedName: []
		});
	}
	function bootFieldDescriptorProto(init) {
		const proto$6 = Object.create({
			label: 1,
			typeName: "",
			extendee: "",
			defaultValue: "",
			oneofIndex: 0,
			jsonName: "",
			proto3Optional: false
		});
		return Object.assign(proto$6, Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, init), { options: init.options ? bootFieldOptions(init.options) : void 0 }));
	}
	function bootFieldOptions(init) {
		var _a, _b, _c;
		const proto$6 = Object.create({
			ctype: 0,
			packed: false,
			jstype: 0,
			lazy: false,
			unverifiedLazy: false,
			deprecated: false,
			weak: false,
			debugRedact: false,
			retention: 0
		});
		return Object.assign(proto$6, Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, init), {
			targets: (_a = init.targets) !== null && _a !== void 0 ? _a : [],
			editionDefaults: (_c = (_b = init.editionDefaults) === null || _b === void 0 ? void 0 : _b.map((e) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, e))) !== null && _c !== void 0 ? _c : [],
			uninterpretedOption: []
		}));
	}
	function bootEnumDescriptorProto(init) {
		const proto$6 = Object.create({ visibility: 0 });
		return Object.assign(proto$6, {
			$typeName: "google.protobuf.EnumDescriptorProto",
			name: init.name,
			reservedName: [],
			reservedRange: [],
			value: init.value.map((e) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, e))
		});
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/fields.js
var require_fields = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/fields.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isFieldSet = isFieldSet;
	exports.clearField = clearField;
	var unsafe_js_1$3 = require_unsafe();
	/**
	* Returns true if the field is set.
	*
	* - Scalar and enum fields with implicit presence (proto3):
	*   Set if not a zero value.
	*
	* - Scalar and enum fields with explicit presence (proto2, oneof):
	*   Set if a value was set when creating or parsing the message, or when a
	*   value was assigned to the field's property.
	*
	* - Message fields:
	*   Set if the property is not undefined.
	*
	* - List and map fields:
	*   Set if not empty.
	*/
	function isFieldSet(message, field) {
		return field.parent.typeName == message.$typeName && (0, unsafe_js_1$3.unsafeIsSet)(message, field);
	}
	/**
	* Resets the field, so that isFieldSet() will return false.
	*/
	function clearField(message, field) {
		if (field.parent.typeName == message.$typeName) (0, unsafe_js_1$3.unsafeClear)(message, field);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wire/base64-encoding.js
var require_base64_encoding = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wire/base64-encoding.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.base64Decode = base64Decode;
	exports.base64Encode = base64Encode;
	/**
	* Decodes a base64 string to a byte array.
	*
	* - ignores white-space, including line breaks and tabs
	* - allows inner padding (can decode concatenated base64 strings)
	* - does not require padding
	* - understands base64url encoding:
	*   "-" instead of "+",
	*   "_" instead of "/",
	*   no padding
	*/
	function base64Decode(base64Str) {
		const table = getDecodeTable();
		let es = base64Str.length * 3 / 4;
		if (base64Str[base64Str.length - 2] == "=") es -= 2;
		else if (base64Str[base64Str.length - 1] == "=") es -= 1;
		let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b$2, p$10 = 0;
		for (let i = 0; i < base64Str.length; i++) {
			b$2 = table[base64Str.charCodeAt(i)];
			if (b$2 === void 0) switch (base64Str[i]) {
				case "=": groupPos = 0;
				case "\n":
				case "\r":
				case "	":
				case " ": continue;
				default: throw Error("invalid base64 string");
			}
			switch (groupPos) {
				case 0:
					p$10 = b$2;
					groupPos = 1;
					break;
				case 1:
					bytes[bytePos++] = p$10 << 2 | (b$2 & 48) >> 4;
					p$10 = b$2;
					groupPos = 2;
					break;
				case 2:
					bytes[bytePos++] = (p$10 & 15) << 4 | (b$2 & 60) >> 2;
					p$10 = b$2;
					groupPos = 3;
					break;
				case 3:
					bytes[bytePos++] = (p$10 & 3) << 6 | b$2;
					groupPos = 0;
					break;
			}
		}
		if (groupPos == 1) throw Error("invalid base64 string");
		return bytes.subarray(0, bytePos);
	}
	/**
	* Encode a byte array to a base64 string.
	*
	* By default, this function uses the standard base64 encoding with padding.
	*
	* To encode without padding, use encoding = "std_raw".
	*
	* To encode with the URL encoding, use encoding = "url", which replaces the
	* characters +/ by their URL-safe counterparts -_, and omits padding.
	*/
	function base64Encode(bytes, encoding = "std") {
		const table = getEncodeTable(encoding);
		const pad = encoding == "std";
		let base64 = "", groupPos = 0, b$2, p$10 = 0;
		for (let i = 0; i < bytes.length; i++) {
			b$2 = bytes[i];
			switch (groupPos) {
				case 0:
					base64 += table[b$2 >> 2];
					p$10 = (b$2 & 3) << 4;
					groupPos = 1;
					break;
				case 1:
					base64 += table[p$10 | b$2 >> 4];
					p$10 = (b$2 & 15) << 2;
					groupPos = 2;
					break;
				case 2:
					base64 += table[p$10 | b$2 >> 6];
					base64 += table[b$2 & 63];
					groupPos = 0;
					break;
			}
		}
		if (groupPos) {
			base64 += table[p$10];
			if (pad) {
				base64 += "=";
				if (groupPos == 1) base64 += "=";
			}
		}
		return base64;
	}
	var encodeTableStd;
	var encodeTableUrl;
	var decodeTable;
	function getEncodeTable(encoding) {
		if (!encodeTableStd) {
			encodeTableStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
			encodeTableUrl = encodeTableStd.slice(0, -2).concat("-", "_");
		}
		return encoding == "url" ? encodeTableUrl : encodeTableStd;
	}
	function getDecodeTable() {
		if (!decodeTable) {
			decodeTable = [];
			const encodeTable = getEncodeTable("std");
			for (let i = 0; i < encodeTable.length; i++) decodeTable[encodeTable[i].charCodeAt(0)] = i;
			decodeTable["-".charCodeAt(0)] = encodeTable.indexOf("+");
			decodeTable["_".charCodeAt(0)] = encodeTable.indexOf("/");
		}
		return decodeTable;
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/is-message.js
var require_is_message = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/is-message.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isMessage = isMessage;
	/**
	* Determine whether the given `arg` is a message.
	* If `desc` is set, determine whether `arg` is this specific message.
	*/
	function isMessage(arg, schema) {
		if (!(arg !== null && typeof arg == "object" && "$typeName" in arg && typeof arg.$typeName == "string")) return false;
		if (schema === void 0) return true;
		return schema.typeName === arg.$typeName;
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/reflect/error.js
var require_error = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/reflect/error.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isFieldError = isFieldError;
	var errorNames = [
		"FieldValueInvalidError",
		"FieldListRangeError",
		"ForeignFieldError"
	];
	var FieldError = class extends Error {
		constructor(fieldOrOneof, message, name = "FieldValueInvalidError") {
			super(message);
			this.name = name;
			this.field = () => fieldOrOneof;
		}
	};
	exports.FieldError = FieldError;
	function isFieldError(arg) {
		return arg instanceof Error && errorNames.includes(arg.name) && "field" in arg && typeof arg.field == "function";
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/reflect/guard.js
var require_guard = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/reflect/guard.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isObject = isObject;
	exports.isOneofADT = isOneofADT;
	exports.isReflectList = isReflectList;
	exports.isReflectMap = isReflectMap;
	exports.isReflectMessage = isReflectMessage;
	var unsafe_js_1$2 = require_unsafe();
	function isObject(arg) {
		return arg !== null && typeof arg == "object" && !Array.isArray(arg);
	}
	function isOneofADT(arg) {
		return arg !== null && typeof arg == "object" && "case" in arg && (typeof arg.case == "string" && "value" in arg && arg.value != null || arg.case === void 0 && (!("value" in arg) || arg.value === void 0));
	}
	function isReflectList(arg, field) {
		var _a, _b, _c, _d;
		if (isObject(arg) && unsafe_js_1$2.unsafeLocal in arg && "add" in arg && "field" in arg && typeof arg.field == "function") {
			if (field !== void 0) {
				const a$1 = field;
				const b$2 = arg.field();
				return a$1.listKind == b$2.listKind && a$1.scalar === b$2.scalar && ((_a = a$1.message) === null || _a === void 0 ? void 0 : _a.typeName) === ((_b = b$2.message) === null || _b === void 0 ? void 0 : _b.typeName) && ((_c = a$1.enum) === null || _c === void 0 ? void 0 : _c.typeName) === ((_d = b$2.enum) === null || _d === void 0 ? void 0 : _d.typeName);
			}
			return true;
		}
		return false;
	}
	function isReflectMap(arg, field) {
		var _a, _b, _c, _d;
		if (isObject(arg) && unsafe_js_1$2.unsafeLocal in arg && "has" in arg && "field" in arg && typeof arg.field == "function") {
			if (field !== void 0) {
				const a$1 = field, b$2 = arg.field();
				return a$1.mapKey === b$2.mapKey && a$1.mapKind == b$2.mapKind && a$1.scalar === b$2.scalar && ((_a = a$1.message) === null || _a === void 0 ? void 0 : _a.typeName) === ((_b = b$2.message) === null || _b === void 0 ? void 0 : _b.typeName) && ((_c = a$1.enum) === null || _c === void 0 ? void 0 : _c.typeName) === ((_d = b$2.enum) === null || _d === void 0 ? void 0 : _d.typeName);
			}
			return true;
		}
		return false;
	}
	function isReflectMessage(arg, messageDesc$1) {
		return isObject(arg) && unsafe_js_1$2.unsafeLocal in arg && "desc" in arg && isObject(arg.desc) && arg.desc.kind === "message" && (messageDesc$1 === void 0 || arg.desc.typeName == messageDesc$1.typeName);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wire/text-encoding.js
var require_text_encoding = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wire/text-encoding.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.configureTextEncoding = configureTextEncoding;
	exports.getTextEncoding = getTextEncoding;
	var symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
	/**
	* Protobuf-ES requires the Text Encoding API to convert UTF-8 from and to
	* binary. This WHATWG API is widely available, but it is not part of the
	* ECMAScript standard. On runtimes where it is not available, use this
	* function to provide your own implementation.
	*
	* Note that the Text Encoding API does not provide a way to validate UTF-8.
	* Our implementation falls back to use encodeURIComponent().
	*/
	function configureTextEncoding(textEncoding) {
		globalThis[symbol] = textEncoding;
	}
	function getTextEncoding() {
		if (globalThis[symbol] == void 0) {
			const te = new globalThis.TextEncoder();
			const td = new globalThis.TextDecoder();
			globalThis[symbol] = {
				encodeUtf8(text) {
					return te.encode(text);
				},
				decodeUtf8(bytes) {
					return td.decode(bytes);
				},
				checkUtf8(text) {
					try {
						return true;
					} catch (_) {
						return false;
					}
				}
			};
		}
		return globalThis[symbol];
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wire/binary-encoding.js
var require_binary_encoding = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wire/binary-encoding.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BinaryReader = exports.BinaryWriter = exports.INT32_MIN = exports.INT32_MAX = exports.UINT32_MAX = exports.FLOAT32_MIN = exports.FLOAT32_MAX = exports.WireType = void 0;
	var varint_js_1$1 = require_varint$1();
	var proto_int64_js_1$5 = require_proto_int64();
	var text_encoding_js_1$1 = require_text_encoding();
	/**
	* Protobuf binary format wire types.
	*
	* A wire type provides just enough information to find the length of the
	* following value.
	*
	* See https://developers.google.com/protocol-buffers/docs/encoding#structure
	*/
	var WireType;
	(function(WireType$1) {
		/**
		* Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
		*/
		WireType$1[WireType$1["Varint"] = 0] = "Varint";
		/**
		* Used for fixed64, sfixed64, double.
		* Always 8 bytes with little-endian byte order.
		*/
		WireType$1[WireType$1["Bit64"] = 1] = "Bit64";
		/**
		* Used for string, bytes, embedded messages, packed repeated fields
		*
		* Only repeated numeric types (types which use the varint, 32-bit,
		* or 64-bit wire types) can be packed. In proto3, such fields are
		* packed by default.
		*/
		WireType$1[WireType$1["LengthDelimited"] = 2] = "LengthDelimited";
		/**
		* Start of a tag-delimited aggregate, such as a proto2 group, or a message
		* in editions with message_encoding = DELIMITED.
		*/
		WireType$1[WireType$1["StartGroup"] = 3] = "StartGroup";
		/**
		* End of a tag-delimited aggregate.
		*/
		WireType$1[WireType$1["EndGroup"] = 4] = "EndGroup";
		/**
		* Used for fixed32, sfixed32, float.
		* Always 4 bytes with little-endian byte order.
		*/
		WireType$1[WireType$1["Bit32"] = 5] = "Bit32";
	})(WireType || (exports.WireType = WireType = {}));
	/**
	* Maximum value for a 32-bit floating point value (Protobuf FLOAT).
	*/
	exports.FLOAT32_MAX = 34028234663852886e22;
	/**
	* Minimum value for a 32-bit floating point value (Protobuf FLOAT).
	*/
	exports.FLOAT32_MIN = -34028234663852886e22;
	/**
	* Maximum value for an unsigned 32-bit integer (Protobuf UINT32, FIXED32).
	*/
	exports.UINT32_MAX = 4294967295;
	/**
	* Maximum value for a signed 32-bit integer (Protobuf INT32, SFIXED32, SINT32).
	*/
	exports.INT32_MAX = 2147483647;
	/**
	* Minimum value for a signed 32-bit integer (Protobuf INT32, SFIXED32, SINT32).
	*/
	exports.INT32_MIN = -2147483648;
	var BinaryWriter = class {
		constructor(encodeUtf8 = (0, text_encoding_js_1$1.getTextEncoding)().encodeUtf8) {
			this.encodeUtf8 = encodeUtf8;
			/**
			* Previous fork states.
			*/
			this.stack = [];
			this.chunks = [];
			this.buf = [];
		}
		/**
		* Return all bytes written and reset this writer.
		*/
		finish() {
			if (this.buf.length) {
				this.chunks.push(new Uint8Array(this.buf));
				this.buf = [];
			}
			let len = 0;
			for (let i = 0; i < this.chunks.length; i++) len += this.chunks[i].length;
			let bytes = new Uint8Array(len);
			let offset = 0;
			for (let i = 0; i < this.chunks.length; i++) {
				bytes.set(this.chunks[i], offset);
				offset += this.chunks[i].length;
			}
			this.chunks = [];
			return bytes;
		}
		/**
		* Start a new fork for length-delimited data like a message
		* or a packed repeated field.
		*
		* Must be joined later with `join()`.
		*/
		fork() {
			this.stack.push({
				chunks: this.chunks,
				buf: this.buf
			});
			this.chunks = [];
			this.buf = [];
			return this;
		}
		/**
		* Join the last fork. Write its length and bytes, then
		* return to the previous state.
		*/
		join() {
			let chunk = this.finish();
			let prev = this.stack.pop();
			if (!prev) throw new Error("invalid state, fork stack empty");
			this.chunks = prev.chunks;
			this.buf = prev.buf;
			this.uint32(chunk.byteLength);
			return this.raw(chunk);
		}
		/**
		* Writes a tag (field number and wire type).
		*
		* Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
		*
		* Generated code should compute the tag ahead of time and call `uint32()`.
		*/
		tag(fieldNo, type$1) {
			return this.uint32((fieldNo << 3 | type$1) >>> 0);
		}
		/**
		* Write a chunk of raw bytes.
		*/
		raw(chunk) {
			if (this.buf.length) {
				this.chunks.push(new Uint8Array(this.buf));
				this.buf = [];
			}
			this.chunks.push(chunk);
			return this;
		}
		/**
		* Write a `uint32` value, an unsigned 32 bit varint.
		*/
		uint32(value) {
			assertUInt32(value);
			while (value > 127) {
				this.buf.push(value & 127 | 128);
				value = value >>> 7;
			}
			this.buf.push(value);
			return this;
		}
		/**
		* Write a `int32` value, a signed 32 bit varint.
		*/
		int32(value) {
			assertInt32(value);
			(0, varint_js_1$1.varint32write)(value, this.buf);
			return this;
		}
		/**
		* Write a `bool` value, a variant.
		*/
		bool(value) {
			this.buf.push(value ? 1 : 0);
			return this;
		}
		/**
		* Write a `bytes` value, length-delimited arbitrary data.
		*/
		bytes(value) {
			this.uint32(value.byteLength);
			return this.raw(value);
		}
		/**
		* Write a `string` value, length-delimited data converted to UTF-8 text.
		*/
		string(value) {
			let chunk = this.encodeUtf8(value);
			this.uint32(chunk.byteLength);
			return this.raw(chunk);
		}
		/**
		* Write a `float` value, 32-bit floating point number.
		*/
		float(value) {
			assertFloat32(value);
			let chunk = new Uint8Array(4);
			new DataView(chunk.buffer).setFloat32(0, value, true);
			return this.raw(chunk);
		}
		/**
		* Write a `double` value, a 64-bit floating point number.
		*/
		double(value) {
			let chunk = new Uint8Array(8);
			new DataView(chunk.buffer).setFloat64(0, value, true);
			return this.raw(chunk);
		}
		/**
		* Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
		*/
		fixed32(value) {
			assertUInt32(value);
			let chunk = new Uint8Array(4);
			new DataView(chunk.buffer).setUint32(0, value, true);
			return this.raw(chunk);
		}
		/**
		* Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
		*/
		sfixed32(value) {
			assertInt32(value);
			let chunk = new Uint8Array(4);
			new DataView(chunk.buffer).setInt32(0, value, true);
			return this.raw(chunk);
		}
		/**
		* Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
		*/
		sint32(value) {
			assertInt32(value);
			value = (value << 1 ^ value >> 31) >>> 0;
			(0, varint_js_1$1.varint32write)(value, this.buf);
			return this;
		}
		/**
		* Write a `fixed64` value, a signed, fixed-length 64-bit integer.
		*/
		sfixed64(value) {
			let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = proto_int64_js_1$5.protoInt64.enc(value);
			view.setInt32(0, tc.lo, true);
			view.setInt32(4, tc.hi, true);
			return this.raw(chunk);
		}
		/**
		* Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
		*/
		fixed64(value) {
			let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = proto_int64_js_1$5.protoInt64.uEnc(value);
			view.setInt32(0, tc.lo, true);
			view.setInt32(4, tc.hi, true);
			return this.raw(chunk);
		}
		/**
		* Write a `int64` value, a signed 64-bit varint.
		*/
		int64(value) {
			let tc = proto_int64_js_1$5.protoInt64.enc(value);
			(0, varint_js_1$1.varint64write)(tc.lo, tc.hi, this.buf);
			return this;
		}
		/**
		* Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
		*/
		sint64(value) {
			const tc = proto_int64_js_1$5.protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
			(0, varint_js_1$1.varint64write)(lo, hi, this.buf);
			return this;
		}
		/**
		* Write a `uint64` value, an unsigned 64-bit varint.
		*/
		uint64(value) {
			const tc = proto_int64_js_1$5.protoInt64.uEnc(value);
			(0, varint_js_1$1.varint64write)(tc.lo, tc.hi, this.buf);
			return this;
		}
	};
	exports.BinaryWriter = BinaryWriter;
	var BinaryReader = class {
		constructor(buf, decodeUtf8 = (0, text_encoding_js_1$1.getTextEncoding)().decodeUtf8) {
			this.decodeUtf8 = decodeUtf8;
			this.varint64 = varint_js_1$1.varint64read;
			/**
			* Read a `uint32` field, an unsigned 32 bit varint.
			*/
			this.uint32 = varint_js_1$1.varint32read;
			this.buf = buf;
			this.len = buf.length;
			this.pos = 0;
			this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
		}
		/**
		* Reads a tag - field number and wire type.
		*/
		tag() {
			let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
			if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
			return [fieldNo, wireType];
		}
		/**
		* Skip one element and return the skipped data.
		*
		* When skipping StartGroup, provide the tags field number to check for
		* matching field number in the EndGroup tag.
		*/
		skip(wireType, fieldNo) {
			let start = this.pos;
			switch (wireType) {
				case WireType.Varint:
					while (this.buf[this.pos++] & 128);
					break;
				case WireType.Bit64: this.pos += 4;
				case WireType.Bit32:
					this.pos += 4;
					break;
				case WireType.LengthDelimited:
					let len = this.uint32();
					this.pos += len;
					break;
				case WireType.StartGroup:
					for (;;) {
						const [fn, wt] = this.tag();
						if (wt === WireType.EndGroup) {
							if (fieldNo !== void 0 && fn !== fieldNo) throw new Error("invalid end group tag");
							break;
						}
						this.skip(wt, fn);
					}
					break;
				default: throw new Error("cant skip wire type " + wireType);
			}
			this.assertBounds();
			return this.buf.subarray(start, this.pos);
		}
		/**
		* Throws error if position in byte array is out of range.
		*/
		assertBounds() {
			if (this.pos > this.len) throw new RangeError("premature EOF");
		}
		/**
		* Read a `int32` field, a signed 32 bit varint.
		*/
		int32() {
			return this.uint32() | 0;
		}
		/**
		* Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
		*/
		sint32() {
			let zze = this.uint32();
			return zze >>> 1 ^ -(zze & 1);
		}
		/**
		* Read a `int64` field, a signed 64-bit varint.
		*/
		int64() {
			return proto_int64_js_1$5.protoInt64.dec(...this.varint64());
		}
		/**
		* Read a `uint64` field, an unsigned 64-bit varint.
		*/
		uint64() {
			return proto_int64_js_1$5.protoInt64.uDec(...this.varint64());
		}
		/**
		* Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
		*/
		sint64() {
			let [lo, hi] = this.varint64();
			let s = -(lo & 1);
			lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
			hi = hi >>> 1 ^ s;
			return proto_int64_js_1$5.protoInt64.dec(lo, hi);
		}
		/**
		* Read a `bool` field, a variant.
		*/
		bool() {
			let [lo, hi] = this.varint64();
			return lo !== 0 || hi !== 0;
		}
		/**
		* Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
		*/
		fixed32() {
			return this.view.getUint32((this.pos += 4) - 4, true);
		}
		/**
		* Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
		*/
		sfixed32() {
			return this.view.getInt32((this.pos += 4) - 4, true);
		}
		/**
		* Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
		*/
		fixed64() {
			return proto_int64_js_1$5.protoInt64.uDec(this.sfixed32(), this.sfixed32());
		}
		/**
		* Read a `fixed64` field, a signed, fixed-length 64-bit integer.
		*/
		sfixed64() {
			return proto_int64_js_1$5.protoInt64.dec(this.sfixed32(), this.sfixed32());
		}
		/**
		* Read a `float` field, 32-bit floating point number.
		*/
		float() {
			return this.view.getFloat32((this.pos += 4) - 4, true);
		}
		/**
		* Read a `double` field, a 64-bit floating point number.
		*/
		double() {
			return this.view.getFloat64((this.pos += 8) - 8, true);
		}
		/**
		* Read a `bytes` field, length-delimited arbitrary data.
		*/
		bytes() {
			let len = this.uint32(), start = this.pos;
			this.pos += len;
			this.assertBounds();
			return this.buf.subarray(start, start + len);
		}
		/**
		* Read a `string` field, length-delimited data converted to UTF-8 text.
		*/
		string() {
			return this.decodeUtf8(this.bytes());
		}
	};
	exports.BinaryReader = BinaryReader;
	/**
	* Assert a valid signed protobuf 32-bit integer as a number or string.
	*/
	function assertInt32(arg) {
		if (typeof arg == "string") arg = Number(arg);
		else if (typeof arg != "number") throw new Error("invalid int32: " + typeof arg);
		if (!Number.isInteger(arg) || arg > exports.INT32_MAX || arg < exports.INT32_MIN) throw new Error("invalid int32: " + arg);
	}
	/**
	* Assert a valid unsigned protobuf 32-bit integer as a number or string.
	*/
	function assertUInt32(arg) {
		if (typeof arg == "string") arg = Number(arg);
		else if (typeof arg != "number") throw new Error("invalid uint32: " + typeof arg);
		if (!Number.isInteger(arg) || arg > exports.UINT32_MAX || arg < 0) throw new Error("invalid uint32: " + arg);
	}
	/**
	* Assert a valid protobuf float value as a number or string.
	*/
	function assertFloat32(arg) {
		if (typeof arg == "string") {
			const o = arg;
			arg = Number(arg);
			if (Number.isNaN(arg) && o !== "NaN") throw new Error("invalid float32: " + o);
		} else if (typeof arg != "number") throw new Error("invalid float32: " + typeof arg);
		if (Number.isFinite(arg) && (arg > exports.FLOAT32_MAX || arg < exports.FLOAT32_MIN)) throw new Error("invalid float32: " + arg);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect-check.js
var require_reflect_check = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect-check.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkField = checkField;
	exports.checkListItem = checkListItem;
	exports.checkMapEntry = checkMapEntry;
	exports.formatVal = formatVal;
	var descriptors_js_1$9 = require_descriptors();
	var is_message_js_1$1 = require_is_message();
	var error_js_1$2 = require_error();
	var guard_js_1$3 = require_guard();
	var binary_encoding_js_1$4 = require_binary_encoding();
	var text_encoding_js_1 = require_text_encoding();
	var proto_int64_js_1$4 = require_proto_int64();
	/**
	* Check whether the given field value is valid for the reflect API.
	*/
	function checkField(field, value) {
		const check = field.fieldKind == "list" ? (0, guard_js_1$3.isReflectList)(value, field) : field.fieldKind == "map" ? (0, guard_js_1$3.isReflectMap)(value, field) : checkSingular(field, value);
		if (check === true) return;
		let reason;
		switch (field.fieldKind) {
			case "list":
				reason = `expected ${formatReflectList(field)}, got ${formatVal(value)}`;
				break;
			case "map":
				reason = `expected ${formatReflectMap(field)}, got ${formatVal(value)}`;
				break;
			default: reason = reasonSingular(field, value, check);
		}
		return new error_js_1$2.FieldError(field, reason);
	}
	/**
	* Check whether the given list item is valid for the reflect API.
	*/
	function checkListItem(field, index, value) {
		const check = checkSingular(field, value);
		if (check !== true) return new error_js_1$2.FieldError(field, `list item #${index + 1}: ${reasonSingular(field, value, check)}`);
	}
	/**
	* Check whether the given map key and value are valid for the reflect API.
	*/
	function checkMapEntry(field, key, value) {
		const checkKey = checkScalarValue(key, field.mapKey);
		if (checkKey !== true) return new error_js_1$2.FieldError(field, `invalid map key: ${reasonSingular({ scalar: field.mapKey }, key, checkKey)}`);
		const checkVal = checkSingular(field, value);
		if (checkVal !== true) return new error_js_1$2.FieldError(field, `map entry ${formatVal(key)}: ${reasonSingular(field, value, checkVal)}`);
	}
	function checkSingular(field, value) {
		if (field.scalar !== void 0) return checkScalarValue(value, field.scalar);
		if (field.enum !== void 0) {
			if (field.enum.open) return Number.isInteger(value);
			return field.enum.values.some((v) => v.number === value);
		}
		return (0, guard_js_1$3.isReflectMessage)(value, field.message);
	}
	function checkScalarValue(value, scalar) {
		switch (scalar) {
			case descriptors_js_1$9.ScalarType.DOUBLE: return typeof value == "number";
			case descriptors_js_1$9.ScalarType.FLOAT:
				if (typeof value != "number") return false;
				if (Number.isNaN(value) || !Number.isFinite(value)) return true;
				if (value > binary_encoding_js_1$4.FLOAT32_MAX || value < binary_encoding_js_1$4.FLOAT32_MIN) return `${value.toFixed()} out of range`;
				return true;
			case descriptors_js_1$9.ScalarType.INT32:
			case descriptors_js_1$9.ScalarType.SFIXED32:
			case descriptors_js_1$9.ScalarType.SINT32:
				if (typeof value !== "number" || !Number.isInteger(value)) return false;
				if (value > binary_encoding_js_1$4.INT32_MAX || value < binary_encoding_js_1$4.INT32_MIN) return `${value.toFixed()} out of range`;
				return true;
			case descriptors_js_1$9.ScalarType.FIXED32:
			case descriptors_js_1$9.ScalarType.UINT32:
				if (typeof value !== "number" || !Number.isInteger(value)) return false;
				if (value > binary_encoding_js_1$4.UINT32_MAX || value < 0) return `${value.toFixed()} out of range`;
				return true;
			case descriptors_js_1$9.ScalarType.BOOL: return typeof value == "boolean";
			case descriptors_js_1$9.ScalarType.STRING:
				if (typeof value != "string") return false;
				return (0, text_encoding_js_1.getTextEncoding)().checkUtf8(value) || "invalid UTF8";
			case descriptors_js_1$9.ScalarType.BYTES: return value instanceof Uint8Array;
			case descriptors_js_1$9.ScalarType.INT64:
			case descriptors_js_1$9.ScalarType.SFIXED64:
			case descriptors_js_1$9.ScalarType.SINT64:
				if (typeof value == "bigint" || typeof value == "number" || typeof value == "string" && value.length > 0) try {
					proto_int64_js_1$4.protoInt64.parse(value);
					return true;
				} catch (_) {
					return `${value} out of range`;
				}
				return false;
			case descriptors_js_1$9.ScalarType.FIXED64:
			case descriptors_js_1$9.ScalarType.UINT64:
				if (typeof value == "bigint" || typeof value == "number" || typeof value == "string" && value.length > 0) try {
					proto_int64_js_1$4.protoInt64.uParse(value);
					return true;
				} catch (_) {
					return `${value} out of range`;
				}
				return false;
		}
	}
	function reasonSingular(field, val, details) {
		details = typeof details == "string" ? `: ${details}` : `, got ${formatVal(val)}`;
		if (field.scalar !== void 0) return `expected ${scalarTypeDescription(field.scalar)}` + details;
		if (field.enum !== void 0) return `expected ${field.enum.toString()}` + details;
		return `expected ${formatReflectMessage(field.message)}` + details;
	}
	function formatVal(val) {
		switch (typeof val) {
			case "object":
				if (val === null) return "null";
				if (val instanceof Uint8Array) return `Uint8Array(${val.length})`;
				if (Array.isArray(val)) return `Array(${val.length})`;
				if ((0, guard_js_1$3.isReflectList)(val)) return formatReflectList(val.field());
				if ((0, guard_js_1$3.isReflectMap)(val)) return formatReflectMap(val.field());
				if ((0, guard_js_1$3.isReflectMessage)(val)) return formatReflectMessage(val.desc);
				if ((0, is_message_js_1$1.isMessage)(val)) return `message ${val.$typeName}`;
				return "object";
			case "string": return val.length > 30 ? "string" : `"${val.split("\"").join("\\\"")}"`;
			case "boolean": return String(val);
			case "number": return String(val);
			case "bigint": return String(val) + "n";
			default: return typeof val;
		}
	}
	function formatReflectMessage(desc) {
		return `ReflectMessage (${desc.typeName})`;
	}
	function formatReflectList(field) {
		switch (field.listKind) {
			case "message": return `ReflectList (${field.message.toString()})`;
			case "enum": return `ReflectList (${field.enum.toString()})`;
			case "scalar": return `ReflectList (${descriptors_js_1$9.ScalarType[field.scalar]})`;
		}
	}
	function formatReflectMap(field) {
		switch (field.mapKind) {
			case "message": return `ReflectMap (${descriptors_js_1$9.ScalarType[field.mapKey]}, ${field.message.toString()})`;
			case "enum": return `ReflectMap (${descriptors_js_1$9.ScalarType[field.mapKey]}, ${field.enum.toString()})`;
			case "scalar": return `ReflectMap (${descriptors_js_1$9.ScalarType[field.mapKey]}, ${descriptors_js_1$9.ScalarType[field.scalar]})`;
		}
	}
	function scalarTypeDescription(scalar) {
		switch (scalar) {
			case descriptors_js_1$9.ScalarType.STRING: return "string";
			case descriptors_js_1$9.ScalarType.BOOL: return "boolean";
			case descriptors_js_1$9.ScalarType.INT64:
			case descriptors_js_1$9.ScalarType.SINT64:
			case descriptors_js_1$9.ScalarType.SFIXED64: return "bigint (int64)";
			case descriptors_js_1$9.ScalarType.UINT64:
			case descriptors_js_1$9.ScalarType.FIXED64: return "bigint (uint64)";
			case descriptors_js_1$9.ScalarType.BYTES: return "Uint8Array";
			case descriptors_js_1$9.ScalarType.DOUBLE: return "number (float64)";
			case descriptors_js_1$9.ScalarType.FLOAT: return "number (float32)";
			case descriptors_js_1$9.ScalarType.FIXED32:
			case descriptors_js_1$9.ScalarType.UINT32: return "number (uint32)";
			case descriptors_js_1$9.ScalarType.INT32:
			case descriptors_js_1$9.ScalarType.SFIXED32:
			case descriptors_js_1$9.ScalarType.SINT32: return "number (int32)";
		}
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/wrappers.js
var require_wrappers = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/wrappers.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isWrapper = isWrapper;
	exports.isWrapperDesc = isWrapperDesc;
	function isWrapper(arg) {
		return isWrapperTypeName(arg.$typeName);
	}
	function isWrapperDesc(messageDesc$1) {
		const f = messageDesc$1.fields[0];
		return isWrapperTypeName(messageDesc$1.typeName) && f !== void 0 && f.fieldKind == "scalar" && f.name == "value" && f.number == 1;
	}
	function isWrapperTypeName(name) {
		return name.startsWith("google.protobuf.") && [
			"DoubleValue",
			"FloatValue",
			"Int64Value",
			"UInt64Value",
			"Int32Value",
			"UInt32Value",
			"BoolValue",
			"StringValue",
			"BytesValue"
		].includes(name.substring(16));
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/create.js
var require_create = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/create.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.create = create;
	var is_message_js_1 = require_is_message();
	var descriptors_js_1$8 = require_descriptors();
	var scalar_js_1$5 = require_scalar$1();
	var guard_js_1$2 = require_guard();
	var unsafe_js_1$1 = require_unsafe();
	var wrappers_js_1$3 = require_wrappers();
	var EDITION_PROTO3 = 999;
	var EDITION_PROTO2 = 998;
	var IMPLICIT$1 = 2;
	/**
	* Create a new message instance.
	*
	* The second argument is an optional initializer object, where all fields are
	* optional.
	*/
	function create(schema, init) {
		if ((0, is_message_js_1.isMessage)(init, schema)) return init;
		const message = createZeroMessage(schema);
		if (init !== void 0) initMessage(schema, message, init);
		return message;
	}
	/**
	* Sets field values from a MessageInitShape on a zero message.
	*/
	function initMessage(messageDesc$1, message, init) {
		for (const member of messageDesc$1.members) {
			let value = init[member.localName];
			if (value == null) continue;
			let field;
			if (member.kind == "oneof") {
				const oneofField = (0, unsafe_js_1$1.unsafeOneofCase)(init, member);
				if (!oneofField) continue;
				field = oneofField;
				value = (0, unsafe_js_1$1.unsafeGet)(init, oneofField);
			} else field = member;
			switch (field.fieldKind) {
				case "message":
					value = toMessage(field, value);
					break;
				case "scalar":
					value = initScalar(field, value);
					break;
				case "list":
					value = initList(field, value);
					break;
				case "map":
					value = initMap(field, value);
					break;
			}
			(0, unsafe_js_1$1.unsafeSet)(message, field, value);
		}
		return message;
	}
	function initScalar(field, value) {
		if (field.scalar == descriptors_js_1$8.ScalarType.BYTES) return toU8Arr(value);
		return value;
	}
	function initMap(field, value) {
		if ((0, guard_js_1$2.isObject)(value)) {
			if (field.scalar == descriptors_js_1$8.ScalarType.BYTES) return convertObjectValues(value, toU8Arr);
			if (field.mapKind == "message") return convertObjectValues(value, (val) => toMessage(field, val));
		}
		return value;
	}
	function initList(field, value) {
		if (Array.isArray(value)) {
			if (field.scalar == descriptors_js_1$8.ScalarType.BYTES) return value.map(toU8Arr);
			if (field.listKind == "message") return value.map((item) => toMessage(field, item));
		}
		return value;
	}
	function toMessage(field, value) {
		if (field.fieldKind == "message" && !field.oneof && (0, wrappers_js_1$3.isWrapperDesc)(field.message)) return initScalar(field.message.fields[0], value);
		if ((0, guard_js_1$2.isObject)(value)) {
			if (field.message.typeName == "google.protobuf.Struct" && field.parent.typeName !== "google.protobuf.Value") return value;
			if (!(0, is_message_js_1.isMessage)(value, field.message)) return create(field.message, value);
		}
		return value;
	}
	function toU8Arr(value) {
		return Array.isArray(value) ? new Uint8Array(value) : value;
	}
	function convertObjectValues(obj, fn) {
		const ret = {};
		for (const entry of Object.entries(obj)) ret[entry[0]] = fn(entry[1]);
		return ret;
	}
	var tokenZeroMessageField = Symbol();
	var messagePrototypes = /* @__PURE__ */ new WeakMap();
	/**
	* Create a zero message.
	*/
	function createZeroMessage(desc) {
		let msg;
		if (!needsPrototypeChain(desc)) {
			msg = { $typeName: desc.typeName };
			for (const member of desc.members) if (member.kind == "oneof" || member.presence == IMPLICIT$1) msg[member.localName] = createZeroField(member);
		} else {
			const cached = messagePrototypes.get(desc);
			let prototype;
			let members;
			if (cached) ({prototype, members} = cached);
			else {
				prototype = {};
				members = /* @__PURE__ */ new Set();
				for (const member of desc.members) {
					if (member.kind == "oneof") continue;
					if (member.fieldKind != "scalar" && member.fieldKind != "enum") continue;
					if (member.presence == IMPLICIT$1) continue;
					members.add(member);
					prototype[member.localName] = createZeroField(member);
				}
				messagePrototypes.set(desc, {
					prototype,
					members
				});
			}
			msg = Object.create(prototype);
			msg.$typeName = desc.typeName;
			for (const member of desc.members) {
				if (members.has(member)) continue;
				if (member.kind == "field") {
					if (member.fieldKind == "message") continue;
					if (member.fieldKind == "scalar" || member.fieldKind == "enum") {
						if (member.presence != IMPLICIT$1) continue;
					}
				}
				msg[member.localName] = createZeroField(member);
			}
		}
		return msg;
	}
	/**
	* Do we need the prototype chain to track field presence?
	*/
	function needsPrototypeChain(desc) {
		switch (desc.file.edition) {
			case EDITION_PROTO3: return false;
			case EDITION_PROTO2: return true;
			default: return desc.fields.some((f) => f.presence != IMPLICIT$1 && f.fieldKind != "message" && !f.oneof);
		}
	}
	/**
	* Returns a zero value for oneof groups, and for every field kind except
	* messages. Scalar and enum fields can have default values.
	*/
	function createZeroField(field) {
		if (field.kind == "oneof") return { case: void 0 };
		if (field.fieldKind == "list") return [];
		if (field.fieldKind == "map") return {};
		if (field.fieldKind == "message") return tokenZeroMessageField;
		const defaultValue = field.getDefaultValue();
		if (defaultValue !== void 0) return field.fieldKind == "scalar" && field.longAsString ? defaultValue.toString() : defaultValue;
		return field.fieldKind == "scalar" ? (0, scalar_js_1$5.scalarZeroValue)(field.scalar, field.longAsString) : field.enum.values[0].number;
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect.js
var require_reflect = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.reflect = reflect;
	exports.reflectList = reflectList;
	exports.reflectMap = reflectMap;
	var descriptors_js_1$7 = require_descriptors();
	var reflect_check_js_1$2 = require_reflect_check();
	var error_js_1$1 = require_error();
	var unsafe_js_1 = require_unsafe();
	var create_js_1$5 = require_create();
	var wrappers_js_1$2 = require_wrappers();
	var scalar_js_1$4 = require_scalar$1();
	var proto_int64_js_1$3 = require_proto_int64();
	var guard_js_1$1 = require_guard();
	/**
	* Create a ReflectMessage.
	*/
	function reflect(messageDesc$1, message, check = true) {
		return new ReflectMessageImpl(messageDesc$1, message, check);
	}
	var messageSortedFields = /* @__PURE__ */ new WeakMap();
	var ReflectMessageImpl = class {
		get sortedFields() {
			const cached = messageSortedFields.get(this.desc);
			if (cached) return cached;
			const sortedFields = this.desc.fields.concat().sort((a$1, b$2) => a$1.number - b$2.number);
			messageSortedFields.set(this.desc, sortedFields);
			return sortedFields;
		}
		constructor(messageDesc$1, message, check = true) {
			this.lists = /* @__PURE__ */ new Map();
			this.maps = /* @__PURE__ */ new Map();
			this.check = check;
			this.desc = messageDesc$1;
			this.message = this[unsafe_js_1.unsafeLocal] = message !== null && message !== void 0 ? message : (0, create_js_1$5.create)(messageDesc$1);
			this.fields = messageDesc$1.fields;
			this.oneofs = messageDesc$1.oneofs;
			this.members = messageDesc$1.members;
		}
		findNumber(number) {
			if (!this._fieldsByNumber) this._fieldsByNumber = new Map(this.desc.fields.map((f) => [f.number, f]));
			return this._fieldsByNumber.get(number);
		}
		oneofCase(oneof) {
			assertOwn(this.message, oneof);
			return (0, unsafe_js_1.unsafeOneofCase)(this.message, oneof);
		}
		isSet(field) {
			assertOwn(this.message, field);
			return (0, unsafe_js_1.unsafeIsSet)(this.message, field);
		}
		clear(field) {
			assertOwn(this.message, field);
			(0, unsafe_js_1.unsafeClear)(this.message, field);
		}
		get(field) {
			assertOwn(this.message, field);
			const value = (0, unsafe_js_1.unsafeGet)(this.message, field);
			switch (field.fieldKind) {
				case "list":
					let list = this.lists.get(field);
					if (!list || list[unsafe_js_1.unsafeLocal] !== value) this.lists.set(field, list = new ReflectListImpl(field, value, this.check));
					return list;
				case "map":
					let map$1 = this.maps.get(field);
					if (!map$1 || map$1[unsafe_js_1.unsafeLocal] !== value) this.maps.set(field, map$1 = new ReflectMapImpl(field, value, this.check));
					return map$1;
				case "message": return messageToReflect(field, value, this.check);
				case "scalar": return value === void 0 ? (0, scalar_js_1$4.scalarZeroValue)(field.scalar, false) : longToReflect(field, value);
				case "enum": return value !== null && value !== void 0 ? value : field.enum.values[0].number;
			}
		}
		set(field, value) {
			assertOwn(this.message, field);
			if (this.check) {
				const err = (0, reflect_check_js_1$2.checkField)(field, value);
				if (err) throw err;
			}
			let local;
			if (field.fieldKind == "message") local = messageToLocal(field, value);
			else if ((0, guard_js_1$1.isReflectMap)(value) || (0, guard_js_1$1.isReflectList)(value)) local = value[unsafe_js_1.unsafeLocal];
			else local = longToLocal(field, value);
			(0, unsafe_js_1.unsafeSet)(this.message, field, local);
		}
		getUnknown() {
			return this.message.$unknown;
		}
		setUnknown(value) {
			this.message.$unknown = value;
		}
	};
	function assertOwn(owner, member) {
		if (member.parent.typeName !== owner.$typeName) throw new error_js_1$1.FieldError(member, `cannot use ${member.toString()} with message ${owner.$typeName}`, "ForeignFieldError");
	}
	/**
	* Create a ReflectList.
	*/
	function reflectList(field, unsafeInput, check = true) {
		return new ReflectListImpl(field, unsafeInput !== null && unsafeInput !== void 0 ? unsafeInput : [], check);
	}
	var ReflectListImpl = class {
		field() {
			return this._field;
		}
		get size() {
			return this._arr.length;
		}
		constructor(field, unsafeInput, check) {
			this._field = field;
			this._arr = this[unsafe_js_1.unsafeLocal] = unsafeInput;
			this.check = check;
		}
		get(index) {
			const item = this._arr[index];
			return item === void 0 ? void 0 : listItemToReflect(this._field, item, this.check);
		}
		set(index, item) {
			if (index < 0 || index >= this._arr.length) throw new error_js_1$1.FieldError(this._field, `list item #${index + 1}: out of range`);
			if (this.check) {
				const err = (0, reflect_check_js_1$2.checkListItem)(this._field, index, item);
				if (err) throw err;
			}
			this._arr[index] = listItemToLocal(this._field, item);
		}
		add(item) {
			if (this.check) {
				const err = (0, reflect_check_js_1$2.checkListItem)(this._field, this._arr.length, item);
				if (err) throw err;
			}
			this._arr.push(listItemToLocal(this._field, item));
		}
		clear() {
			this._arr.splice(0, this._arr.length);
		}
		[Symbol.iterator]() {
			return this.values();
		}
		keys() {
			return this._arr.keys();
		}
		*values() {
			for (const item of this._arr) yield listItemToReflect(this._field, item, this.check);
		}
		*entries() {
			for (let i = 0; i < this._arr.length; i++) yield [i, listItemToReflect(this._field, this._arr[i], this.check)];
		}
	};
	/**
	* Create a ReflectMap.
	*/
	function reflectMap(field, unsafeInput, check = true) {
		return new ReflectMapImpl(field, unsafeInput, check);
	}
	var ReflectMapImpl = class {
		constructor(field, unsafeInput, check = true) {
			this.obj = this[unsafe_js_1.unsafeLocal] = unsafeInput !== null && unsafeInput !== void 0 ? unsafeInput : {};
			this.check = check;
			this._field = field;
		}
		field() {
			return this._field;
		}
		set(key, value) {
			if (this.check) {
				const err = (0, reflect_check_js_1$2.checkMapEntry)(this._field, key, value);
				if (err) throw err;
			}
			this.obj[mapKeyToLocal(key)] = mapValueToLocal(this._field, value);
			return this;
		}
		delete(key) {
			const k = mapKeyToLocal(key);
			const has$1 = Object.prototype.hasOwnProperty.call(this.obj, k);
			if (has$1) delete this.obj[k];
			return has$1;
		}
		clear() {
			for (const key of Object.keys(this.obj)) delete this.obj[key];
		}
		get(key) {
			let val = this.obj[mapKeyToLocal(key)];
			if (val !== void 0) val = mapValueToReflect(this._field, val, this.check);
			return val;
		}
		has(key) {
			return Object.prototype.hasOwnProperty.call(this.obj, mapKeyToLocal(key));
		}
		*keys() {
			for (const objKey of Object.keys(this.obj)) yield mapKeyToReflect(objKey, this._field.mapKey);
		}
		*entries() {
			for (const objEntry of Object.entries(this.obj)) yield [mapKeyToReflect(objEntry[0], this._field.mapKey), mapValueToReflect(this._field, objEntry[1], this.check)];
		}
		[Symbol.iterator]() {
			return this.entries();
		}
		get size() {
			return Object.keys(this.obj).length;
		}
		*values() {
			for (const val of Object.values(this.obj)) yield mapValueToReflect(this._field, val, this.check);
		}
		forEach(callbackfn, thisArg) {
			for (const mapEntry of this.entries()) callbackfn.call(thisArg, mapEntry[1], mapEntry[0], this);
		}
	};
	function messageToLocal(field, value) {
		if (!(0, guard_js_1$1.isReflectMessage)(value)) return value;
		if ((0, wrappers_js_1$2.isWrapper)(value.message) && !field.oneof && field.fieldKind == "message") return value.message.value;
		if (value.desc.typeName == "google.protobuf.Struct" && field.parent.typeName != "google.protobuf.Value") return wktStructToLocal(value.message);
		return value.message;
	}
	function messageToReflect(field, value, check) {
		if (value !== void 0) {
			if ((0, wrappers_js_1$2.isWrapperDesc)(field.message) && !field.oneof && field.fieldKind == "message") value = {
				$typeName: field.message.typeName,
				value: longToReflect(field.message.fields[0], value)
			};
			else if (field.message.typeName == "google.protobuf.Struct" && field.parent.typeName != "google.protobuf.Value" && (0, guard_js_1$1.isObject)(value)) value = wktStructToReflect(value);
		}
		return new ReflectMessageImpl(field.message, value, check);
	}
	function listItemToLocal(field, value) {
		if (field.listKind == "message") return messageToLocal(field, value);
		return longToLocal(field, value);
	}
	function listItemToReflect(field, value, check) {
		if (field.listKind == "message") return messageToReflect(field, value, check);
		return longToReflect(field, value);
	}
	function mapValueToLocal(field, value) {
		if (field.mapKind == "message") return messageToLocal(field, value);
		return longToLocal(field, value);
	}
	function mapValueToReflect(field, value, check) {
		if (field.mapKind == "message") return messageToReflect(field, value, check);
		return value;
	}
	function mapKeyToLocal(key) {
		return typeof key == "string" || typeof key == "number" ? key : String(key);
	}
	/**
	* Converts a map key (any scalar value except float, double, or bytes) from its
	* representation in a message (string or number, the only possible object key
	* types) to the closest possible type in ECMAScript.
	*/
	function mapKeyToReflect(key, type$1) {
		switch (type$1) {
			case descriptors_js_1$7.ScalarType.STRING: return key;
			case descriptors_js_1$7.ScalarType.INT32:
			case descriptors_js_1$7.ScalarType.FIXED32:
			case descriptors_js_1$7.ScalarType.UINT32:
			case descriptors_js_1$7.ScalarType.SFIXED32:
			case descriptors_js_1$7.ScalarType.SINT32: {
				const n$2 = Number.parseInt(key);
				if (Number.isFinite(n$2)) return n$2;
				break;
			}
			case descriptors_js_1$7.ScalarType.BOOL:
				switch (key) {
					case "true": return true;
					case "false": return false;
				}
				break;
			case descriptors_js_1$7.ScalarType.UINT64:
			case descriptors_js_1$7.ScalarType.FIXED64:
				try {
					return proto_int64_js_1$3.protoInt64.uParse(key);
				} catch (_a) {}
				break;
			default:
				try {
					return proto_int64_js_1$3.protoInt64.parse(key);
				} catch (_b) {}
				break;
		}
		return key;
	}
	function longToReflect(field, value) {
		switch (field.scalar) {
			case descriptors_js_1$7.ScalarType.INT64:
			case descriptors_js_1$7.ScalarType.SFIXED64:
			case descriptors_js_1$7.ScalarType.SINT64:
				if ("longAsString" in field && field.longAsString && typeof value == "string") value = proto_int64_js_1$3.protoInt64.parse(value);
				break;
			case descriptors_js_1$7.ScalarType.FIXED64:
			case descriptors_js_1$7.ScalarType.UINT64:
				if ("longAsString" in field && field.longAsString && typeof value == "string") value = proto_int64_js_1$3.protoInt64.uParse(value);
				break;
		}
		return value;
	}
	function longToLocal(field, value) {
		switch (field.scalar) {
			case descriptors_js_1$7.ScalarType.INT64:
			case descriptors_js_1$7.ScalarType.SFIXED64:
			case descriptors_js_1$7.ScalarType.SINT64:
				if ("longAsString" in field && field.longAsString) value = String(value);
				else if (typeof value == "string" || typeof value == "number") value = proto_int64_js_1$3.protoInt64.parse(value);
				break;
			case descriptors_js_1$7.ScalarType.FIXED64:
			case descriptors_js_1$7.ScalarType.UINT64:
				if ("longAsString" in field && field.longAsString) value = String(value);
				else if (typeof value == "string" || typeof value == "number") value = proto_int64_js_1$3.protoInt64.uParse(value);
				break;
		}
		return value;
	}
	function wktStructToReflect(json) {
		const struct = {
			$typeName: "google.protobuf.Struct",
			fields: {}
		};
		if ((0, guard_js_1$1.isObject)(json)) for (const [k, v] of Object.entries(json)) struct.fields[k] = wktValueToReflect(v);
		return struct;
	}
	function wktStructToLocal(val) {
		const json = {};
		for (const [k, v] of Object.entries(val.fields)) json[k] = wktValueToLocal(v);
		return json;
	}
	function wktValueToLocal(val) {
		switch (val.kind.case) {
			case "structValue": return wktStructToLocal(val.kind.value);
			case "listValue": return val.kind.value.values.map(wktValueToLocal);
			case "nullValue":
			case void 0: return null;
			default: return val.kind.value;
		}
	}
	function wktValueToReflect(json) {
		const value = {
			$typeName: "google.protobuf.Value",
			kind: { case: void 0 }
		};
		switch (typeof json) {
			case "number":
				value.kind = {
					case: "numberValue",
					value: json
				};
				break;
			case "string":
				value.kind = {
					case: "stringValue",
					value: json
				};
				break;
			case "boolean":
				value.kind = {
					case: "boolValue",
					value: json
				};
				break;
			case "object":
				if (json === null) value.kind = {
					case: "nullValue",
					value: 0
				};
				else if (Array.isArray(json)) {
					const listValue = {
						$typeName: "google.protobuf.ListValue",
						values: []
					};
					if (Array.isArray(json)) for (const e of json) listValue.values.push(wktValueToReflect(e));
					value.kind = {
						case: "listValue",
						value: listValue
					};
				} else value.kind = {
					case: "structValue",
					value: wktStructToReflect(json)
				};
				break;
		}
		return value;
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/to-binary.js
var require_to_binary = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/to-binary.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toBinary = toBinary;
	exports.writeField = writeField;
	var reflect_js_1$7 = require_reflect();
	var binary_encoding_js_1$3 = require_binary_encoding();
	var descriptors_js_1$6 = require_descriptors();
	var LEGACY_REQUIRED$1 = 3;
	var writeDefaults = { writeUnknownFields: true };
	function makeWriteOptions$1(options) {
		return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
	}
	function toBinary(schema, message, options) {
		return writeFields(new binary_encoding_js_1$3.BinaryWriter(), makeWriteOptions$1(options), (0, reflect_js_1$7.reflect)(schema, message)).finish();
	}
	function writeFields(writer, opts, msg) {
		var _a;
		for (const f of msg.sortedFields) {
			if (!msg.isSet(f)) {
				if (f.presence == LEGACY_REQUIRED$1) throw new Error(`cannot encode ${f} to binary: required field not set`);
				continue;
			}
			writeField(writer, opts, msg, f);
		}
		if (opts.writeUnknownFields) for (const { no, wireType, data } of (_a = msg.getUnknown()) !== null && _a !== void 0 ? _a : []) writer.tag(no, wireType).raw(data);
		return writer;
	}
	/**
	* @private
	*/
	function writeField(writer, opts, msg, field) {
		var _a;
		switch (field.fieldKind) {
			case "scalar":
			case "enum":
				writeScalar(writer, msg.desc.typeName, field.name, (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1$6.ScalarType.INT32, field.number, msg.get(field));
				break;
			case "list":
				writeListField(writer, opts, field, msg.get(field));
				break;
			case "message":
				writeMessageField(writer, opts, field, msg.get(field));
				break;
			case "map":
				for (const [key, val] of msg.get(field)) writeMapEntry(writer, opts, field, key, val);
				break;
		}
	}
	function writeScalar(writer, msgName, fieldName, scalarType, fieldNo, value) {
		writeScalarValue(writer.tag(fieldNo, writeTypeOfScalar(scalarType)), msgName, fieldName, scalarType, value);
	}
	function writeMessageField(writer, opts, field, message) {
		if (field.delimitedEncoding) writeFields(writer.tag(field.number, binary_encoding_js_1$3.WireType.StartGroup), opts, message).tag(field.number, binary_encoding_js_1$3.WireType.EndGroup);
		else writeFields(writer.tag(field.number, binary_encoding_js_1$3.WireType.LengthDelimited).fork(), opts, message).join();
	}
	function writeListField(writer, opts, field, list) {
		var _a;
		if (field.listKind == "message") {
			for (const item of list) writeMessageField(writer, opts, field, item);
			return;
		}
		const scalarType = (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1$6.ScalarType.INT32;
		if (field.packed) {
			if (!list.size) return;
			writer.tag(field.number, binary_encoding_js_1$3.WireType.LengthDelimited).fork();
			for (const item of list) writeScalarValue(writer, field.parent.typeName, field.name, scalarType, item);
			writer.join();
			return;
		}
		for (const item of list) writeScalar(writer, field.parent.typeName, field.name, scalarType, field.number, item);
	}
	function writeMapEntry(writer, opts, field, key, value) {
		var _a;
		writer.tag(field.number, binary_encoding_js_1$3.WireType.LengthDelimited).fork();
		writeScalar(writer, field.parent.typeName, field.name, field.mapKey, 1, key);
		switch (field.mapKind) {
			case "scalar":
			case "enum":
				writeScalar(writer, field.parent.typeName, field.name, (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1$6.ScalarType.INT32, 2, value);
				break;
			case "message":
				writeFields(writer.tag(2, binary_encoding_js_1$3.WireType.LengthDelimited).fork(), opts, value).join();
				break;
		}
		writer.join();
	}
	function writeScalarValue(writer, msgName, fieldName, type$1, value) {
		try {
			switch (type$1) {
				case descriptors_js_1$6.ScalarType.STRING:
					writer.string(value);
					break;
				case descriptors_js_1$6.ScalarType.BOOL:
					writer.bool(value);
					break;
				case descriptors_js_1$6.ScalarType.DOUBLE:
					writer.double(value);
					break;
				case descriptors_js_1$6.ScalarType.FLOAT:
					writer.float(value);
					break;
				case descriptors_js_1$6.ScalarType.INT32:
					writer.int32(value);
					break;
				case descriptors_js_1$6.ScalarType.INT64:
					writer.int64(value);
					break;
				case descriptors_js_1$6.ScalarType.UINT64:
					writer.uint64(value);
					break;
				case descriptors_js_1$6.ScalarType.FIXED64:
					writer.fixed64(value);
					break;
				case descriptors_js_1$6.ScalarType.BYTES:
					writer.bytes(value);
					break;
				case descriptors_js_1$6.ScalarType.FIXED32:
					writer.fixed32(value);
					break;
				case descriptors_js_1$6.ScalarType.SFIXED32:
					writer.sfixed32(value);
					break;
				case descriptors_js_1$6.ScalarType.SFIXED64:
					writer.sfixed64(value);
					break;
				case descriptors_js_1$6.ScalarType.SINT64:
					writer.sint64(value);
					break;
				case descriptors_js_1$6.ScalarType.UINT32:
					writer.uint32(value);
					break;
				case descriptors_js_1$6.ScalarType.SINT32:
					writer.sint32(value);
					break;
			}
		} catch (e) {
			if (e instanceof Error) throw new Error(`cannot encode field ${msgName}.${fieldName} to binary: ${e.message}`);
			throw e;
		}
	}
	function writeTypeOfScalar(type$1) {
		switch (type$1) {
			case descriptors_js_1$6.ScalarType.BYTES:
			case descriptors_js_1$6.ScalarType.STRING: return binary_encoding_js_1$3.WireType.LengthDelimited;
			case descriptors_js_1$6.ScalarType.DOUBLE:
			case descriptors_js_1$6.ScalarType.FIXED64:
			case descriptors_js_1$6.ScalarType.SFIXED64: return binary_encoding_js_1$3.WireType.Bit64;
			case descriptors_js_1$6.ScalarType.FIXED32:
			case descriptors_js_1$6.ScalarType.SFIXED32:
			case descriptors_js_1$6.ScalarType.FLOAT: return binary_encoding_js_1$3.WireType.Bit32;
			default: return binary_encoding_js_1$3.WireType.Varint;
		}
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/clone.js
var require_clone = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/clone.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.clone = clone$1;
	var descriptors_js_1$5 = require_descriptors();
	var reflect_js_1$6 = require_reflect();
	var guard_js_1 = require_guard();
	/**
	* Create a deep copy of a message, including extensions and unknown fields.
	*/
	function clone$1(schema, message) {
		return cloneReflect((0, reflect_js_1$6.reflect)(schema, message)).message;
	}
	function cloneReflect(i) {
		const o = (0, reflect_js_1$6.reflect)(i.desc);
		for (const f of i.fields) {
			if (!i.isSet(f)) continue;
			switch (f.fieldKind) {
				case "list":
					const list = o.get(f);
					for (const item of i.get(f)) list.add(cloneSingular(f, item));
					break;
				case "map":
					const map$1 = o.get(f);
					for (const entry of i.get(f).entries()) map$1.set(entry[0], cloneSingular(f, entry[1]));
					break;
				default:
					o.set(f, cloneSingular(f, i.get(f)));
					break;
			}
		}
		const unknown = i.getUnknown();
		if (unknown && unknown.length > 0) o.setUnknown([...unknown]);
		return o;
	}
	function cloneSingular(field, value) {
		if (field.message !== void 0 && (0, guard_js_1.isReflectMessage)(value)) return cloneReflect(value);
		if (field.scalar == descriptors_js_1$5.ScalarType.BYTES && value instanceof Uint8Array) return value.slice();
		return value;
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/message.js
var require_message = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/message.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.messageDesc = messageDesc;
	/**
	* Hydrate a message descriptor.
	*
	* @private
	*/
	function messageDesc(file, path$2, ...paths) {
		return paths.reduce((acc, cur) => acc.nestedMessages[cur], file.messages[path$2]);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/enum.js
var require_enum = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/enum.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.enumDesc = enumDesc;
	exports.tsEnum = tsEnum;
	/**
	* Hydrate an enum descriptor.
	*
	* @private
	*/
	function enumDesc(file, path$2, ...paths) {
		if (paths.length == 0) return file.enums[path$2];
		const e = paths.pop();
		return paths.reduce((acc, cur) => acc.nestedMessages[cur], file.messages[path$2]).nestedEnums[e];
	}
	/**
	* Construct a TypeScript enum object at runtime from a descriptor.
	*/
	function tsEnum(desc) {
		const enumObject = {};
		for (const value of desc.values) {
			enumObject[value.localName] = value.number;
			enumObject[value.number] = value.localName;
		}
		return enumObject;
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/descriptor_pb.js
var require_descriptor_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/descriptor_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FeatureSet_FieldPresence = exports.FeatureSet_VisibilityFeature_DefaultSymbolVisibilitySchema = exports.FeatureSet_VisibilityFeature_DefaultSymbolVisibility = exports.FeatureSet_VisibilityFeatureSchema = exports.FeatureSetSchema = exports.UninterpretedOption_NamePartSchema = exports.UninterpretedOptionSchema = exports.MethodOptions_IdempotencyLevelSchema = exports.MethodOptions_IdempotencyLevel = exports.MethodOptionsSchema = exports.ServiceOptionsSchema = exports.EnumValueOptionsSchema = exports.EnumOptionsSchema = exports.OneofOptionsSchema = exports.FieldOptions_OptionTargetTypeSchema = exports.FieldOptions_OptionTargetType = exports.FieldOptions_OptionRetentionSchema = exports.FieldOptions_OptionRetention = exports.FieldOptions_JSTypeSchema = exports.FieldOptions_JSType = exports.FieldOptions_CTypeSchema = exports.FieldOptions_CType = exports.FieldOptions_FeatureSupportSchema = exports.FieldOptions_EditionDefaultSchema = exports.FieldOptionsSchema = exports.MessageOptionsSchema = exports.FileOptions_OptimizeModeSchema = exports.FileOptions_OptimizeMode = exports.FileOptionsSchema = exports.MethodDescriptorProtoSchema = exports.ServiceDescriptorProtoSchema = exports.EnumValueDescriptorProtoSchema = exports.EnumDescriptorProto_EnumReservedRangeSchema = exports.EnumDescriptorProtoSchema = exports.OneofDescriptorProtoSchema = exports.FieldDescriptorProto_LabelSchema = exports.FieldDescriptorProto_Label = exports.FieldDescriptorProto_TypeSchema = exports.FieldDescriptorProto_Type = exports.FieldDescriptorProtoSchema = exports.ExtensionRangeOptions_VerificationStateSchema = exports.ExtensionRangeOptions_VerificationState = exports.ExtensionRangeOptions_DeclarationSchema = exports.ExtensionRangeOptionsSchema = exports.DescriptorProto_ReservedRangeSchema = exports.DescriptorProto_ExtensionRangeSchema = exports.DescriptorProtoSchema = exports.FileDescriptorProtoSchema = exports.FileDescriptorSetSchema = exports.file_google_protobuf_descriptor = void 0;
	exports.SymbolVisibilitySchema = exports.SymbolVisibility = exports.EditionSchema = exports.Edition = exports.GeneratedCodeInfo_Annotation_SemanticSchema = exports.GeneratedCodeInfo_Annotation_Semantic = exports.GeneratedCodeInfo_AnnotationSchema = exports.GeneratedCodeInfoSchema = exports.SourceCodeInfo_LocationSchema = exports.SourceCodeInfoSchema = exports.FeatureSetDefaults_FeatureSetEditionDefaultSchema = exports.FeatureSetDefaultsSchema = exports.FeatureSet_EnforceNamingStyleSchema = exports.FeatureSet_EnforceNamingStyle = exports.FeatureSet_JsonFormatSchema = exports.FeatureSet_JsonFormat = exports.FeatureSet_MessageEncodingSchema = exports.FeatureSet_MessageEncoding = exports.FeatureSet_Utf8ValidationSchema = exports.FeatureSet_Utf8Validation = exports.FeatureSet_RepeatedFieldEncodingSchema = exports.FeatureSet_RepeatedFieldEncoding = exports.FeatureSet_EnumTypeSchema = exports.FeatureSet_EnumType = exports.FeatureSet_FieldPresenceSchema = void 0;
	var boot_js_1 = require_boot();
	var message_js_1$14 = require_message();
	var enum_js_1$6 = require_enum();
	/**
	* Describes the file google/protobuf/descriptor.proto.
	*/
	exports.file_google_protobuf_descriptor = (0, boot_js_1.boot)({
		"name": "google/protobuf/descriptor.proto",
		"package": "google.protobuf",
		"messageType": [
			{
				"name": "FileDescriptorSet",
				"field": [{
					"name": "file",
					"number": 1,
					"type": 11,
					"label": 3,
					"typeName": ".google.protobuf.FileDescriptorProto"
				}],
				"extensionRange": [{
					"start": 536e6,
					"end": 536000001
				}]
			},
			{
				"name": "FileDescriptorProto",
				"field": [
					{
						"name": "name",
						"number": 1,
						"type": 9,
						"label": 1
					},
					{
						"name": "package",
						"number": 2,
						"type": 9,
						"label": 1
					},
					{
						"name": "dependency",
						"number": 3,
						"type": 9,
						"label": 3
					},
					{
						"name": "public_dependency",
						"number": 10,
						"type": 5,
						"label": 3
					},
					{
						"name": "weak_dependency",
						"number": 11,
						"type": 5,
						"label": 3
					},
					{
						"name": "option_dependency",
						"number": 15,
						"type": 9,
						"label": 3
					},
					{
						"name": "message_type",
						"number": 4,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.DescriptorProto"
					},
					{
						"name": "enum_type",
						"number": 5,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.EnumDescriptorProto"
					},
					{
						"name": "service",
						"number": 6,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.ServiceDescriptorProto"
					},
					{
						"name": "extension",
						"number": 7,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.FieldDescriptorProto"
					},
					{
						"name": "options",
						"number": 8,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FileOptions"
					},
					{
						"name": "source_code_info",
						"number": 9,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.SourceCodeInfo"
					},
					{
						"name": "syntax",
						"number": 12,
						"type": 9,
						"label": 1
					},
					{
						"name": "edition",
						"number": 14,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.Edition"
					}
				]
			},
			{
				"name": "DescriptorProto",
				"field": [
					{
						"name": "name",
						"number": 1,
						"type": 9,
						"label": 1
					},
					{
						"name": "field",
						"number": 2,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.FieldDescriptorProto"
					},
					{
						"name": "extension",
						"number": 6,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.FieldDescriptorProto"
					},
					{
						"name": "nested_type",
						"number": 3,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.DescriptorProto"
					},
					{
						"name": "enum_type",
						"number": 4,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.EnumDescriptorProto"
					},
					{
						"name": "extension_range",
						"number": 5,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.DescriptorProto.ExtensionRange"
					},
					{
						"name": "oneof_decl",
						"number": 8,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.OneofDescriptorProto"
					},
					{
						"name": "options",
						"number": 7,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.MessageOptions"
					},
					{
						"name": "reserved_range",
						"number": 9,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.DescriptorProto.ReservedRange"
					},
					{
						"name": "reserved_name",
						"number": 10,
						"type": 9,
						"label": 3
					},
					{
						"name": "visibility",
						"number": 11,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.SymbolVisibility"
					}
				],
				"nestedType": [{
					"name": "ExtensionRange",
					"field": [
						{
							"name": "start",
							"number": 1,
							"type": 5,
							"label": 1
						},
						{
							"name": "end",
							"number": 2,
							"type": 5,
							"label": 1
						},
						{
							"name": "options",
							"number": 3,
							"type": 11,
							"label": 1,
							"typeName": ".google.protobuf.ExtensionRangeOptions"
						}
					]
				}, {
					"name": "ReservedRange",
					"field": [{
						"name": "start",
						"number": 1,
						"type": 5,
						"label": 1
					}, {
						"name": "end",
						"number": 2,
						"type": 5,
						"label": 1
					}]
				}]
			},
			{
				"name": "ExtensionRangeOptions",
				"field": [
					{
						"name": "uninterpreted_option",
						"number": 999,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.UninterpretedOption"
					},
					{
						"name": "declaration",
						"number": 2,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.ExtensionRangeOptions.Declaration",
						"options": { "retention": 2 }
					},
					{
						"name": "features",
						"number": 50,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet"
					},
					{
						"name": "verification",
						"number": 3,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.ExtensionRangeOptions.VerificationState",
						"defaultValue": "UNVERIFIED",
						"options": { "retention": 2 }
					}
				],
				"nestedType": [{
					"name": "Declaration",
					"field": [
						{
							"name": "number",
							"number": 1,
							"type": 5,
							"label": 1
						},
						{
							"name": "full_name",
							"number": 2,
							"type": 9,
							"label": 1
						},
						{
							"name": "type",
							"number": 3,
							"type": 9,
							"label": 1
						},
						{
							"name": "reserved",
							"number": 5,
							"type": 8,
							"label": 1
						},
						{
							"name": "repeated",
							"number": 6,
							"type": 8,
							"label": 1
						}
					]
				}],
				"enumType": [{
					"name": "VerificationState",
					"value": [{
						"name": "DECLARATION",
						"number": 0
					}, {
						"name": "UNVERIFIED",
						"number": 1
					}]
				}],
				"extensionRange": [{
					"start": 1e3,
					"end": 536870912
				}]
			},
			{
				"name": "FieldDescriptorProto",
				"field": [
					{
						"name": "name",
						"number": 1,
						"type": 9,
						"label": 1
					},
					{
						"name": "number",
						"number": 3,
						"type": 5,
						"label": 1
					},
					{
						"name": "label",
						"number": 4,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FieldDescriptorProto.Label"
					},
					{
						"name": "type",
						"number": 5,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FieldDescriptorProto.Type"
					},
					{
						"name": "type_name",
						"number": 6,
						"type": 9,
						"label": 1
					},
					{
						"name": "extendee",
						"number": 2,
						"type": 9,
						"label": 1
					},
					{
						"name": "default_value",
						"number": 7,
						"type": 9,
						"label": 1
					},
					{
						"name": "oneof_index",
						"number": 9,
						"type": 5,
						"label": 1
					},
					{
						"name": "json_name",
						"number": 10,
						"type": 9,
						"label": 1
					},
					{
						"name": "options",
						"number": 8,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FieldOptions"
					},
					{
						"name": "proto3_optional",
						"number": 17,
						"type": 8,
						"label": 1
					}
				],
				"enumType": [{
					"name": "Type",
					"value": [
						{
							"name": "TYPE_DOUBLE",
							"number": 1
						},
						{
							"name": "TYPE_FLOAT",
							"number": 2
						},
						{
							"name": "TYPE_INT64",
							"number": 3
						},
						{
							"name": "TYPE_UINT64",
							"number": 4
						},
						{
							"name": "TYPE_INT32",
							"number": 5
						},
						{
							"name": "TYPE_FIXED64",
							"number": 6
						},
						{
							"name": "TYPE_FIXED32",
							"number": 7
						},
						{
							"name": "TYPE_BOOL",
							"number": 8
						},
						{
							"name": "TYPE_STRING",
							"number": 9
						},
						{
							"name": "TYPE_GROUP",
							"number": 10
						},
						{
							"name": "TYPE_MESSAGE",
							"number": 11
						},
						{
							"name": "TYPE_BYTES",
							"number": 12
						},
						{
							"name": "TYPE_UINT32",
							"number": 13
						},
						{
							"name": "TYPE_ENUM",
							"number": 14
						},
						{
							"name": "TYPE_SFIXED32",
							"number": 15
						},
						{
							"name": "TYPE_SFIXED64",
							"number": 16
						},
						{
							"name": "TYPE_SINT32",
							"number": 17
						},
						{
							"name": "TYPE_SINT64",
							"number": 18
						}
					]
				}, {
					"name": "Label",
					"value": [
						{
							"name": "LABEL_OPTIONAL",
							"number": 1
						},
						{
							"name": "LABEL_REPEATED",
							"number": 3
						},
						{
							"name": "LABEL_REQUIRED",
							"number": 2
						}
					]
				}]
			},
			{
				"name": "OneofDescriptorProto",
				"field": [{
					"name": "name",
					"number": 1,
					"type": 9,
					"label": 1
				}, {
					"name": "options",
					"number": 2,
					"type": 11,
					"label": 1,
					"typeName": ".google.protobuf.OneofOptions"
				}]
			},
			{
				"name": "EnumDescriptorProto",
				"field": [
					{
						"name": "name",
						"number": 1,
						"type": 9,
						"label": 1
					},
					{
						"name": "value",
						"number": 2,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.EnumValueDescriptorProto"
					},
					{
						"name": "options",
						"number": 3,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.EnumOptions"
					},
					{
						"name": "reserved_range",
						"number": 4,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.EnumDescriptorProto.EnumReservedRange"
					},
					{
						"name": "reserved_name",
						"number": 5,
						"type": 9,
						"label": 3
					},
					{
						"name": "visibility",
						"number": 6,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.SymbolVisibility"
					}
				],
				"nestedType": [{
					"name": "EnumReservedRange",
					"field": [{
						"name": "start",
						"number": 1,
						"type": 5,
						"label": 1
					}, {
						"name": "end",
						"number": 2,
						"type": 5,
						"label": 1
					}]
				}]
			},
			{
				"name": "EnumValueDescriptorProto",
				"field": [
					{
						"name": "name",
						"number": 1,
						"type": 9,
						"label": 1
					},
					{
						"name": "number",
						"number": 2,
						"type": 5,
						"label": 1
					},
					{
						"name": "options",
						"number": 3,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.EnumValueOptions"
					}
				]
			},
			{
				"name": "ServiceDescriptorProto",
				"field": [
					{
						"name": "name",
						"number": 1,
						"type": 9,
						"label": 1
					},
					{
						"name": "method",
						"number": 2,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.MethodDescriptorProto"
					},
					{
						"name": "options",
						"number": 3,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.ServiceOptions"
					}
				]
			},
			{
				"name": "MethodDescriptorProto",
				"field": [
					{
						"name": "name",
						"number": 1,
						"type": 9,
						"label": 1
					},
					{
						"name": "input_type",
						"number": 2,
						"type": 9,
						"label": 1
					},
					{
						"name": "output_type",
						"number": 3,
						"type": 9,
						"label": 1
					},
					{
						"name": "options",
						"number": 4,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.MethodOptions"
					},
					{
						"name": "client_streaming",
						"number": 5,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "server_streaming",
						"number": 6,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					}
				]
			},
			{
				"name": "FileOptions",
				"field": [
					{
						"name": "java_package",
						"number": 1,
						"type": 9,
						"label": 1
					},
					{
						"name": "java_outer_classname",
						"number": 8,
						"type": 9,
						"label": 1
					},
					{
						"name": "java_multiple_files",
						"number": 10,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "java_generate_equals_and_hash",
						"number": 20,
						"type": 8,
						"label": 1,
						"options": { "deprecated": true }
					},
					{
						"name": "java_string_check_utf8",
						"number": 27,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "optimize_for",
						"number": 9,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FileOptions.OptimizeMode",
						"defaultValue": "SPEED"
					},
					{
						"name": "go_package",
						"number": 11,
						"type": 9,
						"label": 1
					},
					{
						"name": "cc_generic_services",
						"number": 16,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "java_generic_services",
						"number": 17,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "py_generic_services",
						"number": 18,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "deprecated",
						"number": 23,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "cc_enable_arenas",
						"number": 31,
						"type": 8,
						"label": 1,
						"defaultValue": "true"
					},
					{
						"name": "objc_class_prefix",
						"number": 36,
						"type": 9,
						"label": 1
					},
					{
						"name": "csharp_namespace",
						"number": 37,
						"type": 9,
						"label": 1
					},
					{
						"name": "swift_prefix",
						"number": 39,
						"type": 9,
						"label": 1
					},
					{
						"name": "php_class_prefix",
						"number": 40,
						"type": 9,
						"label": 1
					},
					{
						"name": "php_namespace",
						"number": 41,
						"type": 9,
						"label": 1
					},
					{
						"name": "php_metadata_namespace",
						"number": 44,
						"type": 9,
						"label": 1
					},
					{
						"name": "ruby_package",
						"number": 45,
						"type": 9,
						"label": 1
					},
					{
						"name": "features",
						"number": 50,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet"
					},
					{
						"name": "uninterpreted_option",
						"number": 999,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.UninterpretedOption"
					}
				],
				"enumType": [{
					"name": "OptimizeMode",
					"value": [
						{
							"name": "SPEED",
							"number": 1
						},
						{
							"name": "CODE_SIZE",
							"number": 2
						},
						{
							"name": "LITE_RUNTIME",
							"number": 3
						}
					]
				}],
				"extensionRange": [{
					"start": 1e3,
					"end": 536870912
				}]
			},
			{
				"name": "MessageOptions",
				"field": [
					{
						"name": "message_set_wire_format",
						"number": 1,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "no_standard_descriptor_accessor",
						"number": 2,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "deprecated",
						"number": 3,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "map_entry",
						"number": 7,
						"type": 8,
						"label": 1
					},
					{
						"name": "deprecated_legacy_json_field_conflicts",
						"number": 11,
						"type": 8,
						"label": 1,
						"options": { "deprecated": true }
					},
					{
						"name": "features",
						"number": 12,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet"
					},
					{
						"name": "uninterpreted_option",
						"number": 999,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.UninterpretedOption"
					}
				],
				"extensionRange": [{
					"start": 1e3,
					"end": 536870912
				}]
			},
			{
				"name": "FieldOptions",
				"field": [
					{
						"name": "ctype",
						"number": 1,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FieldOptions.CType",
						"defaultValue": "STRING"
					},
					{
						"name": "packed",
						"number": 2,
						"type": 8,
						"label": 1
					},
					{
						"name": "jstype",
						"number": 6,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FieldOptions.JSType",
						"defaultValue": "JS_NORMAL"
					},
					{
						"name": "lazy",
						"number": 5,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "unverified_lazy",
						"number": 15,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "deprecated",
						"number": 3,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "weak",
						"number": 10,
						"type": 8,
						"label": 1,
						"defaultValue": "false",
						"options": { "deprecated": true }
					},
					{
						"name": "debug_redact",
						"number": 16,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "retention",
						"number": 17,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FieldOptions.OptionRetention"
					},
					{
						"name": "targets",
						"number": 19,
						"type": 14,
						"label": 3,
						"typeName": ".google.protobuf.FieldOptions.OptionTargetType"
					},
					{
						"name": "edition_defaults",
						"number": 20,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.FieldOptions.EditionDefault"
					},
					{
						"name": "features",
						"number": 21,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet"
					},
					{
						"name": "feature_support",
						"number": 22,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FieldOptions.FeatureSupport"
					},
					{
						"name": "uninterpreted_option",
						"number": 999,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.UninterpretedOption"
					}
				],
				"nestedType": [{
					"name": "EditionDefault",
					"field": [{
						"name": "edition",
						"number": 3,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.Edition"
					}, {
						"name": "value",
						"number": 2,
						"type": 9,
						"label": 1
					}]
				}, {
					"name": "FeatureSupport",
					"field": [
						{
							"name": "edition_introduced",
							"number": 1,
							"type": 14,
							"label": 1,
							"typeName": ".google.protobuf.Edition"
						},
						{
							"name": "edition_deprecated",
							"number": 2,
							"type": 14,
							"label": 1,
							"typeName": ".google.protobuf.Edition"
						},
						{
							"name": "deprecation_warning",
							"number": 3,
							"type": 9,
							"label": 1
						},
						{
							"name": "edition_removed",
							"number": 4,
							"type": 14,
							"label": 1,
							"typeName": ".google.protobuf.Edition"
						}
					]
				}],
				"enumType": [
					{
						"name": "CType",
						"value": [
							{
								"name": "STRING",
								"number": 0
							},
							{
								"name": "CORD",
								"number": 1
							},
							{
								"name": "STRING_PIECE",
								"number": 2
							}
						]
					},
					{
						"name": "JSType",
						"value": [
							{
								"name": "JS_NORMAL",
								"number": 0
							},
							{
								"name": "JS_STRING",
								"number": 1
							},
							{
								"name": "JS_NUMBER",
								"number": 2
							}
						]
					},
					{
						"name": "OptionRetention",
						"value": [
							{
								"name": "RETENTION_UNKNOWN",
								"number": 0
							},
							{
								"name": "RETENTION_RUNTIME",
								"number": 1
							},
							{
								"name": "RETENTION_SOURCE",
								"number": 2
							}
						]
					},
					{
						"name": "OptionTargetType",
						"value": [
							{
								"name": "TARGET_TYPE_UNKNOWN",
								"number": 0
							},
							{
								"name": "TARGET_TYPE_FILE",
								"number": 1
							},
							{
								"name": "TARGET_TYPE_EXTENSION_RANGE",
								"number": 2
							},
							{
								"name": "TARGET_TYPE_MESSAGE",
								"number": 3
							},
							{
								"name": "TARGET_TYPE_FIELD",
								"number": 4
							},
							{
								"name": "TARGET_TYPE_ONEOF",
								"number": 5
							},
							{
								"name": "TARGET_TYPE_ENUM",
								"number": 6
							},
							{
								"name": "TARGET_TYPE_ENUM_ENTRY",
								"number": 7
							},
							{
								"name": "TARGET_TYPE_SERVICE",
								"number": 8
							},
							{
								"name": "TARGET_TYPE_METHOD",
								"number": 9
							}
						]
					}
				],
				"extensionRange": [{
					"start": 1e3,
					"end": 536870912
				}]
			},
			{
				"name": "OneofOptions",
				"field": [{
					"name": "features",
					"number": 1,
					"type": 11,
					"label": 1,
					"typeName": ".google.protobuf.FeatureSet"
				}, {
					"name": "uninterpreted_option",
					"number": 999,
					"type": 11,
					"label": 3,
					"typeName": ".google.protobuf.UninterpretedOption"
				}],
				"extensionRange": [{
					"start": 1e3,
					"end": 536870912
				}]
			},
			{
				"name": "EnumOptions",
				"field": [
					{
						"name": "allow_alias",
						"number": 2,
						"type": 8,
						"label": 1
					},
					{
						"name": "deprecated",
						"number": 3,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "deprecated_legacy_json_field_conflicts",
						"number": 6,
						"type": 8,
						"label": 1,
						"options": { "deprecated": true }
					},
					{
						"name": "features",
						"number": 7,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet"
					},
					{
						"name": "uninterpreted_option",
						"number": 999,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.UninterpretedOption"
					}
				],
				"extensionRange": [{
					"start": 1e3,
					"end": 536870912
				}]
			},
			{
				"name": "EnumValueOptions",
				"field": [
					{
						"name": "deprecated",
						"number": 1,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "features",
						"number": 2,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet"
					},
					{
						"name": "debug_redact",
						"number": 3,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "feature_support",
						"number": 4,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FieldOptions.FeatureSupport"
					},
					{
						"name": "uninterpreted_option",
						"number": 999,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.UninterpretedOption"
					}
				],
				"extensionRange": [{
					"start": 1e3,
					"end": 536870912
				}]
			},
			{
				"name": "ServiceOptions",
				"field": [
					{
						"name": "features",
						"number": 34,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet"
					},
					{
						"name": "deprecated",
						"number": 33,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "uninterpreted_option",
						"number": 999,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.UninterpretedOption"
					}
				],
				"extensionRange": [{
					"start": 1e3,
					"end": 536870912
				}]
			},
			{
				"name": "MethodOptions",
				"field": [
					{
						"name": "deprecated",
						"number": 33,
						"type": 8,
						"label": 1,
						"defaultValue": "false"
					},
					{
						"name": "idempotency_level",
						"number": 34,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.MethodOptions.IdempotencyLevel",
						"defaultValue": "IDEMPOTENCY_UNKNOWN"
					},
					{
						"name": "features",
						"number": 35,
						"type": 11,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet"
					},
					{
						"name": "uninterpreted_option",
						"number": 999,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.UninterpretedOption"
					}
				],
				"enumType": [{
					"name": "IdempotencyLevel",
					"value": [
						{
							"name": "IDEMPOTENCY_UNKNOWN",
							"number": 0
						},
						{
							"name": "NO_SIDE_EFFECTS",
							"number": 1
						},
						{
							"name": "IDEMPOTENT",
							"number": 2
						}
					]
				}],
				"extensionRange": [{
					"start": 1e3,
					"end": 536870912
				}]
			},
			{
				"name": "UninterpretedOption",
				"field": [
					{
						"name": "name",
						"number": 2,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.UninterpretedOption.NamePart"
					},
					{
						"name": "identifier_value",
						"number": 3,
						"type": 9,
						"label": 1
					},
					{
						"name": "positive_int_value",
						"number": 4,
						"type": 4,
						"label": 1
					},
					{
						"name": "negative_int_value",
						"number": 5,
						"type": 3,
						"label": 1
					},
					{
						"name": "double_value",
						"number": 6,
						"type": 1,
						"label": 1
					},
					{
						"name": "string_value",
						"number": 7,
						"type": 12,
						"label": 1
					},
					{
						"name": "aggregate_value",
						"number": 8,
						"type": 9,
						"label": 1
					}
				],
				"nestedType": [{
					"name": "NamePart",
					"field": [{
						"name": "name_part",
						"number": 1,
						"type": 9,
						"label": 2
					}, {
						"name": "is_extension",
						"number": 2,
						"type": 8,
						"label": 2
					}]
				}]
			},
			{
				"name": "FeatureSet",
				"field": [
					{
						"name": "field_presence",
						"number": 1,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet.FieldPresence",
						"options": {
							"retention": 1,
							"targets": [4, 1],
							"editionDefaults": [
								{
									"value": "EXPLICIT",
									"edition": 900
								},
								{
									"value": "IMPLICIT",
									"edition": 999
								},
								{
									"value": "EXPLICIT",
									"edition": 1e3
								}
							]
						}
					},
					{
						"name": "enum_type",
						"number": 2,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet.EnumType",
						"options": {
							"retention": 1,
							"targets": [6, 1],
							"editionDefaults": [{
								"value": "CLOSED",
								"edition": 900
							}, {
								"value": "OPEN",
								"edition": 999
							}]
						}
					},
					{
						"name": "repeated_field_encoding",
						"number": 3,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet.RepeatedFieldEncoding",
						"options": {
							"retention": 1,
							"targets": [4, 1],
							"editionDefaults": [{
								"value": "EXPANDED",
								"edition": 900
							}, {
								"value": "PACKED",
								"edition": 999
							}]
						}
					},
					{
						"name": "utf8_validation",
						"number": 4,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet.Utf8Validation",
						"options": {
							"retention": 1,
							"targets": [4, 1],
							"editionDefaults": [{
								"value": "NONE",
								"edition": 900
							}, {
								"value": "VERIFY",
								"edition": 999
							}]
						}
					},
					{
						"name": "message_encoding",
						"number": 5,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet.MessageEncoding",
						"options": {
							"retention": 1,
							"targets": [4, 1],
							"editionDefaults": [{
								"value": "LENGTH_PREFIXED",
								"edition": 900
							}]
						}
					},
					{
						"name": "json_format",
						"number": 6,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet.JsonFormat",
						"options": {
							"retention": 1,
							"targets": [
								3,
								6,
								1
							],
							"editionDefaults": [{
								"value": "LEGACY_BEST_EFFORT",
								"edition": 900
							}, {
								"value": "ALLOW",
								"edition": 999
							}]
						}
					},
					{
						"name": "enforce_naming_style",
						"number": 7,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet.EnforceNamingStyle",
						"options": {
							"retention": 2,
							"targets": [
								1,
								2,
								3,
								4,
								5,
								6,
								7,
								8,
								9
							],
							"editionDefaults": [{
								"value": "STYLE_LEGACY",
								"edition": 900
							}, {
								"value": "STYLE2024",
								"edition": 1001
							}]
						}
					},
					{
						"name": "default_symbol_visibility",
						"number": 8,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility",
						"options": {
							"retention": 2,
							"targets": [1],
							"editionDefaults": [{
								"value": "EXPORT_ALL",
								"edition": 900
							}, {
								"value": "EXPORT_TOP_LEVEL",
								"edition": 1001
							}]
						}
					}
				],
				"nestedType": [{
					"name": "VisibilityFeature",
					"enumType": [{
						"name": "DefaultSymbolVisibility",
						"value": [
							{
								"name": "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN",
								"number": 0
							},
							{
								"name": "EXPORT_ALL",
								"number": 1
							},
							{
								"name": "EXPORT_TOP_LEVEL",
								"number": 2
							},
							{
								"name": "LOCAL_ALL",
								"number": 3
							},
							{
								"name": "STRICT",
								"number": 4
							}
						]
					}]
				}],
				"enumType": [
					{
						"name": "FieldPresence",
						"value": [
							{
								"name": "FIELD_PRESENCE_UNKNOWN",
								"number": 0
							},
							{
								"name": "EXPLICIT",
								"number": 1
							},
							{
								"name": "IMPLICIT",
								"number": 2
							},
							{
								"name": "LEGACY_REQUIRED",
								"number": 3
							}
						]
					},
					{
						"name": "EnumType",
						"value": [
							{
								"name": "ENUM_TYPE_UNKNOWN",
								"number": 0
							},
							{
								"name": "OPEN",
								"number": 1
							},
							{
								"name": "CLOSED",
								"number": 2
							}
						]
					},
					{
						"name": "RepeatedFieldEncoding",
						"value": [
							{
								"name": "REPEATED_FIELD_ENCODING_UNKNOWN",
								"number": 0
							},
							{
								"name": "PACKED",
								"number": 1
							},
							{
								"name": "EXPANDED",
								"number": 2
							}
						]
					},
					{
						"name": "Utf8Validation",
						"value": [
							{
								"name": "UTF8_VALIDATION_UNKNOWN",
								"number": 0
							},
							{
								"name": "VERIFY",
								"number": 2
							},
							{
								"name": "NONE",
								"number": 3
							}
						]
					},
					{
						"name": "MessageEncoding",
						"value": [
							{
								"name": "MESSAGE_ENCODING_UNKNOWN",
								"number": 0
							},
							{
								"name": "LENGTH_PREFIXED",
								"number": 1
							},
							{
								"name": "DELIMITED",
								"number": 2
							}
						]
					},
					{
						"name": "JsonFormat",
						"value": [
							{
								"name": "JSON_FORMAT_UNKNOWN",
								"number": 0
							},
							{
								"name": "ALLOW",
								"number": 1
							},
							{
								"name": "LEGACY_BEST_EFFORT",
								"number": 2
							}
						]
					},
					{
						"name": "EnforceNamingStyle",
						"value": [
							{
								"name": "ENFORCE_NAMING_STYLE_UNKNOWN",
								"number": 0
							},
							{
								"name": "STYLE2024",
								"number": 1
							},
							{
								"name": "STYLE_LEGACY",
								"number": 2
							}
						]
					}
				],
				"extensionRange": [
					{
						"start": 1e3,
						"end": 9995
					},
					{
						"start": 9995,
						"end": 1e4
					},
					{
						"start": 1e4,
						"end": 10001
					}
				]
			},
			{
				"name": "FeatureSetDefaults",
				"field": [
					{
						"name": "defaults",
						"number": 1,
						"type": 11,
						"label": 3,
						"typeName": ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault"
					},
					{
						"name": "minimum_edition",
						"number": 4,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.Edition"
					},
					{
						"name": "maximum_edition",
						"number": 5,
						"type": 14,
						"label": 1,
						"typeName": ".google.protobuf.Edition"
					}
				],
				"nestedType": [{
					"name": "FeatureSetEditionDefault",
					"field": [
						{
							"name": "edition",
							"number": 3,
							"type": 14,
							"label": 1,
							"typeName": ".google.protobuf.Edition"
						},
						{
							"name": "overridable_features",
							"number": 4,
							"type": 11,
							"label": 1,
							"typeName": ".google.protobuf.FeatureSet"
						},
						{
							"name": "fixed_features",
							"number": 5,
							"type": 11,
							"label": 1,
							"typeName": ".google.protobuf.FeatureSet"
						}
					]
				}]
			},
			{
				"name": "SourceCodeInfo",
				"field": [{
					"name": "location",
					"number": 1,
					"type": 11,
					"label": 3,
					"typeName": ".google.protobuf.SourceCodeInfo.Location"
				}],
				"nestedType": [{
					"name": "Location",
					"field": [
						{
							"name": "path",
							"number": 1,
							"type": 5,
							"label": 3,
							"options": { "packed": true }
						},
						{
							"name": "span",
							"number": 2,
							"type": 5,
							"label": 3,
							"options": { "packed": true }
						},
						{
							"name": "leading_comments",
							"number": 3,
							"type": 9,
							"label": 1
						},
						{
							"name": "trailing_comments",
							"number": 4,
							"type": 9,
							"label": 1
						},
						{
							"name": "leading_detached_comments",
							"number": 6,
							"type": 9,
							"label": 3
						}
					]
				}],
				"extensionRange": [{
					"start": 536e6,
					"end": 536000001
				}]
			},
			{
				"name": "GeneratedCodeInfo",
				"field": [{
					"name": "annotation",
					"number": 1,
					"type": 11,
					"label": 3,
					"typeName": ".google.protobuf.GeneratedCodeInfo.Annotation"
				}],
				"nestedType": [{
					"name": "Annotation",
					"field": [
						{
							"name": "path",
							"number": 1,
							"type": 5,
							"label": 3,
							"options": { "packed": true }
						},
						{
							"name": "source_file",
							"number": 2,
							"type": 9,
							"label": 1
						},
						{
							"name": "begin",
							"number": 3,
							"type": 5,
							"label": 1
						},
						{
							"name": "end",
							"number": 4,
							"type": 5,
							"label": 1
						},
						{
							"name": "semantic",
							"number": 5,
							"type": 14,
							"label": 1,
							"typeName": ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic"
						}
					],
					"enumType": [{
						"name": "Semantic",
						"value": [
							{
								"name": "NONE",
								"number": 0
							},
							{
								"name": "SET",
								"number": 1
							},
							{
								"name": "ALIAS",
								"number": 2
							}
						]
					}]
				}]
			}
		],
		"enumType": [{
			"name": "Edition",
			"value": [
				{
					"name": "EDITION_UNKNOWN",
					"number": 0
				},
				{
					"name": "EDITION_LEGACY",
					"number": 900
				},
				{
					"name": "EDITION_PROTO2",
					"number": 998
				},
				{
					"name": "EDITION_PROTO3",
					"number": 999
				},
				{
					"name": "EDITION_2023",
					"number": 1e3
				},
				{
					"name": "EDITION_2024",
					"number": 1001
				},
				{
					"name": "EDITION_1_TEST_ONLY",
					"number": 1
				},
				{
					"name": "EDITION_2_TEST_ONLY",
					"number": 2
				},
				{
					"name": "EDITION_99997_TEST_ONLY",
					"number": 99997
				},
				{
					"name": "EDITION_99998_TEST_ONLY",
					"number": 99998
				},
				{
					"name": "EDITION_99999_TEST_ONLY",
					"number": 99999
				},
				{
					"name": "EDITION_MAX",
					"number": 2147483647
				}
			]
		}, {
			"name": "SymbolVisibility",
			"value": [
				{
					"name": "VISIBILITY_UNSET",
					"number": 0
				},
				{
					"name": "VISIBILITY_LOCAL",
					"number": 1
				},
				{
					"name": "VISIBILITY_EXPORT",
					"number": 2
				}
			]
		}]
	});
	/**
	* Describes the message google.protobuf.FileDescriptorSet.
	* Use `create(FileDescriptorSetSchema)` to create a new message.
	*/
	exports.FileDescriptorSetSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 0);
	/**
	* Describes the message google.protobuf.FileDescriptorProto.
	* Use `create(FileDescriptorProtoSchema)` to create a new message.
	*/
	exports.FileDescriptorProtoSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 1);
	/**
	* Describes the message google.protobuf.DescriptorProto.
	* Use `create(DescriptorProtoSchema)` to create a new message.
	*/
	exports.DescriptorProtoSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 2);
	/**
	* Describes the message google.protobuf.DescriptorProto.ExtensionRange.
	* Use `create(DescriptorProto_ExtensionRangeSchema)` to create a new message.
	*/
	exports.DescriptorProto_ExtensionRangeSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 2, 0);
	/**
	* Describes the message google.protobuf.DescriptorProto.ReservedRange.
	* Use `create(DescriptorProto_ReservedRangeSchema)` to create a new message.
	*/
	exports.DescriptorProto_ReservedRangeSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 2, 1);
	/**
	* Describes the message google.protobuf.ExtensionRangeOptions.
	* Use `create(ExtensionRangeOptionsSchema)` to create a new message.
	*/
	exports.ExtensionRangeOptionsSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 3);
	/**
	* Describes the message google.protobuf.ExtensionRangeOptions.Declaration.
	* Use `create(ExtensionRangeOptions_DeclarationSchema)` to create a new message.
	*/
	exports.ExtensionRangeOptions_DeclarationSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 3, 0);
	/**
	* The verification state of the extension range.
	*
	* @generated from enum google.protobuf.ExtensionRangeOptions.VerificationState
	*/
	var ExtensionRangeOptions_VerificationState;
	(function(ExtensionRangeOptions_VerificationState$1) {
		/**
		* All the extensions of the range must be declared.
		*
		* @generated from enum value: DECLARATION = 0;
		*/
		ExtensionRangeOptions_VerificationState$1[ExtensionRangeOptions_VerificationState$1["DECLARATION"] = 0] = "DECLARATION";
		/**
		* @generated from enum value: UNVERIFIED = 1;
		*/
		ExtensionRangeOptions_VerificationState$1[ExtensionRangeOptions_VerificationState$1["UNVERIFIED"] = 1] = "UNVERIFIED";
	})(ExtensionRangeOptions_VerificationState || (exports.ExtensionRangeOptions_VerificationState = ExtensionRangeOptions_VerificationState = {}));
	/**
	* Describes the enum google.protobuf.ExtensionRangeOptions.VerificationState.
	*/
	exports.ExtensionRangeOptions_VerificationStateSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 3, 0);
	/**
	* Describes the message google.protobuf.FieldDescriptorProto.
	* Use `create(FieldDescriptorProtoSchema)` to create a new message.
	*/
	exports.FieldDescriptorProtoSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 4);
	/**
	* @generated from enum google.protobuf.FieldDescriptorProto.Type
	*/
	var FieldDescriptorProto_Type;
	(function(FieldDescriptorProto_Type$1) {
		/**
		* 0 is reserved for errors.
		* Order is weird for historical reasons.
		*
		* @generated from enum value: TYPE_DOUBLE = 1;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["DOUBLE"] = 1] = "DOUBLE";
		/**
		* @generated from enum value: TYPE_FLOAT = 2;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["FLOAT"] = 2] = "FLOAT";
		/**
		* Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
		* negative values are likely.
		*
		* @generated from enum value: TYPE_INT64 = 3;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["INT64"] = 3] = "INT64";
		/**
		* @generated from enum value: TYPE_UINT64 = 4;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["UINT64"] = 4] = "UINT64";
		/**
		* Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
		* negative values are likely.
		*
		* @generated from enum value: TYPE_INT32 = 5;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["INT32"] = 5] = "INT32";
		/**
		* @generated from enum value: TYPE_FIXED64 = 6;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["FIXED64"] = 6] = "FIXED64";
		/**
		* @generated from enum value: TYPE_FIXED32 = 7;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["FIXED32"] = 7] = "FIXED32";
		/**
		* @generated from enum value: TYPE_BOOL = 8;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["BOOL"] = 8] = "BOOL";
		/**
		* @generated from enum value: TYPE_STRING = 9;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["STRING"] = 9] = "STRING";
		/**
		* Tag-delimited aggregate.
		* Group type is deprecated and not supported after google.protobuf. However, Proto3
		* implementations should still be able to parse the group wire format and
		* treat group fields as unknown fields.  In Editions, the group wire format
		* can be enabled via the `message_encoding` feature.
		*
		* @generated from enum value: TYPE_GROUP = 10;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["GROUP"] = 10] = "GROUP";
		/**
		* Length-delimited aggregate.
		*
		* @generated from enum value: TYPE_MESSAGE = 11;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["MESSAGE"] = 11] = "MESSAGE";
		/**
		* New in version 2.
		*
		* @generated from enum value: TYPE_BYTES = 12;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["BYTES"] = 12] = "BYTES";
		/**
		* @generated from enum value: TYPE_UINT32 = 13;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["UINT32"] = 13] = "UINT32";
		/**
		* @generated from enum value: TYPE_ENUM = 14;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["ENUM"] = 14] = "ENUM";
		/**
		* @generated from enum value: TYPE_SFIXED32 = 15;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["SFIXED32"] = 15] = "SFIXED32";
		/**
		* @generated from enum value: TYPE_SFIXED64 = 16;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["SFIXED64"] = 16] = "SFIXED64";
		/**
		* Uses ZigZag encoding.
		*
		* @generated from enum value: TYPE_SINT32 = 17;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["SINT32"] = 17] = "SINT32";
		/**
		* Uses ZigZag encoding.
		*
		* @generated from enum value: TYPE_SINT64 = 18;
		*/
		FieldDescriptorProto_Type$1[FieldDescriptorProto_Type$1["SINT64"] = 18] = "SINT64";
	})(FieldDescriptorProto_Type || (exports.FieldDescriptorProto_Type = FieldDescriptorProto_Type = {}));
	/**
	* Describes the enum google.protobuf.FieldDescriptorProto.Type.
	*/
	exports.FieldDescriptorProto_TypeSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 4, 0);
	/**
	* @generated from enum google.protobuf.FieldDescriptorProto.Label
	*/
	var FieldDescriptorProto_Label;
	(function(FieldDescriptorProto_Label$1) {
		/**
		* 0 is reserved for errors
		*
		* @generated from enum value: LABEL_OPTIONAL = 1;
		*/
		FieldDescriptorProto_Label$1[FieldDescriptorProto_Label$1["OPTIONAL"] = 1] = "OPTIONAL";
		/**
		* @generated from enum value: LABEL_REPEATED = 3;
		*/
		FieldDescriptorProto_Label$1[FieldDescriptorProto_Label$1["REPEATED"] = 3] = "REPEATED";
		/**
		* The required label is only allowed in google.protobuf.  In proto3 and Editions
		* it's explicitly prohibited.  In Editions, the `field_presence` feature
		* can be used to get this behavior.
		*
		* @generated from enum value: LABEL_REQUIRED = 2;
		*/
		FieldDescriptorProto_Label$1[FieldDescriptorProto_Label$1["REQUIRED"] = 2] = "REQUIRED";
	})(FieldDescriptorProto_Label || (exports.FieldDescriptorProto_Label = FieldDescriptorProto_Label = {}));
	/**
	* Describes the enum google.protobuf.FieldDescriptorProto.Label.
	*/
	exports.FieldDescriptorProto_LabelSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 4, 1);
	/**
	* Describes the message google.protobuf.OneofDescriptorProto.
	* Use `create(OneofDescriptorProtoSchema)` to create a new message.
	*/
	exports.OneofDescriptorProtoSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 5);
	/**
	* Describes the message google.protobuf.EnumDescriptorProto.
	* Use `create(EnumDescriptorProtoSchema)` to create a new message.
	*/
	exports.EnumDescriptorProtoSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 6);
	/**
	* Describes the message google.protobuf.EnumDescriptorProto.EnumReservedRange.
	* Use `create(EnumDescriptorProto_EnumReservedRangeSchema)` to create a new message.
	*/
	exports.EnumDescriptorProto_EnumReservedRangeSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 6, 0);
	/**
	* Describes the message google.protobuf.EnumValueDescriptorProto.
	* Use `create(EnumValueDescriptorProtoSchema)` to create a new message.
	*/
	exports.EnumValueDescriptorProtoSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 7);
	/**
	* Describes the message google.protobuf.ServiceDescriptorProto.
	* Use `create(ServiceDescriptorProtoSchema)` to create a new message.
	*/
	exports.ServiceDescriptorProtoSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 8);
	/**
	* Describes the message google.protobuf.MethodDescriptorProto.
	* Use `create(MethodDescriptorProtoSchema)` to create a new message.
	*/
	exports.MethodDescriptorProtoSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 9);
	/**
	* Describes the message google.protobuf.FileOptions.
	* Use `create(FileOptionsSchema)` to create a new message.
	*/
	exports.FileOptionsSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 10);
	/**
	* Generated classes can be optimized for speed or code size.
	*
	* @generated from enum google.protobuf.FileOptions.OptimizeMode
	*/
	var FileOptions_OptimizeMode;
	(function(FileOptions_OptimizeMode$1) {
		/**
		* Generate complete code for parsing, serialization,
		*
		* @generated from enum value: SPEED = 1;
		*/
		FileOptions_OptimizeMode$1[FileOptions_OptimizeMode$1["SPEED"] = 1] = "SPEED";
		/**
		* etc.
		*
		* Use ReflectionOps to implement these methods.
		*
		* @generated from enum value: CODE_SIZE = 2;
		*/
		FileOptions_OptimizeMode$1[FileOptions_OptimizeMode$1["CODE_SIZE"] = 2] = "CODE_SIZE";
		/**
		* Generate code using MessageLite and the lite runtime.
		*
		* @generated from enum value: LITE_RUNTIME = 3;
		*/
		FileOptions_OptimizeMode$1[FileOptions_OptimizeMode$1["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
	})(FileOptions_OptimizeMode || (exports.FileOptions_OptimizeMode = FileOptions_OptimizeMode = {}));
	/**
	* Describes the enum google.protobuf.FileOptions.OptimizeMode.
	*/
	exports.FileOptions_OptimizeModeSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 10, 0);
	/**
	* Describes the message google.protobuf.MessageOptions.
	* Use `create(MessageOptionsSchema)` to create a new message.
	*/
	exports.MessageOptionsSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 11);
	/**
	* Describes the message google.protobuf.FieldOptions.
	* Use `create(FieldOptionsSchema)` to create a new message.
	*/
	exports.FieldOptionsSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 12);
	/**
	* Describes the message google.protobuf.FieldOptions.EditionDefault.
	* Use `create(FieldOptions_EditionDefaultSchema)` to create a new message.
	*/
	exports.FieldOptions_EditionDefaultSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 12, 0);
	/**
	* Describes the message google.protobuf.FieldOptions.FeatureSupport.
	* Use `create(FieldOptions_FeatureSupportSchema)` to create a new message.
	*/
	exports.FieldOptions_FeatureSupportSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 12, 1);
	/**
	* @generated from enum google.protobuf.FieldOptions.CType
	*/
	var FieldOptions_CType;
	(function(FieldOptions_CType$1) {
		/**
		* Default mode.
		*
		* @generated from enum value: STRING = 0;
		*/
		FieldOptions_CType$1[FieldOptions_CType$1["STRING"] = 0] = "STRING";
		/**
		* The option [ctype=CORD] may be applied to a non-repeated field of type
		* "bytes". It indicates that in C++, the data should be stored in a Cord
		* instead of a string.  For very large strings, this may reduce memory
		* fragmentation. It may also allow better performance when parsing from a
		* Cord, or when parsing with aliasing enabled, as the parsed Cord may then
		* alias the original buffer.
		*
		* @generated from enum value: CORD = 1;
		*/
		FieldOptions_CType$1[FieldOptions_CType$1["CORD"] = 1] = "CORD";
		/**
		* @generated from enum value: STRING_PIECE = 2;
		*/
		FieldOptions_CType$1[FieldOptions_CType$1["STRING_PIECE"] = 2] = "STRING_PIECE";
	})(FieldOptions_CType || (exports.FieldOptions_CType = FieldOptions_CType = {}));
	/**
	* Describes the enum google.protobuf.FieldOptions.CType.
	*/
	exports.FieldOptions_CTypeSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 12, 0);
	/**
	* @generated from enum google.protobuf.FieldOptions.JSType
	*/
	var FieldOptions_JSType;
	(function(FieldOptions_JSType$1) {
		/**
		* Use the default type.
		*
		* @generated from enum value: JS_NORMAL = 0;
		*/
		FieldOptions_JSType$1[FieldOptions_JSType$1["JS_NORMAL"] = 0] = "JS_NORMAL";
		/**
		* Use JavaScript strings.
		*
		* @generated from enum value: JS_STRING = 1;
		*/
		FieldOptions_JSType$1[FieldOptions_JSType$1["JS_STRING"] = 1] = "JS_STRING";
		/**
		* Use JavaScript numbers.
		*
		* @generated from enum value: JS_NUMBER = 2;
		*/
		FieldOptions_JSType$1[FieldOptions_JSType$1["JS_NUMBER"] = 2] = "JS_NUMBER";
	})(FieldOptions_JSType || (exports.FieldOptions_JSType = FieldOptions_JSType = {}));
	/**
	* Describes the enum google.protobuf.FieldOptions.JSType.
	*/
	exports.FieldOptions_JSTypeSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 12, 1);
	/**
	* If set to RETENTION_SOURCE, the option will be omitted from the binary.
	*
	* @generated from enum google.protobuf.FieldOptions.OptionRetention
	*/
	var FieldOptions_OptionRetention;
	(function(FieldOptions_OptionRetention$1) {
		/**
		* @generated from enum value: RETENTION_UNKNOWN = 0;
		*/
		FieldOptions_OptionRetention$1[FieldOptions_OptionRetention$1["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
		/**
		* @generated from enum value: RETENTION_RUNTIME = 1;
		*/
		FieldOptions_OptionRetention$1[FieldOptions_OptionRetention$1["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
		/**
		* @generated from enum value: RETENTION_SOURCE = 2;
		*/
		FieldOptions_OptionRetention$1[FieldOptions_OptionRetention$1["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
	})(FieldOptions_OptionRetention || (exports.FieldOptions_OptionRetention = FieldOptions_OptionRetention = {}));
	/**
	* Describes the enum google.protobuf.FieldOptions.OptionRetention.
	*/
	exports.FieldOptions_OptionRetentionSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 12, 2);
	/**
	* This indicates the types of entities that the field may apply to when used
	* as an option. If it is unset, then the field may be freely used as an
	* option on any kind of entity.
	*
	* @generated from enum google.protobuf.FieldOptions.OptionTargetType
	*/
	var FieldOptions_OptionTargetType;
	(function(FieldOptions_OptionTargetType$1) {
		/**
		* @generated from enum value: TARGET_TYPE_UNKNOWN = 0;
		*/
		FieldOptions_OptionTargetType$1[FieldOptions_OptionTargetType$1["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
		/**
		* @generated from enum value: TARGET_TYPE_FILE = 1;
		*/
		FieldOptions_OptionTargetType$1[FieldOptions_OptionTargetType$1["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
		/**
		* @generated from enum value: TARGET_TYPE_EXTENSION_RANGE = 2;
		*/
		FieldOptions_OptionTargetType$1[FieldOptions_OptionTargetType$1["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
		/**
		* @generated from enum value: TARGET_TYPE_MESSAGE = 3;
		*/
		FieldOptions_OptionTargetType$1[FieldOptions_OptionTargetType$1["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
		/**
		* @generated from enum value: TARGET_TYPE_FIELD = 4;
		*/
		FieldOptions_OptionTargetType$1[FieldOptions_OptionTargetType$1["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
		/**
		* @generated from enum value: TARGET_TYPE_ONEOF = 5;
		*/
		FieldOptions_OptionTargetType$1[FieldOptions_OptionTargetType$1["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
		/**
		* @generated from enum value: TARGET_TYPE_ENUM = 6;
		*/
		FieldOptions_OptionTargetType$1[FieldOptions_OptionTargetType$1["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
		/**
		* @generated from enum value: TARGET_TYPE_ENUM_ENTRY = 7;
		*/
		FieldOptions_OptionTargetType$1[FieldOptions_OptionTargetType$1["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
		/**
		* @generated from enum value: TARGET_TYPE_SERVICE = 8;
		*/
		FieldOptions_OptionTargetType$1[FieldOptions_OptionTargetType$1["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
		/**
		* @generated from enum value: TARGET_TYPE_METHOD = 9;
		*/
		FieldOptions_OptionTargetType$1[FieldOptions_OptionTargetType$1["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
	})(FieldOptions_OptionTargetType || (exports.FieldOptions_OptionTargetType = FieldOptions_OptionTargetType = {}));
	/**
	* Describes the enum google.protobuf.FieldOptions.OptionTargetType.
	*/
	exports.FieldOptions_OptionTargetTypeSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 12, 3);
	/**
	* Describes the message google.protobuf.OneofOptions.
	* Use `create(OneofOptionsSchema)` to create a new message.
	*/
	exports.OneofOptionsSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 13);
	/**
	* Describes the message google.protobuf.EnumOptions.
	* Use `create(EnumOptionsSchema)` to create a new message.
	*/
	exports.EnumOptionsSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 14);
	/**
	* Describes the message google.protobuf.EnumValueOptions.
	* Use `create(EnumValueOptionsSchema)` to create a new message.
	*/
	exports.EnumValueOptionsSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 15);
	/**
	* Describes the message google.protobuf.ServiceOptions.
	* Use `create(ServiceOptionsSchema)` to create a new message.
	*/
	exports.ServiceOptionsSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 16);
	/**
	* Describes the message google.protobuf.MethodOptions.
	* Use `create(MethodOptionsSchema)` to create a new message.
	*/
	exports.MethodOptionsSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 17);
	/**
	* Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
	* or neither? HTTP based RPC implementation may choose GET verb for safe
	* methods, and PUT verb for idempotent methods instead of the default POST.
	*
	* @generated from enum google.protobuf.MethodOptions.IdempotencyLevel
	*/
	var MethodOptions_IdempotencyLevel;
	(function(MethodOptions_IdempotencyLevel$1) {
		/**
		* @generated from enum value: IDEMPOTENCY_UNKNOWN = 0;
		*/
		MethodOptions_IdempotencyLevel$1[MethodOptions_IdempotencyLevel$1["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
		/**
		* implies idempotent
		*
		* @generated from enum value: NO_SIDE_EFFECTS = 1;
		*/
		MethodOptions_IdempotencyLevel$1[MethodOptions_IdempotencyLevel$1["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
		/**
		* idempotent, but may have side effects
		*
		* @generated from enum value: IDEMPOTENT = 2;
		*/
		MethodOptions_IdempotencyLevel$1[MethodOptions_IdempotencyLevel$1["IDEMPOTENT"] = 2] = "IDEMPOTENT";
	})(MethodOptions_IdempotencyLevel || (exports.MethodOptions_IdempotencyLevel = MethodOptions_IdempotencyLevel = {}));
	/**
	* Describes the enum google.protobuf.MethodOptions.IdempotencyLevel.
	*/
	exports.MethodOptions_IdempotencyLevelSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 17, 0);
	/**
	* Describes the message google.protobuf.UninterpretedOption.
	* Use `create(UninterpretedOptionSchema)` to create a new message.
	*/
	exports.UninterpretedOptionSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 18);
	/**
	* Describes the message google.protobuf.UninterpretedOption.NamePart.
	* Use `create(UninterpretedOption_NamePartSchema)` to create a new message.
	*/
	exports.UninterpretedOption_NamePartSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 18, 0);
	/**
	* Describes the message google.protobuf.FeatureSet.
	* Use `create(FeatureSetSchema)` to create a new message.
	*/
	exports.FeatureSetSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 19);
	/**
	* Describes the message google.protobuf.FeatureSet.VisibilityFeature.
	* Use `create(FeatureSet_VisibilityFeatureSchema)` to create a new message.
	*/
	exports.FeatureSet_VisibilityFeatureSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 19, 0);
	/**
	* @generated from enum google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility
	*/
	var FeatureSet_VisibilityFeature_DefaultSymbolVisibility;
	(function(FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1) {
		/**
		* @generated from enum value: DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0;
		*/
		FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1[FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1["DEFAULT_SYMBOL_VISIBILITY_UNKNOWN"] = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN";
		/**
		* Default pre-EDITION_2024, all UNSET visibility are export.
		*
		* @generated from enum value: EXPORT_ALL = 1;
		*/
		FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1[FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1["EXPORT_ALL"] = 1] = "EXPORT_ALL";
		/**
		* All top-level symbols default to export, nested default to local.
		*
		* @generated from enum value: EXPORT_TOP_LEVEL = 2;
		*/
		FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1[FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1["EXPORT_TOP_LEVEL"] = 2] = "EXPORT_TOP_LEVEL";
		/**
		* All symbols default to local.
		*
		* @generated from enum value: LOCAL_ALL = 3;
		*/
		FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1[FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1["LOCAL_ALL"] = 3] = "LOCAL_ALL";
		/**
		* All symbols local by default. Nested types cannot be exported.
		* With special case caveat for message { enum {} reserved 1 to max; }
		* This is the recommended setting for new protos.
		*
		* @generated from enum value: STRICT = 4;
		*/
		FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1[FeatureSet_VisibilityFeature_DefaultSymbolVisibility$1["STRICT"] = 4] = "STRICT";
	})(FeatureSet_VisibilityFeature_DefaultSymbolVisibility || (exports.FeatureSet_VisibilityFeature_DefaultSymbolVisibility = FeatureSet_VisibilityFeature_DefaultSymbolVisibility = {}));
	/**
	* Describes the enum google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility.
	*/
	exports.FeatureSet_VisibilityFeature_DefaultSymbolVisibilitySchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 19, 0, 0);
	/**
	* @generated from enum google.protobuf.FeatureSet.FieldPresence
	*/
	var FeatureSet_FieldPresence;
	(function(FeatureSet_FieldPresence$1) {
		/**
		* @generated from enum value: FIELD_PRESENCE_UNKNOWN = 0;
		*/
		FeatureSet_FieldPresence$1[FeatureSet_FieldPresence$1["FIELD_PRESENCE_UNKNOWN"] = 0] = "FIELD_PRESENCE_UNKNOWN";
		/**
		* @generated from enum value: EXPLICIT = 1;
		*/
		FeatureSet_FieldPresence$1[FeatureSet_FieldPresence$1["EXPLICIT"] = 1] = "EXPLICIT";
		/**
		* @generated from enum value: IMPLICIT = 2;
		*/
		FeatureSet_FieldPresence$1[FeatureSet_FieldPresence$1["IMPLICIT"] = 2] = "IMPLICIT";
		/**
		* @generated from enum value: LEGACY_REQUIRED = 3;
		*/
		FeatureSet_FieldPresence$1[FeatureSet_FieldPresence$1["LEGACY_REQUIRED"] = 3] = "LEGACY_REQUIRED";
	})(FeatureSet_FieldPresence || (exports.FeatureSet_FieldPresence = FeatureSet_FieldPresence = {}));
	/**
	* Describes the enum google.protobuf.FeatureSet.FieldPresence.
	*/
	exports.FeatureSet_FieldPresenceSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 19, 0);
	/**
	* @generated from enum google.protobuf.FeatureSet.EnumType
	*/
	var FeatureSet_EnumType;
	(function(FeatureSet_EnumType$1) {
		/**
		* @generated from enum value: ENUM_TYPE_UNKNOWN = 0;
		*/
		FeatureSet_EnumType$1[FeatureSet_EnumType$1["ENUM_TYPE_UNKNOWN"] = 0] = "ENUM_TYPE_UNKNOWN";
		/**
		* @generated from enum value: OPEN = 1;
		*/
		FeatureSet_EnumType$1[FeatureSet_EnumType$1["OPEN"] = 1] = "OPEN";
		/**
		* @generated from enum value: CLOSED = 2;
		*/
		FeatureSet_EnumType$1[FeatureSet_EnumType$1["CLOSED"] = 2] = "CLOSED";
	})(FeatureSet_EnumType || (exports.FeatureSet_EnumType = FeatureSet_EnumType = {}));
	/**
	* Describes the enum google.protobuf.FeatureSet.EnumType.
	*/
	exports.FeatureSet_EnumTypeSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 19, 1);
	/**
	* @generated from enum google.protobuf.FeatureSet.RepeatedFieldEncoding
	*/
	var FeatureSet_RepeatedFieldEncoding;
	(function(FeatureSet_RepeatedFieldEncoding$1) {
		/**
		* @generated from enum value: REPEATED_FIELD_ENCODING_UNKNOWN = 0;
		*/
		FeatureSet_RepeatedFieldEncoding$1[FeatureSet_RepeatedFieldEncoding$1["REPEATED_FIELD_ENCODING_UNKNOWN"] = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN";
		/**
		* @generated from enum value: PACKED = 1;
		*/
		FeatureSet_RepeatedFieldEncoding$1[FeatureSet_RepeatedFieldEncoding$1["PACKED"] = 1] = "PACKED";
		/**
		* @generated from enum value: EXPANDED = 2;
		*/
		FeatureSet_RepeatedFieldEncoding$1[FeatureSet_RepeatedFieldEncoding$1["EXPANDED"] = 2] = "EXPANDED";
	})(FeatureSet_RepeatedFieldEncoding || (exports.FeatureSet_RepeatedFieldEncoding = FeatureSet_RepeatedFieldEncoding = {}));
	/**
	* Describes the enum google.protobuf.FeatureSet.RepeatedFieldEncoding.
	*/
	exports.FeatureSet_RepeatedFieldEncodingSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 19, 2);
	/**
	* @generated from enum google.protobuf.FeatureSet.Utf8Validation
	*/
	var FeatureSet_Utf8Validation;
	(function(FeatureSet_Utf8Validation$1) {
		/**
		* @generated from enum value: UTF8_VALIDATION_UNKNOWN = 0;
		*/
		FeatureSet_Utf8Validation$1[FeatureSet_Utf8Validation$1["UTF8_VALIDATION_UNKNOWN"] = 0] = "UTF8_VALIDATION_UNKNOWN";
		/**
		* @generated from enum value: VERIFY = 2;
		*/
		FeatureSet_Utf8Validation$1[FeatureSet_Utf8Validation$1["VERIFY"] = 2] = "VERIFY";
		/**
		* @generated from enum value: NONE = 3;
		*/
		FeatureSet_Utf8Validation$1[FeatureSet_Utf8Validation$1["NONE"] = 3] = "NONE";
	})(FeatureSet_Utf8Validation || (exports.FeatureSet_Utf8Validation = FeatureSet_Utf8Validation = {}));
	/**
	* Describes the enum google.protobuf.FeatureSet.Utf8Validation.
	*/
	exports.FeatureSet_Utf8ValidationSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 19, 3);
	/**
	* @generated from enum google.protobuf.FeatureSet.MessageEncoding
	*/
	var FeatureSet_MessageEncoding;
	(function(FeatureSet_MessageEncoding$1) {
		/**
		* @generated from enum value: MESSAGE_ENCODING_UNKNOWN = 0;
		*/
		FeatureSet_MessageEncoding$1[FeatureSet_MessageEncoding$1["MESSAGE_ENCODING_UNKNOWN"] = 0] = "MESSAGE_ENCODING_UNKNOWN";
		/**
		* @generated from enum value: LENGTH_PREFIXED = 1;
		*/
		FeatureSet_MessageEncoding$1[FeatureSet_MessageEncoding$1["LENGTH_PREFIXED"] = 1] = "LENGTH_PREFIXED";
		/**
		* @generated from enum value: DELIMITED = 2;
		*/
		FeatureSet_MessageEncoding$1[FeatureSet_MessageEncoding$1["DELIMITED"] = 2] = "DELIMITED";
	})(FeatureSet_MessageEncoding || (exports.FeatureSet_MessageEncoding = FeatureSet_MessageEncoding = {}));
	/**
	* Describes the enum google.protobuf.FeatureSet.MessageEncoding.
	*/
	exports.FeatureSet_MessageEncodingSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 19, 4);
	/**
	* @generated from enum google.protobuf.FeatureSet.JsonFormat
	*/
	var FeatureSet_JsonFormat;
	(function(FeatureSet_JsonFormat$1) {
		/**
		* @generated from enum value: JSON_FORMAT_UNKNOWN = 0;
		*/
		FeatureSet_JsonFormat$1[FeatureSet_JsonFormat$1["JSON_FORMAT_UNKNOWN"] = 0] = "JSON_FORMAT_UNKNOWN";
		/**
		* @generated from enum value: ALLOW = 1;
		*/
		FeatureSet_JsonFormat$1[FeatureSet_JsonFormat$1["ALLOW"] = 1] = "ALLOW";
		/**
		* @generated from enum value: LEGACY_BEST_EFFORT = 2;
		*/
		FeatureSet_JsonFormat$1[FeatureSet_JsonFormat$1["LEGACY_BEST_EFFORT"] = 2] = "LEGACY_BEST_EFFORT";
	})(FeatureSet_JsonFormat || (exports.FeatureSet_JsonFormat = FeatureSet_JsonFormat = {}));
	/**
	* Describes the enum google.protobuf.FeatureSet.JsonFormat.
	*/
	exports.FeatureSet_JsonFormatSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 19, 5);
	/**
	* @generated from enum google.protobuf.FeatureSet.EnforceNamingStyle
	*/
	var FeatureSet_EnforceNamingStyle;
	(function(FeatureSet_EnforceNamingStyle$1) {
		/**
		* @generated from enum value: ENFORCE_NAMING_STYLE_UNKNOWN = 0;
		*/
		FeatureSet_EnforceNamingStyle$1[FeatureSet_EnforceNamingStyle$1["ENFORCE_NAMING_STYLE_UNKNOWN"] = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN";
		/**
		* @generated from enum value: STYLE2024 = 1;
		*/
		FeatureSet_EnforceNamingStyle$1[FeatureSet_EnforceNamingStyle$1["STYLE2024"] = 1] = "STYLE2024";
		/**
		* @generated from enum value: STYLE_LEGACY = 2;
		*/
		FeatureSet_EnforceNamingStyle$1[FeatureSet_EnforceNamingStyle$1["STYLE_LEGACY"] = 2] = "STYLE_LEGACY";
	})(FeatureSet_EnforceNamingStyle || (exports.FeatureSet_EnforceNamingStyle = FeatureSet_EnforceNamingStyle = {}));
	/**
	* Describes the enum google.protobuf.FeatureSet.EnforceNamingStyle.
	*/
	exports.FeatureSet_EnforceNamingStyleSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 19, 6);
	/**
	* Describes the message google.protobuf.FeatureSetDefaults.
	* Use `create(FeatureSetDefaultsSchema)` to create a new message.
	*/
	exports.FeatureSetDefaultsSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 20);
	/**
	* Describes the message google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.
	* Use `create(FeatureSetDefaults_FeatureSetEditionDefaultSchema)` to create a new message.
	*/
	exports.FeatureSetDefaults_FeatureSetEditionDefaultSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 20, 0);
	/**
	* Describes the message google.protobuf.SourceCodeInfo.
	* Use `create(SourceCodeInfoSchema)` to create a new message.
	*/
	exports.SourceCodeInfoSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 21);
	/**
	* Describes the message google.protobuf.SourceCodeInfo.Location.
	* Use `create(SourceCodeInfo_LocationSchema)` to create a new message.
	*/
	exports.SourceCodeInfo_LocationSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 21, 0);
	/**
	* Describes the message google.protobuf.GeneratedCodeInfo.
	* Use `create(GeneratedCodeInfoSchema)` to create a new message.
	*/
	exports.GeneratedCodeInfoSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 22);
	/**
	* Describes the message google.protobuf.GeneratedCodeInfo.Annotation.
	* Use `create(GeneratedCodeInfo_AnnotationSchema)` to create a new message.
	*/
	exports.GeneratedCodeInfo_AnnotationSchema = (0, message_js_1$14.messageDesc)(exports.file_google_protobuf_descriptor, 22, 0);
	/**
	* Represents the identified object's effect on the element in the original
	* .proto file.
	*
	* @generated from enum google.protobuf.GeneratedCodeInfo.Annotation.Semantic
	*/
	var GeneratedCodeInfo_Annotation_Semantic;
	(function(GeneratedCodeInfo_Annotation_Semantic$1) {
		/**
		* There is no effect or the effect is indescribable.
		*
		* @generated from enum value: NONE = 0;
		*/
		GeneratedCodeInfo_Annotation_Semantic$1[GeneratedCodeInfo_Annotation_Semantic$1["NONE"] = 0] = "NONE";
		/**
		* The element is set or otherwise mutated.
		*
		* @generated from enum value: SET = 1;
		*/
		GeneratedCodeInfo_Annotation_Semantic$1[GeneratedCodeInfo_Annotation_Semantic$1["SET"] = 1] = "SET";
		/**
		* An alias to the element is returned.
		*
		* @generated from enum value: ALIAS = 2;
		*/
		GeneratedCodeInfo_Annotation_Semantic$1[GeneratedCodeInfo_Annotation_Semantic$1["ALIAS"] = 2] = "ALIAS";
	})(GeneratedCodeInfo_Annotation_Semantic || (exports.GeneratedCodeInfo_Annotation_Semantic = GeneratedCodeInfo_Annotation_Semantic = {}));
	/**
	* Describes the enum google.protobuf.GeneratedCodeInfo.Annotation.Semantic.
	*/
	exports.GeneratedCodeInfo_Annotation_SemanticSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 22, 0, 0);
	/**
	* The full set of known editions.
	*
	* @generated from enum google.protobuf.Edition
	*/
	var Edition;
	(function(Edition$1) {
		/**
		* A placeholder for an unknown edition value.
		*
		* @generated from enum value: EDITION_UNKNOWN = 0;
		*/
		Edition$1[Edition$1["EDITION_UNKNOWN"] = 0] = "EDITION_UNKNOWN";
		/**
		* A placeholder edition for specifying default behaviors *before* a feature
		* was first introduced.  This is effectively an "infinite past".
		*
		* @generated from enum value: EDITION_LEGACY = 900;
		*/
		Edition$1[Edition$1["EDITION_LEGACY"] = 900] = "EDITION_LEGACY";
		/**
		* Legacy syntax "editions".  These pre-date editions, but behave much like
		* distinct editions.  These can't be used to specify the edition of proto
		* files, but feature definitions must supply proto2/proto3 defaults for
		* backwards compatibility.
		*
		* @generated from enum value: EDITION_PROTO2 = 998;
		*/
		Edition$1[Edition$1["EDITION_PROTO2"] = 998] = "EDITION_PROTO2";
		/**
		* @generated from enum value: EDITION_PROTO3 = 999;
		*/
		Edition$1[Edition$1["EDITION_PROTO3"] = 999] = "EDITION_PROTO3";
		/**
		* Editions that have been released.  The specific values are arbitrary and
		* should not be depended on, but they will always be time-ordered for easy
		* comparison.
		*
		* @generated from enum value: EDITION_2023 = 1000;
		*/
		Edition$1[Edition$1["EDITION_2023"] = 1e3] = "EDITION_2023";
		/**
		* @generated from enum value: EDITION_2024 = 1001;
		*/
		Edition$1[Edition$1["EDITION_2024"] = 1001] = "EDITION_2024";
		/**
		* Placeholder editions for testing feature resolution.  These should not be
		* used or relied on outside of tests.
		*
		* @generated from enum value: EDITION_1_TEST_ONLY = 1;
		*/
		Edition$1[Edition$1["EDITION_1_TEST_ONLY"] = 1] = "EDITION_1_TEST_ONLY";
		/**
		* @generated from enum value: EDITION_2_TEST_ONLY = 2;
		*/
		Edition$1[Edition$1["EDITION_2_TEST_ONLY"] = 2] = "EDITION_2_TEST_ONLY";
		/**
		* @generated from enum value: EDITION_99997_TEST_ONLY = 99997;
		*/
		Edition$1[Edition$1["EDITION_99997_TEST_ONLY"] = 99997] = "EDITION_99997_TEST_ONLY";
		/**
		* @generated from enum value: EDITION_99998_TEST_ONLY = 99998;
		*/
		Edition$1[Edition$1["EDITION_99998_TEST_ONLY"] = 99998] = "EDITION_99998_TEST_ONLY";
		/**
		* @generated from enum value: EDITION_99999_TEST_ONLY = 99999;
		*/
		Edition$1[Edition$1["EDITION_99999_TEST_ONLY"] = 99999] = "EDITION_99999_TEST_ONLY";
		/**
		* Placeholder for specifying unbounded edition support.  This should only
		* ever be used by plugins that can expect to never require any changes to
		* support a new edition.
		*
		* @generated from enum value: EDITION_MAX = 2147483647;
		*/
		Edition$1[Edition$1["EDITION_MAX"] = 2147483647] = "EDITION_MAX";
	})(Edition || (exports.Edition = Edition = {}));
	/**
	* Describes the enum google.protobuf.Edition.
	*/
	exports.EditionSchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 0);
	/**
	* Describes the 'visibility' of a symbol with respect to the proto import
	* system. Symbols can only be imported when the visibility rules do not prevent
	* it (ex: local symbols cannot be imported).  Visibility modifiers can only set
	* on `message` and `enum` as they are the only types available to be referenced
	* from other files.
	*
	* @generated from enum google.protobuf.SymbolVisibility
	*/
	var SymbolVisibility;
	(function(SymbolVisibility$1) {
		/**
		* @generated from enum value: VISIBILITY_UNSET = 0;
		*/
		SymbolVisibility$1[SymbolVisibility$1["VISIBILITY_UNSET"] = 0] = "VISIBILITY_UNSET";
		/**
		* @generated from enum value: VISIBILITY_LOCAL = 1;
		*/
		SymbolVisibility$1[SymbolVisibility$1["VISIBILITY_LOCAL"] = 1] = "VISIBILITY_LOCAL";
		/**
		* @generated from enum value: VISIBILITY_EXPORT = 2;
		*/
		SymbolVisibility$1[SymbolVisibility$1["VISIBILITY_EXPORT"] = 2] = "VISIBILITY_EXPORT";
	})(SymbolVisibility || (exports.SymbolVisibility = SymbolVisibility = {}));
	/**
	* Describes the enum google.protobuf.SymbolVisibility.
	*/
	exports.SymbolVisibilitySchema = (0, enum_js_1$6.enumDesc)(exports.file_google_protobuf_descriptor, 1);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/embed.js
var require_embed = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/embed.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.embedFileDesc = embedFileDesc;
	exports.pathInFileDesc = pathInFileDesc;
	exports.createFileDescriptorProtoBoot = createFileDescriptorProtoBoot;
	var names_js_1$1 = require_names();
	var fields_js_1 = require_fields();
	var base64_encoding_js_1$2 = require_base64_encoding();
	var to_binary_js_1$4 = require_to_binary();
	var clone_js_1 = require_clone();
	var descriptor_pb_js_1$5 = require_descriptor_pb();
	/**
	* Create necessary information to embed a file descriptor in
	* generated code.
	*
	* @private
	*/
	function embedFileDesc(file) {
		const embed = {
			bootable: false,
			proto() {
				const stripped = (0, clone_js_1.clone)(descriptor_pb_js_1$5.FileDescriptorProtoSchema, file);
				(0, fields_js_1.clearField)(stripped, descriptor_pb_js_1$5.FileDescriptorProtoSchema.field.dependency);
				(0, fields_js_1.clearField)(stripped, descriptor_pb_js_1$5.FileDescriptorProtoSchema.field.sourceCodeInfo);
				stripped.messageType.map(stripJsonNames);
				return stripped;
			},
			base64() {
				const bytes = (0, to_binary_js_1$4.toBinary)(descriptor_pb_js_1$5.FileDescriptorProtoSchema, this.proto());
				return (0, base64_encoding_js_1$2.base64Encode)(bytes, "std_raw");
			}
		};
		return file.name == "google/protobuf/descriptor.proto" ? Object.assign(Object.assign({}, embed), {
			bootable: true,
			boot() {
				return createFileDescriptorProtoBoot(this.proto());
			}
		}) : embed;
	}
	function stripJsonNames(d$1) {
		for (const f of d$1.field) if (f.jsonName === (0, names_js_1$1.protoCamelCase)(f.name)) (0, fields_js_1.clearField)(f, descriptor_pb_js_1$5.FieldDescriptorProtoSchema.field.jsonName);
		for (const n$2 of d$1.nestedType) stripJsonNames(n$2);
	}
	/**
	* Compute the path to a message, enumeration, extension, or service in a
	* file descriptor.
	*
	* @private
	*/
	function pathInFileDesc(desc) {
		if (desc.kind == "service") return [desc.file.services.indexOf(desc)];
		const parent$1 = desc.parent;
		if (parent$1 == void 0) switch (desc.kind) {
			case "enum": return [desc.file.enums.indexOf(desc)];
			case "message": return [desc.file.messages.indexOf(desc)];
			case "extension": return [desc.file.extensions.indexOf(desc)];
		}
		function findPath(cur) {
			const nested = [];
			for (let parent$2 = cur.parent; parent$2;) {
				const idx = parent$2.nestedMessages.indexOf(cur);
				nested.unshift(idx);
				cur = parent$2;
				parent$2 = cur.parent;
			}
			nested.unshift(cur.file.messages.indexOf(cur));
			return nested;
		}
		const path$2 = findPath(parent$1);
		switch (desc.kind) {
			case "extension": return [...path$2, parent$1.nestedExtensions.indexOf(desc)];
			case "message": return [...path$2, parent$1.nestedMessages.indexOf(desc)];
			case "enum": return [...path$2, parent$1.nestedEnums.indexOf(desc)];
		}
	}
	/**
	* The file descriptor for google/protobuf/descriptor.proto cannot be embedded
	* in serialized form, since it is required to parse itself.
	*
	* This function takes an instance of the message, and returns a plain object
	* that can be hydrated to the message again via bootFileDescriptorProto().
	*
	* This function only works with a message google.protobuf.FileDescriptorProto
	* for google/protobuf/descriptor.proto, and only supports features that are
	* relevant for the specific use case. For example, it discards file options,
	* reserved ranges and reserved names, and field options that are unused in
	* descriptor.proto.
	*
	* @private
	*/
	function createFileDescriptorProtoBoot(proto$6) {
		var _a;
		assert(proto$6.name == "google/protobuf/descriptor.proto");
		assert(proto$6.package == "google.protobuf");
		assert(!proto$6.dependency.length);
		assert(!proto$6.publicDependency.length);
		assert(!proto$6.weakDependency.length);
		assert(!proto$6.optionDependency.length);
		assert(!proto$6.service.length);
		assert(!proto$6.extension.length);
		assert(proto$6.sourceCodeInfo === void 0);
		assert(proto$6.syntax == "" || proto$6.syntax == "proto2");
		assert(!((_a = proto$6.options) === null || _a === void 0 ? void 0 : _a.features));
		assert(proto$6.edition === descriptor_pb_js_1$5.Edition.EDITION_UNKNOWN);
		return {
			name: proto$6.name,
			package: proto$6.package,
			messageType: proto$6.messageType.map(createDescriptorBoot),
			enumType: proto$6.enumType.map(createEnumDescriptorBoot)
		};
	}
	function createDescriptorBoot(proto$6) {
		assert(proto$6.extension.length == 0);
		assert(!proto$6.oneofDecl.length);
		assert(!proto$6.options);
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.DescriptorProtoSchema.field.visibility));
		const b$2 = { name: proto$6.name };
		if (proto$6.field.length) b$2.field = proto$6.field.map(createFieldDescriptorBoot);
		if (proto$6.nestedType.length) b$2.nestedType = proto$6.nestedType.map(createDescriptorBoot);
		if (proto$6.enumType.length) b$2.enumType = proto$6.enumType.map(createEnumDescriptorBoot);
		if (proto$6.extensionRange.length) b$2.extensionRange = proto$6.extensionRange.map((r) => {
			assert(!r.options);
			return {
				start: r.start,
				end: r.end
			};
		});
		return b$2;
	}
	function createFieldDescriptorBoot(proto$6) {
		assert((0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldDescriptorProtoSchema.field.name));
		assert((0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldDescriptorProtoSchema.field.number));
		assert((0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldDescriptorProtoSchema.field.type));
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldDescriptorProtoSchema.field.oneofIndex));
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldDescriptorProtoSchema.field.jsonName) || proto$6.jsonName === (0, names_js_1$1.protoCamelCase)(proto$6.name));
		const b$2 = {
			name: proto$6.name,
			number: proto$6.number,
			type: proto$6.type
		};
		if ((0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldDescriptorProtoSchema.field.label)) b$2.label = proto$6.label;
		if ((0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldDescriptorProtoSchema.field.typeName)) b$2.typeName = proto$6.typeName;
		if ((0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldDescriptorProtoSchema.field.extendee)) b$2.extendee = proto$6.extendee;
		if ((0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldDescriptorProtoSchema.field.defaultValue)) b$2.defaultValue = proto$6.defaultValue;
		if (proto$6.options) b$2.options = createFieldOptionsBoot(proto$6.options);
		return b$2;
	}
	function createFieldOptionsBoot(proto$6) {
		const b$2 = {};
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.ctype));
		if ((0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.packed)) b$2.packed = proto$6.packed;
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.jstype));
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.lazy));
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.unverifiedLazy));
		if ((0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.deprecated)) b$2.deprecated = proto$6.deprecated;
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.weak));
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.debugRedact));
		if ((0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.retention)) b$2.retention = proto$6.retention;
		if (proto$6.targets.length) b$2.targets = proto$6.targets;
		if (proto$6.editionDefaults.length) b$2.editionDefaults = proto$6.editionDefaults.map((d$1) => ({
			value: d$1.value,
			edition: d$1.edition
		}));
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.features));
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.FieldOptionsSchema.field.uninterpretedOption));
		return b$2;
	}
	function createEnumDescriptorBoot(proto$6) {
		assert(!proto$6.options);
		assert(!(0, fields_js_1.isFieldSet)(proto$6, descriptor_pb_js_1$5.EnumDescriptorProtoSchema.field.visibility));
		return {
			name: proto$6.name,
			value: proto$6.value.map((v) => {
				assert(!v.options);
				return {
					name: v.name,
					number: v.number
				};
			})
		};
	}
	/**
	* Assert that condition is truthy or throw error.
	*/
	function assert(condition) {
		if (!condition) throw new Error();
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/extension.js
var require_extension = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/extension.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extDesc = extDesc;
	/**
	* Hydrate an extension descriptor.
	*
	* @private
	*/
	function extDesc(file, path$2, ...paths) {
		if (paths.length == 0) return file.extensions[path$2];
		const e = paths.pop();
		return paths.reduce((acc, cur) => acc.nestedMessages[cur], file.messages[path$2]).nestedExtensions[e];
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/from-binary.js
var require_from_binary = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/from-binary.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fromBinary = fromBinary;
	exports.mergeFromBinary = mergeFromBinary;
	exports.readField = readField$1;
	var descriptors_js_1$4 = require_descriptors();
	var scalar_js_1$3 = require_scalar$1();
	var reflect_js_1$5 = require_reflect();
	var binary_encoding_js_1$2 = require_binary_encoding();
	var varint_js_1 = require_varint$1();
	var readDefaults = { readUnknownFields: true };
	function makeReadOptions$1(options) {
		return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
	}
	/**
	* Parse serialized binary data.
	*/
	function fromBinary(schema, bytes, options) {
		const msg = (0, reflect_js_1$5.reflect)(schema, void 0, false);
		readMessage$1(msg, new binary_encoding_js_1$2.BinaryReader(bytes), makeReadOptions$1(options), false, bytes.byteLength);
		return msg.message;
	}
	/**
	* Parse from binary data, merging fields.
	*
	* Repeated fields are appended. Map entries are added, overwriting
	* existing keys.
	*
	* If a message field is already present, it will be merged with the
	* new data.
	*/
	function mergeFromBinary(schema, target, bytes, options) {
		readMessage$1((0, reflect_js_1$5.reflect)(schema, target, false), new binary_encoding_js_1$2.BinaryReader(bytes), makeReadOptions$1(options), false, bytes.byteLength);
		return target;
	}
	/**
	* If `delimited` is false, read the length given in `lengthOrDelimitedFieldNo`.
	*
	* If `delimited` is true, read until an EndGroup tag. `lengthOrDelimitedFieldNo`
	* is the expected field number.
	*
	* @private
	*/
	function readMessage$1(message, reader, options, delimited, lengthOrDelimitedFieldNo) {
		var _a;
		const end = delimited ? reader.len : reader.pos + lengthOrDelimitedFieldNo;
		let fieldNo;
		let wireType;
		const unknownFields = (_a = message.getUnknown()) !== null && _a !== void 0 ? _a : [];
		while (reader.pos < end) {
			[fieldNo, wireType] = reader.tag();
			if (delimited && wireType == binary_encoding_js_1$2.WireType.EndGroup) break;
			const field = message.findNumber(fieldNo);
			if (!field) {
				const data = reader.skip(wireType, fieldNo);
				if (options.readUnknownFields) unknownFields.push({
					no: fieldNo,
					wireType,
					data
				});
				continue;
			}
			readField$1(message, reader, field, wireType, options);
		}
		if (delimited) {
			if (wireType != binary_encoding_js_1$2.WireType.EndGroup || fieldNo !== lengthOrDelimitedFieldNo) throw new Error("invalid end group tag");
		}
		if (unknownFields.length > 0) message.setUnknown(unknownFields);
	}
	/**
	* @private
	*/
	function readField$1(message, reader, field, wireType, options) {
		var _a;
		switch (field.fieldKind) {
			case "scalar":
				message.set(field, readScalar(reader, field.scalar));
				break;
			case "enum":
				const val = readScalar(reader, descriptors_js_1$4.ScalarType.INT32);
				if (field.enum.open) message.set(field, val);
				else if (field.enum.values.some((v) => v.number === val)) message.set(field, val);
				else if (options.readUnknownFields) {
					const bytes = [];
					(0, varint_js_1.varint32write)(val, bytes);
					const unknownFields = (_a = message.getUnknown()) !== null && _a !== void 0 ? _a : [];
					unknownFields.push({
						no: field.number,
						wireType,
						data: new Uint8Array(bytes)
					});
					message.setUnknown(unknownFields);
				}
				break;
			case "message":
				message.set(field, readMessageField$1(reader, options, field, message.get(field)));
				break;
			case "list":
				readListField$1(reader, wireType, message.get(field), options);
				break;
			case "map":
				readMapEntry(reader, message.get(field), options);
				break;
		}
	}
	function readMapEntry(reader, map$1, options) {
		const field = map$1.field();
		let key;
		let val;
		const len = reader.uint32();
		const end = reader.pos + len;
		while (reader.pos < end) {
			const [fieldNo] = reader.tag();
			switch (fieldNo) {
				case 1:
					key = readScalar(reader, field.mapKey);
					break;
				case 2:
					switch (field.mapKind) {
						case "scalar":
							val = readScalar(reader, field.scalar);
							break;
						case "enum":
							val = reader.int32();
							break;
						case "message":
							val = readMessageField$1(reader, options, field);
							break;
					}
					break;
			}
		}
		if (key === void 0) key = (0, scalar_js_1$3.scalarZeroValue)(field.mapKey, false);
		if (val === void 0) switch (field.mapKind) {
			case "scalar":
				val = (0, scalar_js_1$3.scalarZeroValue)(field.scalar, false);
				break;
			case "enum":
				val = field.enum.values[0].number;
				break;
			case "message":
				val = (0, reflect_js_1$5.reflect)(field.message, void 0, false);
				break;
		}
		map$1.set(key, val);
	}
	function readListField$1(reader, wireType, list, options) {
		var _a;
		const field = list.field();
		if (field.listKind === "message") {
			list.add(readMessageField$1(reader, options, field));
			return;
		}
		const scalarType = (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1$4.ScalarType.INT32;
		if (!(wireType == binary_encoding_js_1$2.WireType.LengthDelimited && scalarType != descriptors_js_1$4.ScalarType.STRING && scalarType != descriptors_js_1$4.ScalarType.BYTES)) {
			list.add(readScalar(reader, scalarType));
			return;
		}
		const e = reader.uint32() + reader.pos;
		while (reader.pos < e) list.add(readScalar(reader, scalarType));
	}
	function readMessageField$1(reader, options, field, mergeMessage) {
		const delimited = field.delimitedEncoding;
		const message = mergeMessage !== null && mergeMessage !== void 0 ? mergeMessage : (0, reflect_js_1$5.reflect)(field.message, void 0, false);
		readMessage$1(message, reader, options, delimited, delimited ? field.number : reader.uint32());
		return message;
	}
	function readScalar(reader, type$1) {
		switch (type$1) {
			case descriptors_js_1$4.ScalarType.STRING: return reader.string();
			case descriptors_js_1$4.ScalarType.BOOL: return reader.bool();
			case descriptors_js_1$4.ScalarType.DOUBLE: return reader.double();
			case descriptors_js_1$4.ScalarType.FLOAT: return reader.float();
			case descriptors_js_1$4.ScalarType.INT32: return reader.int32();
			case descriptors_js_1$4.ScalarType.INT64: return reader.int64();
			case descriptors_js_1$4.ScalarType.UINT64: return reader.uint64();
			case descriptors_js_1$4.ScalarType.FIXED64: return reader.fixed64();
			case descriptors_js_1$4.ScalarType.BYTES: return reader.bytes();
			case descriptors_js_1$4.ScalarType.FIXED32: return reader.fixed32();
			case descriptors_js_1$4.ScalarType.SFIXED32: return reader.sfixed32();
			case descriptors_js_1$4.ScalarType.SFIXED64: return reader.sfixed64();
			case descriptors_js_1$4.ScalarType.SINT64: return reader.sint64();
			case descriptors_js_1$4.ScalarType.UINT32: return reader.uint32();
			case descriptors_js_1$4.ScalarType.SINT32: return reader.sint32();
		}
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/file.js
var require_file = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/file.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fileDesc = fileDesc;
	var base64_encoding_js_1$1 = require_base64_encoding();
	var descriptor_pb_js_1$4 = require_descriptor_pb();
	var registry_js_1 = require_registry();
	var restore_json_names_js_1 = require_restore_json_names();
	var from_binary_js_1$4 = require_from_binary();
	/**
	* Hydrate a file descriptor.
	*
	* @private
	*/
	function fileDesc(b64, imports) {
		var _a;
		const root = (0, from_binary_js_1$4.fromBinary)(descriptor_pb_js_1$4.FileDescriptorProtoSchema, (0, base64_encoding_js_1$1.base64Decode)(b64));
		root.messageType.forEach(restore_json_names_js_1.restoreJsonNames);
		root.dependency = (_a = imports === null || imports === void 0 ? void 0 : imports.map((f) => f.proto.name)) !== null && _a !== void 0 ? _a : [];
		return (0, registry_js_1.createFileRegistry)(root, (protoFileName) => imports === null || imports === void 0 ? void 0 : imports.find((f) => f.proto.name === protoFileName)).getFile(root.name);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/service.js
var require_service = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/service.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.serviceDesc = serviceDesc;
	/**
	* Hydrate a service descriptor.
	*
	* @private
	*/
	function serviceDesc(file, path$2, ...paths) {
		if (paths.length > 0) throw new Error();
		return file.services[path$2];
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/symbols.js
var require_symbols = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/symbols.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.symbols = exports.wktPublicImportPaths = exports.packageName = void 0;
	/**
	* @private
	*/
	exports.packageName = "@bufbuild/protobuf";
	/**
	* @private
	*/
	exports.wktPublicImportPaths = {
		"google/protobuf/compiler/plugin.proto": exports.packageName + "/wkt",
		"google/protobuf/any.proto": exports.packageName + "/wkt",
		"google/protobuf/api.proto": exports.packageName + "/wkt",
		"google/protobuf/cpp_features.proto": exports.packageName + "/wkt",
		"google/protobuf/descriptor.proto": exports.packageName + "/wkt",
		"google/protobuf/duration.proto": exports.packageName + "/wkt",
		"google/protobuf/empty.proto": exports.packageName + "/wkt",
		"google/protobuf/field_mask.proto": exports.packageName + "/wkt",
		"google/protobuf/go_features.proto": exports.packageName + "/wkt",
		"google/protobuf/java_features.proto": exports.packageName + "/wkt",
		"google/protobuf/source_context.proto": exports.packageName + "/wkt",
		"google/protobuf/struct.proto": exports.packageName + "/wkt",
		"google/protobuf/timestamp.proto": exports.packageName + "/wkt",
		"google/protobuf/type.proto": exports.packageName + "/wkt",
		"google/protobuf/wrappers.proto": exports.packageName + "/wkt"
	};
	/**
	* @private
	*/
	exports.symbols = {
		isMessage: {
			typeOnly: false,
			bootstrapWktFrom: "../../is-message.js",
			from: exports.packageName
		},
		Message: {
			typeOnly: true,
			bootstrapWktFrom: "../../types.js",
			from: exports.packageName
		},
		create: {
			typeOnly: false,
			bootstrapWktFrom: "../../create.js",
			from: exports.packageName
		},
		fromJson: {
			typeOnly: false,
			bootstrapWktFrom: "../../from-json.js",
			from: exports.packageName
		},
		fromJsonString: {
			typeOnly: false,
			bootstrapWktFrom: "../../from-json.js",
			from: exports.packageName
		},
		fromBinary: {
			typeOnly: false,
			bootstrapWktFrom: "../../from-binary.js",
			from: exports.packageName
		},
		toBinary: {
			typeOnly: false,
			bootstrapWktFrom: "../../to-binary.js",
			from: exports.packageName
		},
		toJson: {
			typeOnly: false,
			bootstrapWktFrom: "../../to-json.js",
			from: exports.packageName
		},
		toJsonString: {
			typeOnly: false,
			bootstrapWktFrom: "../../to-json.js",
			from: exports.packageName
		},
		protoInt64: {
			typeOnly: false,
			bootstrapWktFrom: "../../proto-int64.js",
			from: exports.packageName
		},
		JsonValue: {
			typeOnly: true,
			bootstrapWktFrom: "../../json-value.js",
			from: exports.packageName
		},
		JsonObject: {
			typeOnly: true,
			bootstrapWktFrom: "../../json-value.js",
			from: exports.packageName
		},
		codegen: {
			boot: {
				typeOnly: false,
				bootstrapWktFrom: "../../codegenv2/boot.js",
				from: exports.packageName + "/codegenv2"
			},
			fileDesc: {
				typeOnly: false,
				bootstrapWktFrom: "../../codegenv2/file.js",
				from: exports.packageName + "/codegenv2"
			},
			enumDesc: {
				typeOnly: false,
				bootstrapWktFrom: "../../codegenv2/enum.js",
				from: exports.packageName + "/codegenv2"
			},
			extDesc: {
				typeOnly: false,
				bootstrapWktFrom: "../../codegenv2/extension.js",
				from: exports.packageName + "/codegenv2"
			},
			messageDesc: {
				typeOnly: false,
				bootstrapWktFrom: "../../codegenv2/message.js",
				from: exports.packageName + "/codegenv2"
			},
			serviceDesc: {
				typeOnly: false,
				bootstrapWktFrom: "../../codegenv2/service.js",
				from: exports.packageName + "/codegenv2"
			},
			tsEnum: {
				typeOnly: false,
				bootstrapWktFrom: "../../codegenv2/enum.js",
				from: exports.packageName + "/codegenv2"
			},
			GenFile: {
				typeOnly: true,
				bootstrapWktFrom: "../../codegenv2/types.js",
				from: exports.packageName + "/codegenv2"
			},
			GenEnum: {
				typeOnly: true,
				bootstrapWktFrom: "../../codegenv2/types.js",
				from: exports.packageName + "/codegenv2"
			},
			GenExtension: {
				typeOnly: true,
				bootstrapWktFrom: "../../codegenv2/types.js",
				from: exports.packageName + "/codegenv2"
			},
			GenMessage: {
				typeOnly: true,
				bootstrapWktFrom: "../../codegenv2/types.js",
				from: exports.packageName + "/codegenv2"
			},
			GenService: {
				typeOnly: true,
				bootstrapWktFrom: "../../codegenv2/types.js",
				from: exports.packageName + "/codegenv2"
			}
		}
	};
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/scalar.js
var require_scalar = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/scalar.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.scalarTypeScriptType = scalarTypeScriptType;
	exports.scalarJsonType = scalarJsonType;
	var descriptors_js_1$3 = require_descriptors();
	/**
	* Return the TypeScript type (as a string) for the given scalar type.
	*/
	function scalarTypeScriptType(scalar, longAsString) {
		switch (scalar) {
			case descriptors_js_1$3.ScalarType.STRING: return "string";
			case descriptors_js_1$3.ScalarType.BOOL: return "boolean";
			case descriptors_js_1$3.ScalarType.UINT64:
			case descriptors_js_1$3.ScalarType.SFIXED64:
			case descriptors_js_1$3.ScalarType.FIXED64:
			case descriptors_js_1$3.ScalarType.SINT64:
			case descriptors_js_1$3.ScalarType.INT64: return longAsString ? "string" : "bigint";
			case descriptors_js_1$3.ScalarType.BYTES: return "Uint8Array";
			default: return "number";
		}
	}
	/**
	* Return the JSON type (as a string) for the given scalar type.
	*/
	function scalarJsonType(scalar) {
		switch (scalar) {
			case descriptors_js_1$3.ScalarType.DOUBLE:
			case descriptors_js_1$3.ScalarType.FLOAT: return `number | "NaN" | "Infinity" | "-Infinity"`;
			case descriptors_js_1$3.ScalarType.UINT64:
			case descriptors_js_1$3.ScalarType.SFIXED64:
			case descriptors_js_1$3.ScalarType.FIXED64:
			case descriptors_js_1$3.ScalarType.SINT64:
			case descriptors_js_1$3.ScalarType.INT64: return "string";
			case descriptors_js_1$3.ScalarType.INT32:
			case descriptors_js_1$3.ScalarType.FIXED32:
			case descriptors_js_1$3.ScalarType.UINT32:
			case descriptors_js_1$3.ScalarType.SFIXED32:
			case descriptors_js_1$3.ScalarType.SINT32: return "number";
			case descriptors_js_1$3.ScalarType.STRING: return "string";
			case descriptors_js_1$3.ScalarType.BOOL: return "boolean";
			case descriptors_js_1$3.ScalarType.BYTES: return "string";
		}
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/types.js
var require_types$2 = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/types.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/index.js
var require_codegenv2 = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/codegenv2/index.js": ((exports) => {
	var __createBinding$4 = exports && exports.__createBinding || (Object.create ? (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	}));
	var __exportStar$4 = exports && exports.__exportStar || function(m$1, exports$1) {
		for (var p$10 in m$1) if (p$10 !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p$10)) __createBinding$4(exports$1, m$1, p$10);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar$4(require_boot(), exports);
	__exportStar$4(require_embed(), exports);
	__exportStar$4(require_enum(), exports);
	__exportStar$4(require_extension(), exports);
	__exportStar$4(require_file(), exports);
	__exportStar$4(require_message(), exports);
	__exportStar$4(require_service(), exports);
	__exportStar$4(require_symbols(), exports);
	__exportStar$4(require_scalar(), exports);
	__exportStar$4(require_types$2(), exports);
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/vendor/embedded_sass_pb.js
var require_embedded_sass_pb = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/vendor/embedded_sass_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SingletonValue = exports.ListSeparatorSchema = exports.ListSeparator = exports.ProtocolErrorTypeSchema = exports.ProtocolErrorType = exports.LogEventTypeSchema = exports.LogEventType = exports.SyntaxSchema = exports.Syntax = exports.OutputStyleSchema = exports.OutputStyle = exports.NodePackageImporterSchema = exports.Value_Calculation_CalculationOperationSchema = exports.Value_Calculation_CalculationValueSchema = exports.Value_CalculationSchema = exports.Value_ArgumentListSchema = exports.Value_CompilerMixinSchema = exports.Value_HostFunctionSchema = exports.Value_CompilerFunctionSchema = exports.Value_Map_EntrySchema = exports.Value_MapSchema = exports.Value_ListSchema = exports.Value_ColorSchema = exports.Value_NumberSchema = exports.Value_StringSchema = exports.ValueSchema = exports.SourceSpan_SourceLocationSchema = exports.SourceSpanSchema = exports.ProtocolErrorSchema = exports.OutboundMessage_FunctionCallRequestSchema = exports.OutboundMessage_FileImportRequestSchema = exports.OutboundMessage_ImportRequestSchema = exports.OutboundMessage_CanonicalizeRequestSchema = exports.OutboundMessage_LogEventSchema = exports.OutboundMessage_CompileResponse_CompileFailureSchema = exports.OutboundMessage_CompileResponse_CompileSuccessSchema = exports.OutboundMessage_CompileResponseSchema = exports.OutboundMessage_VersionResponseSchema = exports.OutboundMessageSchema = exports.InboundMessage_FunctionCallResponseSchema = exports.InboundMessage_FileImportResponseSchema = exports.InboundMessage_ImportResponse_ImportSuccessSchema = exports.InboundMessage_ImportResponseSchema = exports.InboundMessage_CanonicalizeResponseSchema = exports.InboundMessage_CompileRequest_ImporterSchema = exports.InboundMessage_CompileRequest_StringInputSchema = exports.InboundMessage_CompileRequestSchema = exports.InboundMessage_VersionRequestSchema = exports.InboundMessageSchema = exports.file_embedded_sass = void 0;
	exports.CalculationOperatorSchema = exports.CalculationOperator = exports.SingletonValueSchema = void 0;
	var codegenv2_1 = require_codegenv2();
	/**
	* Describes the file embedded_sass.proto.
	*/
	exports.file_embedded_sass = (0, codegenv2_1.fileDesc)("ChNlbWJlZGRlZF9zYXNzLnByb3RvEhZzYXNzLmVtYmVkZGVkX3Byb3RvY29sIugQCg5JbmJvdW5kTWVzc2FnZRJQCg9jb21waWxlX3JlcXVlc3QYAiABKAsyNS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLkluYm91bmRNZXNzYWdlLkNvbXBpbGVSZXF1ZXN0SAASXAoVY2Fub25pY2FsaXplX3Jlc3BvbnNlGAMgASgLMjsuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5JbmJvdW5kTWVzc2FnZS5DYW5vbmljYWxpemVSZXNwb25zZUgAElAKD2ltcG9ydF9yZXNwb25zZRgEIAEoCzI1LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuSW5ib3VuZE1lc3NhZ2UuSW1wb3J0UmVzcG9uc2VIABJZChRmaWxlX2ltcG9ydF9yZXNwb25zZRgFIAEoCzI5LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuSW5ib3VuZE1lc3NhZ2UuRmlsZUltcG9ydFJlc3BvbnNlSAASXQoWZnVuY3Rpb25fY2FsbF9yZXNwb25zZRgGIAEoCzI7LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuSW5ib3VuZE1lc3NhZ2UuRnVuY3Rpb25DYWxsUmVzcG9uc2VIABJQCg92ZXJzaW9uX3JlcXVlc3QYByABKAsyNS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLkluYm91bmRNZXNzYWdlLlZlcnNpb25SZXF1ZXN0SAAaHAoOVmVyc2lvblJlcXVlc3QSCgoCaWQYASABKA0amAcKDkNvbXBpbGVSZXF1ZXN0ElMKBnN0cmluZxgCIAEoCzJBLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuSW5ib3VuZE1lc3NhZ2UuQ29tcGlsZVJlcXVlc3QuU3RyaW5nSW5wdXRIABIOCgRwYXRoGAMgASgJSAASMgoFc3R5bGUYBCABKA4yIy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLk91dHB1dFN0eWxlEhIKCnNvdXJjZV9tYXAYBSABKAgSUQoJaW1wb3J0ZXJzGAYgAygLMj4uc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5JbmJvdW5kTWVzc2FnZS5Db21waWxlUmVxdWVzdC5JbXBvcnRlchIYChBnbG9iYWxfZnVuY3Rpb25zGAcgAygJEhMKC2FsZXJ0X2NvbG9yGAggASgIEhMKC2FsZXJ0X2FzY2lpGAkgASgIEg8KB3ZlcmJvc2UYCiABKAgSEgoKcXVpZXRfZGVwcxgLIAEoCBIiChpzb3VyY2VfbWFwX2luY2x1ZGVfc291cmNlcxgMIAEoCBIPCgdjaGFyc2V0GA0gASgIEg4KBnNpbGVudBgOIAEoCBIZChFmYXRhbF9kZXByZWNhdGlvbhgPIAMoCRIbChNzaWxlbmNlX2RlcHJlY2F0aW9uGBAgAygJEhoKEmZ1dHVyZV9kZXByZWNhdGlvbhgRIAMoCRqsAQoLU3RyaW5nSW5wdXQSDgoGc291cmNlGAEgASgJEgsKA3VybBgCIAEoCRIuCgZzeW50YXgYAyABKA4yHi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlN5bnRheBJQCghpbXBvcnRlchgEIAEoCzI+LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuSW5ib3VuZE1lc3NhZ2UuQ29tcGlsZVJlcXVlc3QuSW1wb3J0ZXIaxQEKCEltcG9ydGVyEg4KBHBhdGgYASABKAlIABIVCgtpbXBvcnRlcl9pZBgCIAEoDUgAEhoKEGZpbGVfaW1wb3J0ZXJfaWQYAyABKA1IABJMChVub2RlX3BhY2thZ2VfaW1wb3J0ZXIYBSABKAsyKy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLk5vZGVQYWNrYWdlSW1wb3J0ZXJIABIcChRub25fY2Fub25pY2FsX3NjaGVtZRgEIAMoCUIKCghpbXBvcnRlckIHCgVpbnB1dEoECAEQAhprChRDYW5vbmljYWxpemVSZXNwb25zZRIKCgJpZBgBIAEoDRINCgN1cmwYAiABKAlIABIPCgVlcnJvchgDIAEoCUgAEh0KFWNvbnRhaW5pbmdfdXJsX3VudXNlZBgEIAEoCEIICgZyZXN1bHQakwIKDkltcG9ydFJlc3BvbnNlEgoKAmlkGAEgASgNElYKB3N1Y2Nlc3MYAiABKAsyQy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLkluYm91bmRNZXNzYWdlLkltcG9ydFJlc3BvbnNlLkltcG9ydFN1Y2Nlc3NIABIPCgVlcnJvchgDIAEoCUgAGoEBCg1JbXBvcnRTdWNjZXNzEhAKCGNvbnRlbnRzGAEgASgJEi4KBnN5bnRheBgCIAEoDjIeLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuU3ludGF4EhsKDnNvdXJjZV9tYXBfdXJsGAMgASgJSACIAQFCEQoPX3NvdXJjZV9tYXBfdXJsQggKBnJlc3VsdBpuChJGaWxlSW1wb3J0UmVzcG9uc2USCgoCaWQYASABKA0SEgoIZmlsZV91cmwYAiABKAlIABIPCgVlcnJvchgDIAEoCUgAEh0KFWNvbnRhaW5pbmdfdXJsX3VudXNlZBgEIAEoCEIICgZyZXN1bHQakAEKFEZ1bmN0aW9uQ2FsbFJlc3BvbnNlEgoKAmlkGAEgASgNEjAKB3N1Y2Nlc3MYAiABKAsyHS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlSAASDwoFZXJyb3IYAyABKAlIABIfChdhY2Nlc3NlZF9hcmd1bWVudF9saXN0cxgEIAMoDUIICgZyZXN1bHRCCQoHbWVzc2FnZSLLDwoPT3V0Ym91bmRNZXNzYWdlEjYKBWVycm9yGAEgASgLMiUuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5Qcm90b2NvbEVycm9ySAASUwoQY29tcGlsZV9yZXNwb25zZRgCIAEoCzI3LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuT3V0Ym91bmRNZXNzYWdlLkNvbXBpbGVSZXNwb25zZUgAEkUKCWxvZ19ldmVudBgDIAEoCzIwLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuT3V0Ym91bmRNZXNzYWdlLkxvZ0V2ZW50SAASWwoUY2Fub25pY2FsaXplX3JlcXVlc3QYBCABKAsyOy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLk91dGJvdW5kTWVzc2FnZS5DYW5vbmljYWxpemVSZXF1ZXN0SAASTwoOaW1wb3J0X3JlcXVlc3QYBSABKAsyNS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLk91dGJvdW5kTWVzc2FnZS5JbXBvcnRSZXF1ZXN0SAASWAoTZmlsZV9pbXBvcnRfcmVxdWVzdBgGIAEoCzI5LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuT3V0Ym91bmRNZXNzYWdlLkZpbGVJbXBvcnRSZXF1ZXN0SAASXAoVZnVuY3Rpb25fY2FsbF9yZXF1ZXN0GAcgASgLMjsuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5PdXRib3VuZE1lc3NhZ2UuRnVuY3Rpb25DYWxsUmVxdWVzdEgAElMKEHZlcnNpb25fcmVzcG9uc2UYCCABKAsyNy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLk91dGJvdW5kTWVzc2FnZS5WZXJzaW9uUmVzcG9uc2VIABqOAQoPVmVyc2lvblJlc3BvbnNlEgoKAmlkGAUgASgNEhgKEHByb3RvY29sX3ZlcnNpb24YASABKAkSGAoQY29tcGlsZXJfdmVyc2lvbhgCIAEoCRIeChZpbXBsZW1lbnRhdGlvbl92ZXJzaW9uGAMgASgJEhsKE2ltcGxlbWVudGF0aW9uX25hbWUYBCABKAkaogMKD0NvbXBpbGVSZXNwb25zZRJZCgdzdWNjZXNzGAIgASgLMkYuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5PdXRib3VuZE1lc3NhZ2UuQ29tcGlsZVJlc3BvbnNlLkNvbXBpbGVTdWNjZXNzSAASWQoHZmFpbHVyZRgDIAEoCzJGLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuT3V0Ym91bmRNZXNzYWdlLkNvbXBpbGVSZXNwb25zZS5Db21waWxlRmFpbHVyZUgAEhMKC2xvYWRlZF91cmxzGAQgAygJGjcKDkNvbXBpbGVTdWNjZXNzEgsKA2NzcxgBIAEoCRISCgpzb3VyY2VfbWFwGAIgASgJSgQIAxAEGnsKDkNvbXBpbGVGYWlsdXJlEg8KB21lc3NhZ2UYASABKAkSMAoEc3BhbhgCIAEoCzIiLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuU291cmNlU3BhbhITCgtzdGFja190cmFjZRgDIAEoCRIRCglmb3JtYXR0ZWQYBCABKAlCCAoGcmVzdWx0SgQIARACGvEBCghMb2dFdmVudBIyCgR0eXBlGAIgASgOMiQuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5Mb2dFdmVudFR5cGUSDwoHbWVzc2FnZRgDIAEoCRI1CgRzcGFuGAQgASgLMiIuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5Tb3VyY2VTcGFuSACIAQESEwoLc3RhY2tfdHJhY2UYBSABKAkSEQoJZm9ybWF0dGVkGAYgASgJEh0KEGRlcHJlY2F0aW9uX3R5cGUYByABKAlIAYgBAUIHCgVfc3BhbkITChFfZGVwcmVjYXRpb25fdHlwZUoECAEQAhqOAQoTQ2Fub25pY2FsaXplUmVxdWVzdBIKCgJpZBgBIAEoDRITCgtpbXBvcnRlcl9pZBgDIAEoDRILCgN1cmwYBCABKAkSEwoLZnJvbV9pbXBvcnQYBSABKAgSGwoOY29udGFpbmluZ191cmwYBiABKAlIAIgBAUIRCg9fY29udGFpbmluZ191cmxKBAgCEAMaQwoNSW1wb3J0UmVxdWVzdBIKCgJpZBgBIAEoDRITCgtpbXBvcnRlcl9pZBgDIAEoDRILCgN1cmwYBCABKAlKBAgCEAMajAEKEUZpbGVJbXBvcnRSZXF1ZXN0EgoKAmlkGAEgASgNEhMKC2ltcG9ydGVyX2lkGAMgASgNEgsKA3VybBgEIAEoCRITCgtmcm9tX2ltcG9ydBgFIAEoCBIbCg5jb250YWluaW5nX3VybBgGIAEoCUgAiAEBQhEKD19jb250YWluaW5nX3VybEoECAIQAxqOAQoTRnVuY3Rpb25DYWxsUmVxdWVzdBIKCgJpZBgBIAEoDRIOCgRuYW1lGAMgASgJSAASFQoLZnVuY3Rpb25faWQYBCABKA1IABIwCglhcmd1bWVudHMYBSADKAsyHS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlQgwKCmlkZW50aWZpZXJKBAgCEANCCQoHbWVzc2FnZSJlCg1Qcm90b2NvbEVycm9yEjcKBHR5cGUYASABKA4yKS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlByb3RvY29sRXJyb3JUeXBlEgoKAmlkGAIgASgNEg8KB21lc3NhZ2UYAyABKAkihwIKClNvdXJjZVNwYW4SDAoEdGV4dBgBIAEoCRJACgVzdGFydBgCIAEoCzIxLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuU291cmNlU3Bhbi5Tb3VyY2VMb2NhdGlvbhJDCgNlbmQYAyABKAsyMS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlNvdXJjZVNwYW4uU291cmNlTG9jYXRpb25IAIgBARILCgN1cmwYBCABKAkSDwoHY29udGV4dBgFIAEoCRo+Cg5Tb3VyY2VMb2NhdGlvbhIOCgZvZmZzZXQYASABKA0SDAoEbGluZRgCIAEoDRIOCgZjb2x1bW4YAyABKA1CBgoEX2VuZCL4EQoFVmFsdWUSNgoGc3RyaW5nGAEgASgLMiQuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZS5TdHJpbmdIABI2CgZudW1iZXIYAiABKAsyJC5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLk51bWJlckgAEjIKBGxpc3QYBSABKAsyIi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkxpc3RIABIwCgNtYXAYBiABKAsyIS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLk1hcEgAEjsKCXNpbmdsZXRvbhgHIAEoDjImLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuU2luZ2xldG9uVmFsdWVIABJLChFjb21waWxlcl9mdW5jdGlvbhgIIAEoCzIuLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuVmFsdWUuQ29tcGlsZXJGdW5jdGlvbkgAEkMKDWhvc3RfZnVuY3Rpb24YCSABKAsyKi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkhvc3RGdW5jdGlvbkgAEkMKDWFyZ3VtZW50X2xpc3QYCiABKAsyKi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkFyZ3VtZW50TGlzdEgAEkAKC2NhbGN1bGF0aW9uGAwgASgLMikuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZS5DYWxjdWxhdGlvbkgAEkUKDmNvbXBpbGVyX21peGluGA0gASgLMisuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZS5Db21waWxlck1peGluSAASNAoFY29sb3IYDiABKAsyIy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkNvbG9ySAAaJgoGU3RyaW5nEgwKBHRleHQYASABKAkSDgoGcXVvdGVkGAIgASgIGkEKBk51bWJlchINCgV2YWx1ZRgBIAEoARISCgpudW1lcmF0b3JzGAIgAygJEhQKDGRlbm9taW5hdG9ycxgDIAMoCRqgAQoFQ29sb3ISDQoFc3BhY2UYASABKAkSFQoIY2hhbm5lbDEYAiABKAFIAIgBARIVCghjaGFubmVsMhgDIAEoAUgBiAEBEhUKCGNoYW5uZWwzGAQgASgBSAKIAQESEgoFYWxwaGEYBSABKAFIA4gBAUILCglfY2hhbm5lbDFCCwoJX2NoYW5uZWwyQgsKCV9jaGFubmVsM0IICgZfYWxwaGEahwEKBExpc3QSOAoJc2VwYXJhdG9yGAEgASgOMiUuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5MaXN0U2VwYXJhdG9yEhQKDGhhc19icmFja2V0cxgCIAEoCBIvCghjb250ZW50cxgDIAMoCzIdLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuVmFsdWUaogEKA01hcBI4CgdlbnRyaWVzGAEgAygLMicuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZS5NYXAuRW50cnkaYQoFRW50cnkSKgoDa2V5GAEgASgLMh0uc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZRIsCgV2YWx1ZRgCIAEoCzIdLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuVmFsdWUaHgoQQ29tcGlsZXJGdW5jdGlvbhIKCgJpZBgBIAEoDRotCgxIb3N0RnVuY3Rpb24SCgoCaWQYASABKA0SEQoJc2lnbmF0dXJlGAIgASgJGhsKDUNvbXBpbGVyTWl4aW4SCgoCaWQYASABKA0aoQIKDEFyZ3VtZW50TGlzdBIKCgJpZBgBIAEoDRI4CglzZXBhcmF0b3IYAiABKA4yJS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLkxpc3RTZXBhcmF0b3ISLwoIY29udGVudHMYAyADKAsyHS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlEkoKCGtleXdvcmRzGAQgAygLMjguc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZS5Bcmd1bWVudExpc3QuS2V5d29yZHNFbnRyeRpOCg1LZXl3b3Jkc0VudHJ5EgsKA2tleRgBIAEoCRIsCgV2YWx1ZRgCIAEoCzIdLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuVmFsdWU6AjgBGu8ECgtDYWxjdWxhdGlvbhIMCgRuYW1lGAEgASgJEk0KCWFyZ3VtZW50cxgCIAMoCzI6LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuVmFsdWUuQ2FsY3VsYXRpb24uQ2FsY3VsYXRpb25WYWx1ZRqVAgoQQ2FsY3VsYXRpb25WYWx1ZRI2CgZudW1iZXIYASABKAsyJC5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLk51bWJlckgAEhAKBnN0cmluZxgCIAEoCUgAEhcKDWludGVycG9sYXRpb24YAyABKAlIABJTCglvcGVyYXRpb24YBCABKAsyPi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkNhbGN1bGF0aW9uLkNhbGN1bGF0aW9uT3BlcmF0aW9uSAASQAoLY2FsY3VsYXRpb24YBSABKAsyKS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkNhbGN1bGF0aW9uSABCBwoFdmFsdWUa6gEKFENhbGN1bGF0aW9uT3BlcmF0aW9uEj0KCG9wZXJhdG9yGAEgASgOMisuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5DYWxjdWxhdGlvbk9wZXJhdG9yEkgKBGxlZnQYAiABKAsyOi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkNhbGN1bGF0aW9uLkNhbGN1bGF0aW9uVmFsdWUSSQoFcmlnaHQYAyABKAsyOi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkNhbGN1bGF0aW9uLkNhbGN1bGF0aW9uVmFsdWVCBwoFdmFsdWUiNAoTTm9kZVBhY2thZ2VJbXBvcnRlchIdChVlbnRyeV9wb2ludF9kaXJlY3RvcnkYASABKAkqKwoLT3V0cHV0U3R5bGUSDAoIRVhQQU5ERUQQABIOCgpDT01QUkVTU0VEEAEqKQoGU3ludGF4EggKBFNDU1MQABIMCghJTkRFTlRFRBABEgcKA0NTUxACKj8KDExvZ0V2ZW50VHlwZRILCgdXQVJOSU5HEAASFwoTREVQUkVDQVRJT05fV0FSTklORxABEgkKBURFQlVHEAIqOAoRUHJvdG9jb2xFcnJvclR5cGUSCQoFUEFSU0UQABIKCgZQQVJBTVMQARIMCghJTlRFUk5BTBACKj8KDUxpc3RTZXBhcmF0b3ISCQoFQ09NTUEQABIJCgVTUEFDRRABEgkKBVNMQVNIEAISDQoJVU5ERUNJREVEEAMqLwoOU2luZ2xldG9uVmFsdWUSCAoEVFJVRRAAEgkKBUZBTFNFEAESCAoETlVMTBACKkEKE0NhbGN1bGF0aW9uT3BlcmF0b3ISCAoEUExVUxAAEgkKBU1JTlVTEAESCQoFVElNRVMQAhIKCgZESVZJREUQA0IjCh9jb20uc2Fzc19sYW5nLmVtYmVkZGVkX3Byb3RvY29sUAFiBnByb3RvMw");
	/**
	* Describes the message sass.embedded_protocol.InboundMessage.
	* Use `create(InboundMessageSchema)` to create a new message.
	*/
	exports.InboundMessageSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 0);
	/**
	* Describes the message sass.embedded_protocol.InboundMessage.VersionRequest.
	* Use `create(InboundMessage_VersionRequestSchema)` to create a new message.
	*/
	exports.InboundMessage_VersionRequestSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 0, 0);
	/**
	* Describes the message sass.embedded_protocol.InboundMessage.CompileRequest.
	* Use `create(InboundMessage_CompileRequestSchema)` to create a new message.
	*/
	exports.InboundMessage_CompileRequestSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 0, 1);
	/**
	* Describes the message sass.embedded_protocol.InboundMessage.CompileRequest.StringInput.
	* Use `create(InboundMessage_CompileRequest_StringInputSchema)` to create a new message.
	*/
	exports.InboundMessage_CompileRequest_StringInputSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 0, 1, 0);
	/**
	* Describes the message sass.embedded_protocol.InboundMessage.CompileRequest.Importer.
	* Use `create(InboundMessage_CompileRequest_ImporterSchema)` to create a new message.
	*/
	exports.InboundMessage_CompileRequest_ImporterSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 0, 1, 1);
	/**
	* Describes the message sass.embedded_protocol.InboundMessage.CanonicalizeResponse.
	* Use `create(InboundMessage_CanonicalizeResponseSchema)` to create a new message.
	*/
	exports.InboundMessage_CanonicalizeResponseSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 0, 2);
	/**
	* Describes the message sass.embedded_protocol.InboundMessage.ImportResponse.
	* Use `create(InboundMessage_ImportResponseSchema)` to create a new message.
	*/
	exports.InboundMessage_ImportResponseSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 0, 3);
	/**
	* Describes the message sass.embedded_protocol.InboundMessage.ImportResponse.ImportSuccess.
	* Use `create(InboundMessage_ImportResponse_ImportSuccessSchema)` to create a new message.
	*/
	exports.InboundMessage_ImportResponse_ImportSuccessSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 0, 3, 0);
	/**
	* Describes the message sass.embedded_protocol.InboundMessage.FileImportResponse.
	* Use `create(InboundMessage_FileImportResponseSchema)` to create a new message.
	*/
	exports.InboundMessage_FileImportResponseSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 0, 4);
	/**
	* Describes the message sass.embedded_protocol.InboundMessage.FunctionCallResponse.
	* Use `create(InboundMessage_FunctionCallResponseSchema)` to create a new message.
	*/
	exports.InboundMessage_FunctionCallResponseSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 0, 5);
	/**
	* Describes the message sass.embedded_protocol.OutboundMessage.
	* Use `create(OutboundMessageSchema)` to create a new message.
	*/
	exports.OutboundMessageSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 1);
	/**
	* Describes the message sass.embedded_protocol.OutboundMessage.VersionResponse.
	* Use `create(OutboundMessage_VersionResponseSchema)` to create a new message.
	*/
	exports.OutboundMessage_VersionResponseSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 1, 0);
	/**
	* Describes the message sass.embedded_protocol.OutboundMessage.CompileResponse.
	* Use `create(OutboundMessage_CompileResponseSchema)` to create a new message.
	*/
	exports.OutboundMessage_CompileResponseSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 1, 1);
	/**
	* Describes the message sass.embedded_protocol.OutboundMessage.CompileResponse.CompileSuccess.
	* Use `create(OutboundMessage_CompileResponse_CompileSuccessSchema)` to create a new message.
	*/
	exports.OutboundMessage_CompileResponse_CompileSuccessSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 1, 1, 0);
	/**
	* Describes the message sass.embedded_protocol.OutboundMessage.CompileResponse.CompileFailure.
	* Use `create(OutboundMessage_CompileResponse_CompileFailureSchema)` to create a new message.
	*/
	exports.OutboundMessage_CompileResponse_CompileFailureSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 1, 1, 1);
	/**
	* Describes the message sass.embedded_protocol.OutboundMessage.LogEvent.
	* Use `create(OutboundMessage_LogEventSchema)` to create a new message.
	*/
	exports.OutboundMessage_LogEventSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 1, 2);
	/**
	* Describes the message sass.embedded_protocol.OutboundMessage.CanonicalizeRequest.
	* Use `create(OutboundMessage_CanonicalizeRequestSchema)` to create a new message.
	*/
	exports.OutboundMessage_CanonicalizeRequestSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 1, 3);
	/**
	* Describes the message sass.embedded_protocol.OutboundMessage.ImportRequest.
	* Use `create(OutboundMessage_ImportRequestSchema)` to create a new message.
	*/
	exports.OutboundMessage_ImportRequestSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 1, 4);
	/**
	* Describes the message sass.embedded_protocol.OutboundMessage.FileImportRequest.
	* Use `create(OutboundMessage_FileImportRequestSchema)` to create a new message.
	*/
	exports.OutboundMessage_FileImportRequestSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 1, 5);
	/**
	* Describes the message sass.embedded_protocol.OutboundMessage.FunctionCallRequest.
	* Use `create(OutboundMessage_FunctionCallRequestSchema)` to create a new message.
	*/
	exports.OutboundMessage_FunctionCallRequestSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 1, 6);
	/**
	* Describes the message sass.embedded_protocol.ProtocolError.
	* Use `create(ProtocolErrorSchema)` to create a new message.
	*/
	exports.ProtocolErrorSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 2);
	/**
	* Describes the message sass.embedded_protocol.SourceSpan.
	* Use `create(SourceSpanSchema)` to create a new message.
	*/
	exports.SourceSpanSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 3);
	/**
	* Describes the message sass.embedded_protocol.SourceSpan.SourceLocation.
	* Use `create(SourceSpan_SourceLocationSchema)` to create a new message.
	*/
	exports.SourceSpan_SourceLocationSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 3, 0);
	/**
	* Describes the message sass.embedded_protocol.Value.
	* Use `create(ValueSchema)` to create a new message.
	*/
	exports.ValueSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4);
	/**
	* Describes the message sass.embedded_protocol.Value.String.
	* Use `create(Value_StringSchema)` to create a new message.
	*/
	exports.Value_StringSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 0);
	/**
	* Describes the message sass.embedded_protocol.Value.Number.
	* Use `create(Value_NumberSchema)` to create a new message.
	*/
	exports.Value_NumberSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 1);
	/**
	* Describes the message sass.embedded_protocol.Value.Color.
	* Use `create(Value_ColorSchema)` to create a new message.
	*/
	exports.Value_ColorSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 2);
	/**
	* Describes the message sass.embedded_protocol.Value.List.
	* Use `create(Value_ListSchema)` to create a new message.
	*/
	exports.Value_ListSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 3);
	/**
	* Describes the message sass.embedded_protocol.Value.Map.
	* Use `create(Value_MapSchema)` to create a new message.
	*/
	exports.Value_MapSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 4);
	/**
	* Describes the message sass.embedded_protocol.Value.Map.Entry.
	* Use `create(Value_Map_EntrySchema)` to create a new message.
	*/
	exports.Value_Map_EntrySchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 4, 0);
	/**
	* Describes the message sass.embedded_protocol.Value.CompilerFunction.
	* Use `create(Value_CompilerFunctionSchema)` to create a new message.
	*/
	exports.Value_CompilerFunctionSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 5);
	/**
	* Describes the message sass.embedded_protocol.Value.HostFunction.
	* Use `create(Value_HostFunctionSchema)` to create a new message.
	*/
	exports.Value_HostFunctionSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 6);
	/**
	* Describes the message sass.embedded_protocol.Value.CompilerMixin.
	* Use `create(Value_CompilerMixinSchema)` to create a new message.
	*/
	exports.Value_CompilerMixinSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 7);
	/**
	* Describes the message sass.embedded_protocol.Value.ArgumentList.
	* Use `create(Value_ArgumentListSchema)` to create a new message.
	*/
	exports.Value_ArgumentListSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 8);
	/**
	* Describes the message sass.embedded_protocol.Value.Calculation.
	* Use `create(Value_CalculationSchema)` to create a new message.
	*/
	exports.Value_CalculationSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 9);
	/**
	* Describes the message sass.embedded_protocol.Value.Calculation.CalculationValue.
	* Use `create(Value_Calculation_CalculationValueSchema)` to create a new message.
	*/
	exports.Value_Calculation_CalculationValueSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 9, 0);
	/**
	* Describes the message sass.embedded_protocol.Value.Calculation.CalculationOperation.
	* Use `create(Value_Calculation_CalculationOperationSchema)` to create a new message.
	*/
	exports.Value_Calculation_CalculationOperationSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 4, 9, 1);
	/**
	* Describes the message sass.embedded_protocol.NodePackageImporter.
	* Use `create(NodePackageImporterSchema)` to create a new message.
	*/
	exports.NodePackageImporterSchema = (0, codegenv2_1.messageDesc)(exports.file_embedded_sass, 5);
	/**
	* Possible ways to format the CSS output. The compiler is not required to
	* support all possible options; if the host requests an unsupported style, the
	* compiler should choose the closest supported style.
	*
	* @generated from enum sass.embedded_protocol.OutputStyle
	*/
	var OutputStyle;
	(function(OutputStyle$1) {
		/**
		* Each selector and declaration is written on its own line.
		*
		* @generated from enum value: EXPANDED = 0;
		*/
		OutputStyle$1[OutputStyle$1["EXPANDED"] = 0] = "EXPANDED";
		/**
		* The entire stylesheet is written on a single line, with as few characters
		* as possible.
		*
		* @generated from enum value: COMPRESSED = 1;
		*/
		OutputStyle$1[OutputStyle$1["COMPRESSED"] = 1] = "COMPRESSED";
	})(OutputStyle || (exports.OutputStyle = OutputStyle = {}));
	/**
	* Describes the enum sass.embedded_protocol.OutputStyle.
	*/
	exports.OutputStyleSchema = (0, codegenv2_1.enumDesc)(exports.file_embedded_sass, 0);
	/**
	* Possible syntaxes for a Sass stylesheet.
	*
	* @generated from enum sass.embedded_protocol.Syntax
	*/
	var Syntax$1;
	(function(Syntax$2) {
		/**
		* The CSS-superset `.scss` syntax.
		*
		* @generated from enum value: SCSS = 0;
		*/
		Syntax$2[Syntax$2["SCSS"] = 0] = "SCSS";
		/**
		* The indented `.sass` syntax.
		*
		* @generated from enum value: INDENTED = 1;
		*/
		Syntax$2[Syntax$2["INDENTED"] = 1] = "INDENTED";
		/**
		* Plain CSS syntax that doesn't support any special Sass features.
		*
		* @generated from enum value: CSS = 2;
		*/
		Syntax$2[Syntax$2["CSS"] = 2] = "CSS";
	})(Syntax$1 || (exports.Syntax = Syntax$1 = {}));
	/**
	* Describes the enum sass.embedded_protocol.Syntax.
	*/
	exports.SyntaxSchema = (0, codegenv2_1.enumDesc)(exports.file_embedded_sass, 1);
	/**
	* The possible types of [LogEvent].
	*
	* @generated from enum sass.embedded_protocol.LogEventType
	*/
	var LogEventType;
	(function(LogEventType$1) {
		/**
		* A warning for something other than a deprecated Sass feature. Often emitted
		* due to a stylesheet using the `@warn` rule.
		*
		* @generated from enum value: WARNING = 0;
		*/
		LogEventType$1[LogEventType$1["WARNING"] = 0] = "WARNING";
		/**
		* A warning indicating that the stylesheet is using a deprecated Sass
		* feature. Compilers should not add text like "deprecation warning" to
		* deprecation warnings; it's up to the host to determine how to signal that
		* to the user.
		*
		* @generated from enum value: DEPRECATION_WARNING = 1;
		*/
		LogEventType$1[LogEventType$1["DEPRECATION_WARNING"] = 1] = "DEPRECATION_WARNING";
		/**
		* A message generated by the user for their own debugging purposes.
		*
		* @generated from enum value: DEBUG = 2;
		*/
		LogEventType$1[LogEventType$1["DEBUG"] = 2] = "DEBUG";
	})(LogEventType || (exports.LogEventType = LogEventType = {}));
	/**
	* Describes the enum sass.embedded_protocol.LogEventType.
	*/
	exports.LogEventTypeSchema = (0, codegenv2_1.enumDesc)(exports.file_embedded_sass, 2);
	/**
	* Potential types of protocol errors.
	*
	* @generated from enum sass.embedded_protocol.ProtocolErrorType
	*/
	var ProtocolErrorType;
	(function(ProtocolErrorType$1) {
		/**
		* A message was received that couldn't be decoded as an `InboundMessage` (for
		* the compiler) or `OutboundMessage` (for the host).
		*
		* @generated from enum value: PARSE = 0;
		*/
		ProtocolErrorType$1[ProtocolErrorType$1["PARSE"] = 0] = "PARSE";
		/**
		* A message was received that violated a documented restriction, such as not
		* providing a mandatory field.
		*
		* @generated from enum value: PARAMS = 1;
		*/
		ProtocolErrorType$1[ProtocolErrorType$1["PARAMS"] = 1] = "PARAMS";
		/**
		* Something unexpected went wrong within the endpoint.
		*
		* @generated from enum value: INTERNAL = 2;
		*/
		ProtocolErrorType$1[ProtocolErrorType$1["INTERNAL"] = 2] = "INTERNAL";
	})(ProtocolErrorType || (exports.ProtocolErrorType = ProtocolErrorType = {}));
	/**
	* Describes the enum sass.embedded_protocol.ProtocolErrorType.
	*/
	exports.ProtocolErrorTypeSchema = (0, codegenv2_1.enumDesc)(exports.file_embedded_sass, 3);
	/**
	* Different types of separators a list can have.
	*
	* @generated from enum sass.embedded_protocol.ListSeparator
	*/
	var ListSeparator$1;
	(function(ListSeparator$2) {
		/**
		* List elements are separated by a comma.
		*
		* @generated from enum value: COMMA = 0;
		*/
		ListSeparator$2[ListSeparator$2["COMMA"] = 0] = "COMMA";
		/**
		* List elements are separated by whitespace.
		*
		* @generated from enum value: SPACE = 1;
		*/
		ListSeparator$2[ListSeparator$2["SPACE"] = 1] = "SPACE";
		/**
		* List elements are separated by a forward slash.
		*
		* @generated from enum value: SLASH = 2;
		*/
		ListSeparator$2[ListSeparator$2["SLASH"] = 2] = "SLASH";
		/**
		* The list's separator hasn't yet been determined. This is only allowed for
		* singleton and empty lists.
		*
		* Singleton lists and empty lists don't have separators defined. This means
		* that list functions will prefer other lists' separators if possible.
		*
		* @generated from enum value: UNDECIDED = 3;
		*/
		ListSeparator$2[ListSeparator$2["UNDECIDED"] = 3] = "UNDECIDED";
	})(ListSeparator$1 || (exports.ListSeparator = ListSeparator$1 = {}));
	/**
	* Describes the enum sass.embedded_protocol.ListSeparator.
	*/
	exports.ListSeparatorSchema = (0, codegenv2_1.enumDesc)(exports.file_embedded_sass, 4);
	/**
	* Singleton SassScript values that have no internal state.
	*
	* @generated from enum sass.embedded_protocol.SingletonValue
	*/
	var SingletonValue;
	(function(SingletonValue$1) {
		/**
		* The SassScript boolean true value.
		*
		* @generated from enum value: TRUE = 0;
		*/
		SingletonValue$1[SingletonValue$1["TRUE"] = 0] = "TRUE";
		/**
		* The SassScript boolean false value.
		*
		* @generated from enum value: FALSE = 1;
		*/
		SingletonValue$1[SingletonValue$1["FALSE"] = 1] = "FALSE";
		/**
		* The SassScript null value.
		*
		* @generated from enum value: NULL = 2;
		*/
		SingletonValue$1[SingletonValue$1["NULL"] = 2] = "NULL";
	})(SingletonValue || (exports.SingletonValue = SingletonValue = {}));
	/**
	* Describes the enum sass.embedded_protocol.SingletonValue.
	*/
	exports.SingletonValueSchema = (0, codegenv2_1.enumDesc)(exports.file_embedded_sass, 5);
	/**
	* An operator used in a calculation value's operation.
	*
	* @generated from enum sass.embedded_protocol.CalculationOperator
	*/
	var CalculationOperator$1;
	(function(CalculationOperator$2) {
		/**
		* The addition operator.
		*
		* @generated from enum value: PLUS = 0;
		*/
		CalculationOperator$2[CalculationOperator$2["PLUS"] = 0] = "PLUS";
		/**
		* The subtraction operator.
		*
		* @generated from enum value: MINUS = 1;
		*/
		CalculationOperator$2[CalculationOperator$2["MINUS"] = 1] = "MINUS";
		/**
		* The multiplication operator.
		*
		* @generated from enum value: TIMES = 2;
		*/
		CalculationOperator$2[CalculationOperator$2["TIMES"] = 2] = "TIMES";
		/**
		* The division operator.
		*
		* @generated from enum value: DIVIDE = 3;
		*/
		CalculationOperator$2[CalculationOperator$2["DIVIDE"] = 3] = "DIVIDE";
	})(CalculationOperator$1 || (exports.CalculationOperator = CalculationOperator$1 = {}));
	/**
	* Describes the enum sass.embedded_protocol.CalculationOperator.
	*/
	exports.CalculationOperatorSchema = (0, codegenv2_1.enumDesc)(exports.file_embedded_sass, 6);
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/utils.js
var require_utils$3 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/utils.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.thenOr = thenOr;
	exports.catchOr = catchOr;
	exports.isNullOrUndefined = isNullOrUndefined;
	exports.asImmutableList = asImmutableList;
	exports.compilerError = compilerError;
	exports.mandatoryError = mandatoryError;
	exports.hostError = hostError;
	exports.valueError = valueError;
	exports.pathToUrlString = pathToUrlString;
	exports.fileUrlToPathCrossPlatform = fileUrlToPathCrossPlatform;
	exports.withoutExtension = withoutExtension$1;
	exports.protofySyntax = protofySyntax;
	exports.isErrnoException = isErrnoException;
	exports.putIfAbsent = putIfAbsent;
	var immutable_1$15 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var p$9 = require_browser_external_path();
	var url = require_browser_external_url();
	var proto$5 = require_embedded_sass_pb();
	/**
	* The equivalent of `Promise.then()`, except that if the first argument is a
	* plain value it synchronously invokes `callback()` and returns its result.
	*/
	function thenOr(promiseOrValue, callback) {
		return promiseOrValue instanceof Promise ? promiseOrValue.then(callback) : callback(promiseOrValue);
	}
	/**
	* The equivalent of `Promise.catch()`, except that if the first argument throws
	* synchronously it synchronously invokes `callback()` and returns its result.
	*/
	function catchOr(promiseOrValueCallback, callback) {
		try {
			const result = promiseOrValueCallback();
			return result instanceof Promise ? result.catch(callback) : result;
		} catch (error) {
			return callback(error);
		}
	}
	/** Checks for null or undefined. */
	function isNullOrUndefined(object) {
		return object === null || object === void 0;
	}
	/** Returns `collection` as an immutable List. */
	function asImmutableList(collection) {
		return immutable_1$15.List.isList(collection) ? collection : (0, immutable_1$15.List)(collection);
	}
	/** Constructs a compiler-caused Error. */
	function compilerError(message) {
		return Error(`Compiler caused error: ${message}.`);
	}
	/**
	* Returns a `compilerError()` indicating that the given `field` should have
	* been included but was not.
	*/
	function mandatoryError(field) {
		return compilerError(`Missing mandatory field ${field}`);
	}
	/** Constructs a host-caused Error. */
	function hostError(message) {
		return Error(`Compiler reported error: ${message}.`);
	}
	/** Constructs an error caused by an invalid value type. */
	function valueError(message, name) {
		return Error(name ? `$${name}: ${message}.` : `${message}.`);
	}
	var unsafePathToFileURL = url.pathToFileURL("~").pathname.endsWith("~");
	/** Converts a (possibly relative) path on the local filesystem to a URL. */
	function pathToUrlString(path$2) {
		if (p$9.isAbsolute(path$2)) return url.pathToFileURL(path$2).toString();
		let fileUrl = encodeURI(path$2).replace(/[#?]/g, encodeURIComponent);
		if (unsafePathToFileURL) fileUrl = fileUrl.replace(/%(5B|5D|5E|7C)/g, decodeURIComponent);
		else fileUrl = fileUrl.replace(/~/g, "%7E");
		if (process.platform === "win32") fileUrl = fileUrl.replace(/%5C/g, "/");
		return fileUrl;
	}
	/**
	* Like `url.fileURLToPath`, but returns the same result for Windows-style file
	* URLs on all platforms.
	*/
	function fileUrlToPathCrossPlatform(fileUrl) {
		const path$2 = url.fileURLToPath(fileUrl);
		return /^\/[A-Za-z]:\//.test(path$2) ? path$2.substring(1) : path$2;
	}
	/** Returns `path` without an extension, if it had one. */
	function withoutExtension$1(path$2) {
		const extension = p$9.extname(path$2);
		return path$2.substring(0, path$2.length - extension.length);
	}
	/** Converts a JS syntax string into a protobuf syntax enum. */
	function protofySyntax(syntax) {
		switch (syntax) {
			case "scss": return proto$5.Syntax.SCSS;
			case "indented": return proto$5.Syntax.INDENTED;
			case "css": return proto$5.Syntax.CSS;
			default: throw new Error(`Unknown syntax: "${syntax}"`);
		}
	}
	/** Returns whether `error` is a NodeJS-style exception with an error code. */
	function isErrnoException(error) {
		return error instanceof Error && ("errno" in error || "code" in error);
	}
	/**
	* Dart-style utility. See
	* http://go/dart-api/stable/2.8.4/dart-core/Map/putIfAbsent.html.
	*/
	function putIfAbsent(map$1, key, provider) {
		const val = map$1.get(key);
		if (val !== void 0) return val;
		else {
			const newVal = provider();
			map$1.set(key, newVal);
			return newVal;
		}
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/index.js
var require_value$1 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1$14 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var utils_1$17 = require_utils$3();
	/**
	* A SassScript value.
	*
	* All SassScript values are immutable.
	*
	* Concrete values (such as `SassColor`) are implemented as subclasses and get
	* instantiated as normal JS classes.
	*
	* Untyped values can be cast to particular types using `assert*()` functions,
	* which throw user-friendly error messages if they fail.
	*
	* All values, except `false` and `null`, count as `true`.
	*
	* All values can be used as lists. Maps count as lists of pairs, while all
	* other values count as single-value lists. Empty maps are equal to empty
	* lists.
	*/
	var Value$1 = class {
		/** Whether `this` counts as `true`. */
		get isTruthy() {
			return true;
		}
		/** Returns JS null if `this` is `sassNull`. Otherwise, returns `this`. */
		get realNull() {
			return this;
		}
		/** `this` as a list. */
		get asList() {
			return (0, immutable_1$14.List)([this]);
		}
		/** The separator for `this` as a list. */
		get separator() {
			return null;
		}
		/** Whether `this`, as a list, has brackets. */
		get hasBrackets() {
			return false;
		}
		get lengthAsList() {
			return 1;
		}
		/**
		* Converts `sassIndex` to a JS index into the array returned by `asList`.
		*
		* Sass indices start counting at 1, and may be negative in order to index
		* from the end of the list.
		*
		* `sassIndex` must be...
		* - a number, and
		* - an integer, and
		* - a valid index into `asList`.
		*
		* Otherwise, this throws an error.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		sassIndexToListIndex(sassIndex, name) {
			const index = sassIndex.assertNumber().assertInt();
			if (index === 0) throw Error("List index may not be 0.");
			if (Math.abs(index) > this.lengthAsList) throw (0, utils_1$17.valueError)(`Invalid index ${sassIndex} for a list with ${this.lengthAsList} elements.`, name);
			return index < 0 ? this.lengthAsList + index : index - 1;
		}
		/** Returns `this.asList.get(index)`. */
		get(index) {
			return index < 1 && index >= -1 ? this : void 0;
		}
		/**
		* Casts `this` to `SassBoolean`; throws if `this` isn't a boolean.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertBoolean(name) {
			throw (0, utils_1$17.valueError)(`${this} is not a boolean`, name);
		}
		/**
		* Casts `this` to `SassCalculation`; throws if `this` isn't a calculation.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertCalculation(name) {
			throw (0, utils_1$17.valueError)(`${this} is not a calculation`, name);
		}
		/**
		* Casts `this` to `SassColor`; throws if `this` isn't a color.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertColor(name) {
			throw (0, utils_1$17.valueError)(`${this} is not a color`, name);
		}
		/**
		* Casts `this` to `SassFunction`; throws if `this` isn't a function
		* reference.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertFunction(name) {
			throw (0, utils_1$17.valueError)(`${this} is not a function reference`, name);
		}
		/**
		* Casts `this` to `SassMixin`; throws if `this` isn't a mixin
		* reference.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertMixin(name) {
			throw (0, utils_1$17.valueError)(`${this} is not a mixin reference`, name);
		}
		/**
		* Casts `this` to `SassMap`; throws if `this` isn't a map.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertMap(name) {
			throw (0, utils_1$17.valueError)(`${this} is not a map`, name);
		}
		/**
		* Returns `this` as a `SassMap` if it counts as one (including empty lists),
		* or `null` if it does not.
		*/
		tryMap() {
			return null;
		}
		/**
		* Casts `this` to `SassString`; throws if `this` isn't a string.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertNumber(name) {
			throw (0, utils_1$17.valueError)(`${this} is not a number`, name);
		}
		/**
		* Casts `this` to `SassString`; throws if `this` isn't a string.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertString(name) {
			throw (0, utils_1$17.valueError)(`${this} is not a string`, name);
		}
	};
	exports.Value = Value$1;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/boolean.js
var require_boolean = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/boolean.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sassFalse = exports.sassTrue = exports.SassBooleanInternal = exports.SassBoolean = void 0;
	var immutable_1$13 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var index_1$9 = require_value$1();
	/**
	* Sass boolean.
	*
	* This is an abstract class that cannot be directly instantiated. Instead,
	* use the provided {@link sassTrue} and {@link sassFalse} singleton instances.
	*/
	var SassBoolean$1 = class extends index_1$9.Value {};
	exports.SassBoolean = SassBoolean$1;
	var trueHash = (0, immutable_1$13.hash)(true);
	var falseHash = (0, immutable_1$13.hash)(false);
	var SassBooleanInternal = class SassBooleanInternal extends SassBoolean$1 {
		valueInternal;
		static constructionAllowed = true;
		constructor(valueInternal) {
			super();
			this.valueInternal = valueInternal;
			if (!SassBooleanInternal.constructionAllowed) throw "new sass.types.Boolean() isn't allowed.\nUse sass.types.Boolean.TRUE or sass.types.Boolean.FALSE instead.";
			Object.freeze(this);
		}
		get value() {
			return this.valueInternal;
		}
		get isTruthy() {
			return this.value;
		}
		assertBoolean() {
			return this;
		}
		equals(other) {
			return this === other;
		}
		hashCode() {
			return this.value ? trueHash : falseHash;
		}
		toString() {
			return this.value ? "sassTrue" : "sassFalse";
		}
		static TRUE;
		static FALSE;
		getValue() {
			return this.value;
		}
	};
	exports.SassBooleanInternal = SassBooleanInternal;
	/** The singleton instance of SassScript true. */
	exports.sassTrue = new SassBooleanInternal(true);
	/** The singleton instance of SassScript false. */
	exports.sassFalse = new SassBooleanInternal(false);
	SassBooleanInternal.constructionAllowed = false;
	SassBooleanInternal.TRUE = exports.sassTrue;
	SassBooleanInternal.FALSE = exports.sassFalse;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/null.js
var require_null = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/null.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sassNull = exports.SassNull = void 0;
	var immutable_1$12 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var index_1$8 = require_value$1();
	var hashCode = (0, immutable_1$12.hash)(null);
	var SassNull = class SassNull extends index_1$8.Value {
		static constructionAllowed = true;
		constructor() {
			super();
			if (!SassNull.constructionAllowed) throw "new sass.types.Null() isn't allowed.\nUse sass.types.Null.NULL instead.";
			Object.freeze(this);
		}
		get isTruthy() {
			return false;
		}
		get realNull() {
			return null;
		}
		equals(other) {
			return this === other;
		}
		hashCode() {
			return hashCode;
		}
		toString() {
			return "sassNull";
		}
		static NULL;
	};
	exports.SassNull = SassNull;
	/** The singleton instance of SassScript null. */
	exports.sassNull = new SassNull();
	SassNull.constructionAllowed = false;
	SassNull.NULL = exports.sassNull;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/map.js
var require_map$2 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/map.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1$11 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var index_1$7 = require_value$1();
	var list_1$6 = require_list$1();
	/** A SassScript map */
	var SassMap$1 = class SassMap$1 extends index_1$7.Value {
		contentsInternal;
		/** Returns a map that contains `contents`. */
		constructor(contents) {
			super();
			this.contentsInternal = contents ?? (0, immutable_1$11.OrderedMap)();
		}
		/** The separator for `this`'s contents as a list. */
		get separator() {
			return this.contentsInternal.isEmpty() ? null : ",";
		}
		/** `this`'s contents. */
		get contents() {
			return this.contentsInternal;
		}
		/**
		* Returns an immutable list of `contents`'s keys and values as two-element
		* `SassList`s.
		*/
		get asList() {
			const list = [];
			for (const entry of this.contents.entries()) list.push(new list_1$6.SassList(entry, { separator: " " }));
			return (0, immutable_1$11.List)(list);
		}
		get lengthAsList() {
			return this.contentsInternal.size;
		}
		get(indexOrKey) {
			if (indexOrKey instanceof index_1$7.Value) return this.contentsInternal.get(indexOrKey);
			else {
				const entry = this.contentsInternal.entrySeq().get(Math.floor(indexOrKey));
				return entry ? new list_1$6.SassList(entry, { separator: " " }) : void 0;
			}
		}
		assertMap() {
			return this;
		}
		tryMap() {
			return this;
		}
		equals(other) {
			if (other instanceof list_1$6.SassList && this.contents.size === 0 && other.asList.size === 0) return true;
			if (!(other instanceof SassMap$1) || this.contents.size !== other.contents.size) return false;
			for (const [key, value] of this.contents.entries()) {
				const otherValue = other.contents.get(key);
				if (otherValue === void 0 || !otherValue.equals(value)) return false;
			}
			return true;
		}
		hashCode() {
			return this.contents.isEmpty() ? new list_1$6.SassList().hashCode() : this.contents.reduce((accumulator, value, key) => accumulator ^ value.hashCode() ^ key.hashCode(), 0);
		}
		toString() {
			let string = "(";
			string += Array.from(this.contents.entries(), ([key, value]) => `${key}: ${value}`).join(", ");
			string += ")";
			return string;
		}
	};
	exports.SassMap = SassMap$1;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/list.js
var require_list$1 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/list.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1$10 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var index_1$6 = require_value$1();
	var map_1$13 = require_map$2();
	var utils_1$16 = require_utils$3();
	var emptyListHashCode = (0, immutable_1$10.hash)([]);
	/** A SassScript list. */
	var SassList$1 = class SassList$1 extends index_1$6.Value {
		contentsInternal;
		separatorInternal;
		hasBracketsInternal;
		constructor(contentsOrOptions, options) {
			super();
			if ((0, immutable_1$10.isList)(contentsOrOptions) || Array.isArray(contentsOrOptions)) this.contentsInternal = (0, utils_1$16.asImmutableList)(contentsOrOptions);
			else {
				this.contentsInternal = (0, immutable_1$10.List)();
				options = contentsOrOptions;
			}
			if (this.contentsInternal.size > 1 && options?.separator === null) throw Error("Non-null separator required for SassList with more than one element.");
			this.separatorInternal = options?.separator === void 0 ? "," : options.separator;
			this.hasBracketsInternal = options?.brackets ?? false;
		}
		get asList() {
			return this.contentsInternal;
		}
		/** Whether `this` has brackets. */
		get hasBrackets() {
			return this.hasBracketsInternal;
		}
		/** `this`'s list separator. */
		get separator() {
			return this.separatorInternal;
		}
		get lengthAsList() {
			return this.contentsInternal.size;
		}
		get(index) {
			return this.contentsInternal.get(index);
		}
		assertList() {
			return this;
		}
		assertMap(name) {
			if (this.contentsInternal.isEmpty()) return new map_1$13.SassMap();
			throw (0, utils_1$16.valueError)(`${this} is not a map`, name);
		}
		/**
		* If `this` is empty, returns an empty OrderedMap.
		*
		* Otherwise, returns null.
		*/
		tryMap() {
			return this.contentsInternal.isEmpty() ? new map_1$13.SassMap() : null;
		}
		equals(other) {
			if ((other instanceof SassList$1 || other instanceof map_1$13.SassMap) && this.contentsInternal.isEmpty() && other.asList.isEmpty()) return true;
			if (!(other instanceof SassList$1) || this.hasBrackets !== other.hasBrackets || this.separator !== other.separator) return false;
			return this.contentsInternal.equals(other.asList);
		}
		hashCode() {
			return this.contentsInternal.isEmpty() ? emptyListHashCode : this.contentsInternal.hashCode() ^ (0, immutable_1$10.hash)(this.hasBrackets) ^ (0, immutable_1$10.hash)(this.separator);
		}
		toString() {
			let string = "";
			if (this.hasBrackets) string += "[";
			string += `${this.contentsInternal.join(this.separator === " " || this.separator === null ? " " : `${this.separator} `)}`;
			if (this.hasBrackets) string += "]";
			return string;
		}
	};
	exports.SassList = SassList$1;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/argument-list.js
var require_argument_list = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/argument-list.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1$9 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var list_1$5 = require_list$1();
	var SassArgumentList$1 = class extends list_1$5.SassList {
		/**
		* The `FunctionCallRequest`-scoped ID of this argument list, used to tell the
		* compiler which argument lists have had their keywords accessed during a
		* function call.
		*
		* The special undefined indicates an argument list constructed in the host.
		*
		* This is marked as public so that the protofier can access it, but it's not
		* part of the package's public API and should not be accessed by user code.
		* It may be renamed or removed without warning in the future.
		*/
		id;
		/**
		* If this argument list is constructed in the compiler, this is the unique
		* context that the host uses to determine which compilation this argument
		* list belongs to.
		*
		* This is marked as public so that the protofier can access it, but it's not
		* part of the package's public API and should not be accessed by user code.
		* It may be renamed or removed without warning in the future.
		*/
		compileContext;
		/**
		* The argument list's keywords. This isn't exposed directly so that we can
		* set `keywordsAccessed` when the user reads it.
		*
		* This is marked as public so that the protofier can access it, but it's not
		* part of the package's public API and should not be accessed by user code.
		* It may be renamed or removed without warning in the future.
		*/
		keywordsInternal;
		_keywordsAccessed = false;
		/**
		* Whether the `keywords` getter has been accessed.
		*
		* This is marked as public so that the protofier can access it, but it's not
		* part of the package's public API and should not be accessed by user code.
		* It may be renamed or removed without warning in the future.
		*/
		get keywordsAccessed() {
			return this._keywordsAccessed;
		}
		get keywords() {
			this._keywordsAccessed = true;
			return this.keywordsInternal;
		}
		constructor(contents, keywords, separator, id, compileContext) {
			super(contents, { separator });
			this.keywordsInternal = (0, immutable_1$9.isOrderedMap)(keywords) ? keywords : (0, immutable_1$9.OrderedMap)(keywords);
			this.id = id;
			this.compileContext = compileContext;
		}
	};
	exports.SassArgumentList = SassArgumentList$1;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/version.js
var require_version = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/version.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Version$1 = class Version$1 {
		major;
		minor;
		patch;
		constructor(major, minor, patch) {
			this.major = major;
			this.minor = minor;
			this.patch = patch;
		}
		static parse(version$1) {
			const match = version$1.match(/^(\d+)\.(\d+)\.(\d+)$/);
			if (match === null) throw new Error(`Invalid version ${version$1}`);
			return new Version$1(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
		}
		toString() {
			return `${this.major}.${this.minor}.${this.patch}`;
		}
	};
	exports.Version = Version$1;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/vendor/deprecations.js
var require_deprecations$1 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/vendor/deprecations.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var version_1$2 = require_version();
	exports.deprecations = {
		"call-string": {
			id: "call-string",
			description: "Passing a string directly to meta.call().",
			status: "active",
			deprecatedIn: new version_1$2.Version(0, 0, 0),
			obsoleteIn: null
		},
		elseif: {
			id: "elseif",
			description: "@elseif.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 3, 2),
			obsoleteIn: null
		},
		"moz-document": {
			id: "moz-document",
			description: "@-moz-document.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 7, 2),
			obsoleteIn: null
		},
		"relative-canonical": {
			id: "relative-canonical",
			description: "Imports using relative canonical URLs.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 14, 2),
			obsoleteIn: null
		},
		"new-global": {
			id: "new-global",
			description: "Declaring new variables with !global.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 17, 2),
			obsoleteIn: null
		},
		"color-module-compat": {
			id: "color-module-compat",
			description: "Using color module functions in place of plain CSS functions.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 23, 0),
			obsoleteIn: null
		},
		"slash-div": {
			id: "slash-div",
			description: "/ operator for division.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 33, 0),
			obsoleteIn: null
		},
		"bogus-combinators": {
			id: "bogus-combinators",
			description: "Leading, trailing, and repeated combinators.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 54, 0),
			obsoleteIn: null
		},
		"strict-unary": {
			id: "strict-unary",
			description: "Ambiguous + and - operators.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 55, 0),
			obsoleteIn: null
		},
		"function-units": {
			id: "function-units",
			description: "Passing invalid units to built-in functions.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 56, 0),
			obsoleteIn: null
		},
		"duplicate-var-flags": {
			id: "duplicate-var-flags",
			description: "Using !default or !global multiple times for one variable.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 62, 0),
			obsoleteIn: null
		},
		"null-alpha": {
			id: "null-alpha",
			description: "Passing null as alpha in the $PLATFORM API.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 62, 3),
			obsoleteIn: null
		},
		"abs-percent": {
			id: "abs-percent",
			description: "Passing percentages to the Sass abs() function.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 65, 0),
			obsoleteIn: null
		},
		"fs-importer-cwd": {
			id: "fs-importer-cwd",
			description: "Using the current working directory as an implicit load path.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 73, 0),
			obsoleteIn: null
		},
		"css-function-mixin": {
			id: "css-function-mixin",
			description: "Function and mixin names beginning with --.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 76, 0),
			obsoleteIn: null
		},
		"mixed-decls": {
			id: "mixed-decls",
			description: "Declarations after or between nested rules.",
			status: "obsolete",
			deprecatedIn: new version_1$2.Version(1, 77, 7),
			obsoleteIn: new version_1$2.Version(1, 92, 0)
		},
		"feature-exists": {
			id: "feature-exists",
			description: "meta.feature-exists",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 78, 0),
			obsoleteIn: null
		},
		"color-4-api": {
			id: "color-4-api",
			description: "Certain uses of built-in sass:color functions.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 79, 0),
			obsoleteIn: null
		},
		"color-functions": {
			id: "color-functions",
			description: "Using global color functions instead of sass:color.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 79, 0),
			obsoleteIn: null
		},
		"legacy-js-api": {
			id: "legacy-js-api",
			description: "Legacy JS API.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 79, 0),
			obsoleteIn: null
		},
		import: {
			id: "import",
			description: "@import rules.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 80, 0),
			obsoleteIn: null
		},
		"global-builtin": {
			id: "global-builtin",
			description: "Global built-in functions that are available in sass: modules.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 80, 0),
			obsoleteIn: null
		},
		"type-function": {
			id: "type-function",
			description: "Functions named \"type\".",
			status: "obsolete",
			deprecatedIn: new version_1$2.Version(1, 86, 0),
			obsoleteIn: new version_1$2.Version(1, 92, 0)
		},
		"compile-string-relative-url": {
			id: "compile-string-relative-url",
			description: "Passing a relative url to compileString().",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 88, 0),
			obsoleteIn: null
		},
		"misplaced-rest": {
			id: "misplaced-rest",
			description: "A rest parameter before a positional or named parameter.",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 91, 0),
			obsoleteIn: null
		},
		"with-private": {
			id: "with-private",
			description: "Configuring private variables in @use, @forward, or load-css().",
			status: "active",
			deprecatedIn: new version_1$2.Version(1, 92, 0),
			obsoleteIn: null
		},
		"user-authored": {
			id: "user-authored",
			status: "user",
			deprecatedIn: null,
			obsoleteIn: null
		}
	};
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/deprecations.js
var require_deprecations = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/deprecations.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.activeDeprecationOptions = exports.deprecations = void 0;
	exports.getDeprecationIds = getDeprecationIds;
	exports.warnForHostSideDeprecation = warnForHostSideDeprecation;
	var version_1$1 = require_version();
	var deprecations_1$6 = require_deprecations$1();
	Object.defineProperty(exports, "deprecations", {
		enumerable: true,
		get: function() {
			return deprecations_1$6.deprecations;
		}
	});
	/**
	* Converts a mixed array of deprecations, IDs, and versions to an array of IDs
	* that's ready to include in a CompileRequest.
	*/
	function getDeprecationIds(arr) {
		return arr.map((item) => {
			if (item instanceof version_1$1.Version) return item.toString();
			else if (typeof item === "string") return item;
			return item.id;
		});
	}
	/**
	* Map between active compilations and the deprecation options they use.
	*
	* This is used to determine which options to use when handling host-side
	* deprecation warnings that aren't explicitly tied to a particular compilation.
	*/
	exports.activeDeprecationOptions = /* @__PURE__ */ new Map();
	/**
	* Handles a host-side deprecation warning, either emitting a warning, throwing
	* an error, or doing nothing depending on the deprecation options used.
	*
	* If no specific deprecation options are passed here, then options will be
	* determined based on the options of the active compilations.
	*/
	function warnForHostSideDeprecation(message, deprecation, options) {
		if (deprecation.status === "future" && !isEnabledFuture(deprecation, options)) return;
		const fullMessage = `Deprecation [${deprecation.id}]: ${message}`;
		if (isFatal(deprecation, options)) throw Error(fullMessage);
		if (!isSilent(deprecation, options)) console.warn(fullMessage);
	}
	/**
	* Checks whether the given deprecation is included in the given list of silent
	* deprecations or is silenced by at least one active compilation.
	*/
	function isSilent(deprecation, options) {
		if (!options) {
			for (const potentialOptions of exports.activeDeprecationOptions.values()) if (isSilent(deprecation, potentialOptions)) return true;
			return false;
		}
		return getDeprecationIds(options.silenceDeprecations ?? []).includes(deprecation.id);
	}
	/**
	* Checks whether the given deprecation is included in the given list of future
	* deprecations that should be enabled or is enabled in all active compilations.
	*/
	function isEnabledFuture(deprecation, options) {
		if (!options) {
			for (const potentialOptions of exports.activeDeprecationOptions.values()) if (!isEnabledFuture(deprecation, potentialOptions)) return false;
			return exports.activeDeprecationOptions.size > 0;
		}
		return getDeprecationIds(options.futureDeprecations ?? []).includes(deprecation.id);
	}
	/**
	* Checks whether the given deprecation is included in the given list of
	* fatal deprecations or is marked as fatal in all active compilations.
	*/
	function isFatal(deprecation, options) {
		if (!options) {
			for (const potentialOptions of exports.activeDeprecationOptions.values()) if (!isFatal(deprecation, potentialOptions)) return false;
			return exports.activeDeprecationOptions.size > 0;
		}
		const versionNumber = deprecation.deprecatedIn === null ? null : deprecation.deprecatedIn.major * 1e6 + deprecation.deprecatedIn.minor * 1e3 + deprecation.deprecatedIn.patch;
		for (const fatal of options.fatalDeprecations ?? []) if (fatal instanceof version_1$1.Version) {
			if (versionNumber === null) continue;
			if (versionNumber <= fatal.major * 1e6 + fatal.minor * 1e3 + fatal.patch) return true;
		} else if (typeof fatal === "string") {
			if (fatal === deprecation.id) return true;
		} else if (fatal.id === deprecation.id) return true;
		return false;
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/utils.js
var require_utils$2 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/utils.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.precision = void 0;
	exports.fuzzyEquals = fuzzyEquals;
	exports.fuzzyHashCode = fuzzyHashCode;
	exports.fuzzyLessThan = fuzzyLessThan;
	exports.fuzzyLessThanOrEquals = fuzzyLessThanOrEquals;
	exports.fuzzyGreaterThan = fuzzyGreaterThan;
	exports.fuzzyGreaterThanOrEquals = fuzzyGreaterThanOrEquals;
	exports.fuzzyIsInt = fuzzyIsInt;
	exports.fuzzyAsInt = fuzzyAsInt;
	exports.fuzzyRound = fuzzyRound;
	exports.fuzzyInRange = fuzzyInRange;
	exports.fuzzyAssertInRange = fuzzyAssertInRange;
	exports.positiveMod = positiveMod;
	var immutable_1$8 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var utils_1$15 = require_utils$3();
	/** The precision of Sass numbers. */
	exports.precision = 10;
	var epsilon = 10 ** (-exports.precision - 1);
	/** Whether `num1` and `num2` are equal within `epsilon`. */
	function fuzzyEquals(num1, num2) {
		return Math.abs(num1 - num2) < epsilon;
	}
	/**
	* Returns a hash code for `num`.
	*
	* Two numbers that `fuzzyEquals` each other must have the same hash code.
	*/
	function fuzzyHashCode(num) {
		return !isFinite(num) || isNaN(num) ? (0, immutable_1$8.hash)(num) : (0, immutable_1$8.hash)(Math.round(num / epsilon));
	}
	/** Whether `num1` < `num2`, within `epsilon`. */
	function fuzzyLessThan(num1, num2) {
		return num1 < num2 && !fuzzyEquals(num1, num2);
	}
	/** Whether `num1` <= `num2`, within `epsilon`. */
	function fuzzyLessThanOrEquals(num1, num2) {
		return num1 < num2 || fuzzyEquals(num1, num2);
	}
	/** Whether `num1` > `num2`, within `epsilon`. */
	function fuzzyGreaterThan(num1, num2) {
		return num1 > num2 && !fuzzyEquals(num1, num2);
	}
	/** Whether `num1` >= `num2`, within `epsilon`. */
	function fuzzyGreaterThanOrEquals(num1, num2) {
		return num1 > num2 || fuzzyEquals(num1, num2);
	}
	/** Whether `num` `fuzzyEquals` an integer. */
	function fuzzyIsInt(num) {
		return !isFinite(num) || isNaN(num) ? false : fuzzyEquals(Math.abs(num - .5) % 1, .5);
	}
	/**
	* If `num` `fuzzyIsInt`, returns it as an integer. Otherwise, returns `null`.
	*/
	function fuzzyAsInt(num) {
		return fuzzyIsInt(num) ? Math.round(num) : null;
	}
	/**
	* Rounds `num` to the nearest integer.
	*
	* If `num` `fuzzyEquals` `x.5`, rounds away from zero.
	*/
	function fuzzyRound(num) {
		if (num > 0) return fuzzyLessThan(num % 1, .5) ? Math.floor(num) : Math.ceil(num);
		else return fuzzyGreaterThan(num % 1, -.5) ? Math.ceil(num) : Math.floor(num);
	}
	/**
	* Returns `num` if it's within `min` and `max`, or `null` if it's not.
	*
	* If `num` `fuzzyEquals` `min` or `max`, it gets clamped to that value.
	*/
	function fuzzyInRange(num, min$1, max$2) {
		if (fuzzyEquals(num, min$1)) return min$1;
		if (fuzzyEquals(num, max$2)) return max$2;
		if (num > min$1 && num < max$2) return num;
		return null;
	}
	/**
	* Returns `num` if it's within `min` and `max`. Otherwise, throws an error.
	*
	* If `num` `fuzzyEquals` `min` or `max`, it gets clamped to that value.
	*
	* If `name` is provided, it is used as the parameter name for error reporting.
	*/
	function fuzzyAssertInRange(num, min$1, max$2, name) {
		if (fuzzyEquals(num, min$1)) return min$1;
		if (fuzzyEquals(num, max$2)) return max$2;
		if (num > min$1 && num < max$2) return num;
		throw (0, utils_1$15.valueError)(`${num} must be between ${min$1} and ${max$2}`, name);
	}
	/** Returns `dividend % modulus`, but always in the range `[0, modulus)`. */
	function positiveMod(dividend, modulus) {
		const result = dividend % modulus;
		return result < 0 ? result + modulus : result;
	}
}) });

//#endregion
//#region node_modules/colorjs.io/dist/color.cjs
var require_color$2 = /* @__PURE__ */ __commonJS({ "node_modules/colorjs.io/dist/color.cjs": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function multiplyMatrices(A, B) {
		let m$1 = A.length;
		if (!Array.isArray(A[0])) A = [A];
		if (!Array.isArray(B[0])) B = B.map((x) => [x]);
		let p$10 = B[0].length;
		let B_cols = B[0].map((_, i) => B.map((x) => x[i]));
		let product = A.map((row) => B_cols.map((col) => {
			let ret = 0;
			if (!Array.isArray(row)) {
				for (let c$1 of col) ret += row * c$1;
				return ret;
			}
			for (let i = 0; i < row.length; i++) ret += row[i] * (col[i] || 0);
			return ret;
		}));
		if (m$1 === 1) product = product[0];
		if (p$10 === 1) return product.map((x) => x[0]);
		return product;
	}
	/**
	* Various utility functions
	*/
	/**
	* Check if a value is a string (including a String object)
	* @param {*} str - Value to check
	* @returns {boolean}
	*/
	function isString(str) {
		return type(str) === "string";
	}
	/**
	* Determine the internal JavaScript [[Class]] of an object.
	* @param {*} o - Value to check
	* @returns {string}
	*/
	function type(o) {
		return (Object.prototype.toString.call(o).match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
	}
	function serializeNumber(n$2, { precision, unit }) {
		if (isNone(n$2)) return "none";
		return toPrecision(n$2, precision) + (unit ?? "");
	}
	/**
	* Check if a value corresponds to a none argument
	* @param {*} n - Value to check
	* @returns {boolean}
	*/
	function isNone(n$2) {
		return Number.isNaN(n$2) || n$2 instanceof Number && n$2?.none;
	}
	/**
	* Replace none values with 0
	*/
	function skipNone(n$2) {
		return isNone(n$2) ? 0 : n$2;
	}
	/**
	* Round a number to a certain number of significant digits
	* @param {number} n - The number to round
	* @param {number} precision - Number of significant digits
	*/
	function toPrecision(n$2, precision) {
		if (n$2 === 0) return 0;
		let integer = ~~n$2;
		let digits = 0;
		if (integer && precision) digits = ~~Math.log10(Math.abs(integer)) + 1;
		const multiplier = 10 ** (precision - digits);
		return Math.floor(n$2 * multiplier + .5) / multiplier;
	}
	var angleFactor = {
		deg: 1,
		grad: .9,
		rad: 180 / Math.PI,
		turn: 360
	};
	/**
	* Parse a CSS function, regardless of its name and arguments
	* @param String str String to parse
	* @return {{name, args, rawArgs}}
	*/
	function parseFunction(str) {
		if (!str) return;
		str = str.trim();
		const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
		const isNumberRegex = /^-?[\d.]+$/;
		const unitValueRegex = /%|deg|g?rad|turn$/;
		const singleArgument = /\/?\s*(none|[-\w.]+(?:%|deg|g?rad|turn)?)/g;
		let parts = str.match(isFunctionRegex);
		if (parts) {
			let args = [];
			parts[2].replace(singleArgument, ($0, rawArg) => {
				let match = rawArg.match(unitValueRegex);
				let arg = rawArg;
				if (match) {
					let unit = match[0];
					let unitlessArg = arg.slice(0, -unit.length);
					if (unit === "%") {
						arg = /* @__PURE__ */ new Number(unitlessArg / 100);
						arg.type = "<percentage>";
					} else {
						arg = new Number(unitlessArg * angleFactor[unit]);
						arg.type = "<angle>";
						arg.unit = unit;
					}
				} else if (isNumberRegex.test(arg)) {
					arg = new Number(arg);
					arg.type = "<number>";
				} else if (arg === "none") {
					arg = /* @__PURE__ */ new Number(NaN);
					arg.none = true;
				}
				if ($0.startsWith("/")) {
					arg = arg instanceof Number ? arg : new Number(arg);
					arg.alpha = true;
				}
				if (typeof arg === "object" && arg instanceof Number) arg.raw = rawArg;
				args.push(arg);
			});
			return {
				name: parts[1].toLowerCase(),
				rawName: parts[1],
				rawArgs: parts[2],
				args
			};
		}
	}
	function last$2(arr) {
		return arr[arr.length - 1];
	}
	function interpolate(start, end, p$10) {
		if (isNaN(start)) return end;
		if (isNaN(end)) return start;
		return start + (end - start) * p$10;
	}
	function interpolateInv(start, end, value) {
		return (value - start) / (end - start);
	}
	function mapRange(from$1, to$1, value) {
		return interpolate(to$1[0], to$1[1], interpolateInv(from$1[0], from$1[1], value));
	}
	function parseCoordGrammar(coordGrammars) {
		return coordGrammars.map((coordGrammar$1) => {
			return coordGrammar$1.split("|").map((type$1) => {
				type$1 = type$1.trim();
				let range$2 = type$1.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
				if (range$2) {
					let ret = new String(range$2[1]);
					ret.range = [+range$2[2], +range$2[3]];
					return ret;
				}
				return type$1;
			});
		});
	}
	/**
	* Clamp value between the minimum and maximum
	* @param {number} min minimum value to return
	* @param {number} val the value to return if it is between min and max
	* @param {number} max maximum value to return
	* @returns number
	*/
	function clamp$1(min$1, val, max$2) {
		return Math.max(Math.min(max$2, val), min$1);
	}
	/**
	* Copy sign of one value to another.
	* @param {number} - to number to copy sign to
	* @param {number} - from number to copy sign from
	* @returns number
	*/
	function copySign(to$1, from$1) {
		return Math.sign(to$1) === Math.sign(from$1) ? to$1 : -to$1;
	}
	/**
	* Perform pow on a signed number and copy sign to result
	* @param {number} - base the base number
	* @param {number} - exp the exponent
	* @returns number
	*/
	function spow(base, exp) {
		return copySign(Math.abs(base) ** exp, base);
	}
	/**
	* Perform a divide, but return zero if the numerator is zero
	* @param {number} n - the numerator
	* @param {number} d - the denominator
	* @returns number
	*/
	function zdiv(n$2, d$1) {
		return d$1 === 0 ? 0 : n$2 / d$1;
	}
	/**
	* Perform a bisect on a sorted list and locate the insertion point for
	* a value in arr to maintain sorted order.
	* @param {number[]} arr - array of sorted numbers
	* @param {number} value - value to find insertion point for
	* @param {number} lo - used to specify a the low end of a subset of the list
	* @param {number} hi - used to specify a the high end of a subset of the list
	* @returns number
	*/
	function bisectLeft(arr, value, lo = 0, hi = arr.length) {
		while (lo < hi) {
			const mid = lo + hi >> 1;
			if (arr[mid] < value) lo = mid + 1;
			else hi = mid;
		}
		return lo;
	}
	var util$2 = /* @__PURE__ */ Object.freeze({
		__proto__: null,
		bisectLeft,
		clamp: clamp$1,
		copySign,
		interpolate,
		interpolateInv,
		isNone,
		isString,
		last: last$2,
		mapRange,
		multiplyMatrices,
		parseCoordGrammar,
		parseFunction,
		serializeNumber,
		skipNone,
		spow,
		toPrecision,
		type,
		zdiv
	});
	/**
	* A class for adding deep extensibility to any piece of JS code
	*/
	var Hooks = class {
		add(name, callback, first$1) {
			if (typeof arguments[0] != "string") {
				for (var name in arguments[0]) this.add(name, arguments[0][name], arguments[1]);
				return;
			}
			(Array.isArray(name) ? name : [name]).forEach(function(name$1) {
				this[name$1] = this[name$1] || [];
				if (callback) this[name$1][first$1 ? "unshift" : "push"](callback);
			}, this);
		}
		run(name, env) {
			this[name] = this[name] || [];
			this[name].forEach(function(callback) {
				callback.call(env && env.context ? env.context : env, env);
			});
		}
	};
	/**
	* The instance of {@link Hooks} used throughout Color.js
	*/
	var hooks = new Hooks();
	var defaults = {
		gamut_mapping: "css",
		precision: 5,
		deltaE: "76",
		verbose: globalThis?.process?.env?.NODE_ENV?.toLowerCase() !== "test",
		warn: function warn(msg) {
			if (this.verbose) globalThis?.console?.warn?.(msg);
		}
	};
	var WHITES = {
		D50: [
			.3457 / .3585,
			1,
			.2958 / .3585
		],
		D65: [
			.3127 / .329,
			1,
			.3583 / .329
		]
	};
	function getWhite(name) {
		if (Array.isArray(name)) return name;
		return WHITES[name];
	}
	function adapt$2(W1, W2, XYZ, options = {}) {
		W1 = getWhite(W1);
		W2 = getWhite(W2);
		if (!W1 || !W2) throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
		if (W1 === W2) return XYZ;
		let env = {
			W1,
			W2,
			XYZ,
			options
		};
		hooks.run("chromatic-adaptation-start", env);
		if (!env.M) {
			if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) env.M = [
				[
					1.0479297925449969,
					.022946870601609652,
					-.05019226628920524
				],
				[
					.02962780877005599,
					.9904344267538799,
					-.017073799063418826
				],
				[
					-.009243040646204504,
					.015055191490298152,
					.7518742814281371
				]
			];
			else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) env.M = [
				[
					.955473421488075,
					-.02309845494876471,
					.06325924320057072
				],
				[
					-.0283697093338637,
					1.0099953980813041,
					.021041441191917323
				],
				[
					.012314014864481998,
					-.020507649298898964,
					1.330365926242124
				]
			];
		}
		hooks.run("chromatic-adaptation-end", env);
		if (env.M) return multiplyMatrices(env.M, env.XYZ);
		else throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
	}
	var noneTypes = new Set([
		"<number>",
		"<percentage>",
		"<angle>"
	]);
	/**
	* Validates the coordinates of a color against a format's coord grammar and
	* maps the coordinates to the range or refRange of the coordinates.
	* @param {ColorSpace} space - Colorspace the coords are in
	* @param {object} format - the format object to validate against
	* @param {string} name - the name of the color function. e.g. "oklab" or "color"
	* @returns {object[]} - an array of type metadata for each coordinate
	*/
	function coerceCoords(space, format, name, coords) {
		return Object.entries(space.coords).map(([id, coordMeta], i) => {
			let coordGrammar$1 = format.coordGrammar[i];
			let arg = coords[i];
			let providedType = arg?.type;
			let type$1;
			if (arg.none) type$1 = coordGrammar$1.find((c$1) => noneTypes.has(c$1));
			else type$1 = coordGrammar$1.find((c$1) => c$1 == providedType);
			if (!type$1) {
				let coordName = coordMeta.name || id;
				throw new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);
			}
			let fromRange = type$1.range;
			if (providedType === "<percentage>") fromRange ||= [0, 1];
			let toRange = coordMeta.range || coordMeta.refRange;
			if (fromRange && toRange) coords[i] = mapRange(fromRange, toRange, coords[i]);
			return type$1;
		});
	}
	/**
	* Convert a CSS Color string to a color object
	* @param {string} str
	* @param {object} [options]
	* @param {object} [options.meta] - Object for additional information about the parsing
	* @returns {Color}
	*/
	function parse(str, { meta } = {}) {
		let env = { "str": String(str)?.trim() };
		hooks.run("parse-start", env);
		if (env.color) return env.color;
		env.parsed = parseFunction(env.str);
		if (env.parsed) {
			let name = env.parsed.name;
			if (name === "color") {
				let id = env.parsed.args.shift();
				let alternateId = id.startsWith("--") ? id.substring(2) : `--${id}`;
				let ids = [id, alternateId];
				let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
				for (let space of ColorSpace.all) {
					let colorSpec = space.getFormat("color");
					if (colorSpec) {
						if (ids.includes(colorSpec.id) || colorSpec.ids?.filter((specId) => ids.includes(specId)).length) {
							const coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);
							let types$1;
							if (colorSpec.coordGrammar) types$1 = coerceCoords(space, colorSpec, "color", coords);
							if (meta) Object.assign(meta, {
								formatId: "color",
								types: types$1
							});
							if (colorSpec.id.startsWith("--") && !id.startsWith("--")) defaults.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. Use prefixed color(${colorSpec.id}) instead of color(${id}).`);
							if (id.startsWith("--") && !colorSpec.id.startsWith("--")) defaults.warn(`${space.name} is a standard space and supported in the CSS spec. Use color(${colorSpec.id}) instead of prefixed color(${id}).`);
							return {
								spaceId: space.id,
								coords,
								alpha
							};
						}
					}
				}
				let didYouMean = "";
				let registryId = id in ColorSpace.registry ? id : alternateId;
				if (registryId in ColorSpace.registry) {
					let cssId = ColorSpace.registry[registryId].formats?.color?.id;
					if (cssId) didYouMean = `Did you mean color(${cssId})?`;
				}
				throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
			} else for (let space of ColorSpace.all) {
				let format = space.getFormat(name);
				if (format && format.type === "function") {
					let alpha = 1;
					if (format.lastAlpha || last$2(env.parsed.args).alpha) alpha = env.parsed.args.pop();
					let coords = env.parsed.args;
					let types$1;
					if (format.coordGrammar) types$1 = coerceCoords(space, format, name, coords);
					if (meta) Object.assign(meta, {
						formatId: format.name,
						types: types$1
					});
					return {
						spaceId: space.id,
						coords,
						alpha
					};
				}
			}
		} else for (let space of ColorSpace.all) for (let formatId in space.formats) {
			let format = space.formats[formatId];
			if (format.type !== "custom") continue;
			if (format.test && !format.test(env.str)) continue;
			let color = format.parse(env.str);
			if (color) {
				color.alpha ??= 1;
				if (meta) meta.formatId = formatId;
				return color;
			}
		}
		throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
	}
	/**
	* Resolves a color reference (object or string) to a plain color object
	* @param {Color | {space, coords, alpha} | string | Array<Color | {space, coords, alpha} | string> } color
	* @returns {{space, coords, alpha} | Array<{space, coords, alpha}}>
	*/
	function getColor(color) {
		if (Array.isArray(color)) return color.map(getColor);
		if (!color) throw new TypeError("Empty color reference");
		if (isString(color)) color = parse(color);
		let space = color.space || color.spaceId;
		if (!(space instanceof ColorSpace)) color.space = ColorSpace.get(space);
		if (color.alpha === void 0) color.alpha = 1;
		return color;
	}
	var $7 = 75e-6;
	/**
	* Class to represent a color space
	*/
	var ColorSpace = class ColorSpace {
		constructor(options) {
			this.id = options.id;
			this.name = options.name;
			this.base = options.base ? ColorSpace.get(options.base) : null;
			this.aliases = options.aliases;
			if (this.base) {
				this.fromBase = options.fromBase;
				this.toBase = options.toBase;
			}
			let coords = options.coords ?? this.base.coords;
			for (let name in coords) if (!("name" in coords[name])) coords[name].name = name;
			this.coords = coords;
			this.white = getWhite(options.white ?? this.base.white ?? "D65");
			this.formats = options.formats ?? {};
			for (let name in this.formats) {
				let format = this.formats[name];
				format.type ||= "function";
				format.name ||= name;
			}
			if (!this.formats.color?.id) this.formats.color = {
				...this.formats.color ?? {},
				id: options.cssId || this.id
			};
			if (options.gamutSpace) this.gamutSpace = options.gamutSpace === "self" ? this : ColorSpace.get(options.gamutSpace);
			else if (this.isPolar) this.gamutSpace = this.base;
			else this.gamutSpace = this;
			if (this.gamutSpace.isUnbounded) this.inGamut = (coords$1, options$1) => {
				return true;
			};
			this.referred = options.referred;
			Object.defineProperty(this, "path", {
				value: getPath(this).reverse(),
				writable: false,
				enumerable: true,
				configurable: true
			});
			hooks.run("colorspace-init-end", this);
		}
		inGamut(coords, { epsilon: epsilon$1 = $7 } = {}) {
			if (!this.equals(this.gamutSpace)) {
				coords = this.to(this.gamutSpace, coords);
				return this.gamutSpace.inGamut(coords, { epsilon: epsilon$1 });
			}
			let coordMeta = Object.values(this.coords);
			return coords.every((c$1, i) => {
				let meta = coordMeta[i];
				if (meta.type !== "angle" && meta.range) {
					if (Number.isNaN(c$1)) return true;
					let [min$1, max$2] = meta.range;
					return (min$1 === void 0 || c$1 >= min$1 - epsilon$1) && (max$2 === void 0 || c$1 <= max$2 + epsilon$1);
				}
				return true;
			});
		}
		get isUnbounded() {
			return Object.values(this.coords).every((coord) => !("range" in coord));
		}
		get cssId() {
			return this.formats?.color?.id || this.id;
		}
		get isPolar() {
			for (let id in this.coords) if (this.coords[id].type === "angle") return true;
			return false;
		}
		getFormat(format) {
			if (typeof format === "object") {
				format = processFormat(format, this);
				return format;
			}
			let ret;
			if (format === "default") ret = Object.values(this.formats)[0];
			else ret = this.formats[format];
			if (ret) {
				ret = processFormat(ret, this);
				return ret;
			}
			return null;
		}
		/**
		* Check if this color space is the same as another color space reference.
		* Allows proxying color space objects and comparing color spaces with ids.
		* @param {string | ColorSpace} space ColorSpace object or id to compare to
		* @returns {boolean}
		*/
		equals(space) {
			if (!space) return false;
			return this === space || this.id === space || this.id === space.id;
		}
		to(space, coords) {
			if (arguments.length === 1) {
				const color = getColor(space);
				[space, coords] = [color.space, color.coords];
			}
			space = ColorSpace.get(space);
			if (this.equals(space)) return coords;
			coords = coords.map((c$1) => Number.isNaN(c$1) ? 0 : c$1);
			let myPath = this.path;
			let otherPath = space.path;
			let connectionSpace, connectionSpaceIndex;
			for (let i = 0; i < myPath.length; i++) if (myPath[i].equals(otherPath[i])) {
				connectionSpace = myPath[i];
				connectionSpaceIndex = i;
			} else break;
			if (!connectionSpace) throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
			for (let i = myPath.length - 1; i > connectionSpaceIndex; i--) coords = myPath[i].toBase(coords);
			for (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) coords = otherPath[i].fromBase(coords);
			return coords;
		}
		from(space, coords) {
			if (arguments.length === 1) {
				const color = getColor(space);
				[space, coords] = [color.space, color.coords];
			}
			space = ColorSpace.get(space);
			return space.to(this, coords);
		}
		toString() {
			return `${this.name} (${this.id})`;
		}
		getMinCoords() {
			let ret = [];
			for (let id in this.coords) {
				let meta = this.coords[id];
				let range$2 = meta.range || meta.refRange;
				ret.push(range$2?.min ?? 0);
			}
			return ret;
		}
		static registry = {};
		static get all() {
			return [...new Set(Object.values(ColorSpace.registry))];
		}
		static register(id, space) {
			if (arguments.length === 1) {
				space = arguments[0];
				id = space.id;
			}
			space = this.get(space);
			if (this.registry[id] && this.registry[id] !== space) throw new Error(`Duplicate color space registration: '${id}'`);
			this.registry[id] = space;
			if (arguments.length === 1 && space.aliases) for (let alias of space.aliases) this.register(alias, space);
			return space;
		}
		/**
		* Lookup ColorSpace object by name
		* @param {ColorSpace | string} name
		*/
		static get(space, ...alternatives) {
			if (!space || space instanceof ColorSpace) return space;
			if (type(space) === "string") {
				let ret = ColorSpace.registry[space.toLowerCase()];
				if (!ret) throw new TypeError(`No color space found with id = "${space}"`);
				return ret;
			}
			if (alternatives.length) return ColorSpace.get(...alternatives);
			throw new TypeError(`${space} is not a valid color space`);
		}
		/**
		* Get metadata about a coordinate of a color space
		*
		* @static
		* @param {Array | string} ref
		* @param {ColorSpace | string} [workingSpace]
		* @return {Object}
		*/
		static resolveCoord(ref, workingSpace) {
			let coordType = type(ref);
			let space, coord;
			if (coordType === "string") if (ref.includes(".")) [space, coord] = ref.split(".");
			else [space, coord] = [, ref];
			else if (Array.isArray(ref)) [space, coord] = ref;
			else {
				space = ref.space;
				coord = ref.coordId;
			}
			space = ColorSpace.get(space);
			if (!space) space = workingSpace;
			if (!space) throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);
			coordType = type(coord);
			if (coordType === "number" || coordType === "string" && coord >= 0) {
				let meta = Object.entries(space.coords)[coord];
				if (meta) return {
					space,
					id: meta[0],
					index: coord,
					...meta[1]
				};
			}
			space = ColorSpace.get(space);
			let normalizedCoord = coord.toLowerCase();
			let i = 0;
			for (let id in space.coords) {
				let meta = space.coords[id];
				if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) return {
					space,
					id,
					index: i,
					...meta
				};
				i++;
			}
			throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
		}
		static DEFAULT_FORMAT = {
			type: "functions",
			name: "color"
		};
	};
	function getPath(space) {
		let ret = [space];
		for (let s = space; s = s.base;) ret.push(s);
		return ret;
	}
	function processFormat(format, { coords } = {}) {
		if (format.coords && !format.coordGrammar) {
			format.type ||= "function";
			format.name ||= "color";
			format.coordGrammar = parseCoordGrammar(format.coords);
			let coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {
				let outputType = format.coordGrammar[i][0];
				let fromRange = coordMeta.range || coordMeta.refRange;
				let toRange = outputType.range, suffix = "";
				if (outputType == "<percentage>") {
					toRange = [0, 100];
					suffix = "%";
				} else if (outputType == "<angle>") suffix = "deg";
				return {
					fromRange,
					toRange,
					suffix
				};
			});
			format.serializeCoords = (coords$1, precision) => {
				return coords$1.map((c$1, i) => {
					let { fromRange, toRange, suffix } = coordFormats[i];
					if (fromRange && toRange) c$1 = mapRange(fromRange, toRange, c$1);
					c$1 = serializeNumber(c$1, {
						precision,
						unit: suffix
					});
					return c$1;
				});
			};
		}
		return format;
	}
	var xyz_d65 = new ColorSpace({
		id: "xyz-d65",
		name: "XYZ D65",
		coords: {
			x: { name: "X" },
			y: { name: "Y" },
			z: { name: "Z" }
		},
		white: "D65",
		formats: { color: { ids: ["xyz-d65", "xyz"] } },
		aliases: ["xyz"]
	});
	/**
	* Convenience class for RGB color spaces
	* @extends {ColorSpace}
	*/
	var RGBColorSpace = class extends ColorSpace {
		/**
		* Creates a new RGB ColorSpace.
		* If coords are not specified, they will use the default RGB coords.
		* Instead of `fromBase()` and `toBase()` functions,
		* you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.
		* @param {*} options - Same options as {@link ColorSpace} plus:
		* @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ
		* @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ
		*/
		constructor(options) {
			if (!options.coords) options.coords = {
				r: {
					range: [0, 1],
					name: "Red"
				},
				g: {
					range: [0, 1],
					name: "Green"
				},
				b: {
					range: [0, 1],
					name: "Blue"
				}
			};
			if (!options.base) options.base = xyz_d65;
			if (options.toXYZ_M && options.fromXYZ_M) {
				options.toBase ??= (rgb) => {
					let xyz = multiplyMatrices(options.toXYZ_M, rgb);
					if (this.white !== this.base.white) xyz = adapt$2(this.white, this.base.white, xyz);
					return xyz;
				};
				options.fromBase ??= (xyz) => {
					xyz = adapt$2(this.base.white, this.white, xyz);
					return multiplyMatrices(options.fromXYZ_M, xyz);
				};
			}
			options.referred ??= "display";
			super(options);
		}
	};
	/**
	* Get the coordinates of a color in any color space
	* @param {Color} color
	* @param {string | ColorSpace} [space = color.space] The color space to convert to. Defaults to the color's current space
	* @returns {number[]} The color coordinates in the given color space
	*/
	function getAll(color, space) {
		color = getColor(color);
		if (!space || color.space.equals(space)) return color.coords.slice();
		space = ColorSpace.get(space);
		return space.from(color);
	}
	function get(color, prop) {
		color = getColor(color);
		let { space, index } = ColorSpace.resolveCoord(prop, color.space);
		return getAll(color, space)[index];
	}
	function setAll(color, space, coords) {
		color = getColor(color);
		space = ColorSpace.get(space);
		color.coords = space.to(color.space, coords);
		return color;
	}
	setAll.returns = "color";
	function set(color, prop, value) {
		color = getColor(color);
		if (arguments.length === 2 && type(arguments[1]) === "object") {
			let object = arguments[1];
			for (let p$10 in object) set(color, p$10, object[p$10]);
		} else {
			if (typeof value === "function") value = value(get(color, prop));
			let { space, index } = ColorSpace.resolveCoord(prop, color.space);
			let coords = getAll(color, space);
			coords[index] = value;
			setAll(color, space, coords);
		}
		return color;
	}
	set.returns = "color";
	var XYZ_D50 = new ColorSpace({
		id: "xyz-d50",
		name: "XYZ D50",
		white: "D50",
		base: xyz_d65,
		fromBase: (coords) => adapt$2(xyz_d65.white, "D50", coords),
		toBase: (coords) => adapt$2("D50", xyz_d65.white, coords)
	});
	var $6 = 216 / 24389;
	var 3$1 = 24 / 116;
	var $4 = 24389 / 27;
	var white$4 = WHITES.D50;
	var lab = new ColorSpace({
		id: "lab",
		name: "Lab",
		coords: {
			l: {
				refRange: [0, 100],
				name: "Lightness"
			},
			a: { refRange: [-125, 125] },
			b: { refRange: [-125, 125] }
		},
		white: white$4,
		base: XYZ_D50,
		fromBase(XYZ) {
			let f = XYZ.map((value, i) => value / white$4[i]).map((value) => value > $6 ? Math.cbrt(value) : ($4 * value + 16) / 116);
			return [
				116 * f[1] - 16,
				500 * (f[0] - f[1]),
				200 * (f[1] - f[2])
			];
		},
		toBase(Lab) {
			let f = [];
			f[1] = (Lab[0] + 16) / 116;
			f[0] = Lab[1] / 500 + f[1];
			f[2] = f[1] - Lab[2] / 200;
			return [
				f[0] > 3$1 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / $4,
				Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / $4,
				f[2] > 3$1 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / $4
			].map((value, i) => value * white$4[i]);
		},
		formats: { "lab": { coords: [
			"<number> | <percentage>",
			"<number> | <percentage>[-1,1]",
			"<number> | <percentage>[-1,1]"
		] } }
	});
	function constrain(angle) {
		return (angle % 360 + 360) % 360;
	}
	function adjust(arc, angles) {
		if (arc === "raw") return angles;
		let [a1, a2] = angles.map(constrain);
		let angleDiff = a2 - a1;
		if (arc === "increasing") {
			if (angleDiff < 0) a2 += 360;
		} else if (arc === "decreasing") {
			if (angleDiff > 0) a1 += 360;
		} else if (arc === "longer") {
			if (-180 < angleDiff && angleDiff < 180) if (angleDiff > 0) a1 += 360;
			else a2 += 360;
		} else if (arc === "shorter") {
			if (angleDiff > 180) a1 += 360;
			else if (angleDiff < -180) a2 += 360;
		}
		return [a1, a2];
	}
	var lch = new ColorSpace({
		id: "lch",
		name: "LCH",
		coords: {
			l: {
				refRange: [0, 100],
				name: "Lightness"
			},
			c: {
				refRange: [0, 150],
				name: "Chroma"
			},
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},
		base: lab,
		fromBase(Lab) {
			let [L, a$1, b$2] = Lab;
			let hue;
			const $8 = .02;
			if (Math.abs(a$1) < $8 && Math.abs(b$2) < $8) hue = NaN;
			else hue = Math.atan2(b$2, a$1) * 180 / Math.PI;
			return [
				L,
				Math.sqrt(a$1 ** 2 + b$2 ** 2),
				constrain(hue)
			];
		},
		toBase(LCH) {
			let [Lightness, Chroma, Hue] = LCH;
			if (Chroma < 0) Chroma = 0;
			if (isNaN(Hue)) Hue = 0;
			return [
				Lightness,
				Chroma * Math.cos(Hue * Math.PI / 180),
				Chroma * Math.sin(Hue * Math.PI / 180)
			];
		},
		formats: { "lch": { coords: [
			"<number> | <percentage>",
			"<number> | <percentage>",
			"<number> | <angle>"
		] } }
	});
	var Gfactor = 25 ** 7;
	var $1 = Math.PI;
	var r2d = 180 / $1;
	var d2r$1 = $1 / 180;
	function pow7(x) {
		const x2 = x * x;
		return x2 * x2 * x2 * x;
	}
	function deltaE2000(color, sample$1, { kL = 1, kC = 1, kH = 1 } = {}) {
		[color, sample$1] = getColor([color, sample$1]);
		let [L1, a1, b1] = lab.from(color);
		let C1 = lch.from(lab, [
			L1,
			a1,
			b1
		])[1];
		let [L2, a2, b2] = lab.from(sample$1);
		let C2 = lch.from(lab, [
			L2,
			a2,
			b2
		])[1];
		if (C1 < 0) C1 = 0;
		if (C2 < 0) C2 = 0;
		let C7 = pow7((C1 + C2) / 2);
		let G = .5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
		let adash1 = (1 + G) * a1;
		let adash2 = (1 + G) * a2;
		let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
		let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);
		let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
		let h2 = adash2 === 0 && b2 === 0 ? 0 : Math.atan2(b2, adash2);
		if (h1 < 0) h1 += 2 * $1;
		if (h2 < 0) h2 += 2 * $1;
		h1 *= r2d;
		h2 *= r2d;
		let L = L2 - L1;
		let C = Cdash2 - Cdash1;
		let hdiff = h2 - h1;
		let hsum = h1 + h2;
		let habs = Math.abs(hdiff);
		let h;
		if (Cdash1 * Cdash2 === 0) h = 0;
		else if (habs <= 180) h = hdiff;
		else if (hdiff > 180) h = hdiff - 360;
		else if (hdiff < -180) h = hdiff + 360;
		else defaults.warn("the unthinkable has happened");
		let H = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(h * d2r$1 / 2);
		let Ldash = (L1 + L2) / 2;
		let Cdash = (Cdash1 + Cdash2) / 2;
		let Cdash7 = pow7(Cdash);
		let hdash;
		if (Cdash1 * Cdash2 === 0) hdash = hsum;
		else if (habs <= 180) hdash = hsum / 2;
		else if (hsum < 360) hdash = (hsum + 360) / 2;
		else hdash = (hsum - 360) / 2;
		let lsq = (Ldash - 50) ** 2;
		let SL = 1 + .015 * lsq / Math.sqrt(20 + lsq);
		let SC = 1 + .045 * Cdash;
		let T = 1;
		T -= .17 * Math.cos((hdash - 30) * d2r$1);
		T += .24 * Math.cos(2 * hdash * d2r$1);
		T += .32 * Math.cos((3 * hdash + 6) * d2r$1);
		T -= .2 * Math.cos((4 * hdash - 63) * d2r$1);
		let SH = 1 + .015 * Cdash * T;
		let  = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
		let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
		let RT = -1 * Math.sin(2 *  * d2r$1) * RC;
		let dE = (L / (kL * SL)) ** 2;
		dE += (C / (kC * SC)) ** 2;
		dE += (H / (kH * SH)) ** 2;
		dE += RT * (C / (kC * SC)) * (H / (kH * SH));
		return Math.sqrt(dE);
	}
	var XYZtoLMS_M$1 = [
		[
			.819022437996703,
			.3619062600528904,
			-.1288737815209879
		],
		[
			.0329836539323885,
			.9292868615863434,
			.0361446663506424
		],
		[
			.0481771893596242,
			.2642395317527308,
			.6335478284694309
		]
	];
	var LMStoXYZ_M$1 = [
		[
			1.2268798758459243,
			-.5578149944602171,
			.2813910456659647
		],
		[
			-.0405757452148008,
			1.112286803280317,
			-.0717110580655164
		],
		[
			-.0763729366746601,
			-.4214933324022432,
			1.5869240198367816
		]
	];
	var LMStoLab_M = [
		[
			.210454268309314,
			.7936177747023054,
			-.0040720430116193
		],
		[
			1.9779985324311684,
			-2.42859224204858,
			.450593709617411
		],
		[
			.0259040424655478,
			.7827717124575296,
			-.8086757549230774
		]
	];
	var LabtoLMS_M = [
		[
			1,
			.3963377773761749,
			.2158037573099136
		],
		[
			1,
			-.1055613458156586,
			-.0638541728258133
		],
		[
			1,
			-.0894841775298119,
			-1.2914855480194092
		]
	];
	var OKLab = new ColorSpace({
		id: "oklab",
		name: "Oklab",
		coords: {
			l: {
				refRange: [0, 1],
				name: "Lightness"
			},
			a: { refRange: [-.4, .4] },
			b: { refRange: [-.4, .4] }
		},
		white: "D65",
		base: xyz_d65,
		fromBase(XYZ) {
			return multiplyMatrices(LMStoLab_M, multiplyMatrices(XYZtoLMS_M$1, XYZ).map((val) => Math.cbrt(val)));
		},
		toBase(OKLab$1) {
			return multiplyMatrices(LMStoXYZ_M$1, multiplyMatrices(LabtoLMS_M, OKLab$1).map((val) => val ** 3));
		},
		formats: { "oklab": { coords: [
			"<percentage> | <number>",
			"<number> | <percentage>[-1,1]",
			"<number> | <percentage>[-1,1]"
		] } }
	});
	function deltaEOK(color, sample$1) {
		[color, sample$1] = getColor([color, sample$1]);
		let [L1, a1, b1] = OKLab.from(color);
		let [L2, a2, b2] = OKLab.from(sample$1);
		let L = L1 - L2;
		let a = a1 - a2;
		let b = b1 - b2;
		return Math.sqrt(L ** 2 + a ** 2 + b ** 2);
	}
	var $5 = 75e-6;
	/**
	* Check if a color is in gamut of either its own or another color space
	* @return {Boolean} Is the color in gamut?
	*/
	function inGamut(color, space, { epsilon: epsilon$1 = $5 } = {}) {
		color = getColor(color);
		if (!space) space = color.space;
		space = ColorSpace.get(space);
		let coords = color.coords;
		if (space !== color.space) coords = space.from(color);
		return space.inGamut(coords, { epsilon: epsilon$1 });
	}
	function clone(color) {
		return {
			space: color.space,
			coords: color.coords.slice(),
			alpha: color.alpha
		};
	}
	/**
	* Euclidean distance of colors in an arbitrary color space
	*/
	function distance(color1, color2, space = "lab") {
		space = ColorSpace.get(space);
		let coords1 = space.from(color1);
		let coords2 = space.from(color2);
		return Math.sqrt(coords1.reduce((acc, c1$3, i) => {
			let c2$3 = coords2[i];
			if (isNaN(c1$3) || isNaN(c2$3)) return acc;
			return acc + (c2$3 - c1$3) ** 2;
		}, 0));
	}
	function deltaE76(color, sample$1) {
		return distance(color, sample$1, "lab");
	}
	var d2r = Math.PI / 180;
	function deltaECMC(color, sample$1, { l = 2, c: c$1 = 1 } = {}) {
		[color, sample$1] = getColor([color, sample$1]);
		let [L1, a1, b1] = lab.from(color);
		let [, C1, H1] = lch.from(lab, [
			L1,
			a1,
			b1
		]);
		let [L2, a2, b2] = lab.from(sample$1);
		let C2 = lch.from(lab, [
			L2,
			a2,
			b2
		])[1];
		if (C1 < 0) C1 = 0;
		if (C2 < 0) C2 = 0;
		let L = L1 - L2;
		let C = C1 - C2;
		let a = a1 - a2;
		let b = b1 - b2;
		let H2 = a ** 2 + b ** 2 - C ** 2;
		let SL = .511;
		if (L1 >= 16) SL = .040975 * L1 / (1 + .01765 * L1);
		let SC = .0638 * C1 / (1 + .0131 * C1) + .638;
		let T;
		if (Number.isNaN(H1)) H1 = 0;
		if (H1 >= 164 && H1 <= 345) T = .56 + Math.abs(.2 * Math.cos((H1 + 168) * d2r));
		else T = .36 + Math.abs(.4 * Math.cos((H1 + 35) * d2r));
		let C4 = Math.pow(C1, 4);
		let F = Math.sqrt(C4 / (C4 + 1900));
		let SH = SC * (F * T + 1 - F);
		let dE = (L / (l * SL)) ** 2;
		dE += (C / (c$1 * SC)) ** 2;
		dE += H2 / SH ** 2;
		return Math.sqrt(dE);
	}
	var Yw$1 = 203;
	var XYZ_Abs_D65 = new ColorSpace({
		id: "xyz-abs-d65",
		cssId: "--xyz-abs-d65",
		name: "Absolute XYZ D65",
		coords: {
			x: {
				refRange: [0, 9504.7],
				name: "Xa"
			},
			y: {
				refRange: [0, 1e4],
				name: "Ya"
			},
			z: {
				refRange: [0, 10888.3],
				name: "Za"
			}
		},
		base: xyz_d65,
		fromBase(XYZ) {
			return XYZ.map((v) => Math.max(v * Yw$1, 0));
		},
		toBase(AbsXYZ) {
			return AbsXYZ.map((v) => Math.max(v / Yw$1, 0));
		}
	});
	var b$1 = 1.15;
	var g = .66;
	var n$1 = 2610 / 2 ** 14;
	var ninv$1 = 2 ** 14 / 2610;
	var c1$2 = 3424 / 2 ** 12;
	var c2$2 = 2413 / 2 ** 7;
	var c3$2 = 2392 / 2 ** 7;
	var p$8 = 1.7 * 2523 / 2 ** 5;
	var pinv = 2 ** 5 / (1.7 * 2523);
	var d = -.56;
	var d0 = 16295499532821565e-27;
	var XYZtoCone_M = [
		[
			.41478972,
			.579999,
			.014648
		],
		[
			-.20151,
			1.120649,
			.0531008
		],
		[
			-.0166008,
			.2648,
			.6684799
		]
	];
	var ConetoXYZ_M = [
		[
			1.9242264357876067,
			-1.0047923125953657,
			.037651404030618
		],
		[
			.35031676209499907,
			.7264811939316552,
			-.06538442294808501
		],
		[
			-.09098281098284752,
			-.3127282905230739,
			1.5227665613052603
		]
	];
	var ConetoIab_M = [
		[
			.5,
			.5,
			0
		],
		[
			3.524,
			-4.066708,
			.542708
		],
		[
			.199076,
			1.096799,
			-1.295875
		]
	];
	var IabtoCone_M = [
		[
			1,
			.1386050432715393,
			.05804731615611886
		],
		[
			.9999999999999999,
			-.1386050432715393,
			-.05804731615611886
		],
		[
			.9999999999999998,
			-.09601924202631895,
			-.8118918960560388
		]
	];
	var Jzazbz = new ColorSpace({
		id: "jzazbz",
		name: "Jzazbz",
		coords: {
			jz: {
				refRange: [0, 1],
				name: "Jz"
			},
			az: { refRange: [-.5, .5] },
			bz: { refRange: [-.5, .5] }
		},
		base: XYZ_Abs_D65,
		fromBase(XYZ) {
			let [Xa, Ya, Za] = XYZ;
			let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, multiplyMatrices(XYZtoCone_M, [
				b$1 * Xa - (b$1 - 1) * Za,
				g * Ya - (g - 1) * Xa,
				Za
			]).map(function(val) {
				return ((c1$2 + c2$2 * (val / 1e4) ** n$1) / (1 + c3$2 * (val / 1e4) ** n$1)) ** p$8;
			}));
			return [
				(1 + d) * Iz / (1 + d * Iz) - d0,
				az,
				bz
			];
		},
		toBase(Jzazbz$1) {
			let [Jz, az, bz] = Jzazbz$1;
			let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, multiplyMatrices(IabtoCone_M, [
				(Jz + d0) / (1 + d - d * (Jz + d0)),
				az,
				bz
			]).map(function(val) {
				return 1e4 * ((c1$2 - val ** pinv) / (c3$2 * val ** pinv - c2$2)) ** ninv$1;
			}));
			let Xa = (Xm + (b$1 - 1) * Za) / b$1;
			return [
				Xa,
				(Ym + (g - 1) * Xa) / g,
				Za
			];
		},
		formats: { "color": { coords: [
			"<number> | <percentage>",
			"<number> | <percentage>[-1,1]",
			"<number> | <percentage>[-1,1]"
		] } }
	});
	var jzczhz = new ColorSpace({
		id: "jzczhz",
		name: "JzCzHz",
		coords: {
			jz: {
				refRange: [0, 1],
				name: "Jz"
			},
			cz: {
				refRange: [0, 1],
				name: "Chroma"
			},
			hz: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},
		base: Jzazbz,
		fromBase(jzazbz) {
			let [Jz, az, bz] = jzazbz;
			let hue;
			const $8 = 2e-4;
			if (Math.abs(az) < $8 && Math.abs(bz) < $8) hue = NaN;
			else hue = Math.atan2(bz, az) * 180 / Math.PI;
			return [
				Jz,
				Math.sqrt(az ** 2 + bz ** 2),
				constrain(hue)
			];
		},
		toBase(jzczhz$1) {
			return [
				jzczhz$1[0],
				jzczhz$1[1] * Math.cos(jzczhz$1[2] * Math.PI / 180),
				jzczhz$1[1] * Math.sin(jzczhz$1[2] * Math.PI / 180)
			];
		}
	});
	function deltaEJz(color, sample$1) {
		[color, sample$1] = getColor([color, sample$1]);
		let [Jz1, Cz1, Hz1] = jzczhz.from(color);
		let [Jz2, Cz2, Hz2] = jzczhz.from(sample$1);
		let J = Jz1 - Jz2;
		let C = Cz1 - Cz2;
		if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
			Hz1 = 0;
			Hz2 = 0;
		} else if (Number.isNaN(Hz1)) Hz1 = Hz2;
		else if (Number.isNaN(Hz2)) Hz2 = Hz1;
		let h = Hz1 - Hz2;
		let H = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(h / 2 * (Math.PI / 180));
		return Math.sqrt(J ** 2 + C ** 2 + H ** 2);
	}
	var c1$1 = 3424 / 4096;
	var c2$1 = 2413 / 128;
	var c3$1 = 2392 / 128;
	var m1$1 = 2610 / 16384;
	var m2 = 2523 / 32;
	var im1 = 16384 / 2610;
	var im2 = 32 / 2523;
	var XYZtoLMS_M = [
		[
			.3592832590121217,
			.6976051147779502,
			-.035891593232029
		],
		[
			-.1920808463704993,
			1.100476797037432,
			.0753748658519118
		],
		[
			.0070797844607479,
			.0748396662186362,
			.8433265453898765
		]
	];
	var LMStoIPT_M = [
		[
			2048 / 4096,
			2048 / 4096,
			0
		],
		[
			6610 / 4096,
			-13613 / 4096,
			7003 / 4096
		],
		[
			17933 / 4096,
			-17390 / 4096,
			-543 / 4096
		]
	];
	var IPTtoLMS_M = [
		[
			.9999999999999998,
			.0086090370379328,
			.111029625003026
		],
		[
			.9999999999999998,
			-.0086090370379328,
			-.1110296250030259
		],
		[
			.9999999999999998,
			.5600313357106791,
			-.3206271749873188
		]
	];
	var LMStoXYZ_M = [
		[
			2.0701522183894223,
			-1.3263473389671563,
			.2066510476294053
		],
		[
			.3647385209748072,
			.6805660249472273,
			-.0453045459220347
		],
		[
			-.0497472075358123,
			-.0492609666966131,
			1.1880659249923042
		]
	];
	var ictcp = new ColorSpace({
		id: "ictcp",
		name: "ICTCP",
		coords: {
			i: {
				refRange: [0, 1],
				name: "I"
			},
			ct: {
				refRange: [-.5, .5],
				name: "CT"
			},
			cp: {
				refRange: [-.5, .5],
				name: "CP"
			}
		},
		base: XYZ_Abs_D65,
		fromBase(XYZ) {
			return LMStoICtCp(multiplyMatrices(XYZtoLMS_M, XYZ));
		},
		toBase(ICtCp) {
			return multiplyMatrices(LMStoXYZ_M, ICtCptoLMS(ICtCp));
		}
	});
	function LMStoICtCp(LMS) {
		return multiplyMatrices(LMStoIPT_M, LMS.map(function(val) {
			return ((c1$1 + c2$1 * (val / 1e4) ** m1$1) / (1 + c3$1 * (val / 1e4) ** m1$1)) ** m2;
		}));
	}
	function ICtCptoLMS(ICtCp) {
		return multiplyMatrices(IPTtoLMS_M, ICtCp).map(function(val) {
			return 1e4 * (Math.max(val ** im2 - c1$1, 0) / (c2$1 - c3$1 * val ** im2)) ** im1;
		});
	}
	function deltaEITP(color, sample$1) {
		[color, sample$1] = getColor([color, sample$1]);
		let [I1, T1, P1] = ictcp.from(color);
		let [I2, T2, P2] = ictcp.from(sample$1);
		return 720 * Math.sqrt((I1 - I2) ** 2 + .25 * (T1 - T2) ** 2 + (P1 - P2) ** 2);
	}
	var white$3 = WHITES.D65;
	var adaptedCoef = .42;
	var adaptedCoefInv = 1 / adaptedCoef;
	var tau = 2 * Math.PI;
	var cat16 = [
		[
			.401288,
			.650173,
			-.051461
		],
		[
			-.250268,
			1.204414,
			.045854
		],
		[
			-.002079,
			.048952,
			.953127
		]
	];
	var cat16Inv = [
		[
			1.8620678550872327,
			-1.0112546305316843,
			.14918677544445175
		],
		[
			.38752654323613717,
			.6214474419314753,
			-.008973985167612518
		],
		[
			-.015841498849333856,
			-.03412293802851557,
			1.0499644368778496
		]
	];
	var m1 = [
		[
			460,
			451,
			288
		],
		[
			460,
			-891,
			-261
		],
		[
			460,
			-220,
			-6300
		]
	];
	var surroundMap = {
		dark: [
			.8,
			.525,
			.8
		],
		dim: [
			.9,
			.59,
			.9
		],
		average: [
			1,
			.69,
			1
		]
	};
	var hueQuadMap = {
		h: [
			20.14,
			90,
			164.25,
			237.53,
			380.14
		],
		e: [
			.8,
			.7,
			1,
			1.2,
			.8
		],
		H: [
			0,
			100,
			200,
			300,
			400
		]
	};
	var rad2deg = 180 / Math.PI;
	var deg2rad$1 = Math.PI / 180;
	function adapt$1(coords, fl) {
		return coords.map((c$1) => {
			const x = spow(fl * Math.abs(c$1) * .01, adaptedCoef);
			return 400 * copySign(x, c$1) / (x + 27.13);
		});
	}
	function unadapt(adapted, fl) {
		const constant = 100 / fl * 27.13 ** adaptedCoefInv;
		return adapted.map((c$1) => {
			const cabs = Math.abs(c$1);
			return copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c$1);
		});
	}
	function hueQuadrature(h) {
		let hp = constrain(h);
		if (hp <= hueQuadMap.h[0]) hp += 360;
		const i = bisectLeft(hueQuadMap.h, hp) - 1;
		const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
		const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
		const Hi = hueQuadMap.H[i];
		const t = (hp - hi) / ei;
		return Hi + 100 * t / (t + (hii - hp) / eii);
	}
	function invHueQuadrature(H) {
		let Hp = (H % 400 + 400) % 400;
		const i = Math.floor(.01 * Hp);
		Hp = Hp % 100;
		const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
		const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
		return constrain((Hp * (eii * hi - ei * hii) - 100 * hi * eii) / (Hp * (eii - ei) - 100 * eii));
	}
	function environment(refWhite, adaptingLuminance, backgroundLuminance, surround, discounting) {
		const env = {};
		env.discounting = discounting;
		env.refWhite = refWhite;
		env.surround = surround;
		const xyzW = refWhite.map((c$1) => {
			return c$1 * 100;
		});
		env.la = adaptingLuminance;
		env.yb = backgroundLuminance;
		const yw = xyzW[1];
		const rgbW = multiplyMatrices(cat16, xyzW);
		surround = surroundMap[env.surround];
		const f = surround[0];
		env.c = surround[1];
		env.nc = surround[2];
		const k4 = (1 / (5 * env.la + 1)) ** 4;
		env.fl = k4 * env.la + .1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la);
		env.flRoot = env.fl ** .25;
		env.n = env.yb / yw;
		env.z = 1.48 + Math.sqrt(env.n);
		env.nbb = .725 * env.n ** -.2;
		env.ncb = env.nbb;
		const d$1 = discounting ? 1 : Math.max(Math.min(f * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1), 0);
		env.dRgb = rgbW.map((c$1) => {
			return interpolate(1, yw / c$1, d$1);
		});
		env.dRgbInv = env.dRgb.map((c$1) => {
			return 1 / c$1;
		});
		const rgbAW = adapt$1(rgbW.map((c$1, i) => {
			return c$1 * env.dRgb[i];
		}), env.fl);
		env.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + .05 * rgbAW[2]);
		return env;
	}
	var viewingConditions$1 = environment(white$3, 64 / Math.PI * .2, 20, "average", false);
	function fromCam16(cam16$1, env) {
		if (!(cam16$1.J !== void 0 ^ cam16$1.Q !== void 0)) throw new Error("Conversion requires one and only one: 'J' or 'Q'");
		if (!(cam16$1.C !== void 0 ^ cam16$1.M !== void 0 ^ cam16$1.s !== void 0)) throw new Error("Conversion requires one and only one: 'C', 'M' or 's'");
		if (!(cam16$1.h !== void 0 ^ cam16$1.H !== void 0)) throw new Error("Conversion requires one and only one: 'h' or 'H'");
		if (cam16$1.J === 0 || cam16$1.Q === 0) return [
			0,
			0,
			0
		];
		let hRad = 0;
		if (cam16$1.h !== void 0) hRad = constrain(cam16$1.h) * deg2rad$1;
		else hRad = invHueQuadrature(cam16$1.H) * deg2rad$1;
		const cosh = Math.cos(hRad);
		const sinh = Math.sin(hRad);
		let Jroot = 0;
		if (cam16$1.J !== void 0) Jroot = spow(cam16$1.J, 1 / 2) * .1;
		else if (cam16$1.Q !== void 0) Jroot = .25 * env.c * cam16$1.Q / ((env.aW + 4) * env.flRoot);
		let alpha = 0;
		if (cam16$1.C !== void 0) alpha = cam16$1.C / Jroot;
		else if (cam16$1.M !== void 0) alpha = cam16$1.M / env.flRoot / Jroot;
		else if (cam16$1.s !== void 0) alpha = 4e-4 * cam16$1.s ** 2 * (env.aW + 4) / env.c;
		const t = spow(alpha * Math.pow(1.64 - Math.pow(.29, env.n), -.73), 10 / 9);
		const et = .25 * (Math.cos(hRad + 2) + 3.8);
		const A = env.aW * spow(Jroot, 2 / env.c / env.z);
		const p1 = 5e4 / 13 * env.nc * env.ncb * et;
		const p2 = A / env.nbb;
		const r = 23 * (p2 + .305) * zdiv(t, 23 * p1 + t * (11 * cosh + 108 * sinh));
		return multiplyMatrices(cat16Inv, unadapt(multiplyMatrices(m1, [
			p2,
			r * cosh,
			r * sinh
		]).map((c$1) => {
			return c$1 * 1 / 1403;
		}), env.fl).map((c$1, i) => {
			return c$1 * env.dRgbInv[i];
		})).map((c$1) => {
			return c$1 / 100;
		});
	}
	function toCam16(xyzd65, env) {
		const rgbA = adapt$1(multiplyMatrices(cat16, xyzd65.map((c$1) => {
			return c$1 * 100;
		})).map((c$1, i) => {
			return c$1 * env.dRgb[i];
		}), env.fl);
		const a$1 = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;
		const b$2 = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;
		const hRad = (Math.atan2(b$2, a$1) % tau + tau) % tau;
		const et = .25 * (Math.cos(hRad + 2) + 3.8);
		const alpha = spow(5e4 / 13 * env.nc * env.ncb * zdiv(et * Math.sqrt(a$1 ** 2 + b$2 ** 2), rgbA[0] + rgbA[1] + 1.05 * rgbA[2] + .305), .9) * Math.pow(1.64 - Math.pow(.29, env.n), .73);
		const Jroot = spow(env.nbb * (2 * rgbA[0] + rgbA[1] + .05 * rgbA[2]) / env.aW, .5 * env.c * env.z);
		const J = 100 * spow(Jroot, 2);
		const Q = 4 / env.c * Jroot * (env.aW + 4) * env.flRoot;
		const C = alpha * Jroot;
		const M = C * env.flRoot;
		const h = constrain(hRad * rad2deg);
		const H = hueQuadrature(h);
		return {
			J,
			C,
			h,
			s: 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2),
			Q,
			M,
			H
		};
	}
	var cam16 = new ColorSpace({
		id: "cam16-jmh",
		cssId: "--cam16-jmh",
		name: "CAM16-JMh",
		coords: {
			j: {
				refRange: [0, 100],
				name: "J"
			},
			m: {
				refRange: [0, 105],
				name: "Colorfulness"
			},
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},
		base: xyz_d65,
		fromBase(xyz) {
			const cam16$1 = toCam16(xyz, viewingConditions$1);
			return [
				cam16$1.J,
				cam16$1.M,
				cam16$1.h
			];
		},
		toBase(cam16$1) {
			return fromCam16({
				J: cam16$1[0],
				M: cam16$1[1],
				h: cam16$1[2]
			}, viewingConditions$1);
		}
	});
	var white$2 = WHITES.D65;
	var $4 = 216 / 24389;
	var $3 = 24389 / 27;
	function toLstar(y) {
		return 116 * (y > $4 ? Math.cbrt(y) : ($3 * y + 16) / 116) - 16;
	}
	function fromLstar(lstar) {
		return lstar > 8 ? Math.pow((lstar + 16) / 116, 3) : lstar / $3;
	}
	function fromHct(coords, env) {
		let [h, c$1, t] = coords;
		let xyz = [];
		let j = 0;
		if (t === 0) return [
			0,
			0,
			0
		];
		let y = fromLstar(t);
		if (t > 0) j = .00379058511492914 * t ** 2 + .608983189401032 * t + .9155088574762233;
		else j = 9514440756550361e-21 * t ** 2 + .08693057439788597 * t - 21.928975842194614;
		const threshold = 2e-12;
		const max_attempts = 15;
		let attempt = 0;
		let last$3 = Infinity;
		while (attempt <= max_attempts) {
			xyz = fromCam16({
				J: j,
				C: c$1,
				h
			}, env);
			const delta = Math.abs(xyz[1] - y);
			if (delta < last$3) {
				if (delta <= threshold) return xyz;
				last$3 = delta;
			}
			j = j - (xyz[1] - y) * j / (2 * xyz[1]);
			attempt += 1;
		}
		return fromCam16({
			J: j,
			C: c$1,
			h
		}, env);
	}
	function toHct(xyz, env) {
		const t = toLstar(xyz[1]);
		if (t === 0) return [
			0,
			0,
			0
		];
		const cam16$1 = toCam16(xyz, viewingConditions);
		return [
			constrain(cam16$1.h),
			cam16$1.C,
			t
		];
	}
	var viewingConditions = environment(white$2, 200 / Math.PI * fromLstar(50), fromLstar(50) * 100, "average", false);
	var hct = new ColorSpace({
		id: "hct",
		name: "HCT",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			c: {
				refRange: [0, 145],
				name: "Colorfulness"
			},
			t: {
				refRange: [0, 100],
				name: "Tone"
			}
		},
		base: xyz_d65,
		fromBase(xyz) {
			return toHct(xyz);
		},
		toBase(hct$1) {
			return fromHct(hct$1, viewingConditions);
		},
		formats: { color: {
			id: "--hct",
			coords: [
				"<number> | <angle>",
				"<percentage> | <number>",
				"<percentage> | <number>"
			]
		} }
	});
	var deg2rad = Math.PI / 180;
	var ucsCoeff = [
		1,
		.007,
		.0228
	];
	/**
	* Convert HCT chroma and hue (CAM16 JMh colorfulness and hue) using UCS logic for a and b.
	* @param {number[]} coords - HCT coordinates.
	* @return {number[]}
	*/
	function convertUcsAb(coords) {
		if (coords[1] < 0) coords = hct.fromBase(hct.toBase(coords));
		const M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1)) / ucsCoeff[2];
		const hrad = coords[0] * deg2rad;
		const a$1 = M * Math.cos(hrad);
		const b$2 = M * Math.sin(hrad);
		return [
			coords[2],
			a$1,
			b$2
		];
	}
	/**
	* Color distance using HCT.
	* @param {Color} color - Color to compare.
	* @param {Color} sample - Color to compare.
	* @return {number[]}
	*/
	function deltaEHCT(color, sample$1) {
		[color, sample$1] = getColor([color, sample$1]);
		let [t1, a1, b1] = convertUcsAb(hct.from(color));
		let [t2, a2, b2] = convertUcsAb(hct.from(sample$1));
		return Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);
	}
	var deltaEMethods = {
		deltaE76,
		deltaECMC,
		deltaE2000,
		deltaEJz,
		deltaEITP,
		deltaEOK,
		deltaEHCT
	};
	/**
	* Calculate the epsilon to 2 degrees smaller than the specified JND.
	* @param {Number} jnd - The target "just noticeable difference".
	* @returns {Number}
	*/
	function calcEpsilon(jnd) {
		const order = !jnd ? 0 : Math.floor(Math.log10(Math.abs(jnd)));
		return Math.max(parseFloat(`1e${order - 2}`), 1e-6);
	}
	var GMAPPRESET = {
		"hct": {
			method: "hct.c",
			jnd: 2,
			deltaEMethod: "hct",
			blackWhiteClamp: {}
		},
		"hct-tonal": {
			method: "hct.c",
			jnd: 0,
			deltaEMethod: "hct",
			blackWhiteClamp: {
				channel: "hct.t",
				min: 0,
				max: 100
			}
		}
	};
	/**
	* Force coordinates to be in gamut of a certain color space.
	* Mutates the color it is passed.
	* @param {Object|string} options object or spaceId string
	* @param {string} options.method - How to force into gamut.
	*        If "clip", coordinates are just clipped to their reference range.
	*        If "css", coordinates are reduced according to the CSS 4 Gamut Mapping Algorithm.
	*        If in the form [colorSpaceId].[coordName], that coordinate is reduced
	*        until the color is in gamut. Please note that this may produce nonsensical
	*        results for certain coordinates (e.g. hue) or infinite loops if reducing the coordinate never brings the color in gamut.
	* @param {ColorSpace|string} options.space - The space whose gamut we want to map to
	* @param {string} options.deltaEMethod - The delta E method to use while performing gamut mapping.
	*        If no method is specified, delta E 2000 is used.
	* @param {Number} options.jnd - The "just noticeable difference" to target.
	* @param {Object} options.blackWhiteClamp - Used to configure SDR black and clamping.
	*        "channel" indicates the "space.channel" to use for determining when to clamp.
	*        "min" indicates the lower limit for black clamping and "max" indicates the upper
	*        limit for white clamping.
	*/
	function toGamut(color, { method = defaults.gamut_mapping, space = void 0, deltaEMethod = "", jnd = 2, blackWhiteClamp = {} } = {}) {
		color = getColor(color);
		if (isString(arguments[1])) space = arguments[1];
		else if (!space) space = color.space;
		space = ColorSpace.get(space);
		if (inGamut(color, space, { epsilon: 0 })) return color;
		let spaceColor;
		if (method === "css") spaceColor = toGamutCSS(color, { space });
		else {
			if (method !== "clip" && !inGamut(color, space)) {
				if (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) ({method, jnd, deltaEMethod, blackWhiteClamp} = GMAPPRESET[method]);
				let de = deltaE2000;
				if (deltaEMethod !== "") {
					for (let m$1 in deltaEMethods) if ("deltae" + deltaEMethod.toLowerCase() === m$1.toLowerCase()) {
						de = deltaEMethods[m$1];
						break;
					}
				}
				let clipped = toGamut(to(color, space), {
					method: "clip",
					space
				});
				if (de(color, clipped) > jnd) {
					if (Object.keys(blackWhiteClamp).length === 3) {
						let channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);
						let channel = get(to(color, channelMeta.space), channelMeta.id);
						if (isNone(channel)) channel = 0;
						if (channel >= blackWhiteClamp.max) return to({
							space: "xyz-d65",
							coords: WHITES["D65"]
						}, color.space);
						else if (channel <= blackWhiteClamp.min) return to({
							space: "xyz-d65",
							coords: [
								0,
								0,
								0
							]
						}, color.space);
					}
					let coordMeta = ColorSpace.resolveCoord(method);
					let mapSpace = coordMeta.space;
					let coordId = coordMeta.id;
					let mappedColor = to(color, mapSpace);
					mappedColor.coords.forEach((c$1, i) => {
						if (isNone(c$1)) mappedColor.coords[i] = 0;
					});
					let min$1 = (coordMeta.range || coordMeta.refRange)[0];
					let $8 = calcEpsilon(jnd);
					let low = min$1;
					let high = get(mappedColor, coordId);
					while (high - low > $8) {
						let clipped$1 = clone(mappedColor);
						clipped$1 = toGamut(clipped$1, {
							space,
							method: "clip"
						});
						if (de(mappedColor, clipped$1) - jnd < $8) low = get(mappedColor, coordId);
						else high = get(mappedColor, coordId);
						set(mappedColor, coordId, (low + high) / 2);
					}
					spaceColor = to(mappedColor, space);
				} else spaceColor = clipped;
			} else spaceColor = to(color, space);
			if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
				let bounds = Object.values(space.coords).map((c$1) => c$1.range || []);
				spaceColor.coords = spaceColor.coords.map((c$1, i) => {
					let [min$1, max$2] = bounds[i];
					if (min$1 !== void 0) c$1 = Math.max(min$1, c$1);
					if (max$2 !== void 0) c$1 = Math.min(c$1, max$2);
					return c$1;
				});
			}
		}
		if (space !== color.space) spaceColor = to(spaceColor, color.space);
		color.coords = spaceColor.coords;
		return color;
	}
	toGamut.returns = "color";
	var COLORS = {
		WHITE: {
			space: OKLab,
			coords: [
				1,
				0,
				0
			]
		},
		BLACK: {
			space: OKLab,
			coords: [
				0,
				0,
				0
			]
		}
	};
	/**
	* Given a color `origin`, returns a new color that is in gamut using
	* the CSS Gamut Mapping Algorithm. If `space` is specified, it will be in gamut
	* in `space`, and returned in `space`. Otherwise, it will be in gamut and
	* returned in the color space of `origin`.
	* @param {Object} origin
	* @param {Object} options
	* @param {ColorSpace|string} options.space
	* @returns {Color}
	*/
	function toGamutCSS(origin, { space } = {}) {
		const JND = .02;
		const $8 = 1e-4;
		origin = getColor(origin);
		if (!space) space = origin.space;
		space = ColorSpace.get(space);
		const oklchSpace = ColorSpace.get("oklch");
		if (space.isUnbounded) return to(origin, space);
		const origin_OKLCH = to(origin, oklchSpace);
		let L = origin_OKLCH.coords[0];
		if (L >= 1) {
			const white$5 = to(COLORS.WHITE, space);
			white$5.alpha = origin.alpha;
			return to(white$5, space);
		}
		if (L <= 0) {
			const black = to(COLORS.BLACK, space);
			black.alpha = origin.alpha;
			return to(black, space);
		}
		if (inGamut(origin_OKLCH, space, { epsilon: 0 })) return to(origin_OKLCH, space);
		function clip(_color) {
			const destColor = to(_color, space);
			const spaceCoords = Object.values(space.coords);
			destColor.coords = destColor.coords.map((coord, index) => {
				if ("range" in spaceCoords[index]) {
					const [min$2, max$3] = spaceCoords[index].range;
					return clamp$1(min$2, coord, max$3);
				}
				return coord;
			});
			return destColor;
		}
		let min$1 = 0;
		let max$2 = origin_OKLCH.coords[1];
		let min_inGamut = true;
		let current = clone(origin_OKLCH);
		let clipped = clip(current);
		let E = deltaEOK(clipped, current);
		if (E < JND) return clipped;
		while (max$2 - min$1 > $8) {
			const chroma = (min$1 + max$2) / 2;
			current.coords[1] = chroma;
			if (min_inGamut && inGamut(current, space, { epsilon: 0 })) min$1 = chroma;
			else {
				clipped = clip(current);
				E = deltaEOK(clipped, current);
				if (E < JND) if (JND - E < $8) break;
				else {
					min_inGamut = false;
					min$1 = chroma;
				}
				else max$2 = chroma;
			}
		}
		return clipped;
	}
	/**
	* Convert to color space and return a new color
	* @param {Object|string} space - Color space object or id
	* @param {Object} options
	* @param {boolean} options.inGamut - Whether to force resulting color in gamut
	* @returns {Color}
	*/
	function to(color, space, { inGamut: inGamut$1 } = {}) {
		color = getColor(color);
		space = ColorSpace.get(space);
		let coords = space.from(color);
		let ret = {
			space,
			coords,
			alpha: color.alpha
		};
		if (inGamut$1) ret = toGamut(ret, inGamut$1 === true ? void 0 : inGamut$1);
		return ret;
	}
	to.returns = "color";
	/**
	* Generic toString() method, outputs a color(spaceId ...coords) function, a functional syntax, or custom formats defined by the color space
	* @param {Object} options
	* @param {number} options.precision - Significant digits
	* @param {boolean} options.inGamut - Adjust coordinates to fit in gamut first? [default: false]
	*/
	function serialize(color, { precision = defaults.precision, format = "default", inGamut: inGamut$1 = true,...customOptions } = {}) {
		let ret;
		color = getColor(color);
		let formatId = format;
		format = color.space.getFormat(format) ?? color.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
		let coords = color.coords.slice();
		inGamut$1 ||= format.toGamut;
		if (inGamut$1 && !inGamut(color)) coords = toGamut(clone(color), inGamut$1 === true ? void 0 : inGamut$1).coords;
		if (format.type === "custom") {
			customOptions.precision = precision;
			if (format.serialize) ret = format.serialize(coords, color.alpha, customOptions);
			else throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
		} else {
			let name = format.name || "color";
			if (format.serializeCoords) coords = format.serializeCoords(coords, precision);
			else if (precision !== null) coords = coords.map((c$1) => {
				return serializeNumber(c$1, { precision });
			});
			let args = [...coords];
			if (name === "color") {
				let cssId = format.id || format.ids?.[0] || color.space.id;
				args.unshift(cssId);
			}
			let alpha = color.alpha;
			if (precision !== null) alpha = serializeNumber(alpha, { precision });
			let strAlpha = color.alpha >= 1 || format.noAlpha ? "" : `${format.commas ? "," : " /"} ${alpha}`;
			ret = `${name}(${args.join(format.commas ? ", " : " ")}${strAlpha})`;
		}
		return ret;
	}
	var REC2020Linear = new RGBColorSpace({
		id: "rec2020-linear",
		cssId: "--rec2020-linear",
		name: "Linear REC.2020",
		white: "D65",
		toXYZ_M: [
			[
				.6369580483012914,
				.14461690358620832,
				.1688809751641721
			],
			[
				.2627002120112671,
				.6779980715188708,
				.05930171646986196
			],
			[
				0,
				.028072693049087428,
				1.060985057710791
			]
		],
		fromXYZ_M: [
			[
				1.716651187971268,
				-.355670783776392,
				-.25336628137366
			],
			[
				-.666684351832489,
				1.616481236634939,
				.0157685458139111
			],
			[
				.017639857445311,
				-.042770613257809,
				.942103121235474
			]
		]
	});
	var  = 1.09929682680944;
	var  = .018053968510807;
	var REC2020 = new RGBColorSpace({
		id: "rec2020",
		name: "REC.2020",
		base: REC2020Linear,
		toBase(RGB) {
			return RGB.map(function(val) {
				if (val <  * 4.5) return val / 4.5;
				return Math.pow((val +  - 1) / , 1 / .45);
			});
		},
		fromBase(RGB) {
			return RGB.map(function(val) {
				if (val >= ) return  * Math.pow(val, .45) - ( - 1);
				return 4.5 * val;
			});
		}
	});
	var P3Linear = new RGBColorSpace({
		id: "p3-linear",
		cssId: "--display-p3-linear",
		name: "Linear P3",
		white: "D65",
		toXYZ_M: [
			[
				.4865709486482162,
				.26566769316909306,
				.1982172852343625
			],
			[
				.2289745640697488,
				.6917385218365064,
				.079286914093745
			],
			[
				0,
				.04511338185890264,
				1.043944368900976
			]
		],
		fromXYZ_M: [
			[
				2.493496911941425,
				-.9313836179191239,
				-.40271078445071684
			],
			[
				-.8294889695615747,
				1.7626640603183463,
				.023624685841943577
			],
			[
				.03584583024378447,
				-.07617238926804182,
				.9568845240076872
			]
		]
	});
	var toXYZ_M$3 = [
		[
			.41239079926595934,
			.357584339383878,
			.1804807884018343
		],
		[
			.21263900587151027,
			.715168678767756,
			.07219231536073371
		],
		[
			.01933081871559182,
			.11919477979462598,
			.9505321522496607
		]
	];
	var fromXYZ_M$3 = [
		[
			3.2409699419045226,
			-1.537383177570094,
			-.4986107602930034
		],
		[
			-.9692436362808796,
			1.8759675015077202,
			.04155505740717559
		],
		[
			.05563007969699366,
			-.20397695888897652,
			1.0569715142428786
		]
	];
	var sRGBLinear = new RGBColorSpace({
		id: "srgb-linear",
		name: "Linear sRGB",
		white: "D65",
		toXYZ_M: toXYZ_M$3,
		fromXYZ_M: fromXYZ_M$3
	});
	var KEYWORDS = {
		"aliceblue": [
			240 / 255,
			248 / 255,
			1
		],
		"antiquewhite": [
			250 / 255,
			235 / 255,
			215 / 255
		],
		"aqua": [
			0,
			1,
			1
		],
		"aquamarine": [
			127 / 255,
			1,
			212 / 255
		],
		"azure": [
			240 / 255,
			1,
			1
		],
		"beige": [
			245 / 255,
			245 / 255,
			220 / 255
		],
		"bisque": [
			1,
			228 / 255,
			196 / 255
		],
		"black": [
			0,
			0,
			0
		],
		"blanchedalmond": [
			1,
			235 / 255,
			205 / 255
		],
		"blue": [
			0,
			0,
			1
		],
		"blueviolet": [
			138 / 255,
			43 / 255,
			226 / 255
		],
		"brown": [
			165 / 255,
			42 / 255,
			42 / 255
		],
		"burlywood": [
			222 / 255,
			184 / 255,
			135 / 255
		],
		"cadetblue": [
			95 / 255,
			158 / 255,
			160 / 255
		],
		"chartreuse": [
			127 / 255,
			1,
			0
		],
		"chocolate": [
			210 / 255,
			105 / 255,
			30 / 255
		],
		"coral": [
			1,
			127 / 255,
			80 / 255
		],
		"cornflowerblue": [
			100 / 255,
			149 / 255,
			237 / 255
		],
		"cornsilk": [
			1,
			248 / 255,
			220 / 255
		],
		"crimson": [
			220 / 255,
			20 / 255,
			60 / 255
		],
		"cyan": [
			0,
			1,
			1
		],
		"darkblue": [
			0,
			0,
			139 / 255
		],
		"darkcyan": [
			0,
			139 / 255,
			139 / 255
		],
		"darkgoldenrod": [
			184 / 255,
			134 / 255,
			11 / 255
		],
		"darkgray": [
			169 / 255,
			169 / 255,
			169 / 255
		],
		"darkgreen": [
			0,
			100 / 255,
			0
		],
		"darkgrey": [
			169 / 255,
			169 / 255,
			169 / 255
		],
		"darkkhaki": [
			189 / 255,
			183 / 255,
			107 / 255
		],
		"darkmagenta": [
			139 / 255,
			0,
			139 / 255
		],
		"darkolivegreen": [
			85 / 255,
			107 / 255,
			47 / 255
		],
		"darkorange": [
			1,
			140 / 255,
			0
		],
		"darkorchid": [
			153 / 255,
			50 / 255,
			204 / 255
		],
		"darkred": [
			139 / 255,
			0,
			0
		],
		"darksalmon": [
			233 / 255,
			150 / 255,
			122 / 255
		],
		"darkseagreen": [
			143 / 255,
			188 / 255,
			143 / 255
		],
		"darkslateblue": [
			72 / 255,
			61 / 255,
			139 / 255
		],
		"darkslategray": [
			47 / 255,
			79 / 255,
			79 / 255
		],
		"darkslategrey": [
			47 / 255,
			79 / 255,
			79 / 255
		],
		"darkturquoise": [
			0,
			206 / 255,
			209 / 255
		],
		"darkviolet": [
			148 / 255,
			0,
			211 / 255
		],
		"deeppink": [
			1,
			20 / 255,
			147 / 255
		],
		"deepskyblue": [
			0,
			191 / 255,
			1
		],
		"dimgray": [
			105 / 255,
			105 / 255,
			105 / 255
		],
		"dimgrey": [
			105 / 255,
			105 / 255,
			105 / 255
		],
		"dodgerblue": [
			30 / 255,
			144 / 255,
			1
		],
		"firebrick": [
			178 / 255,
			34 / 255,
			34 / 255
		],
		"floralwhite": [
			1,
			250 / 255,
			240 / 255
		],
		"forestgreen": [
			34 / 255,
			139 / 255,
			34 / 255
		],
		"fuchsia": [
			1,
			0,
			1
		],
		"gainsboro": [
			220 / 255,
			220 / 255,
			220 / 255
		],
		"ghostwhite": [
			248 / 255,
			248 / 255,
			1
		],
		"gold": [
			1,
			215 / 255,
			0
		],
		"goldenrod": [
			218 / 255,
			165 / 255,
			32 / 255
		],
		"gray": [
			128 / 255,
			128 / 255,
			128 / 255
		],
		"green": [
			0,
			128 / 255,
			0
		],
		"greenyellow": [
			173 / 255,
			1,
			47 / 255
		],
		"grey": [
			128 / 255,
			128 / 255,
			128 / 255
		],
		"honeydew": [
			240 / 255,
			1,
			240 / 255
		],
		"hotpink": [
			1,
			105 / 255,
			180 / 255
		],
		"indianred": [
			205 / 255,
			92 / 255,
			92 / 255
		],
		"indigo": [
			75 / 255,
			0,
			130 / 255
		],
		"ivory": [
			1,
			1,
			240 / 255
		],
		"khaki": [
			240 / 255,
			230 / 255,
			140 / 255
		],
		"lavender": [
			230 / 255,
			230 / 255,
			250 / 255
		],
		"lavenderblush": [
			1,
			240 / 255,
			245 / 255
		],
		"lawngreen": [
			124 / 255,
			252 / 255,
			0
		],
		"lemonchiffon": [
			1,
			250 / 255,
			205 / 255
		],
		"lightblue": [
			173 / 255,
			216 / 255,
			230 / 255
		],
		"lightcoral": [
			240 / 255,
			128 / 255,
			128 / 255
		],
		"lightcyan": [
			224 / 255,
			1,
			1
		],
		"lightgoldenrodyellow": [
			250 / 255,
			250 / 255,
			210 / 255
		],
		"lightgray": [
			211 / 255,
			211 / 255,
			211 / 255
		],
		"lightgreen": [
			144 / 255,
			238 / 255,
			144 / 255
		],
		"lightgrey": [
			211 / 255,
			211 / 255,
			211 / 255
		],
		"lightpink": [
			1,
			182 / 255,
			193 / 255
		],
		"lightsalmon": [
			1,
			160 / 255,
			122 / 255
		],
		"lightseagreen": [
			32 / 255,
			178 / 255,
			170 / 255
		],
		"lightskyblue": [
			135 / 255,
			206 / 255,
			250 / 255
		],
		"lightslategray": [
			119 / 255,
			136 / 255,
			153 / 255
		],
		"lightslategrey": [
			119 / 255,
			136 / 255,
			153 / 255
		],
		"lightsteelblue": [
			176 / 255,
			196 / 255,
			222 / 255
		],
		"lightyellow": [
			1,
			1,
			224 / 255
		],
		"lime": [
			0,
			1,
			0
		],
		"limegreen": [
			50 / 255,
			205 / 255,
			50 / 255
		],
		"linen": [
			250 / 255,
			240 / 255,
			230 / 255
		],
		"magenta": [
			1,
			0,
			1
		],
		"maroon": [
			128 / 255,
			0,
			0
		],
		"mediumaquamarine": [
			102 / 255,
			205 / 255,
			170 / 255
		],
		"mediumblue": [
			0,
			0,
			205 / 255
		],
		"mediumorchid": [
			186 / 255,
			85 / 255,
			211 / 255
		],
		"mediumpurple": [
			147 / 255,
			112 / 255,
			219 / 255
		],
		"mediumseagreen": [
			60 / 255,
			179 / 255,
			113 / 255
		],
		"mediumslateblue": [
			123 / 255,
			104 / 255,
			238 / 255
		],
		"mediumspringgreen": [
			0,
			250 / 255,
			154 / 255
		],
		"mediumturquoise": [
			72 / 255,
			209 / 255,
			204 / 255
		],
		"mediumvioletred": [
			199 / 255,
			21 / 255,
			133 / 255
		],
		"midnightblue": [
			25 / 255,
			25 / 255,
			112 / 255
		],
		"mintcream": [
			245 / 255,
			1,
			250 / 255
		],
		"mistyrose": [
			1,
			228 / 255,
			225 / 255
		],
		"moccasin": [
			1,
			228 / 255,
			181 / 255
		],
		"navajowhite": [
			1,
			222 / 255,
			173 / 255
		],
		"navy": [
			0,
			0,
			128 / 255
		],
		"oldlace": [
			253 / 255,
			245 / 255,
			230 / 255
		],
		"olive": [
			128 / 255,
			128 / 255,
			0
		],
		"olivedrab": [
			107 / 255,
			142 / 255,
			35 / 255
		],
		"orange": [
			1,
			165 / 255,
			0
		],
		"orangered": [
			1,
			69 / 255,
			0
		],
		"orchid": [
			218 / 255,
			112 / 255,
			214 / 255
		],
		"palegoldenrod": [
			238 / 255,
			232 / 255,
			170 / 255
		],
		"palegreen": [
			152 / 255,
			251 / 255,
			152 / 255
		],
		"paleturquoise": [
			175 / 255,
			238 / 255,
			238 / 255
		],
		"palevioletred": [
			219 / 255,
			112 / 255,
			147 / 255
		],
		"papayawhip": [
			1,
			239 / 255,
			213 / 255
		],
		"peachpuff": [
			1,
			218 / 255,
			185 / 255
		],
		"peru": [
			205 / 255,
			133 / 255,
			63 / 255
		],
		"pink": [
			1,
			192 / 255,
			203 / 255
		],
		"plum": [
			221 / 255,
			160 / 255,
			221 / 255
		],
		"powderblue": [
			176 / 255,
			224 / 255,
			230 / 255
		],
		"purple": [
			128 / 255,
			0,
			128 / 255
		],
		"rebeccapurple": [
			102 / 255,
			51 / 255,
			153 / 255
		],
		"red": [
			1,
			0,
			0
		],
		"rosybrown": [
			188 / 255,
			143 / 255,
			143 / 255
		],
		"royalblue": [
			65 / 255,
			105 / 255,
			225 / 255
		],
		"saddlebrown": [
			139 / 255,
			69 / 255,
			19 / 255
		],
		"salmon": [
			250 / 255,
			128 / 255,
			114 / 255
		],
		"sandybrown": [
			244 / 255,
			164 / 255,
			96 / 255
		],
		"seagreen": [
			46 / 255,
			139 / 255,
			87 / 255
		],
		"seashell": [
			1,
			245 / 255,
			238 / 255
		],
		"sienna": [
			160 / 255,
			82 / 255,
			45 / 255
		],
		"silver": [
			192 / 255,
			192 / 255,
			192 / 255
		],
		"skyblue": [
			135 / 255,
			206 / 255,
			235 / 255
		],
		"slateblue": [
			106 / 255,
			90 / 255,
			205 / 255
		],
		"slategray": [
			112 / 255,
			128 / 255,
			144 / 255
		],
		"slategrey": [
			112 / 255,
			128 / 255,
			144 / 255
		],
		"snow": [
			1,
			250 / 255,
			250 / 255
		],
		"springgreen": [
			0,
			1,
			127 / 255
		],
		"steelblue": [
			70 / 255,
			130 / 255,
			180 / 255
		],
		"tan": [
			210 / 255,
			180 / 255,
			140 / 255
		],
		"teal": [
			0,
			128 / 255,
			128 / 255
		],
		"thistle": [
			216 / 255,
			191 / 255,
			216 / 255
		],
		"tomato": [
			1,
			99 / 255,
			71 / 255
		],
		"turquoise": [
			64 / 255,
			224 / 255,
			208 / 255
		],
		"violet": [
			238 / 255,
			130 / 255,
			238 / 255
		],
		"wheat": [
			245 / 255,
			222 / 255,
			179 / 255
		],
		"white": [
			1,
			1,
			1
		],
		"whitesmoke": [
			245 / 255,
			245 / 255,
			245 / 255
		],
		"yellow": [
			1,
			1,
			0
		],
		"yellowgreen": [
			154 / 255,
			205 / 255,
			50 / 255
		]
	};
	var coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
	var coordGrammarNumber = Array(3).fill("<number>[0, 255]");
	var sRGB = new RGBColorSpace({
		id: "srgb",
		name: "sRGB",
		base: sRGBLinear,
		fromBase: (rgb) => {
			return rgb.map((val) => {
				let sign = val < 0 ? -1 : 1;
				let abs = val * sign;
				if (abs > .0031308) return sign * (1.055 * abs ** (1 / 2.4) - .055);
				return 12.92 * val;
			});
		},
		toBase: (rgb) => {
			return rgb.map((val) => {
				let sign = val < 0 ? -1 : 1;
				let abs = val * sign;
				if (abs <= .04045) return val / 12.92;
				return sign * ((abs + .055) / 1.055) ** 2.4;
			});
		},
		formats: {
			"rgb": { coords: coordGrammar },
			"rgb_number": {
				name: "rgb",
				commas: true,
				coords: coordGrammarNumber,
				noAlpha: true
			},
			"color": {},
			"rgba": {
				coords: coordGrammar,
				commas: true,
				lastAlpha: true
			},
			"rgba_number": {
				name: "rgba",
				commas: true,
				coords: coordGrammarNumber
			},
			"hex": {
				type: "custom",
				toGamut: true,
				test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
				parse(str) {
					if (str.length <= 5) str = str.replace(/[a-f0-9]/gi, "$&$&");
					let rgba = [];
					str.replace(/[a-f0-9]{2}/gi, (component) => {
						rgba.push(parseInt(component, 16) / 255);
					});
					return {
						spaceId: "srgb",
						coords: rgba.slice(0, 3),
						alpha: rgba.slice(3)[0]
					};
				},
				serialize: (coords, alpha, { collapse = true } = {}) => {
					if (alpha < 1) coords.push(alpha);
					coords = coords.map((c$1) => Math.round(c$1 * 255));
					let collapsible = collapse && coords.every((c$1) => c$1 % 17 === 0);
					return "#" + coords.map((c$1) => {
						if (collapsible) return (c$1 / 17).toString(16);
						return c$1.toString(16).padStart(2, "0");
					}).join("");
				}
			},
			"keyword": {
				type: "custom",
				test: (str) => /^[a-z]+$/i.test(str),
				parse(str) {
					str = str.toLowerCase();
					let ret = {
						spaceId: "srgb",
						coords: null,
						alpha: 1
					};
					if (str === "transparent") {
						ret.coords = KEYWORDS.black;
						ret.alpha = 0;
					} else ret.coords = KEYWORDS[str];
					if (ret.coords) return ret;
				}
			}
		}
	});
	var P3 = new RGBColorSpace({
		id: "p3",
		cssId: "display-p3",
		name: "P3",
		base: P3Linear,
		fromBase: sRGB.fromBase,
		toBase: sRGB.toBase
	});
	defaults.display_space = sRGB;
	var supportsNone;
	if (typeof CSS !== "undefined" && CSS.supports) for (let space of [
		lab,
		REC2020,
		P3
	]) {
		let str = serialize({
			space,
			coords: space.getMinCoords(),
			alpha: 1
		});
		if (CSS.supports("color", str)) {
			defaults.display_space = space;
			break;
		}
	}
	/**
	* Returns a serialization of the color that can actually be displayed in the browser.
	* If the default serialization can be displayed, it is returned.
	* Otherwise, the color is converted to Lab, REC2020, or P3, whichever is the widest supported.
	* In Node.js, this is basically equivalent to `serialize()` but returns a `String` object instead.
	*
	* @export
	* @param {{space, coords} | Color | string} color
	* @param {*} [options={}] Options to be passed to serialize()
	* @param {ColorSpace | string} [options.space = defaults.display_space] Color space to use for serialization if default is not supported
	* @returns {String} String object containing the serialized color with a color property containing the converted color (or the original, if no conversion was necessary)
	*/
	function display(color, { space = defaults.display_space,...options } = {}) {
		let ret = serialize(color, options);
		if (typeof CSS === "undefined" || CSS.supports("color", ret) || !defaults.display_space) {
			ret = new String(ret);
			ret.color = color;
		} else {
			let fallbackColor = color;
			if (color.coords.some(isNone) || isNone(color.alpha)) {
				if (!(supportsNone ??= CSS.supports("color", "hsl(none 50% 50%)"))) {
					fallbackColor = clone(color);
					fallbackColor.coords = fallbackColor.coords.map(skipNone);
					fallbackColor.alpha = skipNone(fallbackColor.alpha);
					ret = serialize(fallbackColor, options);
					if (CSS.supports("color", ret)) {
						ret = new String(ret);
						ret.color = fallbackColor;
						return ret;
					}
				}
			}
			fallbackColor = to(fallbackColor, space);
			ret = new String(serialize(fallbackColor, options));
			ret.color = fallbackColor;
		}
		return ret;
	}
	function equals$1(color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);
		return color1.space === color2.space && color1.alpha === color2.alpha && color1.coords.every((c$1, i) => c$1 === color2.coords[i]);
	}
	/**
	* Relative luminance
	*/
	function getLuminance(color) {
		return get(color, [xyz_d65, "y"]);
	}
	function setLuminance(color, value) {
		set(color, [xyz_d65, "y"], value);
	}
	function register$2(Color$1) {
		Object.defineProperty(Color$1.prototype, "luminance", {
			get() {
				return getLuminance(this);
			},
			set(value) {
				setLuminance(this, value);
			}
		});
	}
	var luminance = /* @__PURE__ */ Object.freeze({
		__proto__: null,
		getLuminance,
		register: register$2,
		setLuminance
	});
	function contrastWCAG21(color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);
		let Y1 = Math.max(getLuminance(color1), 0);
		let Y2 = Math.max(getLuminance(color2), 0);
		if (Y2 > Y1) [Y1, Y2] = [Y2, Y1];
		return (Y1 + .05) / (Y2 + .05);
	}
	var normBG = .56;
	var normTXT = .57;
	var revTXT = .62;
	var revBG = .65;
	var blkThrs = .022;
	var blkClmp = 1.414;
	var loClip = .1;
	var deltaYmin = 5e-4;
	var scaleBoW = 1.14;
	var loBoWoffset = .027;
	var scaleWoB = 1.14;
	function fclamp(Y) {
		if (Y >= blkThrs) return Y;
		return Y + (blkThrs - Y) ** blkClmp;
	}
	function linearize(val) {
		let sign = val < 0 ? -1 : 1;
		let abs = Math.abs(val);
		return sign * Math.pow(abs, 2.4);
	}
	function contrastAPCA(background, foreground) {
		foreground = getColor(foreground);
		background = getColor(background);
		let S;
		let C;
		let Sapc;
		let R, G, B;
		foreground = to(foreground, "srgb");
		[R, G, B] = foreground.coords;
		let lumTxt = linearize(R) * .2126729 + linearize(G) * .7151522 + linearize(B) * .072175;
		background = to(background, "srgb");
		[R, G, B] = background.coords;
		let lumBg = linearize(R) * .2126729 + linearize(G) * .7151522 + linearize(B) * .072175;
		let Ytxt = fclamp(lumTxt);
		let Ybg = fclamp(lumBg);
		let BoW = Ybg > Ytxt;
		if (Math.abs(Ybg - Ytxt) < deltaYmin) C = 0;
		else if (BoW) {
			S = Ybg ** normBG - Ytxt ** normTXT;
			C = S * scaleBoW;
		} else {
			S = Ybg ** revBG - Ytxt ** revTXT;
			C = S * scaleWoB;
		}
		if (Math.abs(C) < loClip) Sapc = 0;
		else if (C > 0) Sapc = C - loBoWoffset;
		else Sapc = C + loBoWoffset;
		return Sapc * 100;
	}
	function contrastMichelson(color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);
		let Y1 = Math.max(getLuminance(color1), 0);
		let Y2 = Math.max(getLuminance(color2), 0);
		if (Y2 > Y1) [Y1, Y2] = [Y2, Y1];
		let denom = Y1 + Y2;
		return denom === 0 ? 0 : (Y1 - Y2) / denom;
	}
	var max$1 = 5e4;
	function contrastWeber(color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);
		let Y1 = Math.max(getLuminance(color1), 0);
		let Y2 = Math.max(getLuminance(color2), 0);
		if (Y2 > Y1) [Y1, Y2] = [Y2, Y1];
		return Y2 === 0 ? max$1 : (Y1 - Y2) / Y2;
	}
	function contrastLstar(color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);
		let L1 = get(color1, [lab, "l"]);
		let L2 = get(color2, [lab, "l"]);
		return Math.abs(L1 - L2);
	}
	var $3 = 216 / 24389;
	var 3 = 24 / 116;
	var $2 = 24389 / 27;
	var white$1 = WHITES.D65;
	var lab_d65 = new ColorSpace({
		id: "lab-d65",
		name: "Lab D65",
		coords: {
			l: {
				refRange: [0, 100],
				name: "Lightness"
			},
			a: { refRange: [-125, 125] },
			b: { refRange: [-125, 125] }
		},
		white: white$1,
		base: xyz_d65,
		fromBase(XYZ) {
			let f = XYZ.map((value, i) => value / white$1[i]).map((value) => value > $3 ? Math.cbrt(value) : ($2 * value + 16) / 116);
			return [
				116 * f[1] - 16,
				500 * (f[0] - f[1]),
				200 * (f[1] - f[2])
			];
		},
		toBase(Lab) {
			let f = [];
			f[1] = (Lab[0] + 16) / 116;
			f[0] = Lab[1] / 500 + f[1];
			f[2] = f[1] - Lab[2] / 200;
			return [
				f[0] > 3 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / $2,
				Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / $2,
				f[2] > 3 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / $2
			].map((value, i) => value * white$1[i]);
		},
		formats: { "lab-d65": { coords: [
			"<number> | <percentage>",
			"<number> | <percentage>[-1,1]",
			"<number> | <percentage>[-1,1]"
		] } }
	});
	var phi = Math.pow(5, .5) * .5 + .5;
	function contrastDeltaPhi(color1, color2) {
		color1 = getColor(color1);
		color2 = getColor(color2);
		let Lstr1 = get(color1, [lab_d65, "l"]);
		let Lstr2 = get(color2, [lab_d65, "l"]);
		let deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));
		let contrast$1 = Math.pow(deltaPhiStar, 1 / phi) * Math.SQRT2 - 40;
		return contrast$1 < 7.5 ? 0 : contrast$1;
	}
	var contrastMethods = /* @__PURE__ */ Object.freeze({
		__proto__: null,
		contrastAPCA,
		contrastDeltaPhi,
		contrastLstar,
		contrastMichelson,
		contrastWCAG21,
		contrastWeber
	});
	function contrast(background, foreground, o = {}) {
		if (isString(o)) o = { algorithm: o };
		let { algorithm,...rest } = o;
		if (!algorithm) {
			let algorithms = Object.keys(contrastMethods).map((a$1) => a$1.replace(/^contrast/, "")).join(", ");
			throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);
		}
		background = getColor(background);
		foreground = getColor(foreground);
		for (let a$1 in contrastMethods) if ("contrast" + algorithm.toLowerCase() === a$1.toLowerCase()) return contrastMethods[a$1](background, foreground, rest);
		throw new TypeError(`Unknown contrast algorithm: ${algorithm}`);
	}
	function uv(color) {
		let [X, Y, Z] = getAll(color, xyz_d65);
		let denom = X + 15 * Y + 3 * Z;
		return [4 * X / denom, 9 * Y / denom];
	}
	function xy(color) {
		let [X, Y, Z] = getAll(color, xyz_d65);
		let sum = X + Y + Z;
		return [X / sum, Y / sum];
	}
	function register$1(Color$1) {
		Object.defineProperty(Color$1.prototype, "uv", { get() {
			return uv(this);
		} });
		Object.defineProperty(Color$1.prototype, "xy", { get() {
			return xy(this);
		} });
	}
	var chromaticity = /* @__PURE__ */ Object.freeze({
		__proto__: null,
		register: register$1,
		uv,
		xy
	});
	function deltaE(c1$3, c2$3, o = {}) {
		if (isString(o)) o = { method: o };
		let { method = defaults.deltaE,...rest } = o;
		for (let m$1 in deltaEMethods) if ("deltae" + method.toLowerCase() === m$1.toLowerCase()) return deltaEMethods[m$1](c1$3, c2$3, rest);
		throw new TypeError(`Unknown deltaE method: ${method}`);
	}
	function lighten(color, amount = .25) {
		return set(color, [ColorSpace.get("oklch", "lch"), "l"], (l) => l * (1 + amount));
	}
	function darken(color, amount = .25) {
		return set(color, [ColorSpace.get("oklch", "lch"), "l"], (l) => l * (1 - amount));
	}
	var variations = /* @__PURE__ */ Object.freeze({
		__proto__: null,
		darken,
		lighten
	});
	/**
	* Functions related to color interpolation
	*/
	/**
	* Return an intermediate color between two colors
	* Signatures: mix(c1, c2, p, options)
	*             mix(c1, c2, options)
	*             mix(color)
	* @param {Color | string} c1 The first color
	* @param {Color | string} [c2] The second color
	* @param {number} [p=.5] A 0-1 percentage where 0 is c1 and 1 is c2
	* @param {Object} [o={}]
	* @return {Color}
	*/
	function mix(c1$3, c2$3, p$10 = .5, o = {}) {
		[c1$3, c2$3] = [getColor(c1$3), getColor(c2$3)];
		if (type(p$10) === "object") [p$10, o] = [.5, p$10];
		return range$1(c1$3, c2$3, o)(p$10);
	}
	/**
	*
	* @param {Color | string | Function} c1 The first color or a range
	* @param {Color | string} [c2] The second color if c1 is not a range
	* @param {Object} [options={}]
	* @return {Color[]}
	*/
	function steps(c1$3, c2$3, options = {}) {
		let colorRange;
		if (isRange(c1$3)) {
			[colorRange, options] = [c1$3, c2$3];
			[c1$3, c2$3] = colorRange.rangeArgs.colors;
		}
		let { maxDeltaE, deltaEMethod, steps: steps$1 = 2, maxSteps = 1e3,...rangeOptions } = options;
		if (!colorRange) {
			[c1$3, c2$3] = [getColor(c1$3), getColor(c2$3)];
			colorRange = range$1(c1$3, c2$3, rangeOptions);
		}
		let totalDelta = deltaE(c1$3, c2$3);
		let actualSteps = maxDeltaE > 0 ? Math.max(steps$1, Math.ceil(totalDelta / maxDeltaE) + 1) : steps$1;
		let ret = [];
		if (maxSteps !== void 0) actualSteps = Math.min(actualSteps, maxSteps);
		if (actualSteps === 1) ret = [{
			p: .5,
			color: colorRange(.5)
		}];
		else {
			let step = 1 / (actualSteps - 1);
			ret = Array.from({ length: actualSteps }, (_, i) => {
				let p$10 = i * step;
				return {
					p: p$10,
					color: colorRange(p$10)
				};
			});
		}
		if (maxDeltaE > 0) {
			let maxDelta = ret.reduce((acc, cur, i) => {
				if (i === 0) return 0;
				let  = deltaE(cur.color, ret[i - 1].color, deltaEMethod);
				return Math.max(acc, );
			}, 0);
			while (maxDelta > maxDeltaE) {
				maxDelta = 0;
				for (let i = 1; i < ret.length && ret.length < maxSteps; i++) {
					let prev = ret[i - 1];
					let cur = ret[i];
					let p$10 = (cur.p + prev.p) / 2;
					let color = colorRange(p$10);
					maxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));
					ret.splice(i, 0, {
						p: p$10,
						color: colorRange(p$10)
					});
					i++;
				}
			}
		}
		ret = ret.map((a$1) => a$1.color);
		return ret;
	}
	/**
	* Interpolate to color2 and return a function that takes a 0-1 percentage
	* @param {Color | string | Function} color1 The first color or an existing range
	* @param {Color | string} [color2] If color1 is a color, this is the second color
	* @param {Object} [options={}]
	* @returns {Function} A function that takes a 0-1 percentage and returns a color
	*/
	function range$1(color1, color2, options = {}) {
		if (isRange(color1)) {
			let [r, options$1] = [color1, color2];
			return range$1(...r.rangeArgs.colors, {
				...r.rangeArgs.options,
				...options$1
			});
		}
		let { space, outputSpace, progression, premultiplied } = options;
		color1 = getColor(color1);
		color2 = getColor(color2);
		color1 = clone(color1);
		color2 = clone(color2);
		let rangeArgs = {
			colors: [color1, color2],
			options
		};
		if (space) space = ColorSpace.get(space);
		else space = ColorSpace.registry[defaults.interpolationSpace] || color1.space;
		outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
		color1 = to(color1, space);
		color2 = to(color2, space);
		color1 = toGamut(color1);
		color2 = toGamut(color2);
		if (space.coords.h && space.coords.h.type === "angle") {
			let arc = options.hue = options.hue || "shorter";
			let hue = [space, "h"];
			let [1, 2] = [get(color1, hue), get(color2, hue)];
			if (isNaN(1) && !isNaN(2)) 1 = 2;
			else if (isNaN(2) && !isNaN(1)) 2 = 1;
			[1, 2] = adjust(arc, [1, 2]);
			set(color1, hue, 1);
			set(color2, hue, 2);
		}
		if (premultiplied) {
			color1.coords = color1.coords.map((c$1) => c$1 * color1.alpha);
			color2.coords = color2.coords.map((c$1) => c$1 * color2.alpha);
		}
		return Object.assign((p$10) => {
			p$10 = progression ? progression(p$10) : p$10;
			let coords = color1.coords.map((start, i) => {
				let end = color2.coords[i];
				return interpolate(start, end, p$10);
			});
			let alpha = interpolate(color1.alpha, color2.alpha, p$10);
			let ret = {
				space,
				coords,
				alpha
			};
			if (premultiplied) ret.coords = ret.coords.map((c$1) => c$1 / alpha);
			if (outputSpace !== space) ret = to(ret, outputSpace);
			return ret;
		}, { rangeArgs });
	}
	function isRange(val) {
		return type(val) === "function" && !!val.rangeArgs;
	}
	defaults.interpolationSpace = "lab";
	function register(Color$1) {
		Color$1.defineFunction("mix", mix, { returns: "color" });
		Color$1.defineFunction("range", range$1, { returns: "function<color>" });
		Color$1.defineFunction("steps", steps, { returns: "array<color>" });
	}
	var interpolation = /* @__PURE__ */ Object.freeze({
		__proto__: null,
		isRange,
		mix,
		range: range$1,
		register,
		steps
	});
	var HSL = new ColorSpace({
		id: "hsl",
		name: "HSL",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			s: {
				range: [0, 100],
				name: "Saturation"
			},
			l: {
				range: [0, 100],
				name: "Lightness"
			}
		},
		base: sRGB,
		fromBase: (rgb) => {
			let max$2 = Math.max(...rgb);
			let min$1 = Math.min(...rgb);
			let [r, g$1, b$2] = rgb;
			let [h, s, l] = [
				NaN,
				0,
				(min$1 + max$2) / 2
			];
			let d$1 = max$2 - min$1;
			if (d$1 !== 0) {
				s = l === 0 || l === 1 ? 0 : (max$2 - l) / Math.min(l, 1 - l);
				switch (max$2) {
					case r:
						h = (g$1 - b$2) / d$1 + (g$1 < b$2 ? 6 : 0);
						break;
					case g$1:
						h = (b$2 - r) / d$1 + 2;
						break;
					case b$2: h = (r - g$1) / d$1 + 4;
				}
				h = h * 60;
			}
			if (s < 0) {
				h += 180;
				s = Math.abs(s);
			}
			if (h >= 360) h -= 360;
			return [
				h,
				s * 100,
				l * 100
			];
		},
		toBase: (hsl) => {
			let [h, s, l] = hsl;
			h = h % 360;
			if (h < 0) h += 360;
			s /= 100;
			l /= 100;
			function f(n$2) {
				let k = (n$2 + h / 30) % 12;
				let a$1 = s * Math.min(l, 1 - l);
				return l - a$1 * Math.max(-1, Math.min(k - 3, 9 - k, 1));
			}
			return [
				f(0),
				f(8),
				f(4)
			];
		},
		formats: {
			"hsl": { coords: [
				"<number> | <angle>",
				"<percentage>",
				"<percentage>"
			] },
			"hsla": {
				coords: [
					"<number> | <angle>",
					"<percentage>",
					"<percentage>"
				],
				commas: true,
				lastAlpha: true
			}
		}
	});
	var HSV = new ColorSpace({
		id: "hsv",
		name: "HSV",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			s: {
				range: [0, 100],
				name: "Saturation"
			},
			v: {
				range: [0, 100],
				name: "Value"
			}
		},
		base: HSL,
		fromBase(hsl) {
			let [h, s, l] = hsl;
			s /= 100;
			l /= 100;
			let v = l + s * Math.min(l, 1 - l);
			return [
				h,
				v === 0 ? 0 : 200 * (1 - l / v),
				100 * v
			];
		},
		toBase(hsv) {
			let [h, s, v] = hsv;
			s /= 100;
			v /= 100;
			let l = v * (1 - s / 2);
			return [
				h,
				l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l) * 100,
				l * 100
			];
		},
		formats: { color: {
			id: "--hsv",
			coords: [
				"<number> | <angle>",
				"<percentage> | <number>",
				"<percentage> | <number>"
			]
		} }
	});
	var hwb = new ColorSpace({
		id: "hwb",
		name: "HWB",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			w: {
				range: [0, 100],
				name: "Whiteness"
			},
			b: {
				range: [0, 100],
				name: "Blackness"
			}
		},
		base: HSV,
		fromBase(hsv) {
			let [h, s, v] = hsv;
			return [
				h,
				v * (100 - s) / 100,
				100 - v
			];
		},
		toBase(hwb$1) {
			let [h, w, b$2] = hwb$1;
			w /= 100;
			b$2 /= 100;
			let sum = w + b$2;
			if (sum >= 1) return [
				h,
				0,
				w / sum * 100
			];
			let v = 1 - b$2;
			return [
				h,
				(v === 0 ? 0 : 1 - w / v) * 100,
				v * 100
			];
		},
		formats: { "hwb": { coords: [
			"<number> | <angle>",
			"<percentage> | <number>",
			"<percentage> | <number>"
		] } }
	});
	var A98Linear = new RGBColorSpace({
		id: "a98rgb-linear",
		cssId: "--a98-rgb-linear",
		name: "Linear Adobe 98 RGB compatible",
		white: "D65",
		toXYZ_M: [
			[
				.5766690429101305,
				.1855582379065463,
				.1882286462349947
			],
			[
				.29734497525053605,
				.6273635662554661,
				.07529145849399788
			],
			[
				.02703136138641234,
				.07068885253582723,
				.9913375368376388
			]
		],
		fromXYZ_M: [
			[
				2.0415879038107465,
				-.5650069742788596,
				-.34473135077832956
			],
			[
				-.9692436362808795,
				1.8759675015077202,
				.04155505740717557
			],
			[
				.013444280632031142,
				-.11836239223101838,
				1.0151749943912054
			]
		]
	});
	var a98rgb = new RGBColorSpace({
		id: "a98rgb",
		cssId: "a98-rgb",
		name: "Adobe 98 RGB compatible",
		base: A98Linear,
		toBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),
		fromBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val))
	});
	var ProPhotoLinear = new RGBColorSpace({
		id: "prophoto-linear",
		cssId: "--prophoto-rgb-linear",
		name: "Linear ProPhoto",
		white: "D50",
		base: XYZ_D50,
		toXYZ_M: [
			[
				.7977666449006423,
				.13518129740053308,
				.0313477341283922
			],
			[
				.2880748288194013,
				.711835234241873,
				8993693872564e-17
			],
			[
				0,
				0,
				.8251046025104602
			]
		],
		fromXYZ_M: [
			[
				1.3457868816471583,
				-.25557208737979464,
				-.05110186497554526
			],
			[
				-.5446307051249019,
				1.5082477428451468,
				.02052744743642139
			],
			[
				0,
				0,
				1.2119675456389452
			]
		]
	});
	var Et = 1 / 512;
	var Et2 = 16 / 512;
	var prophoto = new RGBColorSpace({
		id: "prophoto",
		cssId: "prophoto-rgb",
		name: "ProPhoto",
		base: ProPhotoLinear,
		toBase(RGB) {
			return RGB.map((v) => v < Et2 ? v / 16 : v ** 1.8);
		},
		fromBase(RGB) {
			return RGB.map((v) => v >= Et ? v ** (1 / 1.8) : 16 * v);
		}
	});
	var oklch = new ColorSpace({
		id: "oklch",
		name: "Oklch",
		coords: {
			l: {
				refRange: [0, 1],
				name: "Lightness"
			},
			c: {
				refRange: [0, .4],
				name: "Chroma"
			},
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},
		white: "D65",
		base: OKLab,
		fromBase(oklab) {
			let [L, a$1, b$2] = oklab;
			let h;
			const $8 = 2e-4;
			if (Math.abs(a$1) < $8 && Math.abs(b$2) < $8) h = NaN;
			else h = Math.atan2(b$2, a$1) * 180 / Math.PI;
			return [
				L,
				Math.sqrt(a$1 ** 2 + b$2 ** 2),
				constrain(h)
			];
		},
		toBase(oklch$1) {
			let [L, C, h] = oklch$1;
			let a$1, b$2;
			if (isNaN(h)) {
				a$1 = 0;
				b$2 = 0;
			} else {
				a$1 = C * Math.cos(h * Math.PI / 180);
				b$2 = C * Math.sin(h * Math.PI / 180);
			}
			return [
				L,
				a$1,
				b$2
			];
		},
		formats: { "oklch": { coords: [
			"<percentage> | <number>",
			"<number> | <percentage>[0,1]",
			"<number> | <angle>"
		] } }
	});
	var white = WHITES.D65;
	var $2 = 216 / 24389;
	var $1 = 24389 / 27;
	var [U_PRIME_WHITE, V_PRIME_WHITE] = uv({
		space: xyz_d65,
		coords: white
	});
	var Luv = new ColorSpace({
		id: "luv",
		name: "Luv",
		coords: {
			l: {
				refRange: [0, 100],
				name: "Lightness"
			},
			u: { refRange: [-215, 215] },
			v: { refRange: [-215, 215] }
		},
		white,
		base: xyz_d65,
		fromBase(XYZ) {
			let xyz = [
				skipNone(XYZ[0]),
				skipNone(XYZ[1]),
				skipNone(XYZ[2])
			];
			let y = xyz[1];
			let [up, vp] = uv({
				space: xyz_d65,
				coords: xyz
			});
			if (!Number.isFinite(up) || !Number.isFinite(vp)) return [
				0,
				0,
				0
			];
			let L = y <= $2 ? $1 * y : 116 * Math.cbrt(y) - 16;
			return [
				L,
				13 * L * (up - U_PRIME_WHITE),
				13 * L * (vp - V_PRIME_WHITE)
			];
		},
		toBase(Luv$1) {
			let [L, u, v] = Luv$1;
			if (L === 0 || isNone(L)) return [
				0,
				0,
				0
			];
			u = skipNone(u);
			v = skipNone(v);
			let up = u / (13 * L) + U_PRIME_WHITE;
			let vp = v / (13 * L) + V_PRIME_WHITE;
			let y = L <= 8 ? L / $1 : Math.pow((L + 16) / 116, 3);
			return [
				y * (9 * up / (4 * vp)),
				y,
				y * ((12 - 3 * up - 20 * vp) / (4 * vp))
			];
		},
		formats: { color: {
			id: "--luv",
			coords: [
				"<number> | <percentage>",
				"<number> | <percentage>[-1,1]",
				"<number> | <percentage>[-1,1]"
			]
		} }
	});
	var LCHuv = new ColorSpace({
		id: "lchuv",
		name: "LChuv",
		coords: {
			l: {
				refRange: [0, 100],
				name: "Lightness"
			},
			c: {
				refRange: [0, 220],
				name: "Chroma"
			},
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},
		base: Luv,
		fromBase(Luv$1) {
			let [L, u, v] = Luv$1;
			let hue;
			const $8 = .02;
			if (Math.abs(u) < $8 && Math.abs(v) < $8) hue = NaN;
			else hue = Math.atan2(v, u) * 180 / Math.PI;
			return [
				L,
				Math.sqrt(u ** 2 + v ** 2),
				constrain(hue)
			];
		},
		toBase(LCH) {
			let [Lightness, Chroma, Hue] = LCH;
			if (Chroma < 0) Chroma = 0;
			if (isNaN(Hue)) Hue = 0;
			return [
				Lightness,
				Chroma * Math.cos(Hue * Math.PI / 180),
				Chroma * Math.sin(Hue * Math.PI / 180)
			];
		},
		formats: { color: {
			id: "--lchuv",
			coords: [
				"<number> | <percentage>",
				"<number> | <percentage>",
				"<number> | <angle>"
			]
		} }
	});
	var $1 = 216 / 24389;
	var  = 24389 / 27;
	var m_r0 = fromXYZ_M$3[0][0];
	var m_r1 = fromXYZ_M$3[0][1];
	var m_r2 = fromXYZ_M$3[0][2];
	var m_g0 = fromXYZ_M$3[1][0];
	var m_g1 = fromXYZ_M$3[1][1];
	var m_g2 = fromXYZ_M$3[1][2];
	var m_b0 = fromXYZ_M$3[2][0];
	var m_b1 = fromXYZ_M$3[2][1];
	var m_b2 = fromXYZ_M$3[2][2];
	function distanceFromOriginAngle(slope, intercept, angle) {
		const d$1 = intercept / (Math.sin(angle) - slope * Math.cos(angle));
		return d$1 < 0 ? Infinity : d$1;
	}
	function calculateBoundingLines(l) {
		const sub1 = Math.pow(l + 16, 3) / 1560896;
		const sub2 = sub1 > $1 ? sub1 : l / ;
		const s1r = sub2 * (284517 * m_r0 - 94839 * m_r2);
		const s2r = sub2 * (838422 * m_r2 + 769860 * m_r1 + 731718 * m_r0);
		const s3r = sub2 * (632260 * m_r2 - 126452 * m_r1);
		const s1g = sub2 * (284517 * m_g0 - 94839 * m_g2);
		const s2g = sub2 * (838422 * m_g2 + 769860 * m_g1 + 731718 * m_g0);
		const s3g = sub2 * (632260 * m_g2 - 126452 * m_g1);
		const s1b = sub2 * (284517 * m_b0 - 94839 * m_b2);
		const s2b = sub2 * (838422 * m_b2 + 769860 * m_b1 + 731718 * m_b0);
		const s3b = sub2 * (632260 * m_b2 - 126452 * m_b1);
		return {
			r0s: s1r / s3r,
			r0i: s2r * l / s3r,
			r1s: s1r / (s3r + 126452),
			r1i: (s2r - 769860) * l / (s3r + 126452),
			g0s: s1g / s3g,
			g0i: s2g * l / s3g,
			g1s: s1g / (s3g + 126452),
			g1i: (s2g - 769860) * l / (s3g + 126452),
			b0s: s1b / s3b,
			b0i: s2b * l / s3b,
			b1s: s1b / (s3b + 126452),
			b1i: (s2b - 769860) * l / (s3b + 126452)
		};
	}
	function calcMaxChromaHsluv(lines, h) {
		const hueRad = h / 360 * Math.PI * 2;
		const r0 = distanceFromOriginAngle(lines.r0s, lines.r0i, hueRad);
		const r1 = distanceFromOriginAngle(lines.r1s, lines.r1i, hueRad);
		const g0 = distanceFromOriginAngle(lines.g0s, lines.g0i, hueRad);
		const g1 = distanceFromOriginAngle(lines.g1s, lines.g1i, hueRad);
		const b0 = distanceFromOriginAngle(lines.b0s, lines.b0i, hueRad);
		const b1 = distanceFromOriginAngle(lines.b1s, lines.b1i, hueRad);
		return Math.min(r0, r1, g0, g1, b0, b1);
	}
	var hsluv = new ColorSpace({
		id: "hsluv",
		name: "HSLuv",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			s: {
				range: [0, 100],
				name: "Saturation"
			},
			l: {
				range: [0, 100],
				name: "Lightness"
			}
		},
		base: LCHuv,
		gamutSpace: sRGB,
		fromBase(lch$1) {
			let [l, c$1, h] = [
				skipNone(lch$1[0]),
				skipNone(lch$1[1]),
				skipNone(lch$1[2])
			];
			let s;
			if (l > 99.9999999) {
				s = 0;
				l = 100;
			} else if (l < 1e-8) {
				s = 0;
				l = 0;
			} else s = c$1 / calcMaxChromaHsluv(calculateBoundingLines(l), h) * 100;
			return [
				h,
				s,
				l
			];
		},
		toBase(hsl) {
			let [h, s, l] = [
				skipNone(hsl[0]),
				skipNone(hsl[1]),
				skipNone(hsl[2])
			];
			let c$1;
			if (l > 99.9999999) {
				l = 100;
				c$1 = 0;
			} else if (l < 1e-8) {
				l = 0;
				c$1 = 0;
			} else c$1 = calcMaxChromaHsluv(calculateBoundingLines(l), h) / 100 * s;
			return [
				l,
				c$1,
				h
			];
		},
		formats: { color: {
			id: "--hsluv",
			coords: [
				"<number> | <angle>",
				"<percentage> | <number>",
				"<percentage> | <number>"
			]
		} }
	});
	fromXYZ_M$3[0][0];
	fromXYZ_M$3[0][1];
	fromXYZ_M$3[0][2];
	fromXYZ_M$3[1][0];
	fromXYZ_M$3[1][1];
	fromXYZ_M$3[1][2];
	fromXYZ_M$3[2][0];
	fromXYZ_M$3[2][1];
	fromXYZ_M$3[2][2];
	function distanceFromOrigin(slope, intercept) {
		return Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
	}
	function calcMaxChromaHpluv(lines) {
		let r0 = distanceFromOrigin(lines.r0s, lines.r0i);
		let r1 = distanceFromOrigin(lines.r1s, lines.r1i);
		let g0 = distanceFromOrigin(lines.g0s, lines.g0i);
		let g1 = distanceFromOrigin(lines.g1s, lines.g1i);
		let b0 = distanceFromOrigin(lines.b0s, lines.b0i);
		let b1 = distanceFromOrigin(lines.b1s, lines.b1i);
		return Math.min(r0, r1, g0, g1, b0, b1);
	}
	var hpluv = new ColorSpace({
		id: "hpluv",
		name: "HPLuv",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			s: {
				range: [0, 100],
				name: "Saturation"
			},
			l: {
				range: [0, 100],
				name: "Lightness"
			}
		},
		base: LCHuv,
		gamutSpace: "self",
		fromBase(lch$1) {
			let [l, c$1, h] = [
				skipNone(lch$1[0]),
				skipNone(lch$1[1]),
				skipNone(lch$1[2])
			];
			let s;
			if (l > 99.9999999) {
				s = 0;
				l = 100;
			} else if (l < 1e-8) {
				s = 0;
				l = 0;
			} else s = c$1 / calcMaxChromaHpluv(calculateBoundingLines(l)) * 100;
			return [
				h,
				s,
				l
			];
		},
		toBase(hsl) {
			let [h, s, l] = [
				skipNone(hsl[0]),
				skipNone(hsl[1]),
				skipNone(hsl[2])
			];
			let c$1;
			if (l > 99.9999999) {
				l = 100;
				c$1 = 0;
			} else if (l < 1e-8) {
				l = 0;
				c$1 = 0;
			} else c$1 = calcMaxChromaHpluv(calculateBoundingLines(l)) / 100 * s;
			return [
				l,
				c$1,
				h
			];
		},
		formats: { color: {
			id: "--hpluv",
			coords: [
				"<number> | <angle>",
				"<percentage> | <number>",
				"<percentage> | <number>"
			]
		} }
	});
	var Yw = 203;
	var n = 2610 / 2 ** 14;
	var ninv = 2 ** 14 / 2610;
	var m = 2523 / 2 ** 5;
	var minv = 2 ** 5 / 2523;
	var c1 = 3424 / 2 ** 12;
	var c2 = 2413 / 2 ** 7;
	var c3 = 2392 / 2 ** 7;
	var rec2100Pq = new RGBColorSpace({
		id: "rec2100pq",
		cssId: "rec2100-pq",
		name: "REC.2100-PQ",
		base: REC2020Linear,
		toBase(RGB) {
			return RGB.map(function(val) {
				return (Math.max(val ** minv - c1, 0) / (c2 - c3 * val ** minv)) ** ninv * 1e4 / Yw;
			});
		},
		fromBase(RGB) {
			return RGB.map(function(val) {
				let x = Math.max(val * Yw / 1e4, 0);
				return ((c1 + c2 * x ** n) / (1 + c3 * x ** n)) ** m;
			});
		}
	});
	var a = .17883277;
	var b = .28466892;
	var c = .55991073;
	var scale = 3.7743;
	var rec2100Hlg = new RGBColorSpace({
		id: "rec2100hlg",
		cssId: "rec2100-hlg",
		name: "REC.2100-HLG",
		referred: "scene",
		base: REC2020Linear,
		toBase(RGB) {
			return RGB.map(function(val) {
				if (val <= .5) return val ** 2 / 3 * scale;
				return (Math.exp((val - c) / a) + b) / 12 * scale;
			});
		},
		fromBase(RGB) {
			return RGB.map(function(val) {
				val /= scale;
				if (val <= 1 / 12) return Math.sqrt(3 * val);
				return a * Math.log(12 * val - b) + c;
			});
		}
	});
	var CATs = {};
	hooks.add("chromatic-adaptation-start", (env) => {
		if (env.options.method) env.M = adapt(env.W1, env.W2, env.options.method);
	});
	hooks.add("chromatic-adaptation-end", (env) => {
		if (!env.M) env.M = adapt(env.W1, env.W2, env.options.method);
	});
	function defineCAT({ id, toCone_M, fromCone_M }) {
		CATs[id] = arguments[0];
	}
	function adapt(W1, W2, id = "Bradford") {
		let method = CATs[id];
		let [s, s, s] = multiplyMatrices(method.toCone_M, W1);
		let [d, d, d] = multiplyMatrices(method.toCone_M, W2);
		let scaled_cone_M = multiplyMatrices([
			[
				d / s,
				0,
				0
			],
			[
				0,
				d / s,
				0
			],
			[
				0,
				0,
				d / s
			]
		], method.toCone_M);
		return multiplyMatrices(method.fromCone_M, scaled_cone_M);
	}
	defineCAT({
		id: "von Kries",
		toCone_M: [
			[
				.40024,
				.7076,
				-.08081
			],
			[
				-.2263,
				1.16532,
				.0457
			],
			[
				0,
				0,
				.91822
			]
		],
		fromCone_M: [
			[
				1.8599363874558397,
				-1.1293816185800916,
				.21989740959619328
			],
			[
				.3611914362417676,
				.6388124632850422,
				-6370596838649899e-21
			],
			[
				0,
				0,
				1.0890636230968613
			]
		]
	});
	defineCAT({
		id: "Bradford",
		toCone_M: [
			[
				.8951,
				.2664,
				-.1614
			],
			[
				-.7502,
				1.7135,
				.0367
			],
			[
				.0389,
				-.0685,
				1.0296
			]
		],
		fromCone_M: [
			[
				.9869929054667121,
				-.14705425642099013,
				.15996265166373122
			],
			[
				.4323052697233945,
				.5183602715367774,
				.049291228212855594
			],
			[
				-.00852866457517732,
				.04004282165408486,
				.96848669578755
			]
		]
	});
	defineCAT({
		id: "CAT02",
		toCone_M: [
			[
				.7328,
				.4296,
				-.1624
			],
			[
				-.7036,
				1.6975,
				.0061
			],
			[
				.003,
				.0136,
				.9834
			]
		],
		fromCone_M: [
			[
				1.0961238208355142,
				-.27886900021828726,
				.18274517938277307
			],
			[
				.4543690419753592,
				.4735331543074117,
				.07209780371722911
			],
			[
				-.009627608738429355,
				-.00569803121611342,
				1.0153256399545427
			]
		]
	});
	defineCAT({
		id: "CAT16",
		toCone_M: [
			[
				.401288,
				.650173,
				-.051461
			],
			[
				-.250268,
				1.204414,
				.045854
			],
			[
				-.002079,
				.048952,
				.953127
			]
		],
		fromCone_M: [
			[
				1.862067855087233,
				-1.0112546305316845,
				.14918677544445172
			],
			[
				.3875265432361372,
				.6214474419314753,
				-.008973985167612521
			],
			[
				-.01584149884933386,
				-.03412293802851557,
				1.0499644368778496
			]
		]
	});
	Object.assign(WHITES, {
		A: [
			1.0985,
			1,
			.35585
		],
		C: [
			.98074,
			1,
			1.18232
		],
		D55: [
			.95682,
			1,
			.92149
		],
		D75: [
			.94972,
			1,
			1.22638
		],
		E: [
			1,
			1,
			1
		],
		F2: [
			.99186,
			1,
			.67393
		],
		F7: [
			.95041,
			1,
			1.08747
		],
		F11: [
			1.00962,
			1,
			.6435
		]
	});
	WHITES.ACES = [
		.32168 / .33767,
		1,
		.34065 / .33767
	];
	var ACEScg = new RGBColorSpace({
		id: "acescg",
		cssId: "--acescg",
		name: "ACEScg",
		coords: {
			r: {
				range: [0, 65504],
				name: "Red"
			},
			g: {
				range: [0, 65504],
				name: "Green"
			},
			b: {
				range: [0, 65504],
				name: "Blue"
			}
		},
		referred: "scene",
		white: WHITES.ACES,
		toXYZ_M: [
			[
				.6624541811085053,
				.13400420645643313,
				.1561876870049078
			],
			[
				.27222871678091454,
				.6740817658111484,
				.05368951740793705
			],
			[
				-.005574649490394108,
				.004060733528982826,
				1.0103391003129971
			]
		],
		fromXYZ_M: [
			[
				1.6410233796943257,
				-.32480329418479,
				-.23642469523761225
			],
			[
				-.6636628587229829,
				1.6153315916573379,
				.016756347685530137
			],
			[
				.011721894328375376,
				-.008284441996237409,
				.9883948585390215
			]
		]
	});
	var  = 2 ** -16;
	var ACES_min_nonzero = -.35828683;
	var ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52;
	var acescc = new RGBColorSpace({
		id: "acescc",
		cssId: "--acescc",
		name: "ACEScc",
		coords: {
			r: {
				range: [ACES_min_nonzero, ACES_cc_max],
				name: "Red"
			},
			g: {
				range: [ACES_min_nonzero, ACES_cc_max],
				name: "Green"
			},
			b: {
				range: [ACES_min_nonzero, ACES_cc_max],
				name: "Blue"
			}
		},
		referred: "scene",
		base: ACEScg,
		toBase(RGB) {
			const low = -5.279999999999999 / 17.52;
			return RGB.map(function(val) {
				if (val <= low) return (2 ** (val * 17.52 - 9.72) - ) * 2;
				else if (val < ACES_cc_max) return 2 ** (val * 17.52 - 9.72);
				else return 65504;
			});
		},
		fromBase(RGB) {
			return RGB.map(function(val) {
				if (val <= 0) return (Math.log2() + 9.72) / 17.52;
				else if (val < ) return (Math.log2( + val * .5) + 9.72) / 17.52;
				else return (Math.log2(val) + 9.72) / 17.52;
			});
		}
	});
	var spaces = /* @__PURE__ */ Object.freeze({
		__proto__: null,
		A98RGB: a98rgb,
		A98RGB_Linear: A98Linear,
		ACEScc: acescc,
		ACEScg,
		CAM16_JMh: cam16,
		HCT: hct,
		HPLuv: hpluv,
		HSL,
		HSLuv: hsluv,
		HSV,
		HWB: hwb,
		ICTCP: ictcp,
		JzCzHz: jzczhz,
		Jzazbz,
		LCH: lch,
		LCHuv,
		Lab: lab,
		Lab_D65: lab_d65,
		Luv,
		OKLCH: oklch,
		OKLab,
		P3,
		P3_Linear: P3Linear,
		ProPhoto: prophoto,
		ProPhoto_Linear: ProPhotoLinear,
		REC_2020: REC2020,
		REC_2020_Linear: REC2020Linear,
		REC_2100_HLG: rec2100Hlg,
		REC_2100_PQ: rec2100Pq,
		XYZ_ABS_D65: XYZ_Abs_D65,
		XYZ_D50,
		XYZ_D65: xyz_d65,
		sRGB,
		sRGB_Linear: sRGBLinear
	});
	/**
	* Class that represents a color
	*/
	var Color = class Color {
		/**
		* Creates an instance of Color.
		* Signatures:
		* - `new Color(stringToParse)`
		* - `new Color(otherColor)`
		* - `new Color({space, coords, alpha})`
		* - `new Color(space, coords, alpha)`
		* - `new Color(spaceId, coords, alpha)`
		*/
		constructor(...args) {
			let color;
			if (args.length === 1) color = getColor(args[0]);
			let space, coords, alpha;
			if (color) {
				space = color.space || color.spaceId;
				coords = color.coords;
				alpha = color.alpha;
			} else [space, coords, alpha] = args;
			Object.defineProperty(this, "space", {
				value: ColorSpace.get(space),
				writable: false,
				enumerable: true,
				configurable: true
			});
			this.coords = coords ? coords.slice() : [
				0,
				0,
				0
			];
			this.alpha = alpha > 1 || alpha === void 0 ? 1 : alpha < 0 ? 0 : alpha;
			for (let i = 0; i < this.coords.length; i++) if (this.coords[i] === "NaN") this.coords[i] = NaN;
			for (let id in this.space.coords) Object.defineProperty(this, id, {
				get: () => this.get(id),
				set: (value) => this.set(id, value)
			});
		}
		get spaceId() {
			return this.space.id;
		}
		clone() {
			return new Color(this.space, this.coords, this.alpha);
		}
		toJSON() {
			return {
				spaceId: this.spaceId,
				coords: this.coords,
				alpha: this.alpha
			};
		}
		display(...args) {
			let ret = display(this, ...args);
			ret.color = new Color(ret.color);
			return ret;
		}
		/**
		* Get a color from the argument passed
		* Basically gets us the same result as new Color(color) but doesn't clone an existing color object
		*/
		static get(color, ...args) {
			if (color instanceof Color) return color;
			return new Color(color, ...args);
		}
		static defineFunction(name, code, o = code) {
			let { instance = true, returns } = o;
			let func = function(...args) {
				let ret = code(...args);
				if (returns === "color") ret = Color.get(ret);
				else if (returns === "function<color>") {
					let f = ret;
					ret = function(...args$1) {
						let ret$1 = f(...args$1);
						return Color.get(ret$1);
					};
					Object.assign(ret, f);
				} else if (returns === "array<color>") ret = ret.map((c$1) => Color.get(c$1));
				return ret;
			};
			if (!(name in Color)) Color[name] = func;
			if (instance) Color.prototype[name] = function(...args) {
				return func(this, ...args);
			};
		}
		static defineFunctions(o) {
			for (let name in o) Color.defineFunction(name, o[name], o[name]);
		}
		static extend(exports$1) {
			if (exports$1.register) exports$1.register(Color);
			else for (let name in exports$1) Color.defineFunction(name, exports$1[name]);
		}
	};
	Color.defineFunctions({
		get,
		getAll,
		set,
		setAll,
		to,
		equals: equals$1,
		inGamut,
		toGamut,
		distance,
		toString: serialize
	});
	Object.assign(Color, {
		util: util$2,
		hooks,
		WHITES,
		Space: ColorSpace,
		spaces: ColorSpace.registry,
		parse,
		defaults
	});
	for (let key of Object.keys(spaces)) ColorSpace.register(spaces[key]);
	/**
	* This plugin defines getters and setters for color[spaceId]
	* e.g. color.lch on *any* color gives us the lch coords
	*/
	for (let id in ColorSpace.registry) addSpaceAccessors(id, ColorSpace.registry[id]);
	hooks.add("colorspace-init-end", (space) => {
		addSpaceAccessors(space.id, space);
		space.aliases?.forEach((alias) => {
			addSpaceAccessors(alias, space);
		});
	});
	function addSpaceAccessors(id, space) {
		let propId = id.replace(/-/g, "_");
		Object.defineProperty(Color.prototype, propId, {
			get() {
				let ret = this.getAll(id);
				if (typeof Proxy === "undefined") return ret;
				return new Proxy(ret, {
					has: (obj, property) => {
						try {
							ColorSpace.resolveCoord([space, property]);
							return true;
						} catch (e) {}
						return Reflect.has(obj, property);
					},
					get: (obj, property, receiver) => {
						if (property && typeof property !== "symbol" && !(property in obj)) {
							let { index } = ColorSpace.resolveCoord([space, property]);
							if (index >= 0) return obj[index];
						}
						return Reflect.get(obj, property, receiver);
					},
					set: (obj, property, value, receiver) => {
						if (property && typeof property !== "symbol" && !(property in obj) || property >= 0) {
							let { index } = ColorSpace.resolveCoord([space, property]);
							if (index >= 0) {
								obj[index] = value;
								this.setAll(id, obj);
								return true;
							}
						}
						return Reflect.set(obj, property, value, receiver);
					}
				});
			},
			set(coords) {
				this.setAll(id, coords);
			},
			configurable: true,
			enumerable: true
		});
	}
	Color.extend(deltaEMethods);
	Color.extend({ deltaE });
	Object.assign(Color, { deltaEMethods });
	Color.extend(variations);
	Color.extend({ contrast });
	Color.extend(chromaticity);
	Color.extend(luminance);
	Color.extend(interpolation);
	Color.extend(contrastMethods);
	exports.default = Color;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/color.js
var require_color$1 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/color.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var index_1$5 = require_value$1();
	var deprecations_1$5 = require_deprecations();
	var utils_1$14 = require_utils$3();
	var utils_2$3 = require_utils$2();
	var immutable_1$7 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var colorjs_io_1 = require_color$2();
	/** Legacy determination of color space by channel name. */
	function getColorSpace(options) {
		if (typeof options.red === "number") return "rgb";
		if (typeof options.saturation === "number") return "hsl";
		if (typeof options.whiteness === "number") return "hwb";
		throw (0, utils_1$14.valueError)("No color space found");
	}
	/**
	* Convert from the ColorJS representation of a missing component (`NaN`) to
	* `null`.
	*/
	function NaNtoNull(val) {
		return Number.isNaN(val) ? null : val;
	}
	/**
	* Convert from the ColorJS representation of a missing component (`NaN`) to
	* `0`.
	*/
	function NaNtoZero(val) {
		return Number.isNaN(val) ? 0 : val;
	}
	/** Convert from sRGB (0-1) to RGB (0-255) units. */
	function coordToRgb(val) {
		return val * 255;
	}
	/** Normalize `hue` values to be within the range `[0, 360)`. */
	function normalizeHue(val) {
		return (0, utils_2$3.positiveMod)(val, 360);
	}
	/**
	* Normalize discrepancies between Sass color spaces and ColorJS color space
	* ids, converting Sass values to ColorJS values.
	*/
	function encodeSpaceForColorJs(space) {
		switch (space) {
			case "rgb": return "srgb";
			case "a98-rgb": return "a98rgb";
			case "display-p3": return "p3";
			case "prophoto-rgb": return "prophoto";
		}
		return space;
	}
	/**
	* Normalize discrepancies between Sass's [GamutMapMethod] and Color.js's
	* `method` option.
	*/
	function encodeGamutMapMethodForColorJs(method) {
		return method === "local-minde" ? "css" : method;
	}
	/**
	* Normalize discrepancies between Sass color spaces and ColorJS color space
	* ids, converting ColorJS values to Sass values.
	*/
	function decodeSpaceFromColorJs(space, isRgb = false) {
		switch (space) {
			case "srgb": return isRgb ? "rgb" : space;
			case "xyz-d65": return "xyz";
			case "a98rgb": return "a98-rgb";
			case "p3": return "display-p3";
			case "prophoto": return "prophoto-rgb";
		}
		return space;
	}
	/**
	* Normalize discrepancies between Sass channel names and ColorJS channel ids,
	* converting Sass values to ColorJS values.
	*
	* @TODO Waiting on a new release of ColorJS that allows Lab spaces to accept
	* `lightness` instead of only `l` and not as a channel name.
	* Fixed in: https://github.com/LeaVerou/color.js/pull/348
	*/
	function encodeChannelForColorJs(channel) {
		if (channel === "lightness") return "l";
		return channel;
	}
	/**
	* Implement our own check of channel name validity for a given space, because
	* ColorJS allows e.g. `b` for any of `blue`, `blackness`, or `b` channels.
	*/
	function validateChannelInSpace(channel, space) {
		if (channel === "alpha") return;
		let valid = false;
		switch (space) {
			case "rgb":
			case "srgb":
			case "srgb-linear":
			case "display-p3":
			case "a98-rgb":
			case "prophoto-rgb":
			case "rec2020":
				valid = [
					"red",
					"green",
					"blue"
				].includes(channel);
				break;
			case "hsl":
				valid = [
					"hue",
					"saturation",
					"lightness"
				].includes(channel);
				break;
			case "hwb":
				valid = [
					"hue",
					"whiteness",
					"blackness"
				].includes(channel);
				break;
			case "lab":
			case "oklab":
				valid = [
					"lightness",
					"a",
					"b"
				].includes(channel);
				break;
			case "lch":
			case "oklch":
				valid = [
					"lightness",
					"chroma",
					"hue"
				].includes(channel);
				break;
			case "xyz":
			case "xyz-d65":
			case "xyz-d50":
				valid = [
					"x",
					"y",
					"z"
				].includes(channel);
				break;
		}
		if (!valid) throw (0, utils_1$14.valueError)(`Unknown channel name "${channel}" for color space "${space}".`);
	}
	/** Determine whether the given space is a polar color space. */
	function isPolarColorSpace(space) {
		switch (space) {
			case "hsl":
			case "hwb":
			case "lch":
			case "oklch": return true;
			default: return false;
		}
	}
	/**
	* Convert from ColorJS coordinates (which use `NaN` for missing components, and
	* a range of `0-1` for `rgb` channel values) to Sass Color coordinates (which
	* use `null` for missing components, and a range of `0-255` for `rgb` channel
	* values).
	*/
	function decodeCoordsFromColorJs(coords, isRgb = false) {
		let newCoords = coords;
		if (isRgb) newCoords = newCoords.map(coordToRgb);
		return newCoords.map(NaNtoNull);
	}
	/** Returns `true` if `val` is a `number` or `null`. */
	function isNumberOrNull(val) {
		return val === null || typeof val === "number";
	}
	/**
	* Emit deprecation warnings when legacy color spaces set `alpha` or channel
	* values to `null` without explicitly setting the `space`.
	*/
	function checkChangeDeprecations(options, channels) {
		if (options.alpha === null) emitNullAlphaDeprecation();
		for (const channel of channels) if (options[channel] === null) emitColor4ApiChangeNullDeprecation(channel);
	}
	/** Warn users about legacy color channel getters. */
	function emitColor4ApiGetterDeprecation(name) {
		(0, deprecations_1$5.warnForHostSideDeprecation)(`\`${name}\` is deprecated, use \`channel\` instead.
More info: https://sass-lang.com/d/color-4-api`, deprecations_1$5.deprecations["color-4-api"]);
	}
	/**
	* Warn users about changing channels not in the current color space without
	* explicitly setting `space`.
	*/
	function emitColor4ApiChangeSpaceDeprecation() {
		(0, deprecations_1$5.warnForHostSideDeprecation)("Changing a channel not in this color's space without explicitly specifying the `space` option is deprecated.\nMore info: https://sass-lang.com/d/color-4-api", deprecations_1$5.deprecations["color-4-api"]);
	}
	/** Warn users about `null` channel values without setting `space`. */
	function emitColor4ApiChangeNullDeprecation(channel) {
		(0, deprecations_1$5.warnForHostSideDeprecation)(`Passing \`${channel}: null\` without setting \`space\` is deprecated.
More info: https://sass-lang.com/d/color-4-api`, deprecations_1$5.deprecations["color-4-api"]);
	}
	/** Warn users about null-alpha deprecation. */
	function emitNullAlphaDeprecation() {
		(0, deprecations_1$5.warnForHostSideDeprecation)("Passing `alpha: null` without setting `space` is deprecated.\nMore info: https://sass-lang.com/d/null-alpha", deprecations_1$5.deprecations["null-alpha"]);
	}
	/**
	* Determines whether the options passed to the Constructor include an existing
	* ColorJS color object.
	*/
	function optionsHaveColor(opts) {
		return opts.color instanceof colorjs_io_1.default;
	}
	/** A SassScript color. */
	var SassColor$1 = class SassColor$1 extends index_1$5.Value {
		color;
		isRgb = false;
		channel0Id;
		channel1Id;
		channel2Id;
		setChannelIds(space) {
			switch (space) {
				case "rgb":
				case "srgb":
				case "srgb-linear":
				case "display-p3":
				case "a98-rgb":
				case "prophoto-rgb":
				case "rec2020":
					this.channel0Id = "red";
					this.channel1Id = "green";
					this.channel2Id = "blue";
					break;
				case "hsl":
					this.channel0Id = "hue";
					this.channel1Id = "saturation";
					this.channel2Id = "lightness";
					break;
				case "hwb":
					this.channel0Id = "hue";
					this.channel1Id = "whiteness";
					this.channel2Id = "blackness";
					break;
				case "lab":
				case "oklab":
					this.channel0Id = "lightness";
					this.channel1Id = "a";
					this.channel2Id = "b";
					break;
				case "lch":
				case "oklch":
					this.channel0Id = "lightness";
					this.channel1Id = "chroma";
					this.channel2Id = "hue";
					break;
				case "xyz":
				case "xyz-d65":
				case "xyz-d50":
					this.channel0Id = "x";
					this.channel1Id = "y";
					this.channel2Id = "z";
					break;
			}
		}
		constructor(optionsMaybeWithColor) {
			super();
			let options;
			if (optionsHaveColor(optionsMaybeWithColor)) {
				const { color, space: space$1 } = optionsMaybeWithColor;
				if (space$1 === "rgb") this.isRgb = true;
				this.setChannelIds(space$1);
				this.color = color;
				return;
			} else options = optionsMaybeWithColor;
			const space = options.space ?? getColorSpace(options);
			this.setChannelIds(space);
			if (space === "rgb") this.isRgb = true;
			let alpha;
			if (options.alpha === null) {
				if (!options.space) emitNullAlphaDeprecation();
				alpha = NaN;
			} else if (options.alpha === void 0) alpha = 1;
			else alpha = (0, utils_2$3.fuzzyAssertInRange)(options.alpha, 0, 1, "alpha");
			switch (space) {
				case "rgb":
				case "srgb": {
					const red = options.red ?? NaN;
					const green = options.green ?? NaN;
					const blue = options.blue ?? NaN;
					if (this.isRgb) this.color = new colorjs_io_1.default({
						spaceId: encodeSpaceForColorJs(space),
						coords: [
							red / 255,
							green / 255,
							blue / 255
						],
						alpha
					});
					else this.color = new colorjs_io_1.default({
						spaceId: encodeSpaceForColorJs(space),
						coords: [
							red,
							green,
							blue
						],
						alpha
					});
					break;
				}
				case "srgb-linear":
				case "display-p3":
				case "a98-rgb":
				case "prophoto-rgb":
				case "rec2020":
					this.color = new colorjs_io_1.default({
						spaceId: encodeSpaceForColorJs(space),
						coords: [
							options.red ?? NaN,
							options.green ?? NaN,
							options.blue ?? NaN
						],
						alpha
					});
					break;
				case "hsl": {
					let hue = normalizeHue(options.hue ?? NaN);
					let saturation = options.saturation ?? NaN;
					const lightness = options.lightness ?? NaN;
					if (!Number.isNaN(saturation) && (0, utils_2$3.fuzzyLessThan)(saturation, 0)) {
						saturation = Math.abs(saturation);
						hue = (hue + 180) % 360;
					}
					this.color = new colorjs_io_1.default({
						spaceId: encodeSpaceForColorJs(space),
						coords: [
							hue,
							saturation,
							lightness
						],
						alpha
					});
					break;
				}
				case "hwb": {
					const hue = normalizeHue(options.hue ?? NaN);
					const whiteness = options.whiteness ?? NaN;
					const blackness = options.blackness ?? NaN;
					this.color = new colorjs_io_1.default({
						spaceId: encodeSpaceForColorJs(space),
						coords: [
							hue,
							whiteness,
							blackness
						],
						alpha
					});
					break;
				}
				case "lab":
				case "oklab": {
					const lightness = options.lightness ?? NaN;
					const a$1 = options.a ?? NaN;
					const b$2 = options.b ?? NaN;
					this.color = new colorjs_io_1.default({
						spaceId: encodeSpaceForColorJs(space),
						coords: [
							lightness,
							a$1,
							b$2
						],
						alpha
					});
					break;
				}
				case "lch":
				case "oklch": {
					const lightness = options.lightness ?? NaN;
					let chroma = options.chroma ?? NaN;
					let hue = normalizeHue(options.hue ?? NaN);
					if (!Number.isNaN(chroma) && (0, utils_2$3.fuzzyLessThan)(chroma, 0)) {
						chroma = Math.abs(chroma);
						hue = (hue + 180) % 360;
					}
					this.color = new colorjs_io_1.default({
						spaceId: encodeSpaceForColorJs(space),
						coords: [
							lightness,
							chroma,
							hue
						],
						alpha
					});
					break;
				}
				case "xyz":
				case "xyz-d65":
				case "xyz-d50":
					this.color = new colorjs_io_1.default({
						spaceId: encodeSpaceForColorJs(space),
						coords: [
							options.x ?? NaN,
							options.y ?? NaN,
							options.z ?? NaN
						],
						alpha
					});
					break;
			}
			if (Number.isNaN(alpha)) this.color.alpha = NaN;
		}
		/** This color's alpha channel, between `0` and `1`. */
		get alpha() {
			return NaNtoZero(this.color.alpha);
		}
		/** The name of this color's color space. */
		get space() {
			return decodeSpaceFromColorJs(this.color.spaceId, this.isRgb);
		}
		/**
		* A boolean indicating whether this color is in a legacy color space (`rgb`,
		* `hsl`, or `hwb`).
		*/
		get isLegacy() {
			return [
				"rgb",
				"hsl",
				"hwb"
			].includes(this.space);
		}
		/**
		* A list of this color's channel values (excluding alpha), with [missing
		* channels] converted to `null`.
		*
		* [missing channels]: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#missing_color_components
		*/
		get channelsOrNull() {
			let coords = this.color.coords;
			if (this.space === "rgb") coords = coords.map(coordToRgb);
			return (0, immutable_1$7.List)(coords.map(NaNtoNull));
		}
		/**
		* A list of this color's channel values (excluding alpha), with [missing
		* channels] converted to `0`.
		*
		* [missing channels]: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#missing_color_components
		*/
		get channels() {
			let coords = this.color.coords;
			if (this.space === "rgb") coords = coords.map(coordToRgb);
			return (0, immutable_1$7.List)(coords.map(NaNtoZero));
		}
		/**
		* This color's red channel in the RGB color space, between `0` and `255`.
		*
		* @deprecated Use {@link channel} instead.
		*/
		get red() {
			emitColor4ApiGetterDeprecation("red");
			const val = NaNtoZero(coordToRgb(this.color.srgb.red));
			return (0, utils_2$3.fuzzyRound)(val);
		}
		/**
		* This color's green channel in the RGB color space, between `0` and `255`.
		*
		* @deprecated Use {@link channel} instead.
		*/
		get green() {
			emitColor4ApiGetterDeprecation("green");
			const val = NaNtoZero(coordToRgb(this.color.srgb.green));
			return (0, utils_2$3.fuzzyRound)(val);
		}
		/**
		* This color's blue channel in the RGB color space, between `0` and `255`.
		*
		* @deprecated Use {@link channel} instead.
		*/
		get blue() {
			emitColor4ApiGetterDeprecation("blue");
			const val = NaNtoZero(coordToRgb(this.color.srgb.blue));
			return (0, utils_2$3.fuzzyRound)(val);
		}
		/**
		* This color's hue in the HSL color space, between `0` and `360`.
		*
		* @deprecated Use {@link channel} instead.
		*/
		get hue() {
			emitColor4ApiGetterDeprecation("hue");
			return NaNtoZero(this.color.hsl.hue);
		}
		/**
		* This color's saturation in the HSL color space, between `0` and `100`.
		*
		* @deprecated Use {@link channel} instead.
		*/
		get saturation() {
			emitColor4ApiGetterDeprecation("saturation");
			return NaNtoZero(this.color.hsl.saturation);
		}
		/**
		* This color's lightness in the HSL color space, between `0` and `100`.
		*
		* @deprecated Use {@link channel} instead.
		*/
		get lightness() {
			emitColor4ApiGetterDeprecation("lightness");
			return NaNtoZero(this.color.hsl.lightness);
		}
		/**
		* This color's whiteness in the HWB color space, between `0` and `100`.
		*
		* @deprecated Use {@link channel} instead.
		*/
		get whiteness() {
			emitColor4ApiGetterDeprecation("whiteness");
			return NaNtoZero(this.color.hwb.whiteness);
		}
		/**
		* This color's blackness in the HWB color space, between `0` and `100`.
		*
		* @deprecated Use {@link channel} instead.
		*/
		get blackness() {
			emitColor4ApiGetterDeprecation("blackness");
			return NaNtoZero(this.color.hwb.blackness);
		}
		assertColor() {
			return this;
		}
		/**
		* Returns a new color that's the result of converting this color to the
		* specified `space`.
		*/
		toSpace(space) {
			if (space === this.space) return this;
			return new SassColor$1({
				color: this.color.to(encodeSpaceForColorJs(space)),
				space
			});
		}
		/**
		* Returns a boolean indicating whether this color is in-gamut (as opposed to
		* having one or more of its channels out of bounds) for the specified
		* `space`, or its current color space if `space` is not specified.
		*/
		isInGamut(space) {
			return this.color.inGamut(encodeSpaceForColorJs(space));
		}
		/**
		* Returns a copy of this color, modified so it is in-gamut for the specified
		* `space`or the current color space if `space` is not specifiedusing
		* `method` to map out-of-gamut colors into the desired gamut.
		*/
		toGamut({ space, method }) {
			if (this.isInGamut(space)) return this;
			return new SassColor$1({
				color: this.color.clone().toGamut({
					space: encodeSpaceForColorJs(space),
					method: encodeGamutMapMethodForColorJs(method)
				}),
				space: space ?? this.space
			});
		}
		channel(channel, options) {
			if (channel === "alpha") return this.alpha;
			let val;
			const space = options?.space ?? this.space;
			validateChannelInSpace(channel, space);
			if (options?.space) val = this.color.get({
				space: encodeSpaceForColorJs(options.space),
				coordId: encodeChannelForColorJs(channel)
			});
			else val = this.color.get({
				space: this.color.spaceId,
				coordId: encodeChannelForColorJs(channel)
			});
			if (space === "rgb") val = coordToRgb(val);
			return NaNtoZero(val);
		}
		/**
		* Returns a boolean indicating whether a given channel value is a [missing
		* channel].
		*
		* [missing channel]: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#missing_color_components
		*/
		isChannelMissing(channel) {
			if (channel === "alpha") return Number.isNaN(this.color.alpha);
			validateChannelInSpace(channel, this.space);
			return Number.isNaN(this.color.get({
				space: this.color.spaceId,
				coordId: encodeChannelForColorJs(channel)
			}));
		}
		isChannelPowerless(channel, options) {
			if (channel === "alpha") return false;
			const color = options?.space ? this.toSpace(options.space) : this;
			validateChannelInSpace(channel, color.space);
			const channels = color.channels.toArray();
			switch (channel) {
				case color.channel0Id:
					if (color.space === "hsl") return (0, utils_2$3.fuzzyEquals)(channels[1], 0);
					if (color.space === "hwb") return (0, utils_2$3.fuzzyGreaterThanOrEquals)(channels[1] + channels[2], 100);
					return false;
				case color.channel2Id:
					switch (color.space) {
						case "lch":
						case "oklch": return (0, utils_2$3.fuzzyEquals)(channels[1], 0);
					}
					return false;
			}
			return false;
		}
		/**
		* Returns a color partway between this color and `color2` according to
		* `method`, as defined by the CSS Color 4 [color interpolation] procedure.
		*
		* [color interpolation]: https://www.w3.org/TR/css-color-4/#interpolation
		*
		* If `method` is missing and this color is in a polar color space (HSL, HWB,
		* LCH, and Oklch spaces), `method` defaults to "shorter".
		*
		* The `weight` is a number between 0 and 1 that indicates how much of this
		* color should be in the resulting color. If omitted, it defaults to 0.5.
		*/
		interpolate(color2, options) {
			const hueInterpolationMethod = options?.method ?? (isPolarColorSpace(this.space) ? "shorter" : void 0);
			const weight = options?.weight ?? .5;
			if ((0, utils_2$3.fuzzyEquals)(weight, 0)) return color2;
			if ((0, utils_2$3.fuzzyEquals)(weight, 1)) return this;
			if (weight < 0 || weight > 1) throw (0, utils_1$14.valueError)(`Expected \`weight\` between \`0\` and \`1\`, received \`${weight}\`.`);
			const coords = decodeCoordsFromColorJs(this.color.mix(color2.color, 1 - weight, {
				space: encodeSpaceForColorJs(this.space),
				hue: hueInterpolationMethod
			}).coords, this.space === "rgb");
			return new SassColor$1({
				space: this.space,
				[this.channel0Id]: coords[0],
				[this.channel1Id]: coords[1],
				[this.channel2Id]: coords[2],
				alpha: NaNtoNull(this.color.alpha)
			});
		}
		/** Legacy determination of color space by option channels. */
		getLegacyChangeSpace(options) {
			let space;
			if (isNumberOrNull(options.whiteness) || isNumberOrNull(options.blackness) || this.space === "hwb" && isNumberOrNull(options.hue)) space = "hwb";
			else if (isNumberOrNull(options.hue) || isNumberOrNull(options.saturation) || isNumberOrNull(options.lightness)) space = "hsl";
			else if (isNumberOrNull(options.red) || isNumberOrNull(options.green) || isNumberOrNull(options.blue)) space = "rgb";
			if (space !== this.space) emitColor4ApiChangeSpaceDeprecation();
			return space ?? this.space;
		}
		/**
		* Returns a new SassColor in the given `space` that's the result of changing
		* one or more of this color's channels.
		*/
		getChangedColor(options, space, spaceSetExplicitly) {
			const color = this.toSpace(space);
			function getChangedValue(channel) {
				if (isNumberOrNull(options[channel])) return options[channel];
				return color.channel(channel);
			}
			switch (space) {
				case "hsl": if (spaceSetExplicitly) return new SassColor$1({
					hue: getChangedValue("hue"),
					saturation: getChangedValue("saturation"),
					lightness: getChangedValue("lightness"),
					alpha: getChangedValue("alpha"),
					space
				});
				else {
					checkChangeDeprecations(options, [
						"hue",
						"saturation",
						"lightness"
					]);
					return new SassColor$1({
						hue: options.hue ?? color.channel("hue"),
						saturation: options.saturation ?? color.channel("saturation"),
						lightness: options.lightness ?? color.channel("lightness"),
						alpha: options.alpha ?? color.channel("alpha"),
						space
					});
				}
				case "hwb": if (spaceSetExplicitly) return new SassColor$1({
					hue: getChangedValue("hue"),
					whiteness: getChangedValue("whiteness"),
					blackness: getChangedValue("blackness"),
					alpha: getChangedValue("alpha"),
					space
				});
				else {
					checkChangeDeprecations(options, [
						"hue",
						"whiteness",
						"blackness"
					]);
					return new SassColor$1({
						hue: options.hue ?? color.channel("hue"),
						whiteness: options.whiteness ?? color.channel("whiteness"),
						blackness: options.blackness ?? color.channel("blackness"),
						alpha: options.alpha ?? color.channel("alpha"),
						space
					});
				}
				case "rgb": if (spaceSetExplicitly) return new SassColor$1({
					red: getChangedValue("red"),
					green: getChangedValue("green"),
					blue: getChangedValue("blue"),
					alpha: getChangedValue("alpha"),
					space
				});
				else {
					checkChangeDeprecations(options, [
						"red",
						"green",
						"blue"
					]);
					return new SassColor$1({
						red: options.red ?? color.channel("red"),
						green: options.green ?? color.channel("green"),
						blue: options.blue ?? color.channel("blue"),
						alpha: options.alpha ?? color.channel("alpha"),
						space
					});
				}
				case "lab":
				case "oklab": return new SassColor$1({
					lightness: getChangedValue("lightness"),
					a: getChangedValue("a"),
					b: getChangedValue("b"),
					alpha: getChangedValue("alpha"),
					space
				});
				case "lch":
				case "oklch": return new SassColor$1({
					lightness: getChangedValue("lightness"),
					chroma: getChangedValue("chroma"),
					hue: getChangedValue("hue"),
					alpha: getChangedValue("alpha"),
					space
				});
				case "a98-rgb":
				case "display-p3":
				case "prophoto-rgb":
				case "rec2020":
				case "srgb":
				case "srgb-linear": return new SassColor$1({
					red: getChangedValue("red"),
					green: getChangedValue("green"),
					blue: getChangedValue("blue"),
					alpha: getChangedValue("alpha"),
					space
				});
				case "xyz":
				case "xyz-d50":
				case "xyz-d65": return new SassColor$1({
					y: getChangedValue("y"),
					x: getChangedValue("x"),
					z: getChangedValue("z"),
					alpha: getChangedValue("alpha"),
					space
				});
			}
		}
		change(options) {
			const spaceSetExplicitly = !!options.space;
			let space = options.space ?? this.space;
			if (this.isLegacy && !spaceSetExplicitly) space = this.getLegacyChangeSpace(options);
			const keys = Object.keys(options).filter((key) => key !== "space");
			for (const channel of keys) validateChannelInSpace(channel, space);
			if (isNumberOrNull(options.alpha) && options.alpha !== null) (0, utils_2$3.fuzzyAssertInRange)(options.alpha, 0, 1, "alpha");
			return this.getChangedColor(options, space, spaceSetExplicitly).toSpace(this.space);
		}
		equals(other) {
			if (!(other instanceof SassColor$1)) return false;
			let coords = this.color.coords;
			let otherCoords = other.color.coords;
			if (this.isLegacy) {
				if (!other.isLegacy) return false;
				if (!(0, utils_2$3.fuzzyEquals)(this.alpha, other.alpha)) return false;
				if (!(this.space === "rgb" && other.space === "rgb")) {
					coords = this.color.to("srgb").coords.map(coordToRgb).map(utils_2$3.fuzzyRound);
					otherCoords = other.color.to("srgb").coords.map(coordToRgb).map(utils_2$3.fuzzyRound);
				}
				return (0, utils_2$3.fuzzyEquals)(coords[0], otherCoords[0]) && (0, utils_2$3.fuzzyEquals)(coords[1], otherCoords[1]) && (0, utils_2$3.fuzzyEquals)(coords[2], otherCoords[2]);
			}
			return this.space === other.space && (0, utils_2$3.fuzzyEquals)(coords[0], otherCoords[0]) && (0, utils_2$3.fuzzyEquals)(coords[1], otherCoords[1]) && (0, utils_2$3.fuzzyEquals)(coords[2], otherCoords[2]) && (0, utils_2$3.fuzzyEquals)(this.alpha, other.alpha);
		}
		hashCode() {
			let coords = this.color.coords;
			if (this.isLegacy) {
				coords = this.color.to("srgb").coords.map(coordToRgb).map(utils_2$3.fuzzyRound);
				return (0, utils_2$3.fuzzyHashCode)(coords[0]) ^ (0, utils_2$3.fuzzyHashCode)(coords[1]) ^ (0, utils_2$3.fuzzyHashCode)(coords[2]) ^ (0, utils_2$3.fuzzyHashCode)(this.alpha);
			}
			return (0, immutable_1$7.hash)(this.space) ^ (0, utils_2$3.fuzzyHashCode)(coords[0]) ^ (0, utils_2$3.fuzzyHashCode)(coords[1]) ^ (0, utils_2$3.fuzzyHashCode)(coords[2]) ^ (0, utils_2$3.fuzzyHashCode)(this.alpha);
		}
		toString() {
			return this.color.toString({ inGamut: false });
		}
	};
	exports.SassColor = SassColor$1;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/function.js
var require_function = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/function.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1$6 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var index_1$4 = require_value$1();
	/** A first-class SassScript function. */
	var SassFunction$1 = class SassFunction$1 extends index_1$4.Value {
		/**
		* If this function is defined in the compiler, this is the unique ID that the
		* compiler uses to determine which function it refers to.
		*
		* This is marked as public so that the protofier can access it, but it's not
		* part of the package's public API and should not be accessed by user code.
		* It may be renamed or removed without warning in the future.
		*/
		id;
		/**
		* If this function is defined in the compiler, this is the unique context
		* that the host uses to determine which compilation this function belongs to.
		*
		* This is marked as public so that the protofier can access it, but it's not
		* part of the package's public API and should not be accessed by user code.
		* It may be renamed or removed without warning in the future.
		*/
		compileContext;
		/**
		* If this function is defined in the host, this is the signature that
		* describes how to pass arguments to it.
		*
		* This is marked as public so that the protofier can access it, but it's not
		* part of the package's public API and should not be accessed by user code.
		* It may be renamed or removed without warning in the future.
		*/
		signature;
		/**
		* If this function is defined in the host, this is the callback to run when
		* the function is invoked from a stylesheet.
		*
		* This is marked as public so that the protofier can access it, but it's not
		* part of the package's public API and should not be accessed by user code.
		* It may be renamed or removed without warning in the future.
		*/
		callback;
		constructor(idOrSignature, callbackOrCompileContext) {
			super();
			if (typeof idOrSignature === "number" && typeof callbackOrCompileContext === "symbol") {
				this.id = idOrSignature;
				this.compileContext = callbackOrCompileContext;
			} else {
				this.signature = idOrSignature;
				this.callback = callbackOrCompileContext;
			}
		}
		equals(other) {
			return this.id === void 0 ? other === this : other instanceof SassFunction$1 && other.compileContext === this.compileContext && other.id === this.id;
		}
		hashCode() {
			return this.id === void 0 ? (0, immutable_1$6.hash)(this.signature) : (0, immutable_1$6.hash)(this.id);
		}
		toString() {
			return this.signature ? this.signature : `<compiler function ${this.id}>`;
		}
	};
	exports.SassFunction = SassFunction$1;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/mixin.js
var require_mixin = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/mixin.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1$5 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var index_1$3 = require_value$1();
	/** A first-class SassScript mixin. */
	var SassMixin$1 = class SassMixin$1 extends index_1$3.Value {
		/**
		* This is the unique ID that the compiler uses to determine which mixin it
		* refers to.
		*
		* This is marked as public so that the protofier can access it, but it's not
		* part of the package's public API and should not be accessed by user code.
		* It may be renamed or removed without warning in the future.
		*/
		id;
		/**
		* This is the unique context that the host uses to determine which
		* compilation this mixin belongs to.
		*
		* This is marked as public so that the protofier can access it, but it's not
		* part of the package's public API and should not be accessed by user code.
		* It may be renamed or removed without warning in the future.
		*/
		compileContext;
		constructor(id, compileContext) {
			super();
			this.id = id;
			this.compileContext = compileContext;
		}
		equals(other) {
			return other instanceof SassMixin$1 && other.compileContext === this.compileContext && other.id === this.id;
		}
		hashCode() {
			return (0, immutable_1$5.hash)(this.id);
		}
		toString() {
			return `<compiler mixin ${this.id}>`;
		}
		assertMixin() {
			return this;
		}
	};
	exports.SassMixin = SassMixin$1;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/number.js
var require_number$1 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/number.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1$4 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var utils_1$13 = require_utils$3();
	var index_1$2 = require_value$1();
	var utils_2$2 = require_utils$2();
	var conversions = {
		in: {
			in: 1,
			cm: 1 / 2.54,
			pc: 1 / 6,
			mm: 1 / 25.4,
			q: 1 / 101.6,
			pt: 1 / 72,
			px: 1 / 96
		},
		cm: {
			in: 2.54,
			cm: 1,
			pc: 2.54 / 6,
			mm: 1 / 10,
			q: 1 / 40,
			pt: 2.54 / 72,
			px: 2.54 / 96
		},
		pc: {
			in: 6,
			cm: 6 / 2.54,
			pc: 1,
			mm: 6 / 25.4,
			q: 6 / 101.6,
			pt: 1 / 12,
			px: 1 / 16
		},
		mm: {
			in: 25.4,
			cm: 10,
			pc: 25.4 / 6,
			mm: 1,
			q: 1 / 4,
			pt: 25.4 / 72,
			px: 25.4 / 96
		},
		q: {
			in: 101.6,
			cm: 40,
			pc: 101.6 / 6,
			mm: 4,
			q: 1,
			pt: 101.6 / 72,
			px: 101.6 / 96
		},
		pt: {
			in: 72,
			cm: 72 / 2.54,
			pc: 12,
			mm: 72 / 25.4,
			q: 72 / 101.6,
			pt: 1,
			px: 3 / 4
		},
		px: {
			in: 96,
			cm: 96 / 2.54,
			pc: 16,
			mm: 96 / 25.4,
			q: 96 / 101.6,
			pt: 4 / 3,
			px: 1
		},
		deg: {
			deg: 1,
			grad: 9 / 10,
			rad: 180 / Math.PI,
			turn: 360
		},
		grad: {
			deg: 10 / 9,
			grad: 1,
			rad: 200 / Math.PI,
			turn: 400
		},
		rad: {
			deg: Math.PI / 180,
			grad: Math.PI / 200,
			rad: 1,
			turn: 2 * Math.PI
		},
		turn: {
			deg: 1 / 360,
			grad: 1 / 400,
			rad: 1 / (2 * Math.PI),
			turn: 1
		},
		s: {
			s: 1,
			ms: 1 / 1e3
		},
		ms: {
			s: 1e3,
			ms: 1
		},
		Hz: {
			Hz: 1,
			kHz: 1e3
		},
		kHz: {
			Hz: 1 / 1e3,
			kHz: 1
		},
		dpi: {
			dpi: 1,
			dpcm: 2.54,
			dppx: 96
		},
		dpcm: {
			dpi: 1 / 2.54,
			dpcm: 1,
			dppx: 96 / 2.54
		},
		dppx: {
			dpi: 1 / 96,
			dpcm: 2.54 / 96,
			dppx: 1
		}
	};
	var unitsByType = {
		length: [
			"in",
			"cm",
			"pc",
			"mm",
			"q",
			"pt",
			"px"
		],
		angle: [
			"deg",
			"grad",
			"rad",
			"turn"
		],
		time: ["s", "ms"],
		frequency: ["Hz", "kHz"],
		"pixel density": [
			"dpi",
			"dpcm",
			"dppx"
		]
	};
	var typesByUnit = {};
	for (const [type$1, units] of Object.entries(unitsByType)) for (const unit of units) typesByUnit[unit] = type$1;
	/** A SassScript number. */
	var SassNumber$1 = class SassNumber$1 extends index_1$2.Value {
		valueInternal;
		numeratorUnitsInternal;
		denominatorUnitsInternal;
		constructor(value, unitOrOptions) {
			super();
			if (typeof unitOrOptions === "string") {
				this.valueInternal = value;
				this.numeratorUnitsInternal = unitOrOptions === void 0 ? (0, immutable_1$4.List)([]) : (0, immutable_1$4.List)([unitOrOptions]);
				this.denominatorUnitsInternal = (0, immutable_1$4.List)([]);
				return;
			}
			let numerators = (0, utils_1$13.asImmutableList)(unitOrOptions?.numeratorUnits ?? []);
			const unsimplifiedDenominators = unitOrOptions?.denominatorUnits ?? [];
			const denominators = [];
			for (const denominator of unsimplifiedDenominators) {
				let simplifiedAway = false;
				for (const [i, numerator] of numerators.entries()) {
					const factor = conversionFactor(denominator, numerator);
					if (factor === null) continue;
					value /= factor;
					numerators = numerators.delete(i);
					simplifiedAway = true;
					break;
				}
				if (!simplifiedAway) denominators.push(denominator);
			}
			this.valueInternal = value;
			this.numeratorUnitsInternal = numerators;
			this.denominatorUnitsInternal = (0, immutable_1$4.List)(denominators);
		}
		/** `this`'s value. */
		get value() {
			return this.valueInternal;
		}
		/** Whether `value` is an integer. */
		get isInt() {
			return (0, utils_2$2.fuzzyIsInt)(this.value);
		}
		/**
		* If `value` is an integer according to `isInt`, returns `value` rounded to
		* that integer.
		*
		* Otherwise, returns null.
		*/
		get asInt() {
			return (0, utils_2$2.fuzzyAsInt)(this.value);
		}
		/** `this`'s numerator units. */
		get numeratorUnits() {
			return this.numeratorUnitsInternal;
		}
		/** `this`'s denominator units. */
		get denominatorUnits() {
			return this.denominatorUnitsInternal;
		}
		/** Whether `this` has any units. */
		get hasUnits() {
			return !(this.numeratorUnits.isEmpty() && this.denominatorUnits.isEmpty());
		}
		assertNumber() {
			return this;
		}
		/**
		* If `value` is an integer according to `isInt`, returns it as an integer.
		*
		* Otherwise, throws an error.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertInt(name) {
			const int = (0, utils_2$2.fuzzyAsInt)(this.value);
			if (int === null) throw (0, utils_1$13.valueError)(`${this} is not an int`, name);
			return int;
		}
		/**
		* If `value` is within `min` and `max`, returns `value`, or if it
		* `fuzzyEquals` `min` or `max`, returns `value` clamped to that value.
		*
		* Otherwise, throws an error.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertInRange(min$1, max$2, name) {
			const clamped = (0, utils_2$2.fuzzyInRange)(this.value, min$1, max$2);
			if (clamped === null) throw (0, utils_1$13.valueError)(`${this} must be between ${min$1} and ${max$2}`, name);
			return clamped;
		}
		/**
		* If `this` has no units, returns `this`.
		*
		* Otherwise, throws an error.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertNoUnits(name) {
			if (this.hasUnits) throw (0, utils_1$13.valueError)(`Expected ${this} to have no units`, name);
			return this;
		}
		/**
		* If `this` has `unit` as its only unit (and as a numerator), returns `this`.
		*
		* Otherwise, throws an error.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		assertUnit(unit, name) {
			if (!this.hasUnit(unit)) throw (0, utils_1$13.valueError)(`Expected ${this} to have no unit ${unit}`, name);
			return this;
		}
		/** Whether `this` has `unit` as its only unit (and as a numerator). */
		hasUnit(unit) {
			return this.denominatorUnits.isEmpty() && this.numeratorUnits.size === 1 && this.numeratorUnits.get(0) === unit;
		}
		/** Whether `this` is compatible with `unit`. */
		compatibleWithUnit(unit) {
			if (!this.denominatorUnits.isEmpty()) return false;
			if (this.numeratorUnits.size > 1) return false;
			const numerator = this.numeratorUnits.get(0);
			return typesByUnit[numerator] ? typesByUnit[numerator] === typesByUnit[unit] : numerator === unit;
		}
		/**
		* Returns a copy of `this`, converted to the units represented by
		* `newNumerators` and `newDenominators`.
		*
		* Throws an error if `this`'s units are incompatible with `newNumerators` and
		* `newDenominators`. Also throws an error if `this` is unitless and either
		* `newNumerators` or `newDenominators` are not empty, or vice-versa.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		convert(newNumerators, newDenominators, name) {
			return new SassNumber$1(this.convertValue(newNumerators, newDenominators, name), {
				numeratorUnits: newNumerators,
				denominatorUnits: newDenominators
			});
		}
		/**
		* Returns `value`, converted to the units represented by `newNumerators` and
		* `newDenominators`.
		*
		* Throws an error if `this`'s units are incompatible with `newNumerators` and
		* `newDenominators`. Also throws an error if `this` is unitless and either
		* `newNumerators` or `newDenominators` are not empty, or vice-versa.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		convertValue(newNumerators, newDenominators, name) {
			return this.convertOrCoerce({
				coerceUnitless: false,
				newNumeratorUnits: (0, utils_1$13.asImmutableList)(newNumerators),
				newDenominatorUnits: (0, utils_1$13.asImmutableList)(newDenominators),
				name
			});
		}
		/**
		* Returns a copy of `this`, converted to the same units as `other`.
		*
		* Throws an error if `this`'s units are incompatible with `other`'s units, or
		* if either number is unitless but the other is not.
		*
		* If `this` came from a function argument, `name` is the argument name
		* and `otherName` is the argument name for `other` (both without the `$`).
		* They are used for error reporting.
		*/
		convertToMatch(other, name, otherName) {
			return new SassNumber$1(this.convertValueToMatch(other, name, otherName), {
				numeratorUnits: other.numeratorUnits,
				denominatorUnits: other.denominatorUnits
			});
		}
		/**
		* Returns `value`, converted to the same units as `other`.
		*
		* Throws an error if `this`'s units are incompatible with `other`'s units, or
		* if either number is unitless but the other is not.
		*
		* If `this` came from a function argument, `name` is the argument name
		* and `otherName` is the argument name for `other` (both without the `$`).
		* They are used for error reporting.
		*/
		convertValueToMatch(other, name, otherName) {
			return this.convertOrCoerce({
				coerceUnitless: false,
				other,
				name,
				otherName
			});
		}
		/**
		* Returns a copy of `this`, converted to the units represented by
		* `newNumerators` and `newDenominators`.
		*
		* Does *not* throw an error if this number is unitless and either
		* `newNumerators` or `newDenominators` are not empty, or vice-versa. Instead,
		* it treats all unitless numbers as convertible to and from all units
		* without changing the value.
		*
		* Throws an error if `this`'s units are incompatible with `newNumerators` and
		* `newDenominators`.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		coerce(newNumerators, newDenominators, name) {
			return new SassNumber$1(this.coerceValue(newNumerators, newDenominators, name), {
				numeratorUnits: newNumerators,
				denominatorUnits: newDenominators
			});
		}
		/**
		* Returns `value`, converted to the units represented by `newNumerators` and
		* `newDenominators`.
		*
		* Does *not* throw an error if this number is unitless and either
		* `newNumerators` or `newDenominators` are not empty, or vice-versa. Instead,
		* it treats all unitless numbers as convertible to and from all units
		* without changing the value.
		*
		* Throws an error if `this`'s units are incompatible with `newNumerators` and
		* `newDenominators`.
		*
		* If `this` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		coerceValue(newNumerators, newDenominators, name) {
			return this.convertOrCoerce({
				coerceUnitless: true,
				newNumeratorUnits: (0, utils_1$13.asImmutableList)(newNumerators),
				newDenominatorUnits: (0, utils_1$13.asImmutableList)(newDenominators),
				name
			});
		}
		/**
		* Returns a copy of `this`, converted to the same units as `other`.
		*
		* Does *not* throw an error if `this` is unitless and `other` is not, or
		* vice-versa. Instead, it treats all unitless numbers as convertible to and
		* from all units without changing the value.
		*
		* Throws an error if `this`'s units are incompatible with `other`'s units.
		*
		* If `this` came from a function argument, `name` is the argument name
		* and `otherName` is the argument name for `other` (both without the `$`).
		* They are used for error reporting.
		*/
		coerceToMatch(other, name, otherName) {
			return new SassNumber$1(this.coerceValueToMatch(other, name, otherName), {
				numeratorUnits: other.numeratorUnits,
				denominatorUnits: other.denominatorUnits
			});
		}
		/**
		* Returns `value`, converted to the same units as `other`.
		*
		* Does *not* throw an error if `this` is unitless and `other` is not, or
		* vice-versa. Instead, it treats all unitless numbers as convertible to and
		* from all units without changing the value.
		*
		* Throws an error if `this`'s units are incompatible with `other`'s units.
		*
		* If `this` came from a function argument, `name` is the argument name
		* and `otherName` is the argument name for `other` (both without the `$`).
		* They are used for error reporting.
		*/
		coerceValueToMatch(other, name, otherName) {
			return this.convertOrCoerce({
				coerceUnitless: true,
				other,
				name,
				otherName
			});
		}
		equals(other) {
			if (!(other instanceof SassNumber$1)) return false;
			try {
				return (0, utils_2$2.fuzzyEquals)(this.value, other.convertValueToMatch(this));
			} catch {
				return false;
			}
		}
		hashCode() {
			const canonicalNumerators = canonicalizeUnits(this.numeratorUnits);
			const canonicalDenominators = canonicalizeUnits(this.denominatorUnits);
			const canonicalValue = this.convertValue(canonicalNumerators, canonicalDenominators);
			return (0, utils_2$2.fuzzyHashCode)(canonicalValue) ^ (0, immutable_1$4.hash)(canonicalNumerators) ^ (0, immutable_1$4.hash)(canonicalDenominators);
		}
		toString() {
			return `${this.value}${unitString(this.numeratorUnits, this.denominatorUnits)}`;
		}
		convertOrCoerce(params) {
			const newNumerators = "other" in params ? params.other.numeratorUnits : params.newNumeratorUnits;
			const newDenominators = "other" in params ? params.other.denominatorUnits : params.newDenominatorUnits;
			const compatibilityError = () => {
				if ("other" in params) {
					let message = `${this} and`;
					if (params.otherName) message += ` $${params.otherName}:`;
					message += ` ${params.other} have incompatible units`;
					if (!this.hasUnits || !otherHasUnits) message += " (one has units and the other doesn't)";
					return (0, utils_1$13.valueError)(message, params.name);
				}
				if (!otherHasUnits) return (0, utils_1$13.valueError)(`Expected ${this} to have no units.`, params.name);
				if (newNumerators.size === 1 && newDenominators.isEmpty()) {
					const type$1 = typesByUnit[newNumerators.get(0)];
					if (type$1) return (0, utils_1$13.valueError)(`Expected ${this} to have a single ${type$1} unit (${unitsByType[type$1].join(", ")}).`, params.name);
				}
				const unitSize = newNumerators.size + newDenominators.size;
				return (0, utils_1$13.valueError)(`Expected $this to have ${unitSize === 0 ? "no units" : `unit${unitSize > 1 ? "s" : ""} ${unitString(newNumerators, newDenominators)}`}.`, params.name);
			};
			const otherHasUnits = !newNumerators.isEmpty() || !newDenominators.isEmpty();
			if (this.hasUnits && !otherHasUnits || !this.hasUnits && otherHasUnits) {
				if (params.coerceUnitless) return this.value;
				throw compatibilityError();
			}
			if (this.numeratorUnits.equals(newNumerators) && this.denominatorUnits.equals(newDenominators)) return this.value;
			let value = this.value;
			let oldNumerators = this.numeratorUnits;
			for (const newNumerator of newNumerators) {
				const idx = oldNumerators.findIndex((oldNumerator) => {
					const factor = conversionFactor(oldNumerator, newNumerator);
					if (factor === null) return false;
					value *= factor;
					return true;
				});
				if (idx < 0) throw compatibilityError();
				oldNumerators = oldNumerators.delete(idx);
			}
			let oldDenominators = this.denominatorUnits;
			for (const newDenominator of newDenominators) {
				const idx = oldDenominators.findIndex((oldDenominator) => {
					const factor = conversionFactor(oldDenominator, newDenominator);
					if (factor === null) return false;
					value /= factor;
					return true;
				});
				if (idx < 0) throw compatibilityError();
				oldDenominators = oldDenominators.delete(idx);
			}
			if (!oldNumerators.isEmpty() || !oldDenominators.isEmpty()) throw compatibilityError();
			return value;
		}
	};
	exports.SassNumber = SassNumber$1;
	function conversionFactor(fromUnit, toUnit) {
		if (fromUnit === toUnit) return 1;
		const factors = conversions[toUnit];
		if (!factors) return null;
		return factors[fromUnit] ?? null;
	}
	function unitString(numerators, denominators) {
		if (numerators.isEmpty() && denominators.isEmpty()) return "";
		if (denominators.isEmpty()) return numerators.join("*");
		if (numerators.isEmpty()) return denominators.size === 1 ? `${denominators.get(0)}^-1` : `(${denominators.join("*")})^-1`;
		return `${numerators.join("*")}/${denominators.join("*")}`;
	}
	function canonicalizeUnits(units) {
		return units.map((unit) => {
			const type$1 = typesByUnit[unit];
			return type$1 ? unitsByType[type$1][0] : unit;
		}).sort();
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/string.js
var require_string$1 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/string.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1$3 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var index_1$1 = require_value$1();
	var utils_1$12 = require_utils$3();
	/** A SassScript string. */
	var SassString$1 = class SassString$1 extends index_1$1.Value {
		textInternal;
		hasQuotesInternal;
		constructor(textOrOptions, options) {
			super();
			if (typeof textOrOptions === "string") {
				this.textInternal = textOrOptions;
				this.hasQuotesInternal = options?.quotes ?? true;
			} else {
				this.textInternal = "";
				this.hasQuotesInternal = textOrOptions?.quotes ?? true;
			}
		}
		/** Creates an empty string, optionally with quotes. */
		static empty(options) {
			return options === void 0 || options?.quotes ? emptyQuoted : emptyUnquoted;
		}
		/** `this`'s text. */
		get text() {
			return this.textInternal;
		}
		/** Whether `this` has quotes. */
		get hasQuotes() {
			return this.hasQuotesInternal;
		}
		assertString() {
			return this;
		}
		/**
		* Sass's notion of `this`'s length.
		*
		* Sass treats strings as a series of Unicode code points while JS treats them
		* as a series of UTF-16 code units. For example, the character U+1F60A,
		* Smiling Face With Smiling Eyes, is a single Unicode code point but is
		* represented in UTF-16 as two code units (`0xD83D` and `0xDE0A`). So in
		* JS, `"nb".length` returns `4`, whereas in Sass `string.length("nb")`
		* returns `3`.
		*/
		get sassLength() {
			let length = 0;
			for (const codepoint of this.text) length++;
			return length;
		}
		/**
		* Converts `sassIndex` to a JS index into `text`.
		*
		* Sass indices are one-based, while JS indices are zero-based. Sass
		* indices may also be negative in order to index from the end of the string.
		*
		* In addition, Sass indices refer to Unicode code points while JS string
		* indices refer to UTF-16 code units. For example, the character U+1F60A,
		* Smiling Face With Smiling Eyes, is a single Unicode code point but is
		* represented in UTF-16 as two code units (`0xD83D` and `0xDE0A`). So in
		* JS, `"nb".charAt(1)` returns `0xD83D`, whereas in Sass
		* `string.slice("nb", 1, 1)` returns `""`.
		*
		* This function converts Sass's code point indices to JS's code unit
		* indices. This means it's O(n) in the length of `text`.
		*
		* Throws an error `sassIndex` isn't a number, if that number isn't an
		* integer, or if that integer isn't a valid index for this string.
		*
		* If `sassIndex` came from a function argument, `name` is the argument name
		* (without the `$`) and is used for error reporting.
		*/
		sassIndexToStringIndex(sassIndex, name) {
			let sassIdx = sassIndex.assertNumber().assertInt();
			if (sassIdx === 0) throw (0, utils_1$12.valueError)("String index may not be 0", name);
			const sassLength = this.sassLength;
			if (Math.abs(sassIdx) > sassLength) throw (0, utils_1$12.valueError)(`Invalid index ${sassIdx} for a string with ${sassLength} characters`, name);
			if (sassIdx < 0) sassIdx += sassLength + 1;
			let pointer = 1;
			let idx = 0;
			for (const codePoint of this.text) {
				if (pointer === sassIdx) break;
				idx += codePoint.length;
				pointer++;
			}
			return idx;
		}
		equals(other) {
			return other instanceof SassString$1 && this.text === other.text;
		}
		hashCode() {
			return (0, immutable_1$3.hash)(this.text);
		}
		toString() {
			return this.hasQuotes ? `"${this.text}"` : this.text;
		}
	};
	exports.SassString = SassString$1;
	var emptyQuoted = new SassString$1("", { quotes: true });
	var emptyUnquoted = new SassString$1("", { quotes: false });
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/value/calculations.js
var require_calculations = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/value/calculations.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1$2 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var index_1 = require_value$1();
	var string_1$5 = require_string$1();
	function assertCalculationValue(value) {
		if (value instanceof string_1$5.SassString && value.hasQuotes) throw new Error(`Expected ${value} to be an unquoted string.`);
	}
	function isValidClampArg(value) {
		return value instanceof CalculationInterpolation$1 || value instanceof string_1$5.SassString && !value.hasQuotes;
	}
	var SassCalculation$1 = class SassCalculation$1 extends index_1.Value {
		name;
		arguments;
		constructor(name, args) {
			super();
			this.name = name;
			this.arguments = (0, immutable_1$2.List)(args);
		}
		static calc(argument) {
			assertCalculationValue(argument);
			return new SassCalculation$1("calc", [argument]);
		}
		static min(args) {
			args.forEach(assertCalculationValue);
			return new SassCalculation$1("min", args);
		}
		static max(args) {
			args.forEach(assertCalculationValue);
			return new SassCalculation$1("max", args);
		}
		static clamp(min$1, value, max$2) {
			if (value === void 0 && !isValidClampArg(min$1) || max$2 === void 0 && ![min$1, value].some((x) => x && isValidClampArg(x))) throw new Error("Argument must be an unquoted SassString or CalculationInterpolation.");
			const args = [min$1];
			if (value !== void 0) args.push(value);
			if (max$2 !== void 0) args.push(max$2);
			args.forEach(assertCalculationValue);
			return new SassCalculation$1("clamp", args);
		}
		assertCalculation() {
			return this;
		}
		equals(other) {
			return other instanceof SassCalculation$1 && this.name === other.name && this.arguments.equals(other.arguments);
		}
		hashCode() {
			return (0, immutable_1$2.hash)(this.name) ^ this.arguments.hashCode();
		}
		toString() {
			return `${this.name}(${this.arguments.join(", ")})`;
		}
	};
	exports.SassCalculation = SassCalculation$1;
	var operators = [
		"+",
		"-",
		"*",
		"/"
	];
	var CalculationOperation$1 = class CalculationOperation$1 {
		operator;
		left;
		right;
		constructor(operator, left, right) {
			this.operator = operator;
			this.left = left;
			this.right = right;
			if (!operators.includes(operator)) throw new Error(`Invalid operator: ${operator}`);
			assertCalculationValue(left);
			assertCalculationValue(right);
		}
		equals(other) {
			return other instanceof CalculationOperation$1 && this.operator === other.operator && this.left === other.left && this.right === other.right;
		}
		hashCode() {
			return (0, immutable_1$2.hash)(this.operator) ^ (0, immutable_1$2.hash)(this.left) ^ (0, immutable_1$2.hash)(this.right);
		}
	};
	exports.CalculationOperation = CalculationOperation$1;
	var CalculationInterpolation$1 = class CalculationInterpolation$1 {
		value;
		constructor(value) {
			this.value = value;
		}
		equals(other) {
			return other instanceof CalculationInterpolation$1 && this.value === other.value;
		}
		hashCode() {
			return (0, immutable_1$2.hash)(this.value);
		}
	};
	exports.CalculationInterpolation = CalculationInterpolation$1;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/value/base.js
var require_base = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/value/base.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* A base class for legacy value types. A shared base class makes it easier to
	* detect legacy values and extract their inner value objects.
	*/
	var LegacyValueBase = class {
		inner;
		constructor(inner) {
			this.inner = inner;
		}
	};
	exports.LegacyValueBase = LegacyValueBase;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/value/color.js
var require_color = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/value/color.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var utils_1$11 = require_utils$3();
	var color_1$4 = require_color$1();
	var base_1$5 = require_base();
	var LegacyColor = class extends base_1$5.LegacyValueBase {
		constructor(redOrArgb, green, blue, alpha) {
			if (redOrArgb instanceof color_1$4.SassColor) {
				super(redOrArgb);
				return;
			}
			let red;
			if ((0, utils_1$11.isNullOrUndefined)(green) || (0, utils_1$11.isNullOrUndefined)(blue)) {
				const argb = redOrArgb;
				alpha = (argb >> 24) / 255;
				red = (argb >> 16) % 256;
				green = (argb >> 8) % 256;
				blue = argb % 256;
			} else red = redOrArgb;
			super(new color_1$4.SassColor({
				red: clamp(red, 0, 255),
				green: clamp(green, 0, 255),
				blue: clamp(blue, 0, 255),
				alpha: alpha ? clamp(alpha, 0, 1) : 1
			}));
		}
		getR() {
			return this.inner.red;
		}
		setR(value) {
			this.inner = this.inner.change({ red: clamp(value, 0, 255) });
		}
		getG() {
			return this.inner.green;
		}
		setG(value) {
			this.inner = this.inner.change({ green: clamp(value, 0, 255) });
		}
		getB() {
			return this.inner.blue;
		}
		setB(value) {
			this.inner = this.inner.change({ blue: clamp(value, 0, 255) });
		}
		getA() {
			return this.inner.alpha;
		}
		setA(value) {
			this.inner = this.inner.change({ alpha: clamp(value, 0, 1) });
		}
	};
	exports.LegacyColor = LegacyColor;
	Object.defineProperty(LegacyColor, "name", { value: "sass.types.Color" });
	function clamp(num, min$1, max$2) {
		return Math.min(Math.max(num, min$1), max$2);
	}
}) });

//#endregion
//#region browser-external:util
var require_browser_external_util = /* @__PURE__ */ __commonJS({ "browser-external:util": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/value/map.js
var require_map$1 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/value/map.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1$1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var base_1$4 = require_base();
	var map_1$12 = require_map$2();
	var number_1$5 = require_number$1();
	var null_1$4 = require_null();
	var wrap_1$2 = require_wrap();
	var LegacyMap = class extends base_1$4.LegacyValueBase {
		constructor(lengthOrInner) {
			if (lengthOrInner instanceof map_1$12.SassMap) {
				super(lengthOrInner);
				return;
			}
			super(new map_1$12.SassMap((0, immutable_1$1.OrderedMap)(Array.from({ length: lengthOrInner }, (_, i) => [new number_1$5.SassNumber(i), null_1$4.sassNull]))));
		}
		getValue(index) {
			const value = this.inner.contents.valueSeq().get(index);
			if (index < 0 || !value) throw new Error(`Invalid index ${index}, must be between 0 and ` + this.inner.contents.size);
			return (0, wrap_1$2.wrapValue)(value);
		}
		setValue(index, value) {
			this.inner = new map_1$12.SassMap(this.inner.contents.set(this.getUnwrappedKey(index), (0, wrap_1$2.unwrapValue)(value)));
		}
		getKey(index) {
			return (0, wrap_1$2.wrapValue)(this.getUnwrappedKey(index));
		}
		getUnwrappedKey(index) {
			const key = this.inner.contents.keySeq().get(index);
			if (index >= 0 && key) return key;
			throw new Error(`Invalid index ${index}, must be between 0 and ` + this.inner.contents.size);
		}
		setKey(index, key) {
			const oldMap = this.inner.contents;
			if (index < 0 || index >= oldMap.size) throw new Error(`Invalid index ${index}, must be between 0 and ${oldMap.size}`);
			const newKey = (0, wrap_1$2.unwrapValue)(key);
			const newMap = (0, immutable_1$1.OrderedMap)().asMutable();
			let i = 0;
			for (const [oldKey, oldValue] of oldMap.entries()) {
				if (i === index) newMap.set(newKey, oldValue);
				else {
					if (newKey.equals(oldKey)) throw new Error(`${key} is already in the map`);
					newMap.set(oldKey, oldValue);
				}
				i++;
			}
			this.inner = new map_1$12.SassMap(newMap.asImmutable());
		}
		getLength() {
			return this.inner.contents.size;
		}
	};
	exports.LegacyMap = LegacyMap;
	Object.defineProperty(LegacyMap, "name", { value: "sass.types.Map" });
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/value/number.js
var require_number = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/value/number.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var number_1$4 = require_number$1();
	var base_1$3 = require_base();
	var LegacyNumber = class extends base_1$3.LegacyValueBase {
		constructor(valueOrInner, unit) {
			super(valueOrInner instanceof number_1$4.SassNumber ? valueOrInner : parseNumber(valueOrInner, unit));
		}
		getValue() {
			return this.inner.value;
		}
		setValue(value) {
			this.inner = new number_1$4.SassNumber(value, {
				numeratorUnits: this.inner.numeratorUnits,
				denominatorUnits: this.inner.denominatorUnits
			});
		}
		getUnit() {
			return this.inner.numeratorUnits.join("*") + (this.inner.denominatorUnits.size === 0 ? "" : "/") + this.inner.denominatorUnits.join("*");
		}
		setUnit(unit) {
			this.inner = parseNumber(this.inner.value, unit);
		}
	};
	exports.LegacyNumber = LegacyNumber;
	Object.defineProperty(LegacyNumber, "name", { value: "sass.types.Number" });
	function parseNumber(value, unit) {
		if (!unit) return new number_1$4.SassNumber(value);
		if (!unit.includes("*") && !unit.includes("/")) return new number_1$4.SassNumber(value, unit);
		const invalidUnit = /* @__PURE__ */ new Error(`Unit ${unit} is invalid`);
		const operands = unit.split("/");
		if (operands.length > 2) throw invalidUnit;
		const numerator = operands[0];
		const denominator = operands.length === 1 ? null : operands[1];
		const numeratorUnits = numerator.length === 0 ? [] : numerator.split("*");
		if (numeratorUnits.some((unit$1) => unit$1.length === 0)) throw invalidUnit;
		const denominatorUnits = denominator === null ? [] : denominator.split("*");
		if (denominatorUnits.some((unit$1) => unit$1.length === 0)) throw invalidUnit;
		return new number_1$4.SassNumber(value, {
			numeratorUnits,
			denominatorUnits
		});
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/value/string.js
var require_string = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/value/string.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var string_1$4 = require_string$1();
	var base_1$2 = require_base();
	var LegacyString = class extends base_1$2.LegacyValueBase {
		constructor(valueOrInner) {
			if (valueOrInner instanceof string_1$4.SassString) super(valueOrInner);
			else super(new string_1$4.SassString(valueOrInner, { quotes: false }));
		}
		getValue() {
			return this.inner.text;
		}
		setValue(value) {
			this.inner = new string_1$4.SassString(value, { quotes: false });
		}
	};
	exports.LegacyString = LegacyString;
	Object.defineProperty(LegacyString, "name", { value: "sass.types.String" });
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/value/wrap.js
var require_wrap = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/value/wrap.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.wrapFunction = wrapFunction;
	exports.unwrapValue = unwrapValue;
	exports.wrapValue = wrapValue;
	var util$1 = require_browser_external_util();
	var base_1$1 = require_base();
	var color_1$3 = require_color();
	var list_1$4 = require_list();
	var map_1$11 = require_map$1();
	var number_1$3 = require_number();
	var string_1$3 = require_string();
	var value_1$2 = require_value$1();
	var color_2 = require_color$1();
	var list_2 = require_list$1();
	var map_2 = require_map$2();
	var number_2 = require_number$1();
	var string_2 = require_string$1();
	/**
	* Converts a `LegacyFunction` into a `CustomFunction` so it can be passed to
	* the new JS API.
	*/
	function wrapFunction(thisArg, callback, sync) {
		if (sync) return (args) => unwrapTypedValue(callback.apply(thisArg, args.map(wrapValue)));
		else return (args) => new Promise((resolve, reject) => {
			function done(result) {
				try {
					if (result instanceof Error) reject(result);
					else resolve(unwrapTypedValue(result));
				} catch (error) {
					reject(error);
				}
			}
			const syncResult = callback.apply(thisArg, [...args.map(wrapValue), done]);
			if (syncResult !== void 0) resolve(unwrapTypedValue(syncResult));
		});
	}
	function unwrapTypedValue(value) {
		return unwrapValue(value);
	}
	/** Converts a value returned by a `LegacyFunction` into a `Value`. */
	function unwrapValue(value) {
		if (value instanceof Error) throw value;
		if (value instanceof value_1$2.Value) return value;
		if (value instanceof base_1$1.LegacyValueBase) return value.inner;
		throw new Error(`Expected legacy Sass value, got ${util$1.inspect(value)}.`);
	}
	/** Converts a `Value` into a `LegacyValue`. */
	function wrapValue(value) {
		if (value instanceof color_2.SassColor) return new color_1$3.LegacyColor(value);
		if (value instanceof list_2.SassList) return new list_1$4.LegacyList(value);
		if (value instanceof map_2.SassMap) return new map_1$11.LegacyMap(value);
		if (value instanceof number_2.SassNumber) return new number_1$3.LegacyNumber(value);
		if (value instanceof string_2.SassString) return new string_1$3.LegacyString(value);
		if (value instanceof value_1$2.Value) return value;
		throw new Error(`Expected Sass value, got ${util$1.inspect(value)}.`);
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/value/list.js
var require_list = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/value/list.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var base_1 = require_base();
	var list_1$3 = require_list$1();
	var null_1$3 = require_null();
	var wrap_1$1 = require_wrap();
	var LegacyList = class extends base_1.LegacyValueBase {
		constructor(lengthOrInner, commaSeparator) {
			if (lengthOrInner instanceof list_1$3.SassList) {
				super(lengthOrInner);
				return;
			}
			super(new list_1$3.SassList(new Array(lengthOrInner).fill(null_1$3.sassNull), { separator: commaSeparator === false ? " " : "," }));
		}
		getValue(index) {
			const length = this.inner.asList.size;
			if (index < 0 || index >= length) throw new Error(`Invalid index ${index}, must be between 0 and ${length}`);
			const value = this.inner.get(index);
			return value ? (0, wrap_1$1.wrapValue)(value) : void 0;
		}
		setValue(index, value) {
			this.inner = new list_1$3.SassList(this.inner.asList.set(index, (0, wrap_1$1.unwrapValue)(value)), {
				separator: this.inner.separator,
				brackets: this.inner.hasBrackets
			});
		}
		getSeparator() {
			return this.inner.separator === ",";
		}
		setSeparator(isComma) {
			this.inner = new list_1$3.SassList(this.inner.asList, {
				separator: isComma ? "," : " ",
				brackets: this.inner.hasBrackets
			});
		}
		getLength() {
			return this.inner.asList.size;
		}
	};
	exports.LegacyList = LegacyList;
	Object.defineProperty(LegacyList, "name", { value: "sass.types.List" });
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/value/index.js
var require_value = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/value/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var boolean_1$2 = require_boolean();
	var null_1$2 = require_null();
	var color_1$2 = require_color();
	var list_1$2 = require_list();
	var map_1$10 = require_map$1();
	var number_1$2 = require_number();
	var string_1$2 = require_string();
	exports.Boolean = boolean_1$2.SassBooleanInternal;
	exports.Color = color_1$2.LegacyColor;
	exports.List = list_1$2.LegacyList;
	exports.Map = map_1$10.LegacyMap;
	exports.Null = null_1$2.SassNull;
	exports.Number = number_1$2.LegacyNumber;
	exports.String = string_1$2.LegacyString;
	exports.Error = global.Error;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/deprotofy-span.js
var require_deprotofy_span = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/deprotofy-span.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.deprotofySourceSpan = deprotofySourceSpan;
	var url_1$3 = require_browser_external_url();
	var utils_1$10 = require_utils$3();
	function deprotofySourceSpan(buffer$1) {
		const text = buffer$1.text;
		if (buffer$1.start === void 0) throw (0, utils_1$10.compilerError)("Expected SourceSpan to have start.");
		let end;
		if (buffer$1.end === void 0) if (text !== "") throw (0, utils_1$10.compilerError)("Expected SourceSpan text to be empty.");
		else end = buffer$1.start;
		else {
			end = buffer$1.end;
			if (end.offset < buffer$1.start.offset) throw (0, utils_1$10.compilerError)("Expected SourceSpan end to be after start.");
		}
		const url$1 = buffer$1.url === "" ? void 0 : new url_1$3.URL(buffer$1.url);
		const context$1 = buffer$1.context === "" ? void 0 : buffer$1.context;
		return {
			text,
			start: buffer$1.start,
			end,
			url: url$1,
			context: context$1
		};
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/exception.js
var require_exception = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/exception.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var deprotofy_span_1$1 = require_deprotofy_span();
	var Exception$1 = class extends Error {
		sassMessage;
		sassStack;
		span;
		constructor(failure) {
			super(failure.formatted);
			this.sassMessage = failure.message;
			this.sassStack = failure.stackTrace;
			this.span = (0, deprotofy_span_1$1.deprotofySourceSpan)(failure.span);
		}
		toString() {
			return this.message;
		}
	};
	exports.Exception = Exception$1;
}) });

//#endregion
//#region browser-external:child_process
var require_browser_external_child_process = /* @__PURE__ */ __commonJS({ "browser-external:child_process": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/isFunction.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function isFunction(value) {
		return typeof value === "function";
	}
	exports.isFunction = isFunction;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function createErrorClass(createImpl) {
		var _super = function(instance) {
			Error.call(instance);
			instance.stack = (/* @__PURE__ */ new Error()).stack;
		};
		var ctorFunc = createImpl(_super);
		ctorFunc.prototype = Object.create(Error.prototype);
		ctorFunc.prototype.constructor = ctorFunc;
		return ctorFunc;
	}
	exports.createErrorClass = createErrorClass;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var createErrorClass_1$6 = require_createErrorClass();
	exports.UnsubscriptionError = createErrorClass_1$6.createErrorClass(function(_super) {
		return function UnsubscriptionErrorImpl(errors) {
			_super(this);
			this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
				return i + 1 + ") " + err.toString();
			}).join("\n  ") : "";
			this.name = "UnsubscriptionError";
			this.errors = errors;
		};
	});
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/arrRemove.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrRemove(arr, item) {
		if (arr) {
			var index = arr.indexOf(item);
			0 <= index && arr.splice(index, 1);
		}
	}
	exports.arrRemove = arrRemove;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/Subscription.js": ((exports) => {
	var __values$9 = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m$1 = s && o[s], i = 0;
		if (m$1) return m$1.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$22 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$21 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var isFunction_1$27 = require_isFunction();
	var UnsubscriptionError_1$1 = require_UnsubscriptionError();
	var arrRemove_1$7 = require_arrRemove();
	var Subscription = function() {
		function Subscription$1(initialTeardown) {
			this.initialTeardown = initialTeardown;
			this.closed = false;
			this._parentage = null;
			this._finalizers = null;
		}
		Subscription$1.prototype.unsubscribe = function() {
			var e_1, _a, e_2, _b;
			var errors;
			if (!this.closed) {
				this.closed = true;
				var _parentage = this._parentage;
				if (_parentage) {
					this._parentage = null;
					if (Array.isArray(_parentage)) try {
						for (var _parentage_1 = __values$9(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) _parentage_1_1.value.remove(this);
					} catch (e_1_1) {
						e_1 = { error: e_1_1 };
					} finally {
						try {
							if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
						} finally {
							if (e_1) throw e_1.error;
						}
					}
					else _parentage.remove(this);
				}
				var initialFinalizer = this.initialTeardown;
				if (isFunction_1$27.isFunction(initialFinalizer)) try {
					initialFinalizer();
				} catch (e) {
					errors = e instanceof UnsubscriptionError_1$1.UnsubscriptionError ? e.errors : [e];
				}
				var _finalizers = this._finalizers;
				if (_finalizers) {
					this._finalizers = null;
					try {
						for (var _finalizers_1 = __values$9(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
							var finalizer = _finalizers_1_1.value;
							try {
								execFinalizer(finalizer);
							} catch (err) {
								errors = errors !== null && errors !== void 0 ? errors : [];
								if (err instanceof UnsubscriptionError_1$1.UnsubscriptionError) errors = __spreadArray$21(__spreadArray$21([], __read$22(errors)), __read$22(err.errors));
								else errors.push(err);
							}
						}
					} catch (e_2_1) {
						e_2 = { error: e_2_1 };
					} finally {
						try {
							if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
						} finally {
							if (e_2) throw e_2.error;
						}
					}
				}
				if (errors) throw new UnsubscriptionError_1$1.UnsubscriptionError(errors);
			}
		};
		Subscription$1.prototype.add = function(teardown) {
			var _a;
			if (teardown && teardown !== this) if (this.closed) execFinalizer(teardown);
			else {
				if (teardown instanceof Subscription$1) {
					if (teardown.closed || teardown._hasParent(this)) return;
					teardown._addParent(this);
				}
				(this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
			}
		};
		Subscription$1.prototype._hasParent = function(parent$1) {
			var _parentage = this._parentage;
			return _parentage === parent$1 || Array.isArray(_parentage) && _parentage.includes(parent$1);
		};
		Subscription$1.prototype._addParent = function(parent$1) {
			var _parentage = this._parentage;
			this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent$1), _parentage) : _parentage ? [_parentage, parent$1] : parent$1;
		};
		Subscription$1.prototype._removeParent = function(parent$1) {
			var _parentage = this._parentage;
			if (_parentage === parent$1) this._parentage = null;
			else if (Array.isArray(_parentage)) arrRemove_1$7.arrRemove(_parentage, parent$1);
		};
		Subscription$1.prototype.remove = function(teardown) {
			var _finalizers = this._finalizers;
			_finalizers && arrRemove_1$7.arrRemove(_finalizers, teardown);
			if (teardown instanceof Subscription$1) teardown._removeParent(this);
		};
		Subscription$1.EMPTY = (function() {
			var empty$1 = new Subscription$1();
			empty$1.closed = true;
			return empty$1;
		})();
		return Subscription$1;
	}();
	exports.Subscription = Subscription;
	exports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
	function isSubscription(value) {
		return value instanceof Subscription || value && "closed" in value && isFunction_1$27.isFunction(value.remove) && isFunction_1$27.isFunction(value.add) && isFunction_1$27.isFunction(value.unsubscribe);
	}
	exports.isSubscription = isSubscription;
	function execFinalizer(finalizer) {
		if (isFunction_1$27.isFunction(finalizer)) finalizer();
		else finalizer.unsubscribe();
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/config.js
var require_config = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/config.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.config = {
		onUnhandledError: null,
		onStoppedNotification: null,
		Promise: void 0,
		useDeprecatedSynchronousErrorHandling: false,
		useDeprecatedNextContext: false
	};
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js": ((exports) => {
	var __read$21 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$20 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.timeoutProvider = void 0;
	exports.timeoutProvider = {
		setTimeout: function(handler, timeout$1) {
			var args = [];
			for (var _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
			var delegate = exports.timeoutProvider.delegate;
			if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) return delegate.setTimeout.apply(delegate, __spreadArray$20([handler, timeout$1], __read$21(args)));
			return setTimeout.apply(void 0, __spreadArray$20([handler, timeout$1], __read$21(args)));
		},
		clearTimeout: function(handle) {
			var delegate = exports.timeoutProvider.delegate;
			return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
		},
		delegate: void 0
	};
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var config_1$4 = require_config();
	var timeoutProvider_1$1 = require_timeoutProvider();
	function reportUnhandledError(err) {
		timeoutProvider_1$1.timeoutProvider.setTimeout(function() {
			var onUnhandledError = config_1$4.config.onUnhandledError;
			if (onUnhandledError) onUnhandledError(err);
			else throw err;
		});
	}
	exports.reportUnhandledError = reportUnhandledError;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/noop.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function noop() {}
	exports.noop = noop;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/NotificationFactories.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.COMPLETE_NOTIFICATION = (function() {
		return createNotification("C", void 0, void 0);
	})();
	function errorNotification(error) {
		return createNotification("E", void 0, error);
	}
	exports.errorNotification = errorNotification;
	function nextNotification(value) {
		return createNotification("N", value, void 0);
	}
	exports.nextNotification = nextNotification;
	function createNotification(kind, value, error) {
		return {
			kind,
			value,
			error
		};
	}
	exports.createNotification = createNotification;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/errorContext.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var config_1$3 = require_config();
	var context = null;
	function errorContext(cb) {
		if (config_1$3.config.useDeprecatedSynchronousErrorHandling) {
			var isRoot = !context;
			if (isRoot) context = {
				errorThrown: false,
				error: null
			};
			cb();
			if (isRoot) {
				var _a = context, errorThrown = _a.errorThrown, error = _a.error;
				context = null;
				if (errorThrown) throw error;
			}
		} else cb();
	}
	exports.errorContext = errorContext;
	function captureError(err) {
		if (config_1$3.config.useDeprecatedSynchronousErrorHandling && context) {
			context.errorThrown = true;
			context.error = err;
		}
	}
	exports.captureError = captureError;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/Subscriber.js": ((exports) => {
	var __extends$16 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
	var isFunction_1$26 = require_isFunction();
	var Subscription_1$10 = require_Subscription();
	var config_1$2 = require_config();
	var reportUnhandledError_1$1 = require_reportUnhandledError();
	var noop_1$15 = require_noop();
	var NotificationFactories_1 = require_NotificationFactories();
	var timeoutProvider_1 = require_timeoutProvider();
	var errorContext_1$2 = require_errorContext();
	var Subscriber = function(_super) {
		__extends$16(Subscriber$1, _super);
		function Subscriber$1(destination) {
			var _this = _super.call(this) || this;
			_this.isStopped = false;
			if (destination) {
				_this.destination = destination;
				if (Subscription_1$10.isSubscription(destination)) destination.add(_this);
			} else _this.destination = exports.EMPTY_OBSERVER;
			return _this;
		}
		Subscriber$1.create = function(next, error, complete) {
			return new SafeSubscriber(next, error, complete);
		};
		Subscriber$1.prototype.next = function(value) {
			if (this.isStopped) handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
			else this._next(value);
		};
		Subscriber$1.prototype.error = function(err) {
			if (this.isStopped) handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
			else {
				this.isStopped = true;
				this._error(err);
			}
		};
		Subscriber$1.prototype.complete = function() {
			if (this.isStopped) handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
			else {
				this.isStopped = true;
				this._complete();
			}
		};
		Subscriber$1.prototype.unsubscribe = function() {
			if (!this.closed) {
				this.isStopped = true;
				_super.prototype.unsubscribe.call(this);
				this.destination = null;
			}
		};
		Subscriber$1.prototype._next = function(value) {
			this.destination.next(value);
		};
		Subscriber$1.prototype._error = function(err) {
			try {
				this.destination.error(err);
			} finally {
				this.unsubscribe();
			}
		};
		Subscriber$1.prototype._complete = function() {
			try {
				this.destination.complete();
			} finally {
				this.unsubscribe();
			}
		};
		return Subscriber$1;
	}(Subscription_1$10.Subscription);
	exports.Subscriber = Subscriber;
	var _bind = Function.prototype.bind;
	function bind(fn, thisArg) {
		return _bind.call(fn, thisArg);
	}
	var ConsumerObserver = function() {
		function ConsumerObserver$1(partialObserver) {
			this.partialObserver = partialObserver;
		}
		ConsumerObserver$1.prototype.next = function(value) {
			var partialObserver = this.partialObserver;
			if (partialObserver.next) try {
				partialObserver.next(value);
			} catch (error) {
				handleUnhandledError(error);
			}
		};
		ConsumerObserver$1.prototype.error = function(err) {
			var partialObserver = this.partialObserver;
			if (partialObserver.error) try {
				partialObserver.error(err);
			} catch (error) {
				handleUnhandledError(error);
			}
			else handleUnhandledError(err);
		};
		ConsumerObserver$1.prototype.complete = function() {
			var partialObserver = this.partialObserver;
			if (partialObserver.complete) try {
				partialObserver.complete();
			} catch (error) {
				handleUnhandledError(error);
			}
		};
		return ConsumerObserver$1;
	}();
	var SafeSubscriber = function(_super) {
		__extends$16(SafeSubscriber$1, _super);
		function SafeSubscriber$1(observerOrNext, error, complete) {
			var _this = _super.call(this) || this;
			var partialObserver;
			if (isFunction_1$26.isFunction(observerOrNext) || !observerOrNext) partialObserver = {
				next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
				error: error !== null && error !== void 0 ? error : void 0,
				complete: complete !== null && complete !== void 0 ? complete : void 0
			};
			else {
				var context_1;
				if (_this && config_1$2.config.useDeprecatedNextContext) {
					context_1 = Object.create(observerOrNext);
					context_1.unsubscribe = function() {
						return _this.unsubscribe();
					};
					partialObserver = {
						next: observerOrNext.next && bind(observerOrNext.next, context_1),
						error: observerOrNext.error && bind(observerOrNext.error, context_1),
						complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
					};
				} else partialObserver = observerOrNext;
			}
			_this.destination = new ConsumerObserver(partialObserver);
			return _this;
		}
		return SafeSubscriber$1;
	}(Subscriber);
	exports.SafeSubscriber = SafeSubscriber;
	function handleUnhandledError(error) {
		if (config_1$2.config.useDeprecatedSynchronousErrorHandling) errorContext_1$2.captureError(error);
		else reportUnhandledError_1$1.reportUnhandledError(error);
	}
	function defaultErrorHandler(err) {
		throw err;
	}
	function handleStoppedNotification(notification, subscriber) {
		var onStoppedNotification = config_1$2.config.onStoppedNotification;
		onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
			return onStoppedNotification(notification, subscriber);
		});
	}
	exports.EMPTY_OBSERVER = {
		closed: true,
		next: noop_1$15.noop,
		error: defaultErrorHandler,
		complete: noop_1$15.noop
	};
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/symbol/observable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.observable = (function() {
		return typeof Symbol === "function" && Symbol.observable || "@@observable";
	})();
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/identity.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function identity(x) {
		return x;
	}
	exports.identity = identity;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/pipe.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var identity_1$15 = require_identity();
	function pipe() {
		var fns = [];
		for (var _i = 0; _i < arguments.length; _i++) fns[_i] = arguments[_i];
		return pipeFromArray(fns);
	}
	exports.pipe = pipe;
	function pipeFromArray(fns) {
		if (fns.length === 0) return identity_1$15.identity;
		if (fns.length === 1) return fns[0];
		return function piped(input) {
			return fns.reduce(function(prev, fn) {
				return fn(prev);
			}, input);
		};
	}
	exports.pipeFromArray = pipeFromArray;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/Observable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subscriber_1$4 = require_Subscriber();
	var Subscription_1$9 = require_Subscription();
	var observable_1$3 = require_observable();
	var pipe_1$3 = require_pipe();
	var config_1$1 = require_config();
	var isFunction_1$25 = require_isFunction();
	var errorContext_1$1 = require_errorContext();
	var Observable = function() {
		function Observable$1(subscribe) {
			if (subscribe) this._subscribe = subscribe;
		}
		Observable$1.prototype.lift = function(operator) {
			var observable = new Observable$1();
			observable.source = this;
			observable.operator = operator;
			return observable;
		};
		Observable$1.prototype.subscribe = function(observerOrNext, error, complete) {
			var _this = this;
			var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1$4.SafeSubscriber(observerOrNext, error, complete);
			errorContext_1$1.errorContext(function() {
				var _a = _this, operator = _a.operator, source = _a.source;
				subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
			});
			return subscriber;
		};
		Observable$1.prototype._trySubscribe = function(sink) {
			try {
				return this._subscribe(sink);
			} catch (err) {
				sink.error(err);
			}
		};
		Observable$1.prototype.forEach = function(next, promiseCtor) {
			var _this = this;
			promiseCtor = getPromiseCtor(promiseCtor);
			return new promiseCtor(function(resolve, reject) {
				var subscriber = new Subscriber_1$4.SafeSubscriber({
					next: function(value) {
						try {
							next(value);
						} catch (err) {
							reject(err);
							subscriber.unsubscribe();
						}
					},
					error: reject,
					complete: resolve
				});
				_this.subscribe(subscriber);
			});
		};
		Observable$1.prototype._subscribe = function(subscriber) {
			var _a;
			return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
		};
		Observable$1.prototype[observable_1$3.observable] = function() {
			return this;
		};
		Observable$1.prototype.pipe = function() {
			var operations = [];
			for (var _i = 0; _i < arguments.length; _i++) operations[_i] = arguments[_i];
			return pipe_1$3.pipeFromArray(operations)(this);
		};
		Observable$1.prototype.toPromise = function(promiseCtor) {
			var _this = this;
			promiseCtor = getPromiseCtor(promiseCtor);
			return new promiseCtor(function(resolve, reject) {
				var value;
				_this.subscribe(function(x) {
					return value = x;
				}, function(err) {
					return reject(err);
				}, function() {
					return resolve(value);
				});
			});
		};
		Observable$1.create = function(subscribe) {
			return new Observable$1(subscribe);
		};
		return Observable$1;
	}();
	exports.Observable = Observable;
	function getPromiseCtor(promiseCtor) {
		var _a;
		return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1$1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
	}
	function isObserver(value) {
		return value && isFunction_1$25.isFunction(value.next) && isFunction_1$25.isFunction(value.error) && isFunction_1$25.isFunction(value.complete);
	}
	function isSubscriber(value) {
		return value && value instanceof Subscriber_1$4.Subscriber || isObserver(value) && Subscription_1$9.isSubscription(value);
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/lift.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var isFunction_1$24 = require_isFunction();
	function hasLift(source) {
		return isFunction_1$24.isFunction(source === null || source === void 0 ? void 0 : source.lift);
	}
	exports.hasLift = hasLift;
	function operate(init) {
		return function(source) {
			if (hasLift(source)) return source.lift(function(liftedSource) {
				try {
					return init(liftedSource, this);
				} catch (err) {
					this.error(err);
				}
			});
			throw new TypeError("Unable to lift unknown Observable type");
		};
	}
	exports.operate = operate;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js": ((exports) => {
	var __extends$15 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subscriber_1$3 = require_Subscriber();
	function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
		return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
	}
	exports.createOperatorSubscriber = createOperatorSubscriber;
	var OperatorSubscriber = function(_super) {
		__extends$15(OperatorSubscriber$1, _super);
		function OperatorSubscriber$1(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
			var _this = _super.call(this, destination) || this;
			_this.onFinalize = onFinalize;
			_this.shouldUnsubscribe = shouldUnsubscribe;
			_this._next = onNext ? function(value) {
				try {
					onNext(value);
				} catch (err) {
					destination.error(err);
				}
			} : _super.prototype._next;
			_this._error = onError ? function(err) {
				try {
					onError(err);
				} catch (err$1) {
					destination.error(err$1);
				} finally {
					this.unsubscribe();
				}
			} : _super.prototype._error;
			_this._complete = onComplete ? function() {
				try {
					onComplete();
				} catch (err) {
					destination.error(err);
				} finally {
					this.unsubscribe();
				}
			} : _super.prototype._complete;
			return _this;
		}
		OperatorSubscriber$1.prototype.unsubscribe = function() {
			var _a;
			if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
				var closed_1 = this.closed;
				_super.prototype.unsubscribe.call(this);
				!closed_1 && ((_a = this.onFinalize) === null || _a === void 0 || _a.call(this));
			}
		};
		return OperatorSubscriber$1;
	}(Subscriber_1$3.Subscriber);
	exports.OperatorSubscriber = OperatorSubscriber;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/refCount.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$69 = require_lift();
	var OperatorSubscriber_1$58 = require_OperatorSubscriber();
	function refCount() {
		return lift_1$69.operate(function(source, subscriber) {
			var connection = null;
			source._refCount++;
			var refCounter = OperatorSubscriber_1$58.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
				if (!source || source._refCount <= 0 || 0 < --source._refCount) {
					connection = null;
					return;
				}
				var sharedConnection = source._connection;
				var conn = connection;
				connection = null;
				if (sharedConnection && (!conn || sharedConnection === conn)) sharedConnection.unsubscribe();
				subscriber.unsubscribe();
			});
			source.subscribe(refCounter);
			if (!refCounter.closed) connection = source.connect();
		});
	}
	exports.refCount = refCount;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js": ((exports) => {
	var __extends$14 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$26 = require_Observable();
	var Subscription_1$8 = require_Subscription();
	var refCount_1$2 = require_refCount();
	var OperatorSubscriber_1$57 = require_OperatorSubscriber();
	var lift_1$68 = require_lift();
	var ConnectableObservable = function(_super) {
		__extends$14(ConnectableObservable$1, _super);
		function ConnectableObservable$1(source, subjectFactory) {
			var _this = _super.call(this) || this;
			_this.source = source;
			_this.subjectFactory = subjectFactory;
			_this._subject = null;
			_this._refCount = 0;
			_this._connection = null;
			if (lift_1$68.hasLift(source)) _this.lift = source.lift;
			return _this;
		}
		ConnectableObservable$1.prototype._subscribe = function(subscriber) {
			return this.getSubject().subscribe(subscriber);
		};
		ConnectableObservable$1.prototype.getSubject = function() {
			var subject = this._subject;
			if (!subject || subject.isStopped) this._subject = this.subjectFactory();
			return this._subject;
		};
		ConnectableObservable$1.prototype._teardown = function() {
			this._refCount = 0;
			var _connection = this._connection;
			this._subject = this._connection = null;
			_connection === null || _connection === void 0 || _connection.unsubscribe();
		};
		ConnectableObservable$1.prototype.connect = function() {
			var _this = this;
			var connection = this._connection;
			if (!connection) {
				connection = this._connection = new Subscription_1$8.Subscription();
				var subject_1 = this.getSubject();
				connection.add(this.source.subscribe(OperatorSubscriber_1$57.createOperatorSubscriber(subject_1, void 0, function() {
					_this._teardown();
					subject_1.complete();
				}, function(err) {
					_this._teardown();
					subject_1.error(err);
				}, function() {
					return _this._teardown();
				})));
				if (connection.closed) {
					this._connection = null;
					connection = Subscription_1$8.Subscription.EMPTY;
				}
			}
			return connection;
		};
		ConnectableObservable$1.prototype.refCount = function() {
			return refCount_1$2.refCount()(this);
		};
		return ConnectableObservable$1;
	}(Observable_1$26.Observable);
	exports.ConnectableObservable = ConnectableObservable;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.performanceTimestampProvider = void 0;
	exports.performanceTimestampProvider = {
		now: function() {
			return (exports.performanceTimestampProvider.delegate || performance).now();
		},
		delegate: void 0
	};
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js": ((exports) => {
	var __read$20 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$19 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.animationFrameProvider = void 0;
	var Subscription_1$7 = require_Subscription();
	exports.animationFrameProvider = {
		schedule: function(callback) {
			var request = requestAnimationFrame;
			var cancel = cancelAnimationFrame;
			var delegate = exports.animationFrameProvider.delegate;
			if (delegate) {
				request = delegate.requestAnimationFrame;
				cancel = delegate.cancelAnimationFrame;
			}
			var handle = request(function(timestamp$1) {
				cancel = void 0;
				callback(timestamp$1);
			});
			return new Subscription_1$7.Subscription(function() {
				return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
			});
		},
		requestAnimationFrame: function() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var delegate = exports.animationFrameProvider.delegate;
			return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray$19([], __read$20(args)));
		},
		cancelAnimationFrame: function() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var delegate = exports.animationFrameProvider.delegate;
			return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray$19([], __read$20(args)));
		},
		delegate: void 0
	};
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$25 = require_Observable();
	var performanceTimestampProvider_1 = require_performanceTimestampProvider();
	var animationFrameProvider_1$1 = require_animationFrameProvider();
	function animationFrames(timestampProvider) {
		return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
	}
	exports.animationFrames = animationFrames;
	function animationFramesFactory(timestampProvider) {
		return new Observable_1$25.Observable(function(subscriber) {
			var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
			var start = provider.now();
			var id = 0;
			var run = function() {
				if (!subscriber.closed) id = animationFrameProvider_1$1.animationFrameProvider.requestAnimationFrame(function(timestamp$1) {
					id = 0;
					var now = provider.now();
					subscriber.next({
						timestamp: timestampProvider ? now : timestamp$1,
						elapsed: now - start
					});
					run();
				});
			};
			run();
			return function() {
				if (id) animationFrameProvider_1$1.animationFrameProvider.cancelAnimationFrame(id);
			};
		});
	}
	var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var createErrorClass_1$5 = require_createErrorClass();
	exports.ObjectUnsubscribedError = createErrorClass_1$5.createErrorClass(function(_super) {
		return function ObjectUnsubscribedErrorImpl() {
			_super(this);
			this.name = "ObjectUnsubscribedError";
			this.message = "object unsubscribed";
		};
	});
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/Subject.js": ((exports) => {
	var __extends$13 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	var __values$8 = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m$1 = s && o[s], i = 0;
		if (m$1) return m$1.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$24 = require_Observable();
	var Subscription_1$6 = require_Subscription();
	var ObjectUnsubscribedError_1$1 = require_ObjectUnsubscribedError();
	var arrRemove_1$6 = require_arrRemove();
	var errorContext_1 = require_errorContext();
	var Subject = function(_super) {
		__extends$13(Subject$1, _super);
		function Subject$1() {
			var _this = _super.call(this) || this;
			_this.closed = false;
			_this.currentObservers = null;
			_this.observers = [];
			_this.isStopped = false;
			_this.hasError = false;
			_this.thrownError = null;
			return _this;
		}
		Subject$1.prototype.lift = function(operator) {
			var subject = new AnonymousSubject(this, this);
			subject.operator = operator;
			return subject;
		};
		Subject$1.prototype._throwIfClosed = function() {
			if (this.closed) throw new ObjectUnsubscribedError_1$1.ObjectUnsubscribedError();
		};
		Subject$1.prototype.next = function(value) {
			var _this = this;
			errorContext_1.errorContext(function() {
				var e_1, _a;
				_this._throwIfClosed();
				if (!_this.isStopped) {
					if (!_this.currentObservers) _this.currentObservers = Array.from(_this.observers);
					try {
						for (var _b = __values$8(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) _c.value.next(value);
					} catch (e_1_1) {
						e_1 = { error: e_1_1 };
					} finally {
						try {
							if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
						} finally {
							if (e_1) throw e_1.error;
						}
					}
				}
			});
		};
		Subject$1.prototype.error = function(err) {
			var _this = this;
			errorContext_1.errorContext(function() {
				_this._throwIfClosed();
				if (!_this.isStopped) {
					_this.hasError = _this.isStopped = true;
					_this.thrownError = err;
					var observers = _this.observers;
					while (observers.length) observers.shift().error(err);
				}
			});
		};
		Subject$1.prototype.complete = function() {
			var _this = this;
			errorContext_1.errorContext(function() {
				_this._throwIfClosed();
				if (!_this.isStopped) {
					_this.isStopped = true;
					var observers = _this.observers;
					while (observers.length) observers.shift().complete();
				}
			});
		};
		Subject$1.prototype.unsubscribe = function() {
			this.isStopped = this.closed = true;
			this.observers = this.currentObservers = null;
		};
		Object.defineProperty(Subject$1.prototype, "observed", {
			get: function() {
				var _a;
				return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
			},
			enumerable: false,
			configurable: true
		});
		Subject$1.prototype._trySubscribe = function(subscriber) {
			this._throwIfClosed();
			return _super.prototype._trySubscribe.call(this, subscriber);
		};
		Subject$1.prototype._subscribe = function(subscriber) {
			this._throwIfClosed();
			this._checkFinalizedStatuses(subscriber);
			return this._innerSubscribe(subscriber);
		};
		Subject$1.prototype._innerSubscribe = function(subscriber) {
			var _this = this;
			var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
			if (hasError || isStopped) return Subscription_1$6.EMPTY_SUBSCRIPTION;
			this.currentObservers = null;
			observers.push(subscriber);
			return new Subscription_1$6.Subscription(function() {
				_this.currentObservers = null;
				arrRemove_1$6.arrRemove(observers, subscriber);
			});
		};
		Subject$1.prototype._checkFinalizedStatuses = function(subscriber) {
			var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
			if (hasError) subscriber.error(thrownError);
			else if (isStopped) subscriber.complete();
		};
		Subject$1.prototype.asObservable = function() {
			var observable = new Observable_1$24.Observable();
			observable.source = this;
			return observable;
		};
		Subject$1.create = function(destination, source) {
			return new AnonymousSubject(destination, source);
		};
		return Subject$1;
	}(Observable_1$24.Observable);
	exports.Subject = Subject;
	var AnonymousSubject = function(_super) {
		__extends$13(AnonymousSubject$1, _super);
		function AnonymousSubject$1(destination, source) {
			var _this = _super.call(this) || this;
			_this.destination = destination;
			_this.source = source;
			return _this;
		}
		AnonymousSubject$1.prototype.next = function(value) {
			var _a, _b;
			(_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 || _b.call(_a, value);
		};
		AnonymousSubject$1.prototype.error = function(err) {
			var _a, _b;
			(_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 || _b.call(_a, err);
		};
		AnonymousSubject$1.prototype.complete = function() {
			var _a, _b;
			(_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 || _b.call(_a);
		};
		AnonymousSubject$1.prototype._subscribe = function(subscriber) {
			var _a, _b;
			return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1$6.EMPTY_SUBSCRIPTION;
		};
		return AnonymousSubject$1;
	}(Subject);
	exports.AnonymousSubject = AnonymousSubject;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js": ((exports) => {
	var __extends$12 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var BehaviorSubject = function(_super) {
		__extends$12(BehaviorSubject$1, _super);
		function BehaviorSubject$1(_value) {
			var _this = _super.call(this) || this;
			_this._value = _value;
			return _this;
		}
		Object.defineProperty(BehaviorSubject$1.prototype, "value", {
			get: function() {
				return this.getValue();
			},
			enumerable: false,
			configurable: true
		});
		BehaviorSubject$1.prototype._subscribe = function(subscriber) {
			var subscription = _super.prototype._subscribe.call(this, subscriber);
			!subscription.closed && subscriber.next(this._value);
			return subscription;
		};
		BehaviorSubject$1.prototype.getValue = function() {
			var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
			if (hasError) throw thrownError;
			this._throwIfClosed();
			return _value;
		};
		BehaviorSubject$1.prototype.next = function(value) {
			_super.prototype.next.call(this, this._value = value);
		};
		return BehaviorSubject$1;
	}(require_Subject().Subject);
	exports.BehaviorSubject = BehaviorSubject;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.dateTimestampProvider = void 0;
	exports.dateTimestampProvider = {
		now: function() {
			return (exports.dateTimestampProvider.delegate || Date).now();
		},
		delegate: void 0
	};
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/ReplaySubject.js": ((exports) => {
	var __extends$11 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subject_1$13 = require_Subject();
	var dateTimestampProvider_1$2 = require_dateTimestampProvider();
	var ReplaySubject = function(_super) {
		__extends$11(ReplaySubject$1, _super);
		function ReplaySubject$1(_bufferSize, _windowTime, _timestampProvider) {
			if (_bufferSize === void 0) _bufferSize = Infinity;
			if (_windowTime === void 0) _windowTime = Infinity;
			if (_timestampProvider === void 0) _timestampProvider = dateTimestampProvider_1$2.dateTimestampProvider;
			var _this = _super.call(this) || this;
			_this._bufferSize = _bufferSize;
			_this._windowTime = _windowTime;
			_this._timestampProvider = _timestampProvider;
			_this._buffer = [];
			_this._infiniteTimeWindow = true;
			_this._infiniteTimeWindow = _windowTime === Infinity;
			_this._bufferSize = Math.max(1, _bufferSize);
			_this._windowTime = Math.max(1, _windowTime);
			return _this;
		}
		ReplaySubject$1.prototype.next = function(value) {
			var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
			if (!isStopped) {
				_buffer.push(value);
				!_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
			}
			this._trimBuffer();
			_super.prototype.next.call(this, value);
		};
		ReplaySubject$1.prototype._subscribe = function(subscriber) {
			this._throwIfClosed();
			this._trimBuffer();
			var subscription = this._innerSubscribe(subscriber);
			var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow;
			var copy = _a._buffer.slice();
			for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) subscriber.next(copy[i]);
			this._checkFinalizedStatuses(subscriber);
			return subscription;
		};
		ReplaySubject$1.prototype._trimBuffer = function() {
			var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
			var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
			_bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
			if (!_infiniteTimeWindow) {
				var now = _timestampProvider.now();
				var last$3 = 0;
				for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) last$3 = i;
				last$3 && _buffer.splice(0, last$3 + 1);
			}
		};
		return ReplaySubject$1;
	}(Subject_1$13.Subject);
	exports.ReplaySubject = ReplaySubject;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/AsyncSubject.js": ((exports) => {
	var __extends$10 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var AsyncSubject = function(_super) {
		__extends$10(AsyncSubject$1, _super);
		function AsyncSubject$1() {
			var _this = _super !== null && _super.apply(this, arguments) || this;
			_this._value = null;
			_this._hasValue = false;
			_this._isComplete = false;
			return _this;
		}
		AsyncSubject$1.prototype._checkFinalizedStatuses = function(subscriber) {
			var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
			if (hasError) subscriber.error(thrownError);
			else if (isStopped || _isComplete) {
				_hasValue && subscriber.next(_value);
				subscriber.complete();
			}
		};
		AsyncSubject$1.prototype.next = function(value) {
			if (!this.isStopped) {
				this._value = value;
				this._hasValue = true;
			}
		};
		AsyncSubject$1.prototype.complete = function() {
			var _a = this, _hasValue = _a._hasValue, _value = _a._value;
			if (!_a._isComplete) {
				this._isComplete = true;
				_hasValue && _super.prototype.next.call(this, _value);
				_super.prototype.complete.call(this);
			}
		};
		return AsyncSubject$1;
	}(require_Subject().Subject);
	exports.AsyncSubject = AsyncSubject;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/Action.js": ((exports) => {
	var __extends$9 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var Action = function(_super) {
		__extends$9(Action$1, _super);
		function Action$1(scheduler, work) {
			return _super.call(this) || this;
		}
		Action$1.prototype.schedule = function(state, delay$1) {
			if (delay$1 === void 0) delay$1 = 0;
			return this;
		};
		return Action$1;
	}(require_Subscription().Subscription);
	exports.Action = Action;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js": ((exports) => {
	var __read$19 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$18 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.intervalProvider = void 0;
	exports.intervalProvider = {
		setInterval: function(handler, timeout$1) {
			var args = [];
			for (var _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
			var delegate = exports.intervalProvider.delegate;
			if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) return delegate.setInterval.apply(delegate, __spreadArray$18([handler, timeout$1], __read$19(args)));
			return setInterval.apply(void 0, __spreadArray$18([handler, timeout$1], __read$19(args)));
		},
		clearInterval: function(handle) {
			var delegate = exports.intervalProvider.delegate;
			return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
		},
		delegate: void 0
	};
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js": ((exports) => {
	var __extends$8 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var Action_1 = require_Action();
	var intervalProvider_1 = require_intervalProvider();
	var arrRemove_1$5 = require_arrRemove();
	var AsyncAction = function(_super) {
		__extends$8(AsyncAction$1, _super);
		function AsyncAction$1(scheduler, work) {
			var _this = _super.call(this, scheduler, work) || this;
			_this.scheduler = scheduler;
			_this.work = work;
			_this.pending = false;
			return _this;
		}
		AsyncAction$1.prototype.schedule = function(state, delay$1) {
			var _a;
			if (delay$1 === void 0) delay$1 = 0;
			if (this.closed) return this;
			this.state = state;
			var id = this.id;
			var scheduler = this.scheduler;
			if (id != null) this.id = this.recycleAsyncId(scheduler, id, delay$1);
			this.pending = true;
			this.delay = delay$1;
			this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay$1);
			return this;
		};
		AsyncAction$1.prototype.requestAsyncId = function(scheduler, _id, delay$1) {
			if (delay$1 === void 0) delay$1 = 0;
			return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay$1);
		};
		AsyncAction$1.prototype.recycleAsyncId = function(_scheduler, id, delay$1) {
			if (delay$1 === void 0) delay$1 = 0;
			if (delay$1 != null && this.delay === delay$1 && this.pending === false) return id;
			if (id != null) intervalProvider_1.intervalProvider.clearInterval(id);
		};
		AsyncAction$1.prototype.execute = function(state, delay$1) {
			if (this.closed) return /* @__PURE__ */ new Error("executing a cancelled action");
			this.pending = false;
			var error = this._execute(state, delay$1);
			if (error) return error;
			else if (this.pending === false && this.id != null) this.id = this.recycleAsyncId(this.scheduler, this.id, null);
		};
		AsyncAction$1.prototype._execute = function(state, _delay) {
			var errored = false;
			var errorValue;
			try {
				this.work(state);
			} catch (e) {
				errored = true;
				errorValue = e ? e : /* @__PURE__ */ new Error("Scheduled action threw falsy error");
			}
			if (errored) {
				this.unsubscribe();
				return errorValue;
			}
		};
		AsyncAction$1.prototype.unsubscribe = function() {
			if (!this.closed) {
				var _a = this, id = _a.id, scheduler = _a.scheduler;
				var actions = scheduler.actions;
				this.work = this.state = this.scheduler = null;
				this.pending = false;
				arrRemove_1$5.arrRemove(actions, this);
				if (id != null) this.id = this.recycleAsyncId(scheduler, id, null);
				this.delay = null;
				_super.prototype.unsubscribe.call(this);
			}
		};
		return AsyncAction$1;
	}(Action_1.Action);
	exports.AsyncAction = AsyncAction;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/Immediate.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var nextHandle = 1;
	var resolved;
	var activeHandles = {};
	function findAndClearHandle(handle) {
		if (handle in activeHandles) {
			delete activeHandles[handle];
			return true;
		}
		return false;
	}
	exports.Immediate = {
		setImmediate: function(cb) {
			var handle = nextHandle++;
			activeHandles[handle] = true;
			if (!resolved) resolved = Promise.resolve();
			resolved.then(function() {
				return findAndClearHandle(handle) && cb();
			});
			return handle;
		},
		clearImmediate: function(handle) {
			findAndClearHandle(handle);
		}
	};
	exports.TestTools = { pending: function() {
		return Object.keys(activeHandles).length;
	} };
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js": ((exports) => {
	var __read$18 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$17 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.immediateProvider = void 0;
	var Immediate_1 = require_Immediate();
	var setImmediate = Immediate_1.Immediate.setImmediate, clearImmediate = Immediate_1.Immediate.clearImmediate;
	exports.immediateProvider = {
		setImmediate: function() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var delegate = exports.immediateProvider.delegate;
			return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray$17([], __read$18(args)));
		},
		clearImmediate: function(handle) {
			var delegate = exports.immediateProvider.delegate;
			return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
		},
		delegate: void 0
	};
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js": ((exports) => {
	var __extends$7 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var AsyncAction_1$3 = require_AsyncAction();
	var immediateProvider_1 = require_immediateProvider();
	var AsapAction = function(_super) {
		__extends$7(AsapAction$1, _super);
		function AsapAction$1(scheduler, work) {
			var _this = _super.call(this, scheduler, work) || this;
			_this.scheduler = scheduler;
			_this.work = work;
			return _this;
		}
		AsapAction$1.prototype.requestAsyncId = function(scheduler, id, delay$1) {
			if (delay$1 === void 0) delay$1 = 0;
			if (delay$1 !== null && delay$1 > 0) return _super.prototype.requestAsyncId.call(this, scheduler, id, delay$1);
			scheduler.actions.push(this);
			return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
		};
		AsapAction$1.prototype.recycleAsyncId = function(scheduler, id, delay$1) {
			var _a;
			if (delay$1 === void 0) delay$1 = 0;
			if (delay$1 != null ? delay$1 > 0 : this.delay > 0) return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay$1);
			var actions = scheduler.actions;
			if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
				immediateProvider_1.immediateProvider.clearImmediate(id);
				if (scheduler._scheduled === id) scheduler._scheduled = void 0;
			}
		};
		return AsapAction$1;
	}(AsyncAction_1$3.AsyncAction);
	exports.AsapAction = AsapAction;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/Scheduler.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var dateTimestampProvider_1$1 = require_dateTimestampProvider();
	var Scheduler = function() {
		function Scheduler$1(schedulerActionCtor, now) {
			if (now === void 0) now = Scheduler$1.now;
			this.schedulerActionCtor = schedulerActionCtor;
			this.now = now;
		}
		Scheduler$1.prototype.schedule = function(work, delay$1, state) {
			if (delay$1 === void 0) delay$1 = 0;
			return new this.schedulerActionCtor(this, work).schedule(state, delay$1);
		};
		Scheduler$1.now = dateTimestampProvider_1$1.dateTimestampProvider.now;
		return Scheduler$1;
	}();
	exports.Scheduler = Scheduler;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js": ((exports) => {
	var __extends$6 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var Scheduler_1$1 = require_Scheduler();
	var AsyncScheduler = function(_super) {
		__extends$6(AsyncScheduler$1, _super);
		function AsyncScheduler$1(SchedulerAction, now) {
			if (now === void 0) now = Scheduler_1$1.Scheduler.now;
			var _this = _super.call(this, SchedulerAction, now) || this;
			_this.actions = [];
			_this._active = false;
			return _this;
		}
		AsyncScheduler$1.prototype.flush = function(action) {
			var actions = this.actions;
			if (this._active) {
				actions.push(action);
				return;
			}
			var error;
			this._active = true;
			do
				if (error = action.execute(action.state, action.delay)) break;
			while (action = actions.shift());
			this._active = false;
			if (error) {
				while (action = actions.shift()) action.unsubscribe();
				throw error;
			}
		};
		return AsyncScheduler$1;
	}(Scheduler_1$1.Scheduler);
	exports.AsyncScheduler = AsyncScheduler;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js": ((exports) => {
	var __extends$5 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var AsapScheduler = function(_super) {
		__extends$5(AsapScheduler$1, _super);
		function AsapScheduler$1() {
			return _super !== null && _super.apply(this, arguments) || this;
		}
		AsapScheduler$1.prototype.flush = function(action) {
			this._active = true;
			var flushId = this._scheduled;
			this._scheduled = void 0;
			var actions = this.actions;
			var error;
			action = action || actions.shift();
			do
				if (error = action.execute(action.state, action.delay)) break;
			while ((action = actions[0]) && action.id === flushId && actions.shift());
			this._active = false;
			if (error) {
				while ((action = actions[0]) && action.id === flushId && actions.shift()) action.unsubscribe();
				throw error;
			}
		};
		return AsapScheduler$1;
	}(require_AsyncScheduler().AsyncScheduler);
	exports.AsapScheduler = AsapScheduler;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/asap.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.asap = exports.asapScheduler = void 0;
	var AsapAction_1 = require_AsapAction();
	var AsapScheduler_1 = require_AsapScheduler();
	exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
	exports.asap = exports.asapScheduler;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async$1 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/async.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.async = exports.asyncScheduler = void 0;
	var AsyncAction_1$2 = require_AsyncAction();
	var AsyncScheduler_1 = require_AsyncScheduler();
	exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1$2.AsyncAction);
	exports.async = exports.asyncScheduler;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js": ((exports) => {
	var __extends$4 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var QueueAction = function(_super) {
		__extends$4(QueueAction$1, _super);
		function QueueAction$1(scheduler, work) {
			var _this = _super.call(this, scheduler, work) || this;
			_this.scheduler = scheduler;
			_this.work = work;
			return _this;
		}
		QueueAction$1.prototype.schedule = function(state, delay$1) {
			if (delay$1 === void 0) delay$1 = 0;
			if (delay$1 > 0) return _super.prototype.schedule.call(this, state, delay$1);
			this.delay = delay$1;
			this.state = state;
			this.scheduler.flush(this);
			return this;
		};
		QueueAction$1.prototype.execute = function(state, delay$1) {
			return delay$1 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay$1) : this._execute(state, delay$1);
		};
		QueueAction$1.prototype.requestAsyncId = function(scheduler, id, delay$1) {
			if (delay$1 === void 0) delay$1 = 0;
			if (delay$1 != null && delay$1 > 0 || delay$1 == null && this.delay > 0) return _super.prototype.requestAsyncId.call(this, scheduler, id, delay$1);
			scheduler.flush(this);
			return 0;
		};
		return QueueAction$1;
	}(require_AsyncAction().AsyncAction);
	exports.QueueAction = QueueAction;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js": ((exports) => {
	var __extends$3 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var QueueScheduler = function(_super) {
		__extends$3(QueueScheduler$1, _super);
		function QueueScheduler$1() {
			return _super !== null && _super.apply(this, arguments) || this;
		}
		return QueueScheduler$1;
	}(require_AsyncScheduler().AsyncScheduler);
	exports.QueueScheduler = QueueScheduler;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/queue.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.queue = exports.queueScheduler = void 0;
	var QueueAction_1 = require_QueueAction();
	var QueueScheduler_1 = require_QueueScheduler();
	exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
	exports.queue = exports.queueScheduler;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js": ((exports) => {
	var __extends$2 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var AsyncAction_1$1 = require_AsyncAction();
	var animationFrameProvider_1 = require_animationFrameProvider();
	var AnimationFrameAction = function(_super) {
		__extends$2(AnimationFrameAction$1, _super);
		function AnimationFrameAction$1(scheduler, work) {
			var _this = _super.call(this, scheduler, work) || this;
			_this.scheduler = scheduler;
			_this.work = work;
			return _this;
		}
		AnimationFrameAction$1.prototype.requestAsyncId = function(scheduler, id, delay$1) {
			if (delay$1 === void 0) delay$1 = 0;
			if (delay$1 !== null && delay$1 > 0) return _super.prototype.requestAsyncId.call(this, scheduler, id, delay$1);
			scheduler.actions.push(this);
			return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
				return scheduler.flush(void 0);
			}));
		};
		AnimationFrameAction$1.prototype.recycleAsyncId = function(scheduler, id, delay$1) {
			var _a;
			if (delay$1 === void 0) delay$1 = 0;
			if (delay$1 != null ? delay$1 > 0 : this.delay > 0) return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay$1);
			var actions = scheduler.actions;
			if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
				animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
				scheduler._scheduled = void 0;
			}
		};
		return AnimationFrameAction$1;
	}(AsyncAction_1$1.AsyncAction);
	exports.AnimationFrameAction = AnimationFrameAction;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js": ((exports) => {
	var __extends$1 = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var AnimationFrameScheduler = function(_super) {
		__extends$1(AnimationFrameScheduler$1, _super);
		function AnimationFrameScheduler$1() {
			return _super !== null && _super.apply(this, arguments) || this;
		}
		AnimationFrameScheduler$1.prototype.flush = function(action) {
			this._active = true;
			var flushId;
			if (action) flushId = action.id;
			else {
				flushId = this._scheduled;
				this._scheduled = void 0;
			}
			var actions = this.actions;
			var error;
			action = action || actions.shift();
			do
				if (error = action.execute(action.state, action.delay)) break;
			while ((action = actions[0]) && action.id === flushId && actions.shift());
			this._active = false;
			if (error) {
				while ((action = actions[0]) && action.id === flushId && actions.shift()) action.unsubscribe();
				throw error;
			}
		};
		return AnimationFrameScheduler$1;
	}(require_AsyncScheduler().AsyncScheduler);
	exports.AnimationFrameScheduler = AnimationFrameScheduler;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.animationFrame = exports.animationFrameScheduler = void 0;
	var AnimationFrameAction_1 = require_AnimationFrameAction();
	var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
	exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
	exports.animationFrame = exports.animationFrameScheduler;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js": ((exports) => {
	var __extends = exports && exports.__extends || (function() {
		var extendStatics = function(d$1, b$2) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$3) {
				d$2.__proto__ = b$3;
			} || function(d$2, b$3) {
				for (var p$10 in b$3) if (Object.prototype.hasOwnProperty.call(b$3, p$10)) d$2[p$10] = b$3[p$10];
			};
			return extendStatics(d$1, b$2);
		};
		return function(d$1, b$2) {
			if (typeof b$2 !== "function" && b$2 !== null) throw new TypeError("Class extends value " + String(b$2) + " is not a constructor or null");
			extendStatics(d$1, b$2);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$2 === null ? Object.create(b$2) : (__.prototype = b$2.prototype, new __());
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var AsyncAction_1 = require_AsyncAction();
	var Subscription_1$5 = require_Subscription();
	var VirtualTimeScheduler = function(_super) {
		__extends(VirtualTimeScheduler$1, _super);
		function VirtualTimeScheduler$1(schedulerActionCtor, maxFrames) {
			if (schedulerActionCtor === void 0) schedulerActionCtor = VirtualAction;
			if (maxFrames === void 0) maxFrames = Infinity;
			var _this = _super.call(this, schedulerActionCtor, function() {
				return _this.frame;
			}) || this;
			_this.maxFrames = maxFrames;
			_this.frame = 0;
			_this.index = -1;
			return _this;
		}
		VirtualTimeScheduler$1.prototype.flush = function() {
			var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
			var error;
			var action;
			while ((action = actions[0]) && action.delay <= maxFrames) {
				actions.shift();
				this.frame = action.delay;
				if (error = action.execute(action.state, action.delay)) break;
			}
			if (error) {
				while (action = actions.shift()) action.unsubscribe();
				throw error;
			}
		};
		VirtualTimeScheduler$1.frameTimeFactor = 10;
		return VirtualTimeScheduler$1;
	}(require_AsyncScheduler().AsyncScheduler);
	exports.VirtualTimeScheduler = VirtualTimeScheduler;
	var VirtualAction = function(_super) {
		__extends(VirtualAction$1, _super);
		function VirtualAction$1(scheduler, work, index) {
			if (index === void 0) index = scheduler.index += 1;
			var _this = _super.call(this, scheduler, work) || this;
			_this.scheduler = scheduler;
			_this.work = work;
			_this.index = index;
			_this.active = true;
			_this.index = scheduler.index = index;
			return _this;
		}
		VirtualAction$1.prototype.schedule = function(state, delay$1) {
			if (delay$1 === void 0) delay$1 = 0;
			if (Number.isFinite(delay$1)) {
				if (!this.id) return _super.prototype.schedule.call(this, state, delay$1);
				this.active = false;
				var action = new VirtualAction$1(this.scheduler, this.work);
				this.add(action);
				return action.schedule(state, delay$1);
			} else return Subscription_1$5.Subscription.EMPTY;
		};
		VirtualAction$1.prototype.requestAsyncId = function(scheduler, id, delay$1) {
			if (delay$1 === void 0) delay$1 = 0;
			this.delay = scheduler.frame + delay$1;
			var actions = scheduler.actions;
			actions.push(this);
			actions.sort(VirtualAction$1.sortActions);
			return 1;
		};
		VirtualAction$1.prototype.recycleAsyncId = function(scheduler, id, delay$1) {
			if (delay$1 === void 0) delay$1 = 0;
		};
		VirtualAction$1.prototype._execute = function(state, delay$1) {
			if (this.active === true) return _super.prototype._execute.call(this, state, delay$1);
		};
		VirtualAction$1.sortActions = function(a$1, b$2) {
			if (a$1.delay === b$2.delay) if (a$1.index === b$2.index) return 0;
			else if (a$1.index > b$2.index) return 1;
			else return -1;
			else if (a$1.delay > b$2.delay) return 1;
			else return -1;
		};
		return VirtualAction$1;
	}(AsyncAction_1.AsyncAction);
	exports.VirtualAction = VirtualAction;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/empty.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.empty = exports.EMPTY = void 0;
	var Observable_1$23 = require_Observable();
	exports.EMPTY = new Observable_1$23.Observable(function(subscriber) {
		return subscriber.complete();
	});
	function empty(scheduler) {
		return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
	}
	exports.empty = empty;
	function emptyScheduled(scheduler) {
		return new Observable_1$23.Observable(function(subscriber) {
			return scheduler.schedule(function() {
				return subscriber.complete();
			});
		});
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/isScheduler.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var isFunction_1$23 = require_isFunction();
	function isScheduler(value) {
		return value && isFunction_1$23.isFunction(value.schedule);
	}
	exports.isScheduler = isScheduler;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/args.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var isFunction_1$22 = require_isFunction();
	var isScheduler_1$3 = require_isScheduler();
	function last$1(arr) {
		return arr[arr.length - 1];
	}
	function popResultSelector(args) {
		return isFunction_1$22.isFunction(last$1(args)) ? args.pop() : void 0;
	}
	exports.popResultSelector = popResultSelector;
	function popScheduler(args) {
		return isScheduler_1$3.isScheduler(last$1(args)) ? args.pop() : void 0;
	}
	exports.popScheduler = popScheduler;
	function popNumber(args, defaultValue) {
		return typeof last$1(args) === "number" ? args.pop() : defaultValue;
	}
	exports.popNumber = popNumber;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isArrayLike = (function(x) {
		return x && typeof x.length === "number" && typeof x !== "function";
	});
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/isPromise.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var isFunction_1$21 = require_isFunction();
	function isPromise(value) {
		return isFunction_1$21.isFunction(value === null || value === void 0 ? void 0 : value.then);
	}
	exports.isPromise = isPromise;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var observable_1$2 = require_observable();
	var isFunction_1$20 = require_isFunction();
	function isInteropObservable(input) {
		return isFunction_1$20.isFunction(input[observable_1$2.observable]);
	}
	exports.isInteropObservable = isInteropObservable;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var isFunction_1$19 = require_isFunction();
	function isAsyncIterable(obj) {
		return Symbol.asyncIterator && isFunction_1$19.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
	}
	exports.isAsyncIterable = isAsyncIterable;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function createInvalidObservableTypeError(input) {
		return /* @__PURE__ */ new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
	}
	exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/symbol/iterator.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function getSymbolIterator() {
		if (typeof Symbol !== "function" || !Symbol.iterator) return "@@iterator";
		return Symbol.iterator;
	}
	exports.getSymbolIterator = getSymbolIterator;
	exports.iterator = getSymbolIterator();
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/isIterable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var iterator_1$1 = require_iterator();
	var isFunction_1$18 = require_isFunction();
	function isIterable(input) {
		return isFunction_1$18.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1$1.iterator]);
	}
	exports.isIterable = isIterable;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js": ((exports) => {
	var __generator$2 = exports && exports.__generator || function(thisArg, body) {
		var _ = {
			label: 0,
			sent: function() {
				if (t[0] & 1) throw t[1];
				return t[1];
			},
			trys: [],
			ops: []
		}, f, y, t, g$1;
		return g$1 = {
			next: verb(0),
			"throw": verb(1),
			"return": verb(2)
		}, typeof Symbol === "function" && (g$1[Symbol.iterator] = function() {
			return this;
		}), g$1;
		function verb(n$2) {
			return function(v) {
				return step([n$2, v]);
			};
		}
		function step(op) {
			if (f) throw new TypeError("Generator is already executing.");
			while (_) try {
				if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
				if (y = 0, t) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0:
					case 1:
						t = op;
						break;
					case 4:
						_.label++;
						return {
							value: op[1],
							done: false
						};
					case 5:
						_.label++;
						y = op[1];
						op = [0];
						continue;
					case 7:
						op = _.ops.pop();
						_.trys.pop();
						continue;
					default:
						if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
							_ = 0;
							continue;
						}
						if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
							_.label = op[1];
							break;
						}
						if (op[0] === 6 && _.label < t[1]) {
							_.label = t[1];
							t = op;
							break;
						}
						if (t && _.label < t[2]) {
							_.label = t[2];
							_.ops.push(op);
							break;
						}
						if (t[2]) _.ops.pop();
						_.trys.pop();
						continue;
				}
				op = body.call(thisArg, _);
			} catch (e) {
				op = [6, e];
				y = 0;
			} finally {
				f = t = 0;
			}
			if (op[0] & 5) throw op[1];
			return {
				value: op[0] ? op[1] : void 0,
				done: true
			};
		}
	};
	var __await$1 = exports && exports.__await || function(v) {
		return this instanceof __await$1 ? (this.v = v, this) : new __await$1(v);
	};
	var __asyncGenerator$1 = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
		if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
		var g$1 = generator.apply(thisArg, _arguments || []), i, q = [];
		return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
			return this;
		}, i;
		function verb(n$2) {
			if (g$1[n$2]) i[n$2] = function(v) {
				return new Promise(function(a$1, b$2) {
					q.push([
						n$2,
						v,
						a$1,
						b$2
					]) > 1 || resume(n$2, v);
				});
			};
		}
		function resume(n$2, v) {
			try {
				step(g$1[n$2](v));
			} catch (e) {
				settle(q[0][3], e);
			}
		}
		function step(r) {
			r.value instanceof __await$1 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
		}
		function fulfill(value) {
			resume("next", value);
		}
		function reject(value) {
			resume("throw", value);
		}
		function settle(f, v) {
			if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
		}
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var isFunction_1$17 = require_isFunction();
	function readableStreamLikeToAsyncGenerator(readableStream) {
		return __asyncGenerator$1(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
			var reader, _a, value, done;
			return __generator$2(this, function(_b) {
				switch (_b.label) {
					case 0:
						reader = readableStream.getReader();
						_b.label = 1;
					case 1:
						_b.trys.push([
							1,
							,
							9,
							10
						]);
						_b.label = 2;
					case 2: return [4, __await$1(reader.read())];
					case 3:
						_a = _b.sent(), value = _a.value, done = _a.done;
						if (!done) return [3, 5];
						return [4, __await$1(void 0)];
					case 4: return [2, _b.sent()];
					case 5: return [4, __await$1(value)];
					case 6: return [4, _b.sent()];
					case 7:
						_b.sent();
						return [3, 2];
					case 8: return [3, 10];
					case 9:
						reader.releaseLock();
						return [7];
					case 10: return [2];
				}
			});
		});
	}
	exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
	function isReadableStreamLike(obj) {
		return isFunction_1$17.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
	}
	exports.isReadableStreamLike = isReadableStreamLike;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js": ((exports) => {
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __generator$1 = exports && exports.__generator || function(thisArg, body) {
		var _ = {
			label: 0,
			sent: function() {
				if (t[0] & 1) throw t[1];
				return t[1];
			},
			trys: [],
			ops: []
		}, f, y, t, g$1;
		return g$1 = {
			next: verb(0),
			"throw": verb(1),
			"return": verb(2)
		}, typeof Symbol === "function" && (g$1[Symbol.iterator] = function() {
			return this;
		}), g$1;
		function verb(n$2) {
			return function(v) {
				return step([n$2, v]);
			};
		}
		function step(op) {
			if (f) throw new TypeError("Generator is already executing.");
			while (_) try {
				if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
				if (y = 0, t) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0:
					case 1:
						t = op;
						break;
					case 4:
						_.label++;
						return {
							value: op[1],
							done: false
						};
					case 5:
						_.label++;
						y = op[1];
						op = [0];
						continue;
					case 7:
						op = _.ops.pop();
						_.trys.pop();
						continue;
					default:
						if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
							_ = 0;
							continue;
						}
						if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
							_.label = op[1];
							break;
						}
						if (op[0] === 6 && _.label < t[1]) {
							_.label = t[1];
							t = op;
							break;
						}
						if (t && _.label < t[2]) {
							_.label = t[2];
							_.ops.push(op);
							break;
						}
						if (t[2]) _.ops.pop();
						_.trys.pop();
						continue;
				}
				op = body.call(thisArg, _);
			} catch (e) {
				op = [6, e];
				y = 0;
			} finally {
				f = t = 0;
			}
			if (op[0] & 5) throw op[1];
			return {
				value: op[0] ? op[1] : void 0,
				done: true
			};
		}
	};
	var __asyncValues$1 = exports && exports.__asyncValues || function(o) {
		if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
		var m$1 = o[Symbol.asyncIterator], i;
		return m$1 ? m$1.call(o) : (o = typeof __values$7 === "function" ? __values$7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
			return this;
		}, i);
		function verb(n$2) {
			i[n$2] = o[n$2] && function(v) {
				return new Promise(function(resolve, reject) {
					v = o[n$2](v), settle(resolve, reject, v.done, v.value);
				});
			};
		}
		function settle(resolve, reject, d$1, v) {
			Promise.resolve(v).then(function(v$1) {
				resolve({
					value: v$1,
					done: d$1
				});
			}, reject);
		}
	};
	var __values$7 = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m$1 = s && o[s], i = 0;
		if (m$1) return m$1.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var isArrayLike_1$2 = require_isArrayLike();
	var isPromise_1$1 = require_isPromise();
	var Observable_1$22 = require_Observable();
	var isInteropObservable_1$1 = require_isInteropObservable();
	var isAsyncIterable_1$1 = require_isAsyncIterable();
	var throwUnobservableError_1$1 = require_throwUnobservableError();
	var isIterable_1$1 = require_isIterable();
	var isReadableStreamLike_1$2 = require_isReadableStreamLike();
	var isFunction_1$16 = require_isFunction();
	var reportUnhandledError_1 = require_reportUnhandledError();
	var observable_1$1 = require_observable();
	function innerFrom(input) {
		if (input instanceof Observable_1$22.Observable) return input;
		if (input != null) {
			if (isInteropObservable_1$1.isInteropObservable(input)) return fromInteropObservable(input);
			if (isArrayLike_1$2.isArrayLike(input)) return fromArrayLike(input);
			if (isPromise_1$1.isPromise(input)) return fromPromise(input);
			if (isAsyncIterable_1$1.isAsyncIterable(input)) return fromAsyncIterable(input);
			if (isIterable_1$1.isIterable(input)) return fromIterable(input);
			if (isReadableStreamLike_1$2.isReadableStreamLike(input)) return fromReadableStreamLike(input);
		}
		throw throwUnobservableError_1$1.createInvalidObservableTypeError(input);
	}
	exports.innerFrom = innerFrom;
	function fromInteropObservable(obj) {
		return new Observable_1$22.Observable(function(subscriber) {
			var obs = obj[observable_1$1.observable]();
			if (isFunction_1$16.isFunction(obs.subscribe)) return obs.subscribe(subscriber);
			throw new TypeError("Provided object does not correctly implement Symbol.observable");
		});
	}
	exports.fromInteropObservable = fromInteropObservable;
	function fromArrayLike(array) {
		return new Observable_1$22.Observable(function(subscriber) {
			for (var i = 0; i < array.length && !subscriber.closed; i++) subscriber.next(array[i]);
			subscriber.complete();
		});
	}
	exports.fromArrayLike = fromArrayLike;
	function fromPromise(promise) {
		return new Observable_1$22.Observable(function(subscriber) {
			promise.then(function(value) {
				if (!subscriber.closed) {
					subscriber.next(value);
					subscriber.complete();
				}
			}, function(err) {
				return subscriber.error(err);
			}).then(null, reportUnhandledError_1.reportUnhandledError);
		});
	}
	exports.fromPromise = fromPromise;
	function fromIterable(iterable) {
		return new Observable_1$22.Observable(function(subscriber) {
			var e_1, _a;
			try {
				for (var iterable_1 = __values$7(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
					var value = iterable_1_1.value;
					subscriber.next(value);
					if (subscriber.closed) return;
				}
			} catch (e_1_1) {
				e_1 = { error: e_1_1 };
			} finally {
				try {
					if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
				} finally {
					if (e_1) throw e_1.error;
				}
			}
			subscriber.complete();
		});
	}
	exports.fromIterable = fromIterable;
	function fromAsyncIterable(asyncIterable) {
		return new Observable_1$22.Observable(function(subscriber) {
			process$1(asyncIterable, subscriber).catch(function(err) {
				return subscriber.error(err);
			});
		});
	}
	exports.fromAsyncIterable = fromAsyncIterable;
	function fromReadableStreamLike(readableStream) {
		return fromAsyncIterable(isReadableStreamLike_1$2.readableStreamLikeToAsyncGenerator(readableStream));
	}
	exports.fromReadableStreamLike = fromReadableStreamLike;
	function process$1(asyncIterable, subscriber) {
		var asyncIterable_1, asyncIterable_1_1;
		var e_2, _a;
		return __awaiter(this, void 0, void 0, function() {
			var value, e_2_1;
			return __generator$1(this, function(_b) {
				switch (_b.label) {
					case 0:
						_b.trys.push([
							0,
							5,
							6,
							11
						]);
						asyncIterable_1 = __asyncValues$1(asyncIterable);
						_b.label = 1;
					case 1: return [4, asyncIterable_1.next()];
					case 2:
						if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
						value = asyncIterable_1_1.value;
						subscriber.next(value);
						if (subscriber.closed) return [2];
						_b.label = 3;
					case 3: return [3, 1];
					case 4: return [3, 11];
					case 5:
						e_2_1 = _b.sent();
						e_2 = { error: e_2_1 };
						return [3, 11];
					case 6:
						_b.trys.push([
							6,
							,
							9,
							10
						]);
						if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
						return [4, _a.call(asyncIterable_1)];
					case 7:
						_b.sent();
						_b.label = 8;
					case 8: return [3, 10];
					case 9:
						if (e_2) throw e_2.error;
						return [7];
					case 10: return [7];
					case 11:
						subscriber.complete();
						return [2];
				}
			});
		});
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function executeSchedule(parentSubscription, scheduler, work, delay$1, repeat$1) {
		if (delay$1 === void 0) delay$1 = 0;
		if (repeat$1 === void 0) repeat$1 = false;
		var scheduleSubscription = scheduler.schedule(function() {
			work();
			if (repeat$1) parentSubscription.add(this.schedule(null, delay$1));
			else this.unsubscribe();
		}, delay$1);
		parentSubscription.add(scheduleSubscription);
		if (!repeat$1) return scheduleSubscription;
	}
	exports.executeSchedule = executeSchedule;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/observeOn.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var executeSchedule_1$7 = require_executeSchedule();
	var lift_1$67 = require_lift();
	var OperatorSubscriber_1$56 = require_OperatorSubscriber();
	function observeOn(scheduler, delay$1) {
		if (delay$1 === void 0) delay$1 = 0;
		return lift_1$67.operate(function(source, subscriber) {
			source.subscribe(OperatorSubscriber_1$56.createOperatorSubscriber(subscriber, function(value) {
				return executeSchedule_1$7.executeSchedule(subscriber, scheduler, function() {
					return subscriber.next(value);
				}, delay$1);
			}, function() {
				return executeSchedule_1$7.executeSchedule(subscriber, scheduler, function() {
					return subscriber.complete();
				}, delay$1);
			}, function(err) {
				return executeSchedule_1$7.executeSchedule(subscriber, scheduler, function() {
					return subscriber.error(err);
				}, delay$1);
			}));
		});
	}
	exports.observeOn = observeOn;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$66 = require_lift();
	function subscribeOn(scheduler, delay$1) {
		if (delay$1 === void 0) delay$1 = 0;
		return lift_1$66.operate(function(source, subscriber) {
			subscriber.add(scheduler.schedule(function() {
				return source.subscribe(subscriber);
			}, delay$1));
		});
	}
	exports.subscribeOn = subscribeOn;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var innerFrom_1$40 = require_innerFrom();
	var observeOn_1$4 = require_observeOn();
	var subscribeOn_1$4 = require_subscribeOn();
	function scheduleObservable(input, scheduler) {
		return innerFrom_1$40.innerFrom(input).pipe(subscribeOn_1$4.subscribeOn(scheduler), observeOn_1$4.observeOn(scheduler));
	}
	exports.scheduleObservable = scheduleObservable;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var innerFrom_1$39 = require_innerFrom();
	var observeOn_1$3 = require_observeOn();
	var subscribeOn_1$3 = require_subscribeOn();
	function schedulePromise(input, scheduler) {
		return innerFrom_1$39.innerFrom(input).pipe(subscribeOn_1$3.subscribeOn(scheduler), observeOn_1$3.observeOn(scheduler));
	}
	exports.schedulePromise = schedulePromise;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$21 = require_Observable();
	function scheduleArray(input, scheduler) {
		return new Observable_1$21.Observable(function(subscriber) {
			var i = 0;
			return scheduler.schedule(function() {
				if (i === input.length) subscriber.complete();
				else {
					subscriber.next(input[i++]);
					if (!subscriber.closed) this.schedule();
				}
			});
		});
	}
	exports.scheduleArray = scheduleArray;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$20 = require_Observable();
	var iterator_1 = require_iterator();
	var isFunction_1$15 = require_isFunction();
	var executeSchedule_1$6 = require_executeSchedule();
	function scheduleIterable(input, scheduler) {
		return new Observable_1$20.Observable(function(subscriber) {
			var iterator;
			executeSchedule_1$6.executeSchedule(subscriber, scheduler, function() {
				iterator = input[iterator_1.iterator]();
				executeSchedule_1$6.executeSchedule(subscriber, scheduler, function() {
					var _a;
					var value;
					var done;
					try {
						_a = iterator.next(), value = _a.value, done = _a.done;
					} catch (err) {
						subscriber.error(err);
						return;
					}
					if (done) subscriber.complete();
					else subscriber.next(value);
				}, 0, true);
			});
			return function() {
				return isFunction_1$15.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
			};
		});
	}
	exports.scheduleIterable = scheduleIterable;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$19 = require_Observable();
	var executeSchedule_1$5 = require_executeSchedule();
	function scheduleAsyncIterable(input, scheduler) {
		if (!input) throw new Error("Iterable cannot be null");
		return new Observable_1$19.Observable(function(subscriber) {
			executeSchedule_1$5.executeSchedule(subscriber, scheduler, function() {
				var iterator = input[Symbol.asyncIterator]();
				executeSchedule_1$5.executeSchedule(subscriber, scheduler, function() {
					iterator.next().then(function(result) {
						if (result.done) subscriber.complete();
						else subscriber.next(result.value);
					});
				}, 0, true);
			});
		});
	}
	exports.scheduleAsyncIterable = scheduleAsyncIterable;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var scheduleAsyncIterable_1$1 = require_scheduleAsyncIterable();
	var isReadableStreamLike_1$1 = require_isReadableStreamLike();
	function scheduleReadableStreamLike(input, scheduler) {
		return scheduleAsyncIterable_1$1.scheduleAsyncIterable(isReadableStreamLike_1$1.readableStreamLikeToAsyncGenerator(input), scheduler);
	}
	exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var scheduleObservable_1 = require_scheduleObservable();
	var schedulePromise_1 = require_schedulePromise();
	var scheduleArray_1 = require_scheduleArray();
	var scheduleIterable_1$1 = require_scheduleIterable();
	var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
	var isInteropObservable_1 = require_isInteropObservable();
	var isPromise_1 = require_isPromise();
	var isArrayLike_1$1 = require_isArrayLike();
	var isIterable_1 = require_isIterable();
	var isAsyncIterable_1 = require_isAsyncIterable();
	var throwUnobservableError_1 = require_throwUnobservableError();
	var isReadableStreamLike_1 = require_isReadableStreamLike();
	var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
	function scheduled(input, scheduler) {
		if (input != null) {
			if (isInteropObservable_1.isInteropObservable(input)) return scheduleObservable_1.scheduleObservable(input, scheduler);
			if (isArrayLike_1$1.isArrayLike(input)) return scheduleArray_1.scheduleArray(input, scheduler);
			if (isPromise_1.isPromise(input)) return schedulePromise_1.schedulePromise(input, scheduler);
			if (isAsyncIterable_1.isAsyncIterable(input)) return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
			if (isIterable_1.isIterable(input)) return scheduleIterable_1$1.scheduleIterable(input, scheduler);
			if (isReadableStreamLike_1.isReadableStreamLike(input)) return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
		}
		throw throwUnobservableError_1.createInvalidObservableTypeError(input);
	}
	exports.scheduled = scheduled;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/from.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var scheduled_1$1 = require_scheduled();
	var innerFrom_1$38 = require_innerFrom();
	function from(input, scheduler) {
		return scheduler ? scheduled_1$1.scheduled(input, scheduler) : innerFrom_1$38.innerFrom(input);
	}
	exports.from = from;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/of.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var args_1$12 = require_args();
	var from_1$7 = require_from();
	function of() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var scheduler = args_1$12.popScheduler(args);
		return from_1$7.from(args, scheduler);
	}
	exports.of = of;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/throwError.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$18 = require_Observable();
	var isFunction_1$14 = require_isFunction();
	function throwError(errorOrErrorFactory, scheduler) {
		var errorFactory = isFunction_1$14.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
			return errorOrErrorFactory;
		};
		var init = function(subscriber) {
			return subscriber.error(errorFactory());
		};
		return new Observable_1$18.Observable(scheduler ? function(subscriber) {
			return scheduler.schedule(init, 0, subscriber);
		} : init);
	}
	exports.throwError = throwError;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/Notification.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
	var empty_1$8 = require_empty();
	var of_1$2 = require_of();
	var throwError_1$1 = require_throwError();
	var isFunction_1$13 = require_isFunction();
	(function(NotificationKind) {
		NotificationKind["NEXT"] = "N";
		NotificationKind["ERROR"] = "E";
		NotificationKind["COMPLETE"] = "C";
	})(exports.NotificationKind || (exports.NotificationKind = {}));
	var Notification = function() {
		function Notification$1(kind, value, error) {
			this.kind = kind;
			this.value = value;
			this.error = error;
			this.hasValue = kind === "N";
		}
		Notification$1.prototype.observe = function(observer) {
			return observeNotification(this, observer);
		};
		Notification$1.prototype.do = function(nextHandler, errorHandler, completeHandler) {
			var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
			return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
		};
		Notification$1.prototype.accept = function(nextOrObserver, error, complete) {
			var _a;
			return isFunction_1$13.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
		};
		Notification$1.prototype.toObservable = function() {
			var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
			var result = kind === "N" ? of_1$2.of(value) : kind === "E" ? throwError_1$1.throwError(function() {
				return error;
			}) : kind === "C" ? empty_1$8.EMPTY : 0;
			if (!result) throw new TypeError("Unexpected notification kind " + kind);
			return result;
		};
		Notification$1.createNext = function(value) {
			return new Notification$1("N", value);
		};
		Notification$1.createError = function(err) {
			return new Notification$1("E", void 0, err);
		};
		Notification$1.createComplete = function() {
			return Notification$1.completeNotification;
		};
		Notification$1.completeNotification = new Notification$1("C");
		return Notification$1;
	}();
	exports.Notification = Notification;
	function observeNotification(notification, observer) {
		var _a, _b, _c;
		var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
		if (typeof kind !== "string") throw new TypeError("Invalid notification, missing \"kind\"");
		kind === "N" ? (_a = observer.next) === null || _a === void 0 || _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 || _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 || _c.call(observer);
	}
	exports.observeNotification = observeNotification;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/isObservable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$17 = require_Observable();
	var isFunction_1$12 = require_isFunction();
	function isObservable(obj) {
		return !!obj && (obj instanceof Observable_1$17.Observable || isFunction_1$12.isFunction(obj.lift) && isFunction_1$12.isFunction(obj.subscribe));
	}
	exports.isObservable = isObservable;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/EmptyError.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var createErrorClass_1$4 = require_createErrorClass();
	exports.EmptyError = createErrorClass_1$4.createErrorClass(function(_super) {
		return function EmptyErrorImpl() {
			_super(this);
			this.name = "EmptyError";
			this.message = "no elements in sequence";
		};
	});
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/lastValueFrom.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var EmptyError_1$6 = require_EmptyError();
	function lastValueFrom(source, config) {
		var hasConfig = typeof config === "object";
		return new Promise(function(resolve, reject) {
			var _hasValue = false;
			var _value;
			source.subscribe({
				next: function(value) {
					_value = value;
					_hasValue = true;
				},
				error: reject,
				complete: function() {
					if (_hasValue) resolve(_value);
					else if (hasConfig) resolve(config.defaultValue);
					else reject(new EmptyError_1$6.EmptyError());
				}
			});
		});
	}
	exports.lastValueFrom = lastValueFrom;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/firstValueFrom.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var EmptyError_1$5 = require_EmptyError();
	var Subscriber_1$2 = require_Subscriber();
	function firstValueFrom(source, config) {
		var hasConfig = typeof config === "object";
		return new Promise(function(resolve, reject) {
			var subscriber = new Subscriber_1$2.SafeSubscriber({
				next: function(value) {
					resolve(value);
					subscriber.unsubscribe();
				},
				error: reject,
				complete: function() {
					if (hasConfig) resolve(config.defaultValue);
					else reject(new EmptyError_1$5.EmptyError());
				}
			});
			source.subscribe(subscriber);
		});
	}
	exports.firstValueFrom = firstValueFrom;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var createErrorClass_1$3 = require_createErrorClass();
	exports.ArgumentOutOfRangeError = createErrorClass_1$3.createErrorClass(function(_super) {
		return function ArgumentOutOfRangeErrorImpl() {
			_super(this);
			this.name = "ArgumentOutOfRangeError";
			this.message = "argument out of range";
		};
	});
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var createErrorClass_1$2 = require_createErrorClass();
	exports.NotFoundError = createErrorClass_1$2.createErrorClass(function(_super) {
		return function NotFoundErrorImpl(message) {
			_super(this);
			this.name = "NotFoundError";
			this.message = message;
		};
	});
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/SequenceError.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var createErrorClass_1$1 = require_createErrorClass();
	exports.SequenceError = createErrorClass_1$1.createErrorClass(function(_super) {
		return function SequenceErrorImpl(message) {
			_super(this);
			this.name = "SequenceError";
			this.message = message;
		};
	});
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/isDate.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function isValidDate(value) {
		return value instanceof Date && !isNaN(value);
	}
	exports.isValidDate = isValidDate;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/timeout.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.timeout = exports.TimeoutError = void 0;
	var async_1$14 = require_async$1();
	var isDate_1$2 = require_isDate();
	var lift_1$65 = require_lift();
	var innerFrom_1$37 = require_innerFrom();
	var createErrorClass_1 = require_createErrorClass();
	var OperatorSubscriber_1$55 = require_OperatorSubscriber();
	var executeSchedule_1$4 = require_executeSchedule();
	exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
		return function TimeoutErrorImpl(info$1) {
			if (info$1 === void 0) info$1 = null;
			_super(this);
			this.message = "Timeout has occurred";
			this.name = "TimeoutError";
			this.info = info$1;
		};
	});
	function timeout(config, schedulerArg) {
		var _a = isDate_1$2.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first$1 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1$14.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
		if (first$1 == null && each == null) throw new TypeError("No timeout provided.");
		return lift_1$65.operate(function(source, subscriber) {
			var originalSourceSubscription;
			var timerSubscription;
			var lastValue = null;
			var seen = 0;
			var startTimer = function(delay$1) {
				timerSubscription = executeSchedule_1$4.executeSchedule(subscriber, scheduler, function() {
					try {
						originalSourceSubscription.unsubscribe();
						innerFrom_1$37.innerFrom(_with({
							meta,
							lastValue,
							seen
						})).subscribe(subscriber);
					} catch (err) {
						subscriber.error(err);
					}
				}, delay$1);
			};
			originalSourceSubscription = source.subscribe(OperatorSubscriber_1$55.createOperatorSubscriber(subscriber, function(value) {
				timerSubscription === null || timerSubscription === void 0 || timerSubscription.unsubscribe();
				seen++;
				subscriber.next(lastValue = value);
				each > 0 && startTimer(each);
			}, void 0, void 0, function() {
				if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) timerSubscription === null || timerSubscription === void 0 || timerSubscription.unsubscribe();
				lastValue = null;
			}));
			!seen && startTimer(first$1 != null ? typeof first$1 === "number" ? first$1 : +first$1 - scheduler.now() : each);
		});
	}
	exports.timeout = timeout;
	function timeoutErrorFactory(info$1) {
		throw new exports.TimeoutError(info$1);
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/map.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$64 = require_lift();
	var OperatorSubscriber_1$54 = require_OperatorSubscriber();
	function map(project, thisArg) {
		return lift_1$64.operate(function(source, subscriber) {
			var index = 0;
			source.subscribe(OperatorSubscriber_1$54.createOperatorSubscriber(subscriber, function(value) {
				subscriber.next(project.call(thisArg, value, index++));
			}));
		});
	}
	exports.map = map;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js": ((exports) => {
	var __read$17 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$16 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var map_1$9 = require_map();
	var isArray$2 = Array.isArray;
	function callOrApply(fn, args) {
		return isArray$2(args) ? fn.apply(void 0, __spreadArray$16([], __read$17(args))) : fn(args);
	}
	function mapOneOrManyArgs(fn) {
		return map_1$9.map(function(args) {
			return callOrApply(fn, args);
		});
	}
	exports.mapOneOrManyArgs = mapOneOrManyArgs;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js": ((exports) => {
	var __read$16 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$15 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var isScheduler_1$2 = require_isScheduler();
	var Observable_1$16 = require_Observable();
	var subscribeOn_1$2 = require_subscribeOn();
	var mapOneOrManyArgs_1$6 = require_mapOneOrManyArgs();
	var observeOn_1$2 = require_observeOn();
	var AsyncSubject_1$2 = require_AsyncSubject();
	function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
		if (resultSelector) if (isScheduler_1$2.isScheduler(resultSelector)) scheduler = resultSelector;
		else return function() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1$6.mapOneOrManyArgs(resultSelector));
		};
		if (scheduler) return function() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1$2.subscribeOn(scheduler), observeOn_1$2.observeOn(scheduler));
		};
		return function() {
			var _this = this;
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var subject = new AsyncSubject_1$2.AsyncSubject();
			var uninitialized = true;
			return new Observable_1$16.Observable(function(subscriber) {
				var subs = subject.subscribe(subscriber);
				if (uninitialized) {
					uninitialized = false;
					var isAsync_1 = false;
					var isComplete_1 = false;
					callbackFunc.apply(_this, __spreadArray$15(__spreadArray$15([], __read$16(args)), [function() {
						var results = [];
						for (var _i$1 = 0; _i$1 < arguments.length; _i$1++) results[_i$1] = arguments[_i$1];
						if (isNodeStyle) {
							var err = results.shift();
							if (err != null) {
								subject.error(err);
								return;
							}
						}
						subject.next(1 < results.length ? results : results[0]);
						isComplete_1 = true;
						if (isAsync_1) subject.complete();
					}]));
					if (isComplete_1) subject.complete();
					isAsync_1 = true;
				}
				return subs;
			});
		};
	}
	exports.bindCallbackInternals = bindCallbackInternals;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var bindCallbackInternals_1$1 = require_bindCallbackInternals();
	function bindCallback(callbackFunc, resultSelector, scheduler) {
		return bindCallbackInternals_1$1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
	}
	exports.bindCallback = bindCallback;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var bindCallbackInternals_1 = require_bindCallbackInternals();
	function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
		return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
	}
	exports.bindNodeCallback = bindNodeCallback;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var isArray$1 = Array.isArray;
	var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
	function argsArgArrayOrObject(args) {
		if (args.length === 1) {
			var first_1$2 = args[0];
			if (isArray$1(first_1$2)) return {
				args: first_1$2,
				keys: null
			};
			if (isPOJO(first_1$2)) {
				var keys = getKeys(first_1$2);
				return {
					args: keys.map(function(key) {
						return first_1$2[key];
					}),
					keys
				};
			}
		}
		return {
			args,
			keys: null
		};
	}
	exports.argsArgArrayOrObject = argsArgArrayOrObject;
	function isPOJO(obj) {
		return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/createObject.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function createObject(keys, values) {
		return keys.reduce(function(result, key, i) {
			return result[key] = values[i], result;
		}, {});
	}
	exports.createObject = createObject;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest$1 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$15 = require_Observable();
	var argsArgArrayOrObject_1$1 = require_argsArgArrayOrObject();
	var from_1$6 = require_from();
	var identity_1$14 = require_identity();
	var mapOneOrManyArgs_1$5 = require_mapOneOrManyArgs();
	var args_1$11 = require_args();
	var createObject_1$1 = require_createObject();
	var OperatorSubscriber_1$53 = require_OperatorSubscriber();
	var executeSchedule_1$3 = require_executeSchedule();
	function combineLatest$1() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var scheduler = args_1$11.popScheduler(args);
		var resultSelector = args_1$11.popResultSelector(args);
		var _a = argsArgArrayOrObject_1$1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
		if (observables.length === 0) return from_1$6.from([], scheduler);
		var result = new Observable_1$15.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
			return createObject_1$1.createObject(keys, values);
		} : identity_1$14.identity));
		return resultSelector ? result.pipe(mapOneOrManyArgs_1$5.mapOneOrManyArgs(resultSelector)) : result;
	}
	exports.combineLatest = combineLatest$1;
	function combineLatestInit(observables, scheduler, valueTransform) {
		if (valueTransform === void 0) valueTransform = identity_1$14.identity;
		return function(subscriber) {
			maybeSchedule(scheduler, function() {
				var length = observables.length;
				var values = new Array(length);
				var active = length;
				var remainingFirstValues = length;
				var _loop_1 = function(i$1) {
					maybeSchedule(scheduler, function() {
						var source = from_1$6.from(observables[i$1], scheduler);
						var hasFirstValue = false;
						source.subscribe(OperatorSubscriber_1$53.createOperatorSubscriber(subscriber, function(value) {
							values[i$1] = value;
							if (!hasFirstValue) {
								hasFirstValue = true;
								remainingFirstValues--;
							}
							if (!remainingFirstValues) subscriber.next(valueTransform(values.slice()));
						}, function() {
							if (!--active) subscriber.complete();
						}));
					}, subscriber);
				};
				for (var i = 0; i < length; i++) _loop_1(i);
			}, subscriber);
		};
	}
	exports.combineLatestInit = combineLatestInit;
	function maybeSchedule(scheduler, execute, subscription) {
		if (scheduler) executeSchedule_1$3.executeSchedule(subscription, scheduler, execute);
		else execute();
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var innerFrom_1$36 = require_innerFrom();
	var executeSchedule_1$2 = require_executeSchedule();
	var OperatorSubscriber_1$52 = require_OperatorSubscriber();
	function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand$1, innerSubScheduler, additionalFinalizer) {
		var buffer$1 = [];
		var active = 0;
		var index = 0;
		var isComplete = false;
		var checkComplete = function() {
			if (isComplete && !buffer$1.length && !active) subscriber.complete();
		};
		var outerNext = function(value) {
			return active < concurrent ? doInnerSub(value) : buffer$1.push(value);
		};
		var doInnerSub = function(value) {
			expand$1 && subscriber.next(value);
			active++;
			var innerComplete = false;
			innerFrom_1$36.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1$52.createOperatorSubscriber(subscriber, function(innerValue) {
				onBeforeNext === null || onBeforeNext === void 0 || onBeforeNext(innerValue);
				if (expand$1) outerNext(innerValue);
				else subscriber.next(innerValue);
			}, function() {
				innerComplete = true;
			}, void 0, function() {
				if (innerComplete) try {
					active--;
					var _loop_1 = function() {
						var bufferedValue = buffer$1.shift();
						if (innerSubScheduler) executeSchedule_1$2.executeSchedule(subscriber, innerSubScheduler, function() {
							return doInnerSub(bufferedValue);
						});
						else doInnerSub(bufferedValue);
					};
					while (buffer$1.length && active < concurrent) _loop_1();
					checkComplete();
				} catch (err) {
					subscriber.error(err);
				}
			}));
		};
		source.subscribe(OperatorSubscriber_1$52.createOperatorSubscriber(subscriber, outerNext, function() {
			isComplete = true;
			checkComplete();
		}));
		return function() {
			additionalFinalizer === null || additionalFinalizer === void 0 || additionalFinalizer();
		};
	}
	exports.mergeInternals = mergeInternals;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var map_1$8 = require_map();
	var innerFrom_1$35 = require_innerFrom();
	var lift_1$63 = require_lift();
	var mergeInternals_1$2 = require_mergeInternals();
	var isFunction_1$11 = require_isFunction();
	function mergeMap(project, resultSelector, concurrent) {
		if (concurrent === void 0) concurrent = Infinity;
		if (isFunction_1$11.isFunction(resultSelector)) return mergeMap(function(a$1, i) {
			return map_1$8.map(function(b$2, ii) {
				return resultSelector(a$1, b$2, i, ii);
			})(innerFrom_1$35.innerFrom(project(a$1, i)));
		}, concurrent);
		else if (typeof resultSelector === "number") concurrent = resultSelector;
		return lift_1$63.operate(function(source, subscriber) {
			return mergeInternals_1$2.mergeInternals(source, subscriber, project, concurrent);
		});
	}
	exports.mergeMap = mergeMap;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var mergeMap_1$8 = require_mergeMap();
	var identity_1$13 = require_identity();
	function mergeAll(concurrent) {
		if (concurrent === void 0) concurrent = Infinity;
		return mergeMap_1$8.mergeMap(identity_1$13.identity, concurrent);
	}
	exports.mergeAll = mergeAll;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/concatAll.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var mergeAll_1$4 = require_mergeAll();
	function concatAll() {
		return mergeAll_1$4.mergeAll(1);
	}
	exports.concatAll = concatAll;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat$1 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/concat.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var concatAll_1$3 = require_concatAll();
	var args_1$10 = require_args();
	var from_1$5 = require_from();
	function concat$1() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		return concatAll_1$3.concatAll()(from_1$5.from(args, args_1$10.popScheduler(args)));
	}
	exports.concat = concat$1;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/defer.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$14 = require_Observable();
	var innerFrom_1$34 = require_innerFrom();
	function defer(observableFactory) {
		return new Observable_1$14.Observable(function(subscriber) {
			innerFrom_1$34.innerFrom(observableFactory()).subscribe(subscriber);
		});
	}
	exports.defer = defer;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/connectable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subject_1$12 = require_Subject();
	var Observable_1$13 = require_Observable();
	var defer_1$3 = require_defer();
	var DEFAULT_CONFIG$1 = {
		connector: function() {
			return new Subject_1$12.Subject();
		},
		resetOnDisconnect: true
	};
	function connectable(source, config) {
		if (config === void 0) config = DEFAULT_CONFIG$1;
		var connection = null;
		var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
		var subject = connector();
		var result = new Observable_1$13.Observable(function(subscriber) {
			return subject.subscribe(subscriber);
		});
		result.connect = function() {
			if (!connection || connection.closed) {
				connection = defer_1$3.defer(function() {
					return source;
				}).subscribe(subject);
				if (resetOnDisconnect) connection.add(function() {
					return subject = connector();
				});
			}
			return connection;
		};
		return result;
	}
	exports.connectable = connectable;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$12 = require_Observable();
	var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
	var innerFrom_1$33 = require_innerFrom();
	var args_1$9 = require_args();
	var OperatorSubscriber_1$51 = require_OperatorSubscriber();
	var mapOneOrManyArgs_1$4 = require_mapOneOrManyArgs();
	var createObject_1 = require_createObject();
	function forkJoin() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var resultSelector = args_1$9.popResultSelector(args);
		var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
		var result = new Observable_1$12.Observable(function(subscriber) {
			var length = sources.length;
			if (!length) {
				subscriber.complete();
				return;
			}
			var values = new Array(length);
			var remainingCompletions = length;
			var remainingEmissions = length;
			var _loop_1 = function(sourceIndex$1) {
				var hasValue = false;
				innerFrom_1$33.innerFrom(sources[sourceIndex$1]).subscribe(OperatorSubscriber_1$51.createOperatorSubscriber(subscriber, function(value) {
					if (!hasValue) {
						hasValue = true;
						remainingEmissions--;
					}
					values[sourceIndex$1] = value;
				}, function() {
					return remainingCompletions--;
				}, void 0, function() {
					if (!remainingCompletions || !hasValue) {
						if (!remainingEmissions) subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
						subscriber.complete();
					}
				}));
			};
			for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) _loop_1(sourceIndex);
		});
		return resultSelector ? result.pipe(mapOneOrManyArgs_1$4.mapOneOrManyArgs(resultSelector)) : result;
	}
	exports.forkJoin = forkJoin;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js": ((exports) => {
	var __read$15 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var innerFrom_1$32 = require_innerFrom();
	var Observable_1$11 = require_Observable();
	var mergeMap_1$7 = require_mergeMap();
	var isArrayLike_1 = require_isArrayLike();
	var isFunction_1$10 = require_isFunction();
	var mapOneOrManyArgs_1$3 = require_mapOneOrManyArgs();
	var nodeEventEmitterMethods = ["addListener", "removeListener"];
	var eventTargetMethods = ["addEventListener", "removeEventListener"];
	var jqueryMethods = ["on", "off"];
	function fromEvent(target, eventName, options, resultSelector) {
		if (isFunction_1$10.isFunction(options)) {
			resultSelector = options;
			options = void 0;
		}
		if (resultSelector) return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1$3.mapOneOrManyArgs(resultSelector));
		var _a = __read$15(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
			return function(handler) {
				return target[methodName](eventName, handler, options);
			};
		}) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove$1 = _a[1];
		if (!add) {
			if (isArrayLike_1.isArrayLike(target)) return mergeMap_1$7.mergeMap(function(subTarget) {
				return fromEvent(subTarget, eventName, options);
			})(innerFrom_1$32.innerFrom(target));
		}
		if (!add) throw new TypeError("Invalid event target");
		return new Observable_1$11.Observable(function(subscriber) {
			var handler = function() {
				var args = [];
				for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
				return subscriber.next(1 < args.length ? args : args[0]);
			};
			add(handler);
			return function() {
				return remove$1(handler);
			};
		});
	}
	exports.fromEvent = fromEvent;
	function toCommonHandlerRegistry(target, eventName) {
		return function(methodName) {
			return function(handler) {
				return target[methodName](eventName, handler);
			};
		};
	}
	function isNodeStyleEventEmitter(target) {
		return isFunction_1$10.isFunction(target.addListener) && isFunction_1$10.isFunction(target.removeListener);
	}
	function isJQueryStyleEventEmitter(target) {
		return isFunction_1$10.isFunction(target.on) && isFunction_1$10.isFunction(target.off);
	}
	function isEventTarget(target) {
		return isFunction_1$10.isFunction(target.addEventListener) && isFunction_1$10.isFunction(target.removeEventListener);
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$10 = require_Observable();
	var isFunction_1$9 = require_isFunction();
	var mapOneOrManyArgs_1$2 = require_mapOneOrManyArgs();
	function fromEventPattern(addHandler, removeHandler, resultSelector) {
		if (resultSelector) return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1$2.mapOneOrManyArgs(resultSelector));
		return new Observable_1$10.Observable(function(subscriber) {
			var handler = function() {
				var e = [];
				for (var _i = 0; _i < arguments.length; _i++) e[_i] = arguments[_i];
				return subscriber.next(e.length === 1 ? e[0] : e);
			};
			var retValue = addHandler(handler);
			return isFunction_1$9.isFunction(removeHandler) ? function() {
				return removeHandler(handler, retValue);
			} : void 0;
		});
	}
	exports.fromEventPattern = fromEventPattern;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/generate.js": ((exports) => {
	var __generator = exports && exports.__generator || function(thisArg, body) {
		var _ = {
			label: 0,
			sent: function() {
				if (t[0] & 1) throw t[1];
				return t[1];
			},
			trys: [],
			ops: []
		}, f, y, t, g$1;
		return g$1 = {
			next: verb(0),
			"throw": verb(1),
			"return": verb(2)
		}, typeof Symbol === "function" && (g$1[Symbol.iterator] = function() {
			return this;
		}), g$1;
		function verb(n$2) {
			return function(v) {
				return step([n$2, v]);
			};
		}
		function step(op) {
			if (f) throw new TypeError("Generator is already executing.");
			while (_) try {
				if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
				if (y = 0, t) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0:
					case 1:
						t = op;
						break;
					case 4:
						_.label++;
						return {
							value: op[1],
							done: false
						};
					case 5:
						_.label++;
						y = op[1];
						op = [0];
						continue;
					case 7:
						op = _.ops.pop();
						_.trys.pop();
						continue;
					default:
						if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
							_ = 0;
							continue;
						}
						if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
							_.label = op[1];
							break;
						}
						if (op[0] === 6 && _.label < t[1]) {
							_.label = t[1];
							t = op;
							break;
						}
						if (t && _.label < t[2]) {
							_.label = t[2];
							_.ops.push(op);
							break;
						}
						if (t[2]) _.ops.pop();
						_.trys.pop();
						continue;
				}
				op = body.call(thisArg, _);
			} catch (e) {
				op = [6, e];
				y = 0;
			} finally {
				f = t = 0;
			}
			if (op[0] & 5) throw op[1];
			return {
				value: op[0] ? op[1] : void 0,
				done: true
			};
		}
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var identity_1$12 = require_identity();
	var isScheduler_1$1 = require_isScheduler();
	var defer_1$2 = require_defer();
	var scheduleIterable_1 = require_scheduleIterable();
	function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
		var _a, _b;
		var resultSelector;
		var initialState;
		if (arguments.length === 1) _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1$12.identity : _b, scheduler = _a.scheduler;
		else {
			initialState = initialStateOrOptions;
			if (!resultSelectorOrScheduler || isScheduler_1$1.isScheduler(resultSelectorOrScheduler)) {
				resultSelector = identity_1$12.identity;
				scheduler = resultSelectorOrScheduler;
			} else resultSelector = resultSelectorOrScheduler;
		}
		function gen() {
			var state;
			return __generator(this, function(_a$1) {
				switch (_a$1.label) {
					case 0:
						state = initialState;
						_a$1.label = 1;
					case 1:
						if (!(!condition || condition(state))) return [3, 4];
						return [4, resultSelector(state)];
					case 2:
						_a$1.sent();
						_a$1.label = 3;
					case 3:
						state = iterate(state);
						return [3, 1];
					case 4: return [2];
				}
			});
		}
		return defer_1$2.defer(scheduler ? function() {
			return scheduleIterable_1.scheduleIterable(gen(), scheduler);
		} : gen);
	}
	exports.generate = generate;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/iif.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var defer_1$1 = require_defer();
	function iif(condition, trueResult, falseResult) {
		return defer_1$1.defer(function() {
			return condition() ? trueResult : falseResult;
		});
	}
	exports.iif = iif;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/timer.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$9 = require_Observable();
	var async_1$13 = require_async$1();
	var isScheduler_1 = require_isScheduler();
	var isDate_1$1 = require_isDate();
	function timer(dueTime, intervalOrScheduler, scheduler) {
		if (dueTime === void 0) dueTime = 0;
		if (scheduler === void 0) scheduler = async_1$13.async;
		var intervalDuration = -1;
		if (intervalOrScheduler != null) if (isScheduler_1.isScheduler(intervalOrScheduler)) scheduler = intervalOrScheduler;
		else intervalDuration = intervalOrScheduler;
		return new Observable_1$9.Observable(function(subscriber) {
			var due = isDate_1$1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
			if (due < 0) due = 0;
			var n$2 = 0;
			return scheduler.schedule(function() {
				if (!subscriber.closed) {
					subscriber.next(n$2++);
					if (0 <= intervalDuration) this.schedule(void 0, intervalDuration);
					else subscriber.complete();
				}
			}, due);
		});
	}
	exports.timer = timer;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/interval.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var async_1$12 = require_async$1();
	var timer_1$6 = require_timer();
	function interval(period, scheduler) {
		if (period === void 0) period = 0;
		if (scheduler === void 0) scheduler = async_1$12.asyncScheduler;
		if (period < 0) period = 0;
		return timer_1$6.timer(period, period, scheduler);
	}
	exports.interval = interval;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge$2 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/merge.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var mergeAll_1$3 = require_mergeAll();
	var innerFrom_1$31 = require_innerFrom();
	var empty_1$7 = require_empty();
	var args_1$8 = require_args();
	var from_1$4 = require_from();
	function merge$2() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var scheduler = args_1$8.popScheduler(args);
		var concurrent = args_1$8.popNumber(args, Infinity);
		var sources = args;
		return !sources.length ? empty_1$7.EMPTY : sources.length === 1 ? innerFrom_1$31.innerFrom(sources[0]) : mergeAll_1$3.mergeAll(concurrent)(from_1$4.from(sources, scheduler));
	}
	exports.merge = merge$2;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/never.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.never = exports.NEVER = void 0;
	var Observable_1$8 = require_Observable();
	var noop_1$14 = require_noop();
	exports.NEVER = new Observable_1$8.Observable(noop_1$14.noop);
	function never() {
		return exports.NEVER;
	}
	exports.never = never;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var isArray = Array.isArray;
	function argsOrArgArray(args) {
		return args.length === 1 && isArray(args[0]) ? args[0] : args;
	}
	exports.argsOrArgArray = argsOrArgArray;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$7 = require_Observable();
	var argsOrArgArray_1$5 = require_argsOrArgArray();
	var OperatorSubscriber_1$50 = require_OperatorSubscriber();
	var noop_1$13 = require_noop();
	var innerFrom_1$30 = require_innerFrom();
	function onErrorResumeNext() {
		var sources = [];
		for (var _i = 0; _i < arguments.length; _i++) sources[_i] = arguments[_i];
		var nextSources = argsOrArgArray_1$5.argsOrArgArray(sources);
		return new Observable_1$7.Observable(function(subscriber) {
			var sourceIndex = 0;
			var subscribeNext = function() {
				if (sourceIndex < nextSources.length) {
					var nextSource = void 0;
					try {
						nextSource = innerFrom_1$30.innerFrom(nextSources[sourceIndex++]);
					} catch (err) {
						subscribeNext();
						return;
					}
					var innerSubscriber = new OperatorSubscriber_1$50.OperatorSubscriber(subscriber, void 0, noop_1$13.noop, noop_1$13.noop);
					nextSource.subscribe(innerSubscriber);
					innerSubscriber.add(subscribeNext);
				} else subscriber.complete();
			};
			subscribeNext();
		});
	}
	exports.onErrorResumeNext = onErrorResumeNext;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/pairs.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var from_1$3 = require_from();
	function pairs(obj, scheduler) {
		return from_1$3.from(Object.entries(obj), scheduler);
	}
	exports.pairs = pairs;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/util/not.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function not(pred, thisArg) {
		return function(value, index) {
			return !pred.call(thisArg, value, index);
		};
	}
	exports.not = not;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/filter.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$62 = require_lift();
	var OperatorSubscriber_1$49 = require_OperatorSubscriber();
	function filter(predicate, thisArg) {
		return lift_1$62.operate(function(source, subscriber) {
			var index = 0;
			source.subscribe(OperatorSubscriber_1$49.createOperatorSubscriber(subscriber, function(value) {
				return predicate.call(thisArg, value, index++) && subscriber.next(value);
			}));
		});
	}
	exports.filter = filter;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition$1 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/partition.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var not_1$1 = require_not();
	var filter_1$7 = require_filter();
	var innerFrom_1$29 = require_innerFrom();
	function partition$1(source, predicate, thisArg) {
		return [filter_1$7.filter(predicate, thisArg)(innerFrom_1$29.innerFrom(source)), filter_1$7.filter(not_1$1.not(predicate, thisArg))(innerFrom_1$29.innerFrom(source))];
	}
	exports.partition = partition$1;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race$1 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/race.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$6 = require_Observable();
	var innerFrom_1$28 = require_innerFrom();
	var argsOrArgArray_1$4 = require_argsOrArgArray();
	var OperatorSubscriber_1$48 = require_OperatorSubscriber();
	function race$1() {
		var sources = [];
		for (var _i = 0; _i < arguments.length; _i++) sources[_i] = arguments[_i];
		sources = argsOrArgArray_1$4.argsOrArgArray(sources);
		return sources.length === 1 ? innerFrom_1$28.innerFrom(sources[0]) : new Observable_1$6.Observable(raceInit(sources));
	}
	exports.race = race$1;
	function raceInit(sources) {
		return function(subscriber) {
			var subscriptions = [];
			var _loop_1 = function(i$1) {
				subscriptions.push(innerFrom_1$28.innerFrom(sources[i$1]).subscribe(OperatorSubscriber_1$48.createOperatorSubscriber(subscriber, function(value) {
					if (subscriptions) {
						for (var s = 0; s < subscriptions.length; s++) s !== i$1 && subscriptions[s].unsubscribe();
						subscriptions = null;
					}
					subscriber.next(value);
				})));
			};
			for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) _loop_1(i);
		};
	}
	exports.raceInit = raceInit;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/range.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$5 = require_Observable();
	var empty_1$6 = require_empty();
	function range(start, count$1, scheduler) {
		if (count$1 == null) {
			count$1 = start;
			start = 0;
		}
		if (count$1 <= 0) return empty_1$6.EMPTY;
		var end = count$1 + start;
		return new Observable_1$5.Observable(scheduler ? function(subscriber) {
			var n$2 = start;
			return scheduler.schedule(function() {
				if (n$2 < end) {
					subscriber.next(n$2++);
					this.schedule();
				} else subscriber.complete();
			});
		} : function(subscriber) {
			var n$2 = start;
			while (n$2 < end && !subscriber.closed) subscriber.next(n$2++);
			subscriber.complete();
		});
	}
	exports.range = range;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/using.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$4 = require_Observable();
	var innerFrom_1$27 = require_innerFrom();
	var empty_1$5 = require_empty();
	function using(resourceFactory, observableFactory) {
		return new Observable_1$4.Observable(function(subscriber) {
			var resource = resourceFactory();
			var result = observableFactory(resource);
			(result ? innerFrom_1$27.innerFrom(result) : empty_1$5.EMPTY).subscribe(subscriber);
			return function() {
				if (resource) resource.unsubscribe();
			};
		});
	}
	exports.using = using;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip$1 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/zip.js": ((exports) => {
	var __read$14 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$14 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$3 = require_Observable();
	var innerFrom_1$26 = require_innerFrom();
	var argsOrArgArray_1$3 = require_argsOrArgArray();
	var empty_1$4 = require_empty();
	var OperatorSubscriber_1$47 = require_OperatorSubscriber();
	var args_1$7 = require_args();
	function zip$1() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var resultSelector = args_1$7.popResultSelector(args);
		var sources = argsOrArgArray_1$3.argsOrArgArray(args);
		return sources.length ? new Observable_1$3.Observable(function(subscriber) {
			var buffers = sources.map(function() {
				return [];
			});
			var completed = sources.map(function() {
				return false;
			});
			subscriber.add(function() {
				buffers = completed = null;
			});
			var _loop_1 = function(sourceIndex$1) {
				innerFrom_1$26.innerFrom(sources[sourceIndex$1]).subscribe(OperatorSubscriber_1$47.createOperatorSubscriber(subscriber, function(value) {
					buffers[sourceIndex$1].push(value);
					if (buffers.every(function(buffer$1) {
						return buffer$1.length;
					})) {
						var result = buffers.map(function(buffer$1) {
							return buffer$1.shift();
						});
						subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray$14([], __read$14(result))) : result);
						if (buffers.some(function(buffer$1, i) {
							return !buffer$1.length && completed[i];
						})) subscriber.complete();
					}
				}, function() {
					completed[sourceIndex$1] = true;
					!buffers[sourceIndex$1].length && subscriber.complete();
				}));
			};
			for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) _loop_1(sourceIndex);
			return function() {
				buffers = completed = null;
			};
		}) : empty_1$4.EMPTY;
	}
	exports.zip = zip$1;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/types.js
var require_types$1 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/types.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/audit.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$61 = require_lift();
	var innerFrom_1$25 = require_innerFrom();
	var OperatorSubscriber_1$46 = require_OperatorSubscriber();
	function audit(durationSelector) {
		return lift_1$61.operate(function(source, subscriber) {
			var hasValue = false;
			var lastValue = null;
			var durationSubscriber = null;
			var isComplete = false;
			var endDuration = function() {
				durationSubscriber === null || durationSubscriber === void 0 || durationSubscriber.unsubscribe();
				durationSubscriber = null;
				if (hasValue) {
					hasValue = false;
					var value = lastValue;
					lastValue = null;
					subscriber.next(value);
				}
				isComplete && subscriber.complete();
			};
			var cleanupDuration = function() {
				durationSubscriber = null;
				isComplete && subscriber.complete();
			};
			source.subscribe(OperatorSubscriber_1$46.createOperatorSubscriber(subscriber, function(value) {
				hasValue = true;
				lastValue = value;
				if (!durationSubscriber) innerFrom_1$25.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1$46.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
			}, function() {
				isComplete = true;
				(!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
			}));
		});
	}
	exports.audit = audit;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/auditTime.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var async_1$11 = require_async$1();
	var audit_1$2 = require_audit();
	var timer_1$5 = require_timer();
	function auditTime(duration, scheduler) {
		if (scheduler === void 0) scheduler = async_1$11.asyncScheduler;
		return audit_1$2.audit(function() {
			return timer_1$5.timer(duration, scheduler);
		});
	}
	exports.auditTime = auditTime;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/buffer.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$60 = require_lift();
	var noop_1$12 = require_noop();
	var OperatorSubscriber_1$45 = require_OperatorSubscriber();
	var innerFrom_1$24 = require_innerFrom();
	function buffer(closingNotifier) {
		return lift_1$60.operate(function(source, subscriber) {
			var currentBuffer = [];
			source.subscribe(OperatorSubscriber_1$45.createOperatorSubscriber(subscriber, function(value) {
				return currentBuffer.push(value);
			}, function() {
				subscriber.next(currentBuffer);
				subscriber.complete();
			}));
			innerFrom_1$24.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1$45.createOperatorSubscriber(subscriber, function() {
				var b$2 = currentBuffer;
				currentBuffer = [];
				subscriber.next(b$2);
			}, noop_1$12.noop));
			return function() {
				currentBuffer = null;
			};
		});
	}
	exports.buffer = buffer;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js": ((exports) => {
	var __values$6 = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m$1 = s && o[s], i = 0;
		if (m$1) return m$1.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$59 = require_lift();
	var OperatorSubscriber_1$44 = require_OperatorSubscriber();
	var arrRemove_1$4 = require_arrRemove();
	function bufferCount(bufferSize, startBufferEvery) {
		if (startBufferEvery === void 0) startBufferEvery = null;
		startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
		return lift_1$59.operate(function(source, subscriber) {
			var buffers = [];
			var count$1 = 0;
			source.subscribe(OperatorSubscriber_1$44.createOperatorSubscriber(subscriber, function(value) {
				var e_1, _a, e_2, _b;
				var toEmit = null;
				if (count$1++ % startBufferEvery === 0) buffers.push([]);
				try {
					for (var buffers_1 = __values$6(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
						var buffer$1 = buffers_1_1.value;
						buffer$1.push(value);
						if (bufferSize <= buffer$1.length) {
							toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
							toEmit.push(buffer$1);
						}
					}
				} catch (e_1_1) {
					e_1 = { error: e_1_1 };
				} finally {
					try {
						if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
					} finally {
						if (e_1) throw e_1.error;
					}
				}
				if (toEmit) try {
					for (var toEmit_1 = __values$6(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
						var buffer$1 = toEmit_1_1.value;
						arrRemove_1$4.arrRemove(buffers, buffer$1);
						subscriber.next(buffer$1);
					}
				} catch (e_2_1) {
					e_2 = { error: e_2_1 };
				} finally {
					try {
						if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
					} finally {
						if (e_2) throw e_2.error;
					}
				}
			}, function() {
				var e_3, _a;
				try {
					for (var buffers_2 = __values$6(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
						var buffer$1 = buffers_2_1.value;
						subscriber.next(buffer$1);
					}
				} catch (e_3_1) {
					e_3 = { error: e_3_1 };
				} finally {
					try {
						if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
					} finally {
						if (e_3) throw e_3.error;
					}
				}
				subscriber.complete();
			}, void 0, function() {
				buffers = null;
			}));
		});
	}
	exports.bufferCount = bufferCount;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js": ((exports) => {
	var __values$5 = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m$1 = s && o[s], i = 0;
		if (m$1) return m$1.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subscription_1$4 = require_Subscription();
	var lift_1$58 = require_lift();
	var OperatorSubscriber_1$43 = require_OperatorSubscriber();
	var arrRemove_1$3 = require_arrRemove();
	var async_1$10 = require_async$1();
	var args_1$6 = require_args();
	var executeSchedule_1$1 = require_executeSchedule();
	function bufferTime(bufferTimeSpan) {
		var _a, _b;
		var otherArgs = [];
		for (var _i = 1; _i < arguments.length; _i++) otherArgs[_i - 1] = arguments[_i];
		var scheduler = (_a = args_1$6.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1$10.asyncScheduler;
		var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
		var maxBufferSize = otherArgs[1] || Infinity;
		return lift_1$58.operate(function(source, subscriber) {
			var bufferRecords = [];
			var restartOnEmit = false;
			var emit = function(record) {
				var buffer$1 = record.buffer;
				record.subs.unsubscribe();
				arrRemove_1$3.arrRemove(bufferRecords, record);
				subscriber.next(buffer$1);
				restartOnEmit && startBuffer();
			};
			var startBuffer = function() {
				if (bufferRecords) {
					var subs = new Subscription_1$4.Subscription();
					subscriber.add(subs);
					var record_1 = {
						buffer: [],
						subs
					};
					bufferRecords.push(record_1);
					executeSchedule_1$1.executeSchedule(subs, scheduler, function() {
						return emit(record_1);
					}, bufferTimeSpan);
				}
			};
			if (bufferCreationInterval !== null && bufferCreationInterval >= 0) executeSchedule_1$1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
			else restartOnEmit = true;
			startBuffer();
			var bufferTimeSubscriber = OperatorSubscriber_1$43.createOperatorSubscriber(subscriber, function(value) {
				var e_1, _a$1;
				var recordsCopy = bufferRecords.slice();
				try {
					for (var recordsCopy_1 = __values$5(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
						var record = recordsCopy_1_1.value;
						var buffer$1 = record.buffer;
						buffer$1.push(value);
						maxBufferSize <= buffer$1.length && emit(record);
					}
				} catch (e_1_1) {
					e_1 = { error: e_1_1 };
				} finally {
					try {
						if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a$1 = recordsCopy_1.return)) _a$1.call(recordsCopy_1);
					} finally {
						if (e_1) throw e_1.error;
					}
				}
			}, function() {
				while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) subscriber.next(bufferRecords.shift().buffer);
				bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 || bufferTimeSubscriber.unsubscribe();
				subscriber.complete();
				subscriber.unsubscribe();
			}, void 0, function() {
				return bufferRecords = null;
			});
			source.subscribe(bufferTimeSubscriber);
		});
	}
	exports.bufferTime = bufferTime;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js": ((exports) => {
	var __values$4 = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m$1 = s && o[s], i = 0;
		if (m$1) return m$1.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subscription_1$3 = require_Subscription();
	var lift_1$57 = require_lift();
	var innerFrom_1$23 = require_innerFrom();
	var OperatorSubscriber_1$42 = require_OperatorSubscriber();
	var noop_1$11 = require_noop();
	var arrRemove_1$2 = require_arrRemove();
	function bufferToggle(openings, closingSelector) {
		return lift_1$57.operate(function(source, subscriber) {
			var buffers = [];
			innerFrom_1$23.innerFrom(openings).subscribe(OperatorSubscriber_1$42.createOperatorSubscriber(subscriber, function(openValue) {
				var buffer$1 = [];
				buffers.push(buffer$1);
				var closingSubscription = new Subscription_1$3.Subscription();
				var emitBuffer = function() {
					arrRemove_1$2.arrRemove(buffers, buffer$1);
					subscriber.next(buffer$1);
					closingSubscription.unsubscribe();
				};
				closingSubscription.add(innerFrom_1$23.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1$42.createOperatorSubscriber(subscriber, emitBuffer, noop_1$11.noop)));
			}, noop_1$11.noop));
			source.subscribe(OperatorSubscriber_1$42.createOperatorSubscriber(subscriber, function(value) {
				var e_1, _a;
				try {
					for (var buffers_1 = __values$4(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) buffers_1_1.value.push(value);
				} catch (e_1_1) {
					e_1 = { error: e_1_1 };
				} finally {
					try {
						if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
					} finally {
						if (e_1) throw e_1.error;
					}
				}
			}, function() {
				while (buffers.length > 0) subscriber.next(buffers.shift());
				subscriber.complete();
			}));
		});
	}
	exports.bufferToggle = bufferToggle;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$56 = require_lift();
	var noop_1$10 = require_noop();
	var OperatorSubscriber_1$41 = require_OperatorSubscriber();
	var innerFrom_1$22 = require_innerFrom();
	function bufferWhen(closingSelector) {
		return lift_1$56.operate(function(source, subscriber) {
			var buffer$1 = null;
			var closingSubscriber = null;
			var openBuffer = function() {
				closingSubscriber === null || closingSubscriber === void 0 || closingSubscriber.unsubscribe();
				var b$2 = buffer$1;
				buffer$1 = [];
				b$2 && subscriber.next(b$2);
				innerFrom_1$22.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1$41.createOperatorSubscriber(subscriber, openBuffer, noop_1$10.noop));
			};
			openBuffer();
			source.subscribe(OperatorSubscriber_1$41.createOperatorSubscriber(subscriber, function(value) {
				return buffer$1 === null || buffer$1 === void 0 ? void 0 : buffer$1.push(value);
			}, function() {
				buffer$1 && subscriber.next(buffer$1);
				subscriber.complete();
			}, void 0, function() {
				return buffer$1 = closingSubscriber = null;
			}));
		});
	}
	exports.bufferWhen = bufferWhen;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/catchError.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var innerFrom_1$21 = require_innerFrom();
	var OperatorSubscriber_1$40 = require_OperatorSubscriber();
	var lift_1$55 = require_lift();
	function catchError(selector) {
		return lift_1$55.operate(function(source, subscriber) {
			var innerSub = null;
			var syncUnsub = false;
			var handledResult;
			innerSub = source.subscribe(OperatorSubscriber_1$40.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
				handledResult = innerFrom_1$21.innerFrom(selector(err, catchError(selector)(source)));
				if (innerSub) {
					innerSub.unsubscribe();
					innerSub = null;
					handledResult.subscribe(subscriber);
				} else syncUnsub = true;
			}));
			if (syncUnsub) {
				innerSub.unsubscribe();
				innerSub = null;
				handledResult.subscribe(subscriber);
			}
		});
	}
	exports.catchError = catchError;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var OperatorSubscriber_1$39 = require_OperatorSubscriber();
	function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
		return function(source, subscriber) {
			var hasState = hasSeed;
			var state = seed;
			var index = 0;
			source.subscribe(OperatorSubscriber_1$39.createOperatorSubscriber(subscriber, function(value) {
				var i = index++;
				state = hasState ? accumulator(state, value, i) : (hasState = true, value);
				emitOnNext && subscriber.next(state);
			}, emitBeforeComplete && (function() {
				hasState && subscriber.next(state);
				subscriber.complete();
			})));
		};
	}
	exports.scanInternals = scanInternals;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/reduce.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var scanInternals_1$1 = require_scanInternals();
	var lift_1$54 = require_lift();
	function reduce(accumulator, seed) {
		return lift_1$54.operate(scanInternals_1$1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
	}
	exports.reduce = reduce;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/toArray.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var reduce_1$5 = require_reduce();
	var lift_1$53 = require_lift();
	var arrReducer = function(arr, value) {
		return arr.push(value), arr;
	};
	function toArray() {
		return lift_1$53.operate(function(source, subscriber) {
			reduce_1$5.reduce(arrReducer, [])(source).subscribe(subscriber);
		});
	}
	exports.toArray = toArray;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var identity_1$11 = require_identity();
	var mapOneOrManyArgs_1$1 = require_mapOneOrManyArgs();
	var pipe_1$2 = require_pipe();
	var mergeMap_1$6 = require_mergeMap();
	var toArray_1$2 = require_toArray();
	function joinAllInternals(joinFn, project) {
		return pipe_1$2.pipe(toArray_1$2.toArray(), mergeMap_1$6.mergeMap(function(sources) {
			return joinFn(sources);
		}), project ? mapOneOrManyArgs_1$1.mapOneOrManyArgs(project) : identity_1$11.identity);
	}
	exports.joinAllInternals = joinAllInternals;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var combineLatest_1$4 = require_combineLatest$1();
	var joinAllInternals_1$1 = require_joinAllInternals();
	function combineLatestAll(project) {
		return joinAllInternals_1$1.joinAllInternals(combineLatest_1$4.combineLatest, project);
	}
	exports.combineLatestAll = combineLatestAll;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/combineAll.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var combineLatestAll_1$2 = require_combineLatestAll();
	exports.combineAll = combineLatestAll_1$2.combineLatestAll;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js": ((exports) => {
	var __read$13 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$13 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var combineLatest_1$3 = require_combineLatest$1();
	var lift_1$52 = require_lift();
	var argsOrArgArray_1$2 = require_argsOrArgArray();
	var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
	var pipe_1$1 = require_pipe();
	var args_1$5 = require_args();
	function combineLatest() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var resultSelector = args_1$5.popResultSelector(args);
		return resultSelector ? pipe_1$1.pipe(combineLatest.apply(void 0, __spreadArray$13([], __read$13(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1$52.operate(function(source, subscriber) {
			combineLatest_1$3.combineLatestInit(__spreadArray$13([source], __read$13(argsOrArgArray_1$2.argsOrArgArray(args))))(subscriber);
		});
	}
	exports.combineLatest = combineLatest;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js": ((exports) => {
	var __read$12 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$12 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var combineLatest_1$2 = require_combineLatest();
	function combineLatestWith() {
		var otherSources = [];
		for (var _i = 0; _i < arguments.length; _i++) otherSources[_i] = arguments[_i];
		return combineLatest_1$2.combineLatest.apply(void 0, __spreadArray$12([], __read$12(otherSources)));
	}
	exports.combineLatestWith = combineLatestWith;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/concatMap.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var mergeMap_1$5 = require_mergeMap();
	var isFunction_1$8 = require_isFunction();
	function concatMap(project, resultSelector) {
		return isFunction_1$8.isFunction(resultSelector) ? mergeMap_1$5.mergeMap(project, resultSelector, 1) : mergeMap_1$5.mergeMap(project, 1);
	}
	exports.concatMap = concatMap;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var concatMap_1$2 = require_concatMap();
	var isFunction_1$7 = require_isFunction();
	function concatMapTo(innerObservable, resultSelector) {
		return isFunction_1$7.isFunction(resultSelector) ? concatMap_1$2.concatMap(function() {
			return innerObservable;
		}, resultSelector) : concatMap_1$2.concatMap(function() {
			return innerObservable;
		});
	}
	exports.concatMapTo = concatMapTo;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/concat.js": ((exports) => {
	var __read$11 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$11 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$51 = require_lift();
	var concatAll_1$2 = require_concatAll();
	var args_1$4 = require_args();
	var from_1$2 = require_from();
	function concat() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var scheduler = args_1$4.popScheduler(args);
		return lift_1$51.operate(function(source, subscriber) {
			concatAll_1$2.concatAll()(from_1$2.from(__spreadArray$11([source], __read$11(args)), scheduler)).subscribe(subscriber);
		});
	}
	exports.concat = concat;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/concatWith.js": ((exports) => {
	var __read$10 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$10 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var concat_1$5 = require_concat();
	function concatWith() {
		var otherSources = [];
		for (var _i = 0; _i < arguments.length; _i++) otherSources[_i] = arguments[_i];
		return concat_1$5.concat.apply(void 0, __spreadArray$10([], __read$10(otherSources)));
	}
	exports.concatWith = concatWith;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$2 = require_Observable();
	function fromSubscribable(subscribable) {
		return new Observable_1$2.Observable(function(subscriber) {
			return subscribable.subscribe(subscriber);
		});
	}
	exports.fromSubscribable = fromSubscribable;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/connect.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subject_1$11 = require_Subject();
	var innerFrom_1$20 = require_innerFrom();
	var lift_1$50 = require_lift();
	var fromSubscribable_1 = require_fromSubscribable();
	var DEFAULT_CONFIG = { connector: function() {
		return new Subject_1$11.Subject();
	} };
	function connect(selector, config) {
		if (config === void 0) config = DEFAULT_CONFIG;
		var connector = config.connector;
		return lift_1$50.operate(function(source, subscriber) {
			var subject = connector();
			innerFrom_1$20.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
			subscriber.add(source.subscribe(subject));
		});
	}
	exports.connect = connect;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/count.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var reduce_1$4 = require_reduce();
	function count(predicate) {
		return reduce_1$4.reduce(function(total, value, i) {
			return !predicate || predicate(value, i) ? total + 1 : total;
		}, 0);
	}
	exports.count = count;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/debounce.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$49 = require_lift();
	var noop_1$9 = require_noop();
	var OperatorSubscriber_1$38 = require_OperatorSubscriber();
	var innerFrom_1$19 = require_innerFrom();
	function debounce(durationSelector) {
		return lift_1$49.operate(function(source, subscriber) {
			var hasValue = false;
			var lastValue = null;
			var durationSubscriber = null;
			var emit = function() {
				durationSubscriber === null || durationSubscriber === void 0 || durationSubscriber.unsubscribe();
				durationSubscriber = null;
				if (hasValue) {
					hasValue = false;
					var value = lastValue;
					lastValue = null;
					subscriber.next(value);
				}
			};
			source.subscribe(OperatorSubscriber_1$38.createOperatorSubscriber(subscriber, function(value) {
				durationSubscriber === null || durationSubscriber === void 0 || durationSubscriber.unsubscribe();
				hasValue = true;
				lastValue = value;
				durationSubscriber = OperatorSubscriber_1$38.createOperatorSubscriber(subscriber, emit, noop_1$9.noop);
				innerFrom_1$19.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
			}, function() {
				emit();
				subscriber.complete();
			}, void 0, function() {
				lastValue = durationSubscriber = null;
			}));
		});
	}
	exports.debounce = debounce;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var async_1$9 = require_async$1();
	var lift_1$48 = require_lift();
	var OperatorSubscriber_1$37 = require_OperatorSubscriber();
	function debounceTime(dueTime, scheduler) {
		if (scheduler === void 0) scheduler = async_1$9.asyncScheduler;
		return lift_1$48.operate(function(source, subscriber) {
			var activeTask = null;
			var lastValue = null;
			var lastTime = null;
			var emit = function() {
				if (activeTask) {
					activeTask.unsubscribe();
					activeTask = null;
					var value = lastValue;
					lastValue = null;
					subscriber.next(value);
				}
			};
			function emitWhenIdle() {
				var targetTime = lastTime + dueTime;
				var now = scheduler.now();
				if (now < targetTime) {
					activeTask = this.schedule(void 0, targetTime - now);
					subscriber.add(activeTask);
					return;
				}
				emit();
			}
			source.subscribe(OperatorSubscriber_1$37.createOperatorSubscriber(subscriber, function(value) {
				lastValue = value;
				lastTime = scheduler.now();
				if (!activeTask) {
					activeTask = scheduler.schedule(emitWhenIdle, dueTime);
					subscriber.add(activeTask);
				}
			}, function() {
				emit();
				subscriber.complete();
			}, void 0, function() {
				lastValue = activeTask = null;
			}));
		});
	}
	exports.debounceTime = debounceTime;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$47 = require_lift();
	var OperatorSubscriber_1$36 = require_OperatorSubscriber();
	function defaultIfEmpty(defaultValue) {
		return lift_1$47.operate(function(source, subscriber) {
			var hasValue = false;
			source.subscribe(OperatorSubscriber_1$36.createOperatorSubscriber(subscriber, function(value) {
				hasValue = true;
				subscriber.next(value);
			}, function() {
				if (!hasValue) subscriber.next(defaultValue);
				subscriber.complete();
			}));
		});
	}
	exports.defaultIfEmpty = defaultIfEmpty;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/take.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var empty_1$3 = require_empty();
	var lift_1$46 = require_lift();
	var OperatorSubscriber_1$35 = require_OperatorSubscriber();
	function take(count$1) {
		return count$1 <= 0 ? function() {
			return empty_1$3.EMPTY;
		} : lift_1$46.operate(function(source, subscriber) {
			var seen = 0;
			source.subscribe(OperatorSubscriber_1$35.createOperatorSubscriber(subscriber, function(value) {
				if (++seen <= count$1) {
					subscriber.next(value);
					if (count$1 <= seen) subscriber.complete();
				}
			}));
		});
	}
	exports.take = take;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$45 = require_lift();
	var OperatorSubscriber_1$34 = require_OperatorSubscriber();
	var noop_1$8 = require_noop();
	function ignoreElements() {
		return lift_1$45.operate(function(source, subscriber) {
			source.subscribe(OperatorSubscriber_1$34.createOperatorSubscriber(subscriber, noop_1$8.noop));
		});
	}
	exports.ignoreElements = ignoreElements;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/mapTo.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var map_1$7 = require_map();
	function mapTo(value) {
		return map_1$7.map(function() {
			return value;
		});
	}
	exports.mapTo = mapTo;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var concat_1$4 = require_concat$1();
	var take_1$4 = require_take();
	var ignoreElements_1$2 = require_ignoreElements();
	var mapTo_1$2 = require_mapTo();
	var mergeMap_1$4 = require_mergeMap();
	var innerFrom_1$18 = require_innerFrom();
	function delayWhen(delayDurationSelector, subscriptionDelay) {
		if (subscriptionDelay) return function(source) {
			return concat_1$4.concat(subscriptionDelay.pipe(take_1$4.take(1), ignoreElements_1$2.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
		};
		return mergeMap_1$4.mergeMap(function(value, index) {
			return innerFrom_1$18.innerFrom(delayDurationSelector(value, index)).pipe(take_1$4.take(1), mapTo_1$2.mapTo(value));
		});
	}
	exports.delayWhen = delayWhen;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/delay.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var async_1$8 = require_async$1();
	var delayWhen_1$2 = require_delayWhen();
	var timer_1$4 = require_timer();
	function delay(due, scheduler) {
		if (scheduler === void 0) scheduler = async_1$8.asyncScheduler;
		var duration = timer_1$4.timer(due, scheduler);
		return delayWhen_1$2.delayWhen(function() {
			return duration;
		});
	}
	exports.delay = delay;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Notification_1$2 = require_Notification();
	var lift_1$44 = require_lift();
	var OperatorSubscriber_1$33 = require_OperatorSubscriber();
	function dematerialize() {
		return lift_1$44.operate(function(source, subscriber) {
			source.subscribe(OperatorSubscriber_1$33.createOperatorSubscriber(subscriber, function(notification) {
				return Notification_1$2.observeNotification(notification, subscriber);
			}));
		});
	}
	exports.dematerialize = dematerialize;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/distinct.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$43 = require_lift();
	var OperatorSubscriber_1$32 = require_OperatorSubscriber();
	var noop_1$7 = require_noop();
	var innerFrom_1$17 = require_innerFrom();
	function distinct(keySelector, flushes) {
		return lift_1$43.operate(function(source, subscriber) {
			var distinctKeys = /* @__PURE__ */ new Set();
			source.subscribe(OperatorSubscriber_1$32.createOperatorSubscriber(subscriber, function(value) {
				var key = keySelector ? keySelector(value) : value;
				if (!distinctKeys.has(key)) {
					distinctKeys.add(key);
					subscriber.next(value);
				}
			}));
			flushes && innerFrom_1$17.innerFrom(flushes).subscribe(OperatorSubscriber_1$32.createOperatorSubscriber(subscriber, function() {
				return distinctKeys.clear();
			}, noop_1$7.noop));
		});
	}
	exports.distinct = distinct;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var identity_1$10 = require_identity();
	var lift_1$42 = require_lift();
	var OperatorSubscriber_1$31 = require_OperatorSubscriber();
	function distinctUntilChanged(comparator, keySelector) {
		if (keySelector === void 0) keySelector = identity_1$10.identity;
		comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
		return lift_1$42.operate(function(source, subscriber) {
			var previousKey;
			var first$1 = true;
			source.subscribe(OperatorSubscriber_1$31.createOperatorSubscriber(subscriber, function(value) {
				var currentKey = keySelector(value);
				if (first$1 || !comparator(previousKey, currentKey)) {
					first$1 = false;
					previousKey = currentKey;
					subscriber.next(value);
				}
			}));
		});
	}
	exports.distinctUntilChanged = distinctUntilChanged;
	function defaultCompare(a$1, b$2) {
		return a$1 === b$2;
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var distinctUntilChanged_1$2 = require_distinctUntilChanged();
	function distinctUntilKeyChanged(key, compare) {
		return distinctUntilChanged_1$2.distinctUntilChanged(function(x, y) {
			return compare ? compare(x[key], y[key]) : x[key] === y[key];
		});
	}
	exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var EmptyError_1$4 = require_EmptyError();
	var lift_1$41 = require_lift();
	var OperatorSubscriber_1$30 = require_OperatorSubscriber();
	function throwIfEmpty(errorFactory) {
		if (errorFactory === void 0) errorFactory = defaultErrorFactory;
		return lift_1$41.operate(function(source, subscriber) {
			var hasValue = false;
			source.subscribe(OperatorSubscriber_1$30.createOperatorSubscriber(subscriber, function(value) {
				hasValue = true;
				subscriber.next(value);
			}, function() {
				return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
			}));
		});
	}
	exports.throwIfEmpty = throwIfEmpty;
	function defaultErrorFactory() {
		return new EmptyError_1$4.EmptyError();
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/elementAt.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var ArgumentOutOfRangeError_1$1 = require_ArgumentOutOfRangeError();
	var filter_1$6 = require_filter();
	var throwIfEmpty_1$4 = require_throwIfEmpty();
	var defaultIfEmpty_1$4 = require_defaultIfEmpty();
	var take_1$3 = require_take();
	function elementAt(index, defaultValue) {
		if (index < 0) throw new ArgumentOutOfRangeError_1$1.ArgumentOutOfRangeError();
		var hasDefaultValue = arguments.length >= 2;
		return function(source) {
			return source.pipe(filter_1$6.filter(function(v, i) {
				return i === index;
			}), take_1$3.take(1), hasDefaultValue ? defaultIfEmpty_1$4.defaultIfEmpty(defaultValue) : throwIfEmpty_1$4.throwIfEmpty(function() {
				return new ArgumentOutOfRangeError_1$1.ArgumentOutOfRangeError();
			}));
		};
	}
	exports.elementAt = elementAt;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/endWith.js": ((exports) => {
	var __read$9 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$9 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var concat_1$3 = require_concat$1();
	var of_1$1 = require_of();
	function endWith() {
		var values = [];
		for (var _i = 0; _i < arguments.length; _i++) values[_i] = arguments[_i];
		return function(source) {
			return concat_1$3.concat(source, of_1$1.of.apply(void 0, __spreadArray$9([], __read$9(values))));
		};
	}
	exports.endWith = endWith;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/every.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$40 = require_lift();
	var OperatorSubscriber_1$29 = require_OperatorSubscriber();
	function every(predicate, thisArg) {
		return lift_1$40.operate(function(source, subscriber) {
			var index = 0;
			source.subscribe(OperatorSubscriber_1$29.createOperatorSubscriber(subscriber, function(value) {
				if (!predicate.call(thisArg, value, index++, source)) {
					subscriber.next(false);
					subscriber.complete();
				}
			}, function() {
				subscriber.next(true);
				subscriber.complete();
			}));
		});
	}
	exports.every = every;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var map_1$6 = require_map();
	var innerFrom_1$16 = require_innerFrom();
	var lift_1$39 = require_lift();
	var OperatorSubscriber_1$28 = require_OperatorSubscriber();
	function exhaustMap(project, resultSelector) {
		if (resultSelector) return function(source) {
			return source.pipe(exhaustMap(function(a$1, i) {
				return innerFrom_1$16.innerFrom(project(a$1, i)).pipe(map_1$6.map(function(b$2, ii) {
					return resultSelector(a$1, b$2, i, ii);
				}));
			}));
		};
		return lift_1$39.operate(function(source, subscriber) {
			var index = 0;
			var innerSub = null;
			var isComplete = false;
			source.subscribe(OperatorSubscriber_1$28.createOperatorSubscriber(subscriber, function(outerValue) {
				if (!innerSub) {
					innerSub = OperatorSubscriber_1$28.createOperatorSubscriber(subscriber, void 0, function() {
						innerSub = null;
						isComplete && subscriber.complete();
					});
					innerFrom_1$16.innerFrom(project(outerValue, index++)).subscribe(innerSub);
				}
			}, function() {
				isComplete = true;
				!innerSub && subscriber.complete();
			}));
		});
	}
	exports.exhaustMap = exhaustMap;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var exhaustMap_1$2 = require_exhaustMap();
	var identity_1$9 = require_identity();
	function exhaustAll() {
		return exhaustMap_1$2.exhaustMap(identity_1$9.identity);
	}
	exports.exhaustAll = exhaustAll;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/exhaust.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var exhaustAll_1$2 = require_exhaustAll();
	exports.exhaust = exhaustAll_1$2.exhaustAll;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/expand.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$38 = require_lift();
	var mergeInternals_1$1 = require_mergeInternals();
	function expand(project, concurrent, scheduler) {
		if (concurrent === void 0) concurrent = Infinity;
		concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
		return lift_1$38.operate(function(source, subscriber) {
			return mergeInternals_1$1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
		});
	}
	exports.expand = expand;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/finalize.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$37 = require_lift();
	function finalize(callback) {
		return lift_1$37.operate(function(source, subscriber) {
			try {
				source.subscribe(subscriber);
			} finally {
				subscriber.add(callback);
			}
		});
	}
	exports.finalize = finalize;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/find.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$36 = require_lift();
	var OperatorSubscriber_1$27 = require_OperatorSubscriber();
	function find(predicate, thisArg) {
		return lift_1$36.operate(createFind(predicate, thisArg, "value"));
	}
	exports.find = find;
	function createFind(predicate, thisArg, emit) {
		var findIndex$1 = emit === "index";
		return function(source, subscriber) {
			var index = 0;
			source.subscribe(OperatorSubscriber_1$27.createOperatorSubscriber(subscriber, function(value) {
				var i = index++;
				if (predicate.call(thisArg, value, i, source)) {
					subscriber.next(findIndex$1 ? i : value);
					subscriber.complete();
				}
			}, function() {
				subscriber.next(findIndex$1 ? -1 : void 0);
				subscriber.complete();
			}));
		};
	}
	exports.createFind = createFind;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/findIndex.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$35 = require_lift();
	var find_1$2 = require_find();
	function findIndex(predicate, thisArg) {
		return lift_1$35.operate(find_1$2.createFind(predicate, thisArg, "index"));
	}
	exports.findIndex = findIndex;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/first.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var EmptyError_1$3 = require_EmptyError();
	var filter_1$5 = require_filter();
	var take_1$2 = require_take();
	var defaultIfEmpty_1$3 = require_defaultIfEmpty();
	var throwIfEmpty_1$3 = require_throwIfEmpty();
	var identity_1$8 = require_identity();
	function first(predicate, defaultValue) {
		var hasDefaultValue = arguments.length >= 2;
		return function(source) {
			return source.pipe(predicate ? filter_1$5.filter(function(v, i) {
				return predicate(v, i, source);
			}) : identity_1$8.identity, take_1$2.take(1), hasDefaultValue ? defaultIfEmpty_1$3.defaultIfEmpty(defaultValue) : throwIfEmpty_1$3.throwIfEmpty(function() {
				return new EmptyError_1$3.EmptyError();
			}));
		};
	}
	exports.first = first;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/groupBy.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Observable_1$1 = require_Observable();
	var innerFrom_1$15 = require_innerFrom();
	var Subject_1$10 = require_Subject();
	var lift_1$34 = require_lift();
	var OperatorSubscriber_1$26 = require_OperatorSubscriber();
	function groupBy(keySelector, elementOrOptions, duration, connector) {
		return lift_1$34.operate(function(source, subscriber) {
			var element;
			if (!elementOrOptions || typeof elementOrOptions === "function") element = elementOrOptions;
			else duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
			var groups = /* @__PURE__ */ new Map();
			var notify = function(cb) {
				groups.forEach(cb);
				cb(subscriber);
			};
			var handleError = function(err) {
				return notify(function(consumer) {
					return consumer.error(err);
				});
			};
			var activeGroups = 0;
			var teardownAttempted = false;
			var groupBySourceSubscriber = new OperatorSubscriber_1$26.OperatorSubscriber(subscriber, function(value) {
				try {
					var key_1 = keySelector(value);
					var group_1 = groups.get(key_1);
					if (!group_1) {
						groups.set(key_1, group_1 = connector ? connector() : new Subject_1$10.Subject());
						var grouped = createGroupedObservable(key_1, group_1);
						subscriber.next(grouped);
						if (duration) {
							var durationSubscriber_1 = OperatorSubscriber_1$26.createOperatorSubscriber(group_1, function() {
								group_1.complete();
								durationSubscriber_1 === null || durationSubscriber_1 === void 0 || durationSubscriber_1.unsubscribe();
							}, void 0, void 0, function() {
								return groups.delete(key_1);
							});
							groupBySourceSubscriber.add(innerFrom_1$15.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
						}
					}
					group_1.next(element ? element(value) : value);
				} catch (err) {
					handleError(err);
				}
			}, function() {
				return notify(function(consumer) {
					return consumer.complete();
				});
			}, handleError, function() {
				return groups.clear();
			}, function() {
				teardownAttempted = true;
				return activeGroups === 0;
			});
			source.subscribe(groupBySourceSubscriber);
			function createGroupedObservable(key, groupSubject) {
				var result = new Observable_1$1.Observable(function(groupSubscriber) {
					activeGroups++;
					var innerSub = groupSubject.subscribe(groupSubscriber);
					return function() {
						innerSub.unsubscribe();
						--activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
					};
				});
				result.key = key;
				return result;
			}
		});
	}
	exports.groupBy = groupBy;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$33 = require_lift();
	var OperatorSubscriber_1$25 = require_OperatorSubscriber();
	function isEmpty() {
		return lift_1$33.operate(function(source, subscriber) {
			source.subscribe(OperatorSubscriber_1$25.createOperatorSubscriber(subscriber, function() {
				subscriber.next(false);
				subscriber.complete();
			}, function() {
				subscriber.next(true);
				subscriber.complete();
			}));
		});
	}
	exports.isEmpty = isEmpty;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/takeLast.js": ((exports) => {
	var __values$3 = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m$1 = s && o[s], i = 0;
		if (m$1) return m$1.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var empty_1$2 = require_empty();
	var lift_1$32 = require_lift();
	var OperatorSubscriber_1$24 = require_OperatorSubscriber();
	function takeLast(count$1) {
		return count$1 <= 0 ? function() {
			return empty_1$2.EMPTY;
		} : lift_1$32.operate(function(source, subscriber) {
			var buffer$1 = [];
			source.subscribe(OperatorSubscriber_1$24.createOperatorSubscriber(subscriber, function(value) {
				buffer$1.push(value);
				count$1 < buffer$1.length && buffer$1.shift();
			}, function() {
				var e_1, _a;
				try {
					for (var buffer_1$2 = __values$3(buffer$1), buffer_1_1 = buffer_1$2.next(); !buffer_1_1.done; buffer_1_1 = buffer_1$2.next()) {
						var value = buffer_1_1.value;
						subscriber.next(value);
					}
				} catch (e_1_1) {
					e_1 = { error: e_1_1 };
				} finally {
					try {
						if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1$2.return)) _a.call(buffer_1$2);
					} finally {
						if (e_1) throw e_1.error;
					}
				}
				subscriber.complete();
			}, void 0, function() {
				buffer$1 = null;
			}));
		});
	}
	exports.takeLast = takeLast;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/last.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var EmptyError_1$2 = require_EmptyError();
	var filter_1$4 = require_filter();
	var takeLast_1$2 = require_takeLast();
	var throwIfEmpty_1$2 = require_throwIfEmpty();
	var defaultIfEmpty_1$2 = require_defaultIfEmpty();
	var identity_1$7 = require_identity();
	function last(predicate, defaultValue) {
		var hasDefaultValue = arguments.length >= 2;
		return function(source) {
			return source.pipe(predicate ? filter_1$4.filter(function(v, i) {
				return predicate(v, i, source);
			}) : identity_1$7.identity, takeLast_1$2.takeLast(1), hasDefaultValue ? defaultIfEmpty_1$2.defaultIfEmpty(defaultValue) : throwIfEmpty_1$2.throwIfEmpty(function() {
				return new EmptyError_1$2.EmptyError();
			}));
		};
	}
	exports.last = last;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/materialize.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Notification_1$1 = require_Notification();
	var lift_1$31 = require_lift();
	var OperatorSubscriber_1$23 = require_OperatorSubscriber();
	function materialize() {
		return lift_1$31.operate(function(source, subscriber) {
			source.subscribe(OperatorSubscriber_1$23.createOperatorSubscriber(subscriber, function(value) {
				subscriber.next(Notification_1$1.Notification.createNext(value));
			}, function() {
				subscriber.next(Notification_1$1.Notification.createComplete());
				subscriber.complete();
			}, function(err) {
				subscriber.next(Notification_1$1.Notification.createError(err));
				subscriber.complete();
			}));
		});
	}
	exports.materialize = materialize;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/max.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var reduce_1$3 = require_reduce();
	var isFunction_1$6 = require_isFunction();
	function max(comparer) {
		return reduce_1$3.reduce(isFunction_1$6.isFunction(comparer) ? function(x, y) {
			return comparer(x, y) > 0 ? x : y;
		} : function(x, y) {
			return x > y ? x : y;
		});
	}
	exports.max = max;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/flatMap.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var mergeMap_1$3 = require_mergeMap();
	exports.flatMap = mergeMap_1$3.mergeMap;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var mergeMap_1$2 = require_mergeMap();
	var isFunction_1$5 = require_isFunction();
	function mergeMapTo(innerObservable, resultSelector, concurrent) {
		if (concurrent === void 0) concurrent = Infinity;
		if (isFunction_1$5.isFunction(resultSelector)) return mergeMap_1$2.mergeMap(function() {
			return innerObservable;
		}, resultSelector, concurrent);
		if (typeof resultSelector === "number") concurrent = resultSelector;
		return mergeMap_1$2.mergeMap(function() {
			return innerObservable;
		}, concurrent);
	}
	exports.mergeMapTo = mergeMapTo;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$30 = require_lift();
	var mergeInternals_1 = require_mergeInternals();
	function mergeScan(accumulator, seed, concurrent) {
		if (concurrent === void 0) concurrent = Infinity;
		return lift_1$30.operate(function(source, subscriber) {
			var state = seed;
			return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
				return accumulator(state, value, index);
			}, concurrent, function(value) {
				state = value;
			}, false, void 0, function() {
				return state = null;
			});
		});
	}
	exports.mergeScan = mergeScan;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge$1 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/merge.js": ((exports) => {
	var __read$8 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$8 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$29 = require_lift();
	var mergeAll_1$2 = require_mergeAll();
	var args_1$3 = require_args();
	var from_1$1 = require_from();
	function merge$1() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var scheduler = args_1$3.popScheduler(args);
		var concurrent = args_1$3.popNumber(args, Infinity);
		return lift_1$29.operate(function(source, subscriber) {
			mergeAll_1$2.mergeAll(concurrent)(from_1$1.from(__spreadArray$8([source], __read$8(args)), scheduler)).subscribe(subscriber);
		});
	}
	exports.merge = merge$1;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js": ((exports) => {
	var __read$7 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$7 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var merge_1$2 = require_merge$1();
	function mergeWith() {
		var otherSources = [];
		for (var _i = 0; _i < arguments.length; _i++) otherSources[_i] = arguments[_i];
		return merge_1$2.merge.apply(void 0, __spreadArray$7([], __read$7(otherSources)));
	}
	exports.mergeWith = mergeWith;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/min.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var reduce_1$2 = require_reduce();
	var isFunction_1$4 = require_isFunction();
	function min(comparer) {
		return reduce_1$2.reduce(isFunction_1$4.isFunction(comparer) ? function(x, y) {
			return comparer(x, y) < 0 ? x : y;
		} : function(x, y) {
			return x < y ? x : y;
		});
	}
	exports.min = min;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/multicast.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var ConnectableObservable_1$3 = require_ConnectableObservable();
	var isFunction_1$3 = require_isFunction();
	var connect_1$3 = require_connect();
	function multicast(subjectOrSubjectFactory, selector) {
		var subjectFactory = isFunction_1$3.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
			return subjectOrSubjectFactory;
		};
		if (isFunction_1$3.isFunction(selector)) return connect_1$3.connect(selector, { connector: subjectFactory });
		return function(source) {
			return new ConnectableObservable_1$3.ConnectableObservable(source, subjectFactory);
		};
	}
	exports.multicast = multicast;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js": ((exports) => {
	var __read$6 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$6 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var argsOrArgArray_1$1 = require_argsOrArgArray();
	var onErrorResumeNext_1$1 = require_onErrorResumeNext();
	function onErrorResumeNextWith() {
		var sources = [];
		for (var _i = 0; _i < arguments.length; _i++) sources[_i] = arguments[_i];
		var nextSources = argsOrArgArray_1$1.argsOrArgArray(sources);
		return function(source) {
			return onErrorResumeNext_1$1.onErrorResumeNext.apply(void 0, __spreadArray$6([source], __read$6(nextSources)));
		};
	}
	exports.onErrorResumeNextWith = onErrorResumeNextWith;
	exports.onErrorResumeNext = onErrorResumeNextWith;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/pairwise.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$28 = require_lift();
	var OperatorSubscriber_1$22 = require_OperatorSubscriber();
	function pairwise() {
		return lift_1$28.operate(function(source, subscriber) {
			var prev;
			var hasPrev = false;
			source.subscribe(OperatorSubscriber_1$22.createOperatorSubscriber(subscriber, function(value) {
				var p$10 = prev;
				prev = value;
				hasPrev && subscriber.next([p$10, value]);
				hasPrev = true;
			}));
		});
	}
	exports.pairwise = pairwise;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/pluck.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var map_1$5 = require_map();
	function pluck() {
		var properties = [];
		for (var _i = 0; _i < arguments.length; _i++) properties[_i] = arguments[_i];
		var length = properties.length;
		if (length === 0) throw new Error("list of properties cannot be empty.");
		return map_1$5.map(function(x) {
			var currentProp = x;
			for (var i = 0; i < length; i++) {
				var p$10 = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
				if (typeof p$10 !== "undefined") currentProp = p$10;
				else return;
			}
			return currentProp;
		});
	}
	exports.pluck = pluck;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/publish.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subject_1$9 = require_Subject();
	var multicast_1$3 = require_multicast();
	var connect_1$2 = require_connect();
	function publish(selector) {
		return selector ? function(source) {
			return connect_1$2.connect(selector)(source);
		} : function(source) {
			return multicast_1$3.multicast(new Subject_1$9.Subject())(source);
		};
	}
	exports.publish = publish;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var BehaviorSubject_1$1 = require_BehaviorSubject();
	var ConnectableObservable_1$2 = require_ConnectableObservable();
	function publishBehavior(initialValue) {
		return function(source) {
			var subject = new BehaviorSubject_1$1.BehaviorSubject(initialValue);
			return new ConnectableObservable_1$2.ConnectableObservable(source, function() {
				return subject;
			});
		};
	}
	exports.publishBehavior = publishBehavior;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/publishLast.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var AsyncSubject_1$1 = require_AsyncSubject();
	var ConnectableObservable_1$1 = require_ConnectableObservable();
	function publishLast() {
		return function(source) {
			var subject = new AsyncSubject_1$1.AsyncSubject();
			return new ConnectableObservable_1$1.ConnectableObservable(source, function() {
				return subject;
			});
		};
	}
	exports.publishLast = publishLast;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var ReplaySubject_1$2 = require_ReplaySubject();
	var multicast_1$2 = require_multicast();
	var isFunction_1$2 = require_isFunction();
	function publishReplay(bufferSize, windowTime$1, selectorOrScheduler, timestampProvider) {
		if (selectorOrScheduler && !isFunction_1$2.isFunction(selectorOrScheduler)) timestampProvider = selectorOrScheduler;
		var selector = isFunction_1$2.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
		return function(source) {
			return multicast_1$2.multicast(new ReplaySubject_1$2.ReplaySubject(bufferSize, windowTime$1, timestampProvider), selector)(source);
		};
	}
	exports.publishReplay = publishReplay;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/raceWith.js": ((exports) => {
	var __read$5 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$5 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var race_1$2 = require_race$1();
	var lift_1$27 = require_lift();
	var identity_1$6 = require_identity();
	function raceWith() {
		var otherSources = [];
		for (var _i = 0; _i < arguments.length; _i++) otherSources[_i] = arguments[_i];
		return !otherSources.length ? identity_1$6.identity : lift_1$27.operate(function(source, subscriber) {
			race_1$2.raceInit(__spreadArray$5([source], __read$5(otherSources)))(subscriber);
		});
	}
	exports.raceWith = raceWith;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/repeat.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var empty_1$1 = require_empty();
	var lift_1$26 = require_lift();
	var OperatorSubscriber_1$21 = require_OperatorSubscriber();
	var innerFrom_1$14 = require_innerFrom();
	var timer_1$3 = require_timer();
	function repeat(countOrConfig) {
		var _a;
		var count$1 = Infinity;
		var delay$1;
		if (countOrConfig != null) if (typeof countOrConfig === "object") _a = countOrConfig.count, count$1 = _a === void 0 ? Infinity : _a, delay$1 = countOrConfig.delay;
		else count$1 = countOrConfig;
		return count$1 <= 0 ? function() {
			return empty_1$1.EMPTY;
		} : lift_1$26.operate(function(source, subscriber) {
			var soFar = 0;
			var sourceSub;
			var resubscribe = function() {
				sourceSub === null || sourceSub === void 0 || sourceSub.unsubscribe();
				sourceSub = null;
				if (delay$1 != null) {
					var notifier = typeof delay$1 === "number" ? timer_1$3.timer(delay$1) : innerFrom_1$14.innerFrom(delay$1(soFar));
					var notifierSubscriber_1 = OperatorSubscriber_1$21.createOperatorSubscriber(subscriber, function() {
						notifierSubscriber_1.unsubscribe();
						subscribeToSource();
					});
					notifier.subscribe(notifierSubscriber_1);
				} else subscribeToSource();
			};
			var subscribeToSource = function() {
				var syncUnsub = false;
				sourceSub = source.subscribe(OperatorSubscriber_1$21.createOperatorSubscriber(subscriber, void 0, function() {
					if (++soFar < count$1) if (sourceSub) resubscribe();
					else syncUnsub = true;
					else subscriber.complete();
				}));
				if (syncUnsub) resubscribe();
			};
			subscribeToSource();
		});
	}
	exports.repeat = repeat;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var innerFrom_1$13 = require_innerFrom();
	var Subject_1$8 = require_Subject();
	var lift_1$25 = require_lift();
	var OperatorSubscriber_1$20 = require_OperatorSubscriber();
	function repeatWhen(notifier) {
		return lift_1$25.operate(function(source, subscriber) {
			var innerSub;
			var syncResub = false;
			var completions$;
			var isNotifierComplete = false;
			var isMainComplete = false;
			var checkComplete = function() {
				return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
			};
			var getCompletionSubject = function() {
				if (!completions$) {
					completions$ = new Subject_1$8.Subject();
					innerFrom_1$13.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1$20.createOperatorSubscriber(subscriber, function() {
						if (innerSub) subscribeForRepeatWhen();
						else syncResub = true;
					}, function() {
						isNotifierComplete = true;
						checkComplete();
					}));
				}
				return completions$;
			};
			var subscribeForRepeatWhen = function() {
				isMainComplete = false;
				innerSub = source.subscribe(OperatorSubscriber_1$20.createOperatorSubscriber(subscriber, void 0, function() {
					isMainComplete = true;
					!checkComplete() && getCompletionSubject().next();
				}));
				if (syncResub) {
					innerSub.unsubscribe();
					innerSub = null;
					syncResub = false;
					subscribeForRepeatWhen();
				}
			};
			subscribeForRepeatWhen();
		});
	}
	exports.repeatWhen = repeatWhen;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/retry.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$24 = require_lift();
	var OperatorSubscriber_1$19 = require_OperatorSubscriber();
	var identity_1$5 = require_identity();
	var timer_1$2 = require_timer();
	var innerFrom_1$12 = require_innerFrom();
	function retry(configOrCount) {
		if (configOrCount === void 0) configOrCount = Infinity;
		var config;
		if (configOrCount && typeof configOrCount === "object") config = configOrCount;
		else config = { count: configOrCount };
		var _a = config.count, count$1 = _a === void 0 ? Infinity : _a, delay$1 = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
		return count$1 <= 0 ? identity_1$5.identity : lift_1$24.operate(function(source, subscriber) {
			var soFar = 0;
			var innerSub;
			var subscribeForRetry = function() {
				var syncUnsub = false;
				innerSub = source.subscribe(OperatorSubscriber_1$19.createOperatorSubscriber(subscriber, function(value) {
					if (resetOnSuccess) soFar = 0;
					subscriber.next(value);
				}, void 0, function(err) {
					if (soFar++ < count$1) {
						var resub_1 = function() {
							if (innerSub) {
								innerSub.unsubscribe();
								innerSub = null;
								subscribeForRetry();
							} else syncUnsub = true;
						};
						if (delay$1 != null) {
							var notifier = typeof delay$1 === "number" ? timer_1$2.timer(delay$1) : innerFrom_1$12.innerFrom(delay$1(err, soFar));
							var notifierSubscriber_1 = OperatorSubscriber_1$19.createOperatorSubscriber(subscriber, function() {
								notifierSubscriber_1.unsubscribe();
								resub_1();
							}, function() {
								subscriber.complete();
							});
							notifier.subscribe(notifierSubscriber_1);
						} else resub_1();
					} else subscriber.error(err);
				}));
				if (syncUnsub) {
					innerSub.unsubscribe();
					innerSub = null;
					subscribeForRetry();
				}
			};
			subscribeForRetry();
		});
	}
	exports.retry = retry;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var innerFrom_1$11 = require_innerFrom();
	var Subject_1$7 = require_Subject();
	var lift_1$23 = require_lift();
	var OperatorSubscriber_1$18 = require_OperatorSubscriber();
	function retryWhen(notifier) {
		return lift_1$23.operate(function(source, subscriber) {
			var innerSub;
			var syncResub = false;
			var errors$;
			var subscribeForRetryWhen = function() {
				innerSub = source.subscribe(OperatorSubscriber_1$18.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
					if (!errors$) {
						errors$ = new Subject_1$7.Subject();
						innerFrom_1$11.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1$18.createOperatorSubscriber(subscriber, function() {
							return innerSub ? subscribeForRetryWhen() : syncResub = true;
						}));
					}
					if (errors$) errors$.next(err);
				}));
				if (syncResub) {
					innerSub.unsubscribe();
					innerSub = null;
					syncResub = false;
					subscribeForRetryWhen();
				}
			};
			subscribeForRetryWhen();
		});
	}
	exports.retryWhen = retryWhen;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/sample.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var innerFrom_1$10 = require_innerFrom();
	var lift_1$22 = require_lift();
	var noop_1$6 = require_noop();
	var OperatorSubscriber_1$17 = require_OperatorSubscriber();
	function sample(notifier) {
		return lift_1$22.operate(function(source, subscriber) {
			var hasValue = false;
			var lastValue = null;
			source.subscribe(OperatorSubscriber_1$17.createOperatorSubscriber(subscriber, function(value) {
				hasValue = true;
				lastValue = value;
			}));
			innerFrom_1$10.innerFrom(notifier).subscribe(OperatorSubscriber_1$17.createOperatorSubscriber(subscriber, function() {
				if (hasValue) {
					hasValue = false;
					var value = lastValue;
					lastValue = null;
					subscriber.next(value);
				}
			}, noop_1$6.noop));
		});
	}
	exports.sample = sample;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var async_1$7 = require_async$1();
	var sample_1$2 = require_sample();
	var interval_1$1 = require_interval();
	function sampleTime(period, scheduler) {
		if (scheduler === void 0) scheduler = async_1$7.asyncScheduler;
		return sample_1$2.sample(interval_1$1.interval(period, scheduler));
	}
	exports.sampleTime = sampleTime;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/scan.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$21 = require_lift();
	var scanInternals_1 = require_scanInternals();
	function scan(accumulator, seed) {
		return lift_1$21.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
	}
	exports.scan = scan;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$20 = require_lift();
	var OperatorSubscriber_1$16 = require_OperatorSubscriber();
	var innerFrom_1$9 = require_innerFrom();
	function sequenceEqual(compareTo, comparator) {
		if (comparator === void 0) comparator = function(a$1, b$2) {
			return a$1 === b$2;
		};
		return lift_1$20.operate(function(source, subscriber) {
			var aState = createState();
			var bState = createState();
			var emit = function(isEqual) {
				subscriber.next(isEqual);
				subscriber.complete();
			};
			var createSubscriber = function(selfState, otherState) {
				var sequenceEqualSubscriber = OperatorSubscriber_1$16.createOperatorSubscriber(subscriber, function(a$1) {
					var buffer$1 = otherState.buffer, complete = otherState.complete;
					if (buffer$1.length === 0) complete ? emit(false) : selfState.buffer.push(a$1);
					else !comparator(a$1, buffer$1.shift()) && emit(false);
				}, function() {
					selfState.complete = true;
					var complete = otherState.complete, buffer$1 = otherState.buffer;
					complete && emit(buffer$1.length === 0);
					sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 || sequenceEqualSubscriber.unsubscribe();
				});
				return sequenceEqualSubscriber;
			};
			source.subscribe(createSubscriber(aState, bState));
			innerFrom_1$9.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
		});
	}
	exports.sequenceEqual = sequenceEqual;
	function createState() {
		return {
			buffer: [],
			complete: false
		};
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/share.js": ((exports) => {
	var __read$4 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$4 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var innerFrom_1$8 = require_innerFrom();
	var Subject_1$6 = require_Subject();
	var Subscriber_1$1 = require_Subscriber();
	var lift_1$19 = require_lift();
	function share(options) {
		if (options === void 0) options = {};
		var _a = options.connector, connector = _a === void 0 ? function() {
			return new Subject_1$6.Subject();
		} : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
		return function(wrapperSource) {
			var connection;
			var resetConnection;
			var subject;
			var refCount$1 = 0;
			var hasCompleted = false;
			var hasErrored = false;
			var cancelReset = function() {
				resetConnection === null || resetConnection === void 0 || resetConnection.unsubscribe();
				resetConnection = void 0;
			};
			var reset = function() {
				cancelReset();
				connection = subject = void 0;
				hasCompleted = hasErrored = false;
			};
			var resetAndUnsubscribe = function() {
				var conn = connection;
				reset();
				conn === null || conn === void 0 || conn.unsubscribe();
			};
			return lift_1$19.operate(function(source, subscriber) {
				refCount$1++;
				if (!hasErrored && !hasCompleted) cancelReset();
				var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
				subscriber.add(function() {
					refCount$1--;
					if (refCount$1 === 0 && !hasErrored && !hasCompleted) resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
				});
				dest.subscribe(subscriber);
				if (!connection && refCount$1 > 0) {
					connection = new Subscriber_1$1.SafeSubscriber({
						next: function(value) {
							return dest.next(value);
						},
						error: function(err) {
							hasErrored = true;
							cancelReset();
							resetConnection = handleReset(reset, resetOnError, err);
							dest.error(err);
						},
						complete: function() {
							hasCompleted = true;
							cancelReset();
							resetConnection = handleReset(reset, resetOnComplete);
							dest.complete();
						}
					});
					innerFrom_1$8.innerFrom(source).subscribe(connection);
				}
			})(wrapperSource);
		};
	}
	exports.share = share;
	function handleReset(reset, on) {
		var args = [];
		for (var _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
		if (on === true) {
			reset();
			return;
		}
		if (on === false) return;
		var onSubscriber = new Subscriber_1$1.SafeSubscriber({ next: function() {
			onSubscriber.unsubscribe();
			reset();
		} });
		return innerFrom_1$8.innerFrom(on.apply(void 0, __spreadArray$4([], __read$4(args)))).subscribe(onSubscriber);
	}
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var ReplaySubject_1$1 = require_ReplaySubject();
	var share_1$2 = require_share();
	function shareReplay(configOrBufferSize, windowTime$1, scheduler) {
		var _a, _b, _c;
		var bufferSize;
		var refCount$1 = false;
		if (configOrBufferSize && typeof configOrBufferSize === "object") _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime$1 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount$1 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
		else bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
		return share_1$2.share({
			connector: function() {
				return new ReplaySubject_1$1.ReplaySubject(bufferSize, windowTime$1, scheduler);
			},
			resetOnError: true,
			resetOnComplete: false,
			resetOnRefCountZero: refCount$1
		});
	}
	exports.shareReplay = shareReplay;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/single.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var EmptyError_1$1 = require_EmptyError();
	var SequenceError_1$1 = require_SequenceError();
	var NotFoundError_1$1 = require_NotFoundError();
	var lift_1$18 = require_lift();
	var OperatorSubscriber_1$15 = require_OperatorSubscriber();
	function single(predicate) {
		return lift_1$18.operate(function(source, subscriber) {
			var hasValue = false;
			var singleValue;
			var seenValue = false;
			var index = 0;
			source.subscribe(OperatorSubscriber_1$15.createOperatorSubscriber(subscriber, function(value) {
				seenValue = true;
				if (!predicate || predicate(value, index++, source)) {
					hasValue && subscriber.error(new SequenceError_1$1.SequenceError("Too many matching values"));
					hasValue = true;
					singleValue = value;
				}
			}, function() {
				if (hasValue) {
					subscriber.next(singleValue);
					subscriber.complete();
				} else subscriber.error(seenValue ? new NotFoundError_1$1.NotFoundError("No matching values") : new EmptyError_1$1.EmptyError());
			}));
		});
	}
	exports.single = single;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/skip.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var filter_1$3 = require_filter();
	function skip(count$1) {
		return filter_1$3.filter(function(_, index) {
			return count$1 <= index;
		});
	}
	exports.skip = skip;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/skipLast.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var identity_1$4 = require_identity();
	var lift_1$17 = require_lift();
	var OperatorSubscriber_1$14 = require_OperatorSubscriber();
	function skipLast(skipCount) {
		return skipCount <= 0 ? identity_1$4.identity : lift_1$17.operate(function(source, subscriber) {
			var ring = new Array(skipCount);
			var seen = 0;
			source.subscribe(OperatorSubscriber_1$14.createOperatorSubscriber(subscriber, function(value) {
				var valueIndex = seen++;
				if (valueIndex < skipCount) ring[valueIndex] = value;
				else {
					var index = valueIndex % skipCount;
					var oldValue = ring[index];
					ring[index] = value;
					subscriber.next(oldValue);
				}
			}));
			return function() {
				ring = null;
			};
		});
	}
	exports.skipLast = skipLast;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$16 = require_lift();
	var OperatorSubscriber_1$13 = require_OperatorSubscriber();
	var innerFrom_1$7 = require_innerFrom();
	var noop_1$5 = require_noop();
	function skipUntil(notifier) {
		return lift_1$16.operate(function(source, subscriber) {
			var taking = false;
			var skipSubscriber = OperatorSubscriber_1$13.createOperatorSubscriber(subscriber, function() {
				skipSubscriber === null || skipSubscriber === void 0 || skipSubscriber.unsubscribe();
				taking = true;
			}, noop_1$5.noop);
			innerFrom_1$7.innerFrom(notifier).subscribe(skipSubscriber);
			source.subscribe(OperatorSubscriber_1$13.createOperatorSubscriber(subscriber, function(value) {
				return taking && subscriber.next(value);
			}));
		});
	}
	exports.skipUntil = skipUntil;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$15 = require_lift();
	var OperatorSubscriber_1$12 = require_OperatorSubscriber();
	function skipWhile(predicate) {
		return lift_1$15.operate(function(source, subscriber) {
			var taking = false;
			var index = 0;
			source.subscribe(OperatorSubscriber_1$12.createOperatorSubscriber(subscriber, function(value) {
				return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
			}));
		});
	}
	exports.skipWhile = skipWhile;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/startWith.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var concat_1$2 = require_concat$1();
	var args_1$2 = require_args();
	var lift_1$14 = require_lift();
	function startWith() {
		var values = [];
		for (var _i = 0; _i < arguments.length; _i++) values[_i] = arguments[_i];
		var scheduler = args_1$2.popScheduler(values);
		return lift_1$14.operate(function(source, subscriber) {
			(scheduler ? concat_1$2.concat(values, source, scheduler) : concat_1$2.concat(values, source)).subscribe(subscriber);
		});
	}
	exports.startWith = startWith;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/switchMap.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var innerFrom_1$6 = require_innerFrom();
	var lift_1$13 = require_lift();
	var OperatorSubscriber_1$11 = require_OperatorSubscriber();
	function switchMap(project, resultSelector) {
		return lift_1$13.operate(function(source, subscriber) {
			var innerSubscriber = null;
			var index = 0;
			var isComplete = false;
			var checkComplete = function() {
				return isComplete && !innerSubscriber && subscriber.complete();
			};
			source.subscribe(OperatorSubscriber_1$11.createOperatorSubscriber(subscriber, function(value) {
				innerSubscriber === null || innerSubscriber === void 0 || innerSubscriber.unsubscribe();
				var innerIndex = 0;
				var outerIndex = index++;
				innerFrom_1$6.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1$11.createOperatorSubscriber(subscriber, function(innerValue) {
					return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
				}, function() {
					innerSubscriber = null;
					checkComplete();
				}));
			}, function() {
				isComplete = true;
				checkComplete();
			}));
		});
	}
	exports.switchMap = switchMap;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/switchAll.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var switchMap_1$4 = require_switchMap();
	var identity_1$3 = require_identity();
	function switchAll() {
		return switchMap_1$4.switchMap(identity_1$3.identity);
	}
	exports.switchAll = switchAll;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var switchMap_1$3 = require_switchMap();
	var isFunction_1$1 = require_isFunction();
	function switchMapTo(innerObservable, resultSelector) {
		return isFunction_1$1.isFunction(resultSelector) ? switchMap_1$3.switchMap(function() {
			return innerObservable;
		}, resultSelector) : switchMap_1$3.switchMap(function() {
			return innerObservable;
		});
	}
	exports.switchMapTo = switchMapTo;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/switchScan.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var switchMap_1$2 = require_switchMap();
	var lift_1$12 = require_lift();
	function switchScan(accumulator, seed) {
		return lift_1$12.operate(function(source, subscriber) {
			var state = seed;
			switchMap_1$2.switchMap(function(value, index) {
				return accumulator(state, value, index);
			}, function(_, innerValue) {
				return state = innerValue, innerValue;
			})(source).subscribe(subscriber);
			return function() {
				state = null;
			};
		});
	}
	exports.switchScan = switchScan;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$11 = require_lift();
	var OperatorSubscriber_1$10 = require_OperatorSubscriber();
	var innerFrom_1$5 = require_innerFrom();
	var noop_1$4 = require_noop();
	function takeUntil(notifier) {
		return lift_1$11.operate(function(source, subscriber) {
			innerFrom_1$5.innerFrom(notifier).subscribe(OperatorSubscriber_1$10.createOperatorSubscriber(subscriber, function() {
				return subscriber.complete();
			}, noop_1$4.noop));
			!subscriber.closed && source.subscribe(subscriber);
		});
	}
	exports.takeUntil = takeUntil;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$10 = require_lift();
	var OperatorSubscriber_1$9 = require_OperatorSubscriber();
	function takeWhile(predicate, inclusive) {
		if (inclusive === void 0) inclusive = false;
		return lift_1$10.operate(function(source, subscriber) {
			var index = 0;
			source.subscribe(OperatorSubscriber_1$9.createOperatorSubscriber(subscriber, function(value) {
				var result = predicate(value, index++);
				(result || inclusive) && subscriber.next(value);
				!result && subscriber.complete();
			}));
		});
	}
	exports.takeWhile = takeWhile;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/tap.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var isFunction_1 = require_isFunction();
	var lift_1$9 = require_lift();
	var OperatorSubscriber_1$8 = require_OperatorSubscriber();
	var identity_1$2 = require_identity();
	function tap(observerOrNext, error, complete) {
		var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? {
			next: observerOrNext,
			error,
			complete
		} : observerOrNext;
		return tapObserver ? lift_1$9.operate(function(source, subscriber) {
			var _a;
			(_a = tapObserver.subscribe) === null || _a === void 0 || _a.call(tapObserver);
			var isUnsub = true;
			source.subscribe(OperatorSubscriber_1$8.createOperatorSubscriber(subscriber, function(value) {
				var _a$1;
				(_a$1 = tapObserver.next) === null || _a$1 === void 0 || _a$1.call(tapObserver, value);
				subscriber.next(value);
			}, function() {
				var _a$1;
				isUnsub = false;
				(_a$1 = tapObserver.complete) === null || _a$1 === void 0 || _a$1.call(tapObserver);
				subscriber.complete();
			}, function(err) {
				var _a$1;
				isUnsub = false;
				(_a$1 = tapObserver.error) === null || _a$1 === void 0 || _a$1.call(tapObserver, err);
				subscriber.error(err);
			}, function() {
				var _a$1, _b;
				if (isUnsub) (_a$1 = tapObserver.unsubscribe) === null || _a$1 === void 0 || _a$1.call(tapObserver);
				(_b = tapObserver.finalize) === null || _b === void 0 || _b.call(tapObserver);
			}));
		}) : identity_1$2.identity;
	}
	exports.tap = tap;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/throttle.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$8 = require_lift();
	var OperatorSubscriber_1$7 = require_OperatorSubscriber();
	var innerFrom_1$4 = require_innerFrom();
	function throttle(durationSelector, config) {
		return lift_1$8.operate(function(source, subscriber) {
			var _a = config !== null && config !== void 0 ? config : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
			var hasValue = false;
			var sendValue = null;
			var throttled = null;
			var isComplete = false;
			var endThrottling = function() {
				throttled === null || throttled === void 0 || throttled.unsubscribe();
				throttled = null;
				if (trailing) {
					send();
					isComplete && subscriber.complete();
				}
			};
			var cleanupThrottling = function() {
				throttled = null;
				isComplete && subscriber.complete();
			};
			var startThrottle = function(value) {
				return throttled = innerFrom_1$4.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
			};
			var send = function() {
				if (hasValue) {
					hasValue = false;
					var value = sendValue;
					sendValue = null;
					subscriber.next(value);
					!isComplete && startThrottle(value);
				}
			};
			source.subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(subscriber, function(value) {
				hasValue = true;
				sendValue = value;
				!(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
			}, function() {
				isComplete = true;
				!(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
			}));
		});
	}
	exports.throttle = throttle;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var async_1$6 = require_async$1();
	var throttle_1$2 = require_throttle();
	var timer_1$1 = require_timer();
	function throttleTime(duration, scheduler, config) {
		if (scheduler === void 0) scheduler = async_1$6.asyncScheduler;
		var duration$ = timer_1$1.timer(duration, scheduler);
		return throttle_1$2.throttle(function() {
			return duration$;
		}, config);
	}
	exports.throttleTime = throttleTime;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var async_1$5 = require_async$1();
	var lift_1$7 = require_lift();
	var OperatorSubscriber_1$6 = require_OperatorSubscriber();
	function timeInterval(scheduler) {
		if (scheduler === void 0) scheduler = async_1$5.asyncScheduler;
		return lift_1$7.operate(function(source, subscriber) {
			var last$3 = scheduler.now();
			source.subscribe(OperatorSubscriber_1$6.createOperatorSubscriber(subscriber, function(value) {
				var now = scheduler.now();
				var interval$1 = now - last$3;
				last$3 = now;
				subscriber.next(new TimeInterval(value, interval$1));
			}));
		});
	}
	exports.timeInterval = timeInterval;
	var TimeInterval = function() {
		function TimeInterval$1(value, interval$1) {
			this.value = value;
			this.interval = interval$1;
		}
		return TimeInterval$1;
	}();
	exports.TimeInterval = TimeInterval;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var async_1$4 = require_async$1();
	var isDate_1 = require_isDate();
	var timeout_1$2 = require_timeout();
	function timeoutWith(due, withObservable, scheduler) {
		var first$1;
		var each;
		var _with;
		scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1$4.async;
		if (isDate_1.isValidDate(due)) first$1 = due;
		else if (typeof due === "number") each = due;
		if (withObservable) _with = function() {
			return withObservable;
		};
		else throw new TypeError("No observable provided to switch to");
		if (first$1 == null && each == null) throw new TypeError("No timeout provided.");
		return timeout_1$2.timeout({
			first: first$1,
			each,
			scheduler,
			with: _with
		});
	}
	exports.timeoutWith = timeoutWith;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp$1 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/timestamp.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var dateTimestampProvider_1 = require_dateTimestampProvider();
	var map_1$4 = require_map();
	function timestamp(timestampProvider) {
		if (timestampProvider === void 0) timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
		return map_1$4.map(function(value) {
			return {
				value,
				timestamp: timestampProvider.now()
			};
		});
	}
	exports.timestamp = timestamp;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/window.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subject_1$5 = require_Subject();
	var lift_1$6 = require_lift();
	var OperatorSubscriber_1$5 = require_OperatorSubscriber();
	var noop_1$3 = require_noop();
	var innerFrom_1$3 = require_innerFrom();
	function window(windowBoundaries) {
		return lift_1$6.operate(function(source, subscriber) {
			var windowSubject = new Subject_1$5.Subject();
			subscriber.next(windowSubject.asObservable());
			var errorHandler = function(err) {
				windowSubject.error(err);
				subscriber.error(err);
			};
			source.subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(subscriber, function(value) {
				return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
			}, function() {
				windowSubject.complete();
				subscriber.complete();
			}, errorHandler));
			innerFrom_1$3.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(subscriber, function() {
				windowSubject.complete();
				subscriber.next(windowSubject = new Subject_1$5.Subject());
			}, noop_1$3.noop, errorHandler));
			return function() {
				windowSubject === null || windowSubject === void 0 || windowSubject.unsubscribe();
				windowSubject = null;
			};
		});
	}
	exports.window = window;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/windowCount.js": ((exports) => {
	var __values$2 = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m$1 = s && o[s], i = 0;
		if (m$1) return m$1.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subject_1$4 = require_Subject();
	var lift_1$5 = require_lift();
	var OperatorSubscriber_1$4 = require_OperatorSubscriber();
	function windowCount(windowSize, startWindowEvery) {
		if (startWindowEvery === void 0) startWindowEvery = 0;
		var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
		return lift_1$5.operate(function(source, subscriber) {
			var windows = [new Subject_1$4.Subject()];
			var count$1 = 0;
			subscriber.next(windows[0].asObservable());
			source.subscribe(OperatorSubscriber_1$4.createOperatorSubscriber(subscriber, function(value) {
				var e_1, _a;
				try {
					for (var windows_1 = __values$2(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) windows_1_1.value.next(value);
				} catch (e_1_1) {
					e_1 = { error: e_1_1 };
				} finally {
					try {
						if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
					} finally {
						if (e_1) throw e_1.error;
					}
				}
				var c$1 = count$1 - windowSize + 1;
				if (c$1 >= 0 && c$1 % startEvery === 0) windows.shift().complete();
				if (++count$1 % startEvery === 0) {
					var window_2 = new Subject_1$4.Subject();
					windows.push(window_2);
					subscriber.next(window_2.asObservable());
				}
			}, function() {
				while (windows.length > 0) windows.shift().complete();
				subscriber.complete();
			}, function(err) {
				while (windows.length > 0) windows.shift().error(err);
				subscriber.error(err);
			}, function() {
				windows = null;
			}));
		});
	}
	exports.windowCount = windowCount;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/windowTime.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subject_1$3 = require_Subject();
	var async_1$3 = require_async$1();
	var Subscription_1$2 = require_Subscription();
	var lift_1$4 = require_lift();
	var OperatorSubscriber_1$3 = require_OperatorSubscriber();
	var arrRemove_1$1 = require_arrRemove();
	var args_1$1 = require_args();
	var executeSchedule_1 = require_executeSchedule();
	function windowTime(windowTimeSpan) {
		var _a, _b;
		var otherArgs = [];
		for (var _i = 1; _i < arguments.length; _i++) otherArgs[_i - 1] = arguments[_i];
		var scheduler = (_a = args_1$1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1$3.asyncScheduler;
		var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
		var maxWindowSize = otherArgs[1] || Infinity;
		return lift_1$4.operate(function(source, subscriber) {
			var windowRecords = [];
			var restartOnClose = false;
			var closeWindow = function(record) {
				var window$1 = record.window, subs = record.subs;
				window$1.complete();
				subs.unsubscribe();
				arrRemove_1$1.arrRemove(windowRecords, record);
				restartOnClose && startWindow();
			};
			var startWindow = function() {
				if (windowRecords) {
					var subs = new Subscription_1$2.Subscription();
					subscriber.add(subs);
					var window_1$2 = new Subject_1$3.Subject();
					var record_1 = {
						window: window_1$2,
						subs,
						seen: 0
					};
					windowRecords.push(record_1);
					subscriber.next(window_1$2.asObservable());
					executeSchedule_1.executeSchedule(subs, scheduler, function() {
						return closeWindow(record_1);
					}, windowTimeSpan);
				}
			};
			if (windowCreationInterval !== null && windowCreationInterval >= 0) executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
			else restartOnClose = true;
			startWindow();
			var loop = function(cb) {
				return windowRecords.slice().forEach(cb);
			};
			var terminate = function(cb) {
				loop(function(_a$1) {
					var window$1 = _a$1.window;
					return cb(window$1);
				});
				cb(subscriber);
				subscriber.unsubscribe();
			};
			source.subscribe(OperatorSubscriber_1$3.createOperatorSubscriber(subscriber, function(value) {
				loop(function(record) {
					record.window.next(value);
					maxWindowSize <= ++record.seen && closeWindow(record);
				});
			}, function() {
				return terminate(function(consumer) {
					return consumer.complete();
				});
			}, function(err) {
				return terminate(function(consumer) {
					return consumer.error(err);
				});
			}));
			return function() {
				windowRecords = null;
			};
		});
	}
	exports.windowTime = windowTime;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js": ((exports) => {
	var __values$1 = exports && exports.__values || function(o) {
		var s = typeof Symbol === "function" && Symbol.iterator, m$1 = s && o[s], i = 0;
		if (m$1) return m$1.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i >= o.length) o = void 0;
			return {
				value: o && o[i++],
				done: !o
			};
		} };
		throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subject_1$2 = require_Subject();
	var Subscription_1$1 = require_Subscription();
	var lift_1$3 = require_lift();
	var innerFrom_1$2 = require_innerFrom();
	var OperatorSubscriber_1$2 = require_OperatorSubscriber();
	var noop_1$2 = require_noop();
	var arrRemove_1 = require_arrRemove();
	function windowToggle(openings, closingSelector) {
		return lift_1$3.operate(function(source, subscriber) {
			var windows = [];
			var handleError = function(err) {
				while (0 < windows.length) windows.shift().error(err);
				subscriber.error(err);
			};
			innerFrom_1$2.innerFrom(openings).subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, function(openValue) {
				var window$1 = new Subject_1$2.Subject();
				windows.push(window$1);
				var closingSubscription = new Subscription_1$1.Subscription();
				var closeWindow = function() {
					arrRemove_1.arrRemove(windows, window$1);
					window$1.complete();
					closingSubscription.unsubscribe();
				};
				var closingNotifier;
				try {
					closingNotifier = innerFrom_1$2.innerFrom(closingSelector(openValue));
				} catch (err) {
					handleError(err);
					return;
				}
				subscriber.next(window$1.asObservable());
				closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, closeWindow, noop_1$2.noop, handleError)));
			}, noop_1$2.noop));
			source.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, function(value) {
				var e_1, _a;
				var windowsCopy = windows.slice();
				try {
					for (var windowsCopy_1 = __values$1(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) windowsCopy_1_1.value.next(value);
				} catch (e_1_1) {
					e_1 = { error: e_1_1 };
				} finally {
					try {
						if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
					} finally {
						if (e_1) throw e_1.error;
					}
				}
			}, function() {
				while (0 < windows.length) windows.shift().complete();
				subscriber.complete();
			}, handleError, function() {
				while (0 < windows.length) windows.shift().unsubscribe();
			}));
		});
	}
	exports.windowToggle = windowToggle;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Subject_1$1 = require_Subject();
	var lift_1$2 = require_lift();
	var OperatorSubscriber_1$1 = require_OperatorSubscriber();
	var innerFrom_1$1 = require_innerFrom();
	function windowWhen(closingSelector) {
		return lift_1$2.operate(function(source, subscriber) {
			var window$1;
			var closingSubscriber;
			var handleError = function(err) {
				window$1.error(err);
				subscriber.error(err);
			};
			var openWindow = function() {
				closingSubscriber === null || closingSubscriber === void 0 || closingSubscriber.unsubscribe();
				window$1 === null || window$1 === void 0 || window$1.complete();
				window$1 = new Subject_1$1.Subject();
				subscriber.next(window$1.asObservable());
				var closingNotifier;
				try {
					closingNotifier = innerFrom_1$1.innerFrom(closingSelector());
				} catch (err) {
					handleError(err);
					return;
				}
				closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1$1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
			};
			openWindow();
			source.subscribe(OperatorSubscriber_1$1.createOperatorSubscriber(subscriber, function(value) {
				return window$1.next(value);
			}, function() {
				window$1.complete();
				subscriber.complete();
			}, handleError, function() {
				closingSubscriber === null || closingSubscriber === void 0 || closingSubscriber.unsubscribe();
				window$1 = null;
			}));
		});
	}
	exports.windowWhen = windowWhen;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js": ((exports) => {
	var __read$3 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$3 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var lift_1$1 = require_lift();
	var OperatorSubscriber_1 = require_OperatorSubscriber();
	var innerFrom_1 = require_innerFrom();
	var identity_1$1 = require_identity();
	var noop_1$1 = require_noop();
	var args_1 = require_args();
	function withLatestFrom() {
		var inputs = [];
		for (var _i = 0; _i < arguments.length; _i++) inputs[_i] = arguments[_i];
		var project = args_1.popResultSelector(inputs);
		return lift_1$1.operate(function(source, subscriber) {
			var len = inputs.length;
			var otherValues = new Array(len);
			var hasValue = inputs.map(function() {
				return false;
			});
			var ready = false;
			var _loop_1 = function(i$1) {
				innerFrom_1.innerFrom(inputs[i$1]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
					otherValues[i$1] = value;
					if (!ready && !hasValue[i$1]) {
						hasValue[i$1] = true;
						(ready = hasValue.every(identity_1$1.identity)) && (hasValue = null);
					}
				}, noop_1$1.noop));
			};
			for (var i = 0; i < len; i++) _loop_1(i);
			source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
				if (ready) {
					var values = __spreadArray$3([value], __read$3(otherValues));
					subscriber.next(project ? project.apply(void 0, __spreadArray$3([], __read$3(values))) : values);
				}
			}));
		});
	}
	exports.withLatestFrom = withLatestFrom;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/zipAll.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var zip_1$4 = require_zip$1();
	var joinAllInternals_1 = require_joinAllInternals();
	function zipAll(project) {
		return joinAllInternals_1.joinAllInternals(zip_1$4.zip, project);
	}
	exports.zipAll = zipAll;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/zip.js": ((exports) => {
	var __read$2 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$2 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var zip_1$3 = require_zip$1();
	var lift_1 = require_lift();
	function zip() {
		var sources = [];
		for (var _i = 0; _i < arguments.length; _i++) sources[_i] = arguments[_i];
		return lift_1.operate(function(source, subscriber) {
			zip_1$3.zip.apply(void 0, __spreadArray$2([source], __read$2(sources))).subscribe(subscriber);
		});
	}
	exports.zip = zip;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/zipWith.js": ((exports) => {
	var __read$1 = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray$1 = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var zip_1$2 = require_zip();
	function zipWith() {
		var otherInputs = [];
		for (var _i = 0; _i < arguments.length; _i++) otherInputs[_i] = arguments[_i];
		return zip_1$2.zip.apply(void 0, __spreadArray$1([], __read$1(otherInputs)));
	}
	exports.zipWith = zipWith;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/index.js
var require_cjs$1 = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/index.js": ((exports) => {
	var __createBinding$3 = exports && exports.__createBinding || (Object.create ? (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		});
	}) : (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	}));
	var __exportStar$3 = exports && exports.__exportStar || function(m$1, exports$1) {
		for (var p$10 in m$1) if (p$10 !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p$10)) __createBinding$3(exports$1, m$1, p$10);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
	exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
	exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
	exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
	var Observable_1 = require_Observable();
	Object.defineProperty(exports, "Observable", {
		enumerable: true,
		get: function() {
			return Observable_1.Observable;
		}
	});
	var ConnectableObservable_1 = require_ConnectableObservable();
	Object.defineProperty(exports, "ConnectableObservable", {
		enumerable: true,
		get: function() {
			return ConnectableObservable_1.ConnectableObservable;
		}
	});
	var observable_1 = require_observable();
	Object.defineProperty(exports, "observable", {
		enumerable: true,
		get: function() {
			return observable_1.observable;
		}
	});
	var animationFrames_1 = require_animationFrames();
	Object.defineProperty(exports, "animationFrames", {
		enumerable: true,
		get: function() {
			return animationFrames_1.animationFrames;
		}
	});
	var Subject_1 = require_Subject();
	Object.defineProperty(exports, "Subject", {
		enumerable: true,
		get: function() {
			return Subject_1.Subject;
		}
	});
	var BehaviorSubject_1 = require_BehaviorSubject();
	Object.defineProperty(exports, "BehaviorSubject", {
		enumerable: true,
		get: function() {
			return BehaviorSubject_1.BehaviorSubject;
		}
	});
	var ReplaySubject_1 = require_ReplaySubject();
	Object.defineProperty(exports, "ReplaySubject", {
		enumerable: true,
		get: function() {
			return ReplaySubject_1.ReplaySubject;
		}
	});
	var AsyncSubject_1 = require_AsyncSubject();
	Object.defineProperty(exports, "AsyncSubject", {
		enumerable: true,
		get: function() {
			return AsyncSubject_1.AsyncSubject;
		}
	});
	var asap_1 = require_asap();
	Object.defineProperty(exports, "asap", {
		enumerable: true,
		get: function() {
			return asap_1.asap;
		}
	});
	Object.defineProperty(exports, "asapScheduler", {
		enumerable: true,
		get: function() {
			return asap_1.asapScheduler;
		}
	});
	var async_1$2 = require_async$1();
	Object.defineProperty(exports, "async", {
		enumerable: true,
		get: function() {
			return async_1$2.async;
		}
	});
	Object.defineProperty(exports, "asyncScheduler", {
		enumerable: true,
		get: function() {
			return async_1$2.asyncScheduler;
		}
	});
	var queue_1 = require_queue();
	Object.defineProperty(exports, "queue", {
		enumerable: true,
		get: function() {
			return queue_1.queue;
		}
	});
	Object.defineProperty(exports, "queueScheduler", {
		enumerable: true,
		get: function() {
			return queue_1.queueScheduler;
		}
	});
	var animationFrame_1 = require_animationFrame();
	Object.defineProperty(exports, "animationFrame", {
		enumerable: true,
		get: function() {
			return animationFrame_1.animationFrame;
		}
	});
	Object.defineProperty(exports, "animationFrameScheduler", {
		enumerable: true,
		get: function() {
			return animationFrame_1.animationFrameScheduler;
		}
	});
	var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
	Object.defineProperty(exports, "VirtualTimeScheduler", {
		enumerable: true,
		get: function() {
			return VirtualTimeScheduler_1.VirtualTimeScheduler;
		}
	});
	Object.defineProperty(exports, "VirtualAction", {
		enumerable: true,
		get: function() {
			return VirtualTimeScheduler_1.VirtualAction;
		}
	});
	var Scheduler_1 = require_Scheduler();
	Object.defineProperty(exports, "Scheduler", {
		enumerable: true,
		get: function() {
			return Scheduler_1.Scheduler;
		}
	});
	var Subscription_1 = require_Subscription();
	Object.defineProperty(exports, "Subscription", {
		enumerable: true,
		get: function() {
			return Subscription_1.Subscription;
		}
	});
	var Subscriber_1 = require_Subscriber();
	Object.defineProperty(exports, "Subscriber", {
		enumerable: true,
		get: function() {
			return Subscriber_1.Subscriber;
		}
	});
	var Notification_1 = require_Notification();
	Object.defineProperty(exports, "Notification", {
		enumerable: true,
		get: function() {
			return Notification_1.Notification;
		}
	});
	Object.defineProperty(exports, "NotificationKind", {
		enumerable: true,
		get: function() {
			return Notification_1.NotificationKind;
		}
	});
	var pipe_1 = require_pipe();
	Object.defineProperty(exports, "pipe", {
		enumerable: true,
		get: function() {
			return pipe_1.pipe;
		}
	});
	var noop_1 = require_noop();
	Object.defineProperty(exports, "noop", {
		enumerable: true,
		get: function() {
			return noop_1.noop;
		}
	});
	var identity_1 = require_identity();
	Object.defineProperty(exports, "identity", {
		enumerable: true,
		get: function() {
			return identity_1.identity;
		}
	});
	var isObservable_1 = require_isObservable();
	Object.defineProperty(exports, "isObservable", {
		enumerable: true,
		get: function() {
			return isObservable_1.isObservable;
		}
	});
	var lastValueFrom_1 = require_lastValueFrom();
	Object.defineProperty(exports, "lastValueFrom", {
		enumerable: true,
		get: function() {
			return lastValueFrom_1.lastValueFrom;
		}
	});
	var firstValueFrom_1 = require_firstValueFrom();
	Object.defineProperty(exports, "firstValueFrom", {
		enumerable: true,
		get: function() {
			return firstValueFrom_1.firstValueFrom;
		}
	});
	var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
	Object.defineProperty(exports, "ArgumentOutOfRangeError", {
		enumerable: true,
		get: function() {
			return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
		}
	});
	var EmptyError_1 = require_EmptyError();
	Object.defineProperty(exports, "EmptyError", {
		enumerable: true,
		get: function() {
			return EmptyError_1.EmptyError;
		}
	});
	var NotFoundError_1 = require_NotFoundError();
	Object.defineProperty(exports, "NotFoundError", {
		enumerable: true,
		get: function() {
			return NotFoundError_1.NotFoundError;
		}
	});
	var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
	Object.defineProperty(exports, "ObjectUnsubscribedError", {
		enumerable: true,
		get: function() {
			return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
		}
	});
	var SequenceError_1 = require_SequenceError();
	Object.defineProperty(exports, "SequenceError", {
		enumerable: true,
		get: function() {
			return SequenceError_1.SequenceError;
		}
	});
	var timeout_1$1 = require_timeout();
	Object.defineProperty(exports, "TimeoutError", {
		enumerable: true,
		get: function() {
			return timeout_1$1.TimeoutError;
		}
	});
	var UnsubscriptionError_1 = require_UnsubscriptionError();
	Object.defineProperty(exports, "UnsubscriptionError", {
		enumerable: true,
		get: function() {
			return UnsubscriptionError_1.UnsubscriptionError;
		}
	});
	var bindCallback_1 = require_bindCallback();
	Object.defineProperty(exports, "bindCallback", {
		enumerable: true,
		get: function() {
			return bindCallback_1.bindCallback;
		}
	});
	var bindNodeCallback_1 = require_bindNodeCallback();
	Object.defineProperty(exports, "bindNodeCallback", {
		enumerable: true,
		get: function() {
			return bindNodeCallback_1.bindNodeCallback;
		}
	});
	var combineLatest_1$1 = require_combineLatest$1();
	Object.defineProperty(exports, "combineLatest", {
		enumerable: true,
		get: function() {
			return combineLatest_1$1.combineLatest;
		}
	});
	var concat_1$1 = require_concat$1();
	Object.defineProperty(exports, "concat", {
		enumerable: true,
		get: function() {
			return concat_1$1.concat;
		}
	});
	var connectable_1 = require_connectable();
	Object.defineProperty(exports, "connectable", {
		enumerable: true,
		get: function() {
			return connectable_1.connectable;
		}
	});
	var defer_1 = require_defer();
	Object.defineProperty(exports, "defer", {
		enumerable: true,
		get: function() {
			return defer_1.defer;
		}
	});
	var empty_1 = require_empty();
	Object.defineProperty(exports, "empty", {
		enumerable: true,
		get: function() {
			return empty_1.empty;
		}
	});
	var forkJoin_1 = require_forkJoin();
	Object.defineProperty(exports, "forkJoin", {
		enumerable: true,
		get: function() {
			return forkJoin_1.forkJoin;
		}
	});
	var from_1 = require_from();
	Object.defineProperty(exports, "from", {
		enumerable: true,
		get: function() {
			return from_1.from;
		}
	});
	var fromEvent_1 = require_fromEvent();
	Object.defineProperty(exports, "fromEvent", {
		enumerable: true,
		get: function() {
			return fromEvent_1.fromEvent;
		}
	});
	var fromEventPattern_1 = require_fromEventPattern();
	Object.defineProperty(exports, "fromEventPattern", {
		enumerable: true,
		get: function() {
			return fromEventPattern_1.fromEventPattern;
		}
	});
	var generate_1 = require_generate();
	Object.defineProperty(exports, "generate", {
		enumerable: true,
		get: function() {
			return generate_1.generate;
		}
	});
	var iif_1 = require_iif();
	Object.defineProperty(exports, "iif", {
		enumerable: true,
		get: function() {
			return iif_1.iif;
		}
	});
	var interval_1 = require_interval();
	Object.defineProperty(exports, "interval", {
		enumerable: true,
		get: function() {
			return interval_1.interval;
		}
	});
	var merge_1$1 = require_merge$2();
	Object.defineProperty(exports, "merge", {
		enumerable: true,
		get: function() {
			return merge_1$1.merge;
		}
	});
	var never_1 = require_never();
	Object.defineProperty(exports, "never", {
		enumerable: true,
		get: function() {
			return never_1.never;
		}
	});
	var of_1 = require_of();
	Object.defineProperty(exports, "of", {
		enumerable: true,
		get: function() {
			return of_1.of;
		}
	});
	var onErrorResumeNext_1 = require_onErrorResumeNext();
	Object.defineProperty(exports, "onErrorResumeNext", {
		enumerable: true,
		get: function() {
			return onErrorResumeNext_1.onErrorResumeNext;
		}
	});
	var pairs_1 = require_pairs();
	Object.defineProperty(exports, "pairs", {
		enumerable: true,
		get: function() {
			return pairs_1.pairs;
		}
	});
	var partition_1$1 = require_partition$1();
	Object.defineProperty(exports, "partition", {
		enumerable: true,
		get: function() {
			return partition_1$1.partition;
		}
	});
	var race_1$1 = require_race$1();
	Object.defineProperty(exports, "race", {
		enumerable: true,
		get: function() {
			return race_1$1.race;
		}
	});
	var range_1 = require_range();
	Object.defineProperty(exports, "range", {
		enumerable: true,
		get: function() {
			return range_1.range;
		}
	});
	var throwError_1 = require_throwError();
	Object.defineProperty(exports, "throwError", {
		enumerable: true,
		get: function() {
			return throwError_1.throwError;
		}
	});
	var timer_1 = require_timer();
	Object.defineProperty(exports, "timer", {
		enumerable: true,
		get: function() {
			return timer_1.timer;
		}
	});
	var using_1 = require_using();
	Object.defineProperty(exports, "using", {
		enumerable: true,
		get: function() {
			return using_1.using;
		}
	});
	var zip_1$1 = require_zip$1();
	Object.defineProperty(exports, "zip", {
		enumerable: true,
		get: function() {
			return zip_1$1.zip;
		}
	});
	var scheduled_1 = require_scheduled();
	Object.defineProperty(exports, "scheduled", {
		enumerable: true,
		get: function() {
			return scheduled_1.scheduled;
		}
	});
	var empty_2 = require_empty();
	Object.defineProperty(exports, "EMPTY", {
		enumerable: true,
		get: function() {
			return empty_2.EMPTY;
		}
	});
	var never_2 = require_never();
	Object.defineProperty(exports, "NEVER", {
		enumerable: true,
		get: function() {
			return never_2.NEVER;
		}
	});
	__exportStar$3(require_types$1(), exports);
	var config_1 = require_config();
	Object.defineProperty(exports, "config", {
		enumerable: true,
		get: function() {
			return config_1.config;
		}
	});
	var audit_1$1 = require_audit();
	Object.defineProperty(exports, "audit", {
		enumerable: true,
		get: function() {
			return audit_1$1.audit;
		}
	});
	var auditTime_1$1 = require_auditTime();
	Object.defineProperty(exports, "auditTime", {
		enumerable: true,
		get: function() {
			return auditTime_1$1.auditTime;
		}
	});
	var buffer_1$1 = require_buffer();
	Object.defineProperty(exports, "buffer", {
		enumerable: true,
		get: function() {
			return buffer_1$1.buffer;
		}
	});
	var bufferCount_1$1 = require_bufferCount();
	Object.defineProperty(exports, "bufferCount", {
		enumerable: true,
		get: function() {
			return bufferCount_1$1.bufferCount;
		}
	});
	var bufferTime_1$1 = require_bufferTime();
	Object.defineProperty(exports, "bufferTime", {
		enumerable: true,
		get: function() {
			return bufferTime_1$1.bufferTime;
		}
	});
	var bufferToggle_1$1 = require_bufferToggle();
	Object.defineProperty(exports, "bufferToggle", {
		enumerable: true,
		get: function() {
			return bufferToggle_1$1.bufferToggle;
		}
	});
	var bufferWhen_1$1 = require_bufferWhen();
	Object.defineProperty(exports, "bufferWhen", {
		enumerable: true,
		get: function() {
			return bufferWhen_1$1.bufferWhen;
		}
	});
	var catchError_1$1 = require_catchError();
	Object.defineProperty(exports, "catchError", {
		enumerable: true,
		get: function() {
			return catchError_1$1.catchError;
		}
	});
	var combineAll_1$1 = require_combineAll();
	Object.defineProperty(exports, "combineAll", {
		enumerable: true,
		get: function() {
			return combineAll_1$1.combineAll;
		}
	});
	var combineLatestAll_1$1 = require_combineLatestAll();
	Object.defineProperty(exports, "combineLatestAll", {
		enumerable: true,
		get: function() {
			return combineLatestAll_1$1.combineLatestAll;
		}
	});
	var combineLatestWith_1$1 = require_combineLatestWith();
	Object.defineProperty(exports, "combineLatestWith", {
		enumerable: true,
		get: function() {
			return combineLatestWith_1$1.combineLatestWith;
		}
	});
	var concatAll_1$1 = require_concatAll();
	Object.defineProperty(exports, "concatAll", {
		enumerable: true,
		get: function() {
			return concatAll_1$1.concatAll;
		}
	});
	var concatMap_1$1 = require_concatMap();
	Object.defineProperty(exports, "concatMap", {
		enumerable: true,
		get: function() {
			return concatMap_1$1.concatMap;
		}
	});
	var concatMapTo_1$1 = require_concatMapTo();
	Object.defineProperty(exports, "concatMapTo", {
		enumerable: true,
		get: function() {
			return concatMapTo_1$1.concatMapTo;
		}
	});
	var concatWith_1$1 = require_concatWith();
	Object.defineProperty(exports, "concatWith", {
		enumerable: true,
		get: function() {
			return concatWith_1$1.concatWith;
		}
	});
	var connect_1$1 = require_connect();
	Object.defineProperty(exports, "connect", {
		enumerable: true,
		get: function() {
			return connect_1$1.connect;
		}
	});
	var count_1$1 = require_count();
	Object.defineProperty(exports, "count", {
		enumerable: true,
		get: function() {
			return count_1$1.count;
		}
	});
	var debounce_1$1 = require_debounce();
	Object.defineProperty(exports, "debounce", {
		enumerable: true,
		get: function() {
			return debounce_1$1.debounce;
		}
	});
	var debounceTime_1$1 = require_debounceTime();
	Object.defineProperty(exports, "debounceTime", {
		enumerable: true,
		get: function() {
			return debounceTime_1$1.debounceTime;
		}
	});
	var defaultIfEmpty_1$1 = require_defaultIfEmpty();
	Object.defineProperty(exports, "defaultIfEmpty", {
		enumerable: true,
		get: function() {
			return defaultIfEmpty_1$1.defaultIfEmpty;
		}
	});
	var delay_1$1 = require_delay();
	Object.defineProperty(exports, "delay", {
		enumerable: true,
		get: function() {
			return delay_1$1.delay;
		}
	});
	var delayWhen_1$1 = require_delayWhen();
	Object.defineProperty(exports, "delayWhen", {
		enumerable: true,
		get: function() {
			return delayWhen_1$1.delayWhen;
		}
	});
	var dematerialize_1$1 = require_dematerialize();
	Object.defineProperty(exports, "dematerialize", {
		enumerable: true,
		get: function() {
			return dematerialize_1$1.dematerialize;
		}
	});
	var distinct_1$1 = require_distinct();
	Object.defineProperty(exports, "distinct", {
		enumerable: true,
		get: function() {
			return distinct_1$1.distinct;
		}
	});
	var distinctUntilChanged_1$1 = require_distinctUntilChanged();
	Object.defineProperty(exports, "distinctUntilChanged", {
		enumerable: true,
		get: function() {
			return distinctUntilChanged_1$1.distinctUntilChanged;
		}
	});
	var distinctUntilKeyChanged_1$1 = require_distinctUntilKeyChanged();
	Object.defineProperty(exports, "distinctUntilKeyChanged", {
		enumerable: true,
		get: function() {
			return distinctUntilKeyChanged_1$1.distinctUntilKeyChanged;
		}
	});
	var elementAt_1$1 = require_elementAt();
	Object.defineProperty(exports, "elementAt", {
		enumerable: true,
		get: function() {
			return elementAt_1$1.elementAt;
		}
	});
	var endWith_1$1 = require_endWith();
	Object.defineProperty(exports, "endWith", {
		enumerable: true,
		get: function() {
			return endWith_1$1.endWith;
		}
	});
	var every_1$1 = require_every();
	Object.defineProperty(exports, "every", {
		enumerable: true,
		get: function() {
			return every_1$1.every;
		}
	});
	var exhaust_1$1 = require_exhaust();
	Object.defineProperty(exports, "exhaust", {
		enumerable: true,
		get: function() {
			return exhaust_1$1.exhaust;
		}
	});
	var exhaustAll_1$1 = require_exhaustAll();
	Object.defineProperty(exports, "exhaustAll", {
		enumerable: true,
		get: function() {
			return exhaustAll_1$1.exhaustAll;
		}
	});
	var exhaustMap_1$1 = require_exhaustMap();
	Object.defineProperty(exports, "exhaustMap", {
		enumerable: true,
		get: function() {
			return exhaustMap_1$1.exhaustMap;
		}
	});
	var expand_1$1 = require_expand();
	Object.defineProperty(exports, "expand", {
		enumerable: true,
		get: function() {
			return expand_1$1.expand;
		}
	});
	var filter_1$2 = require_filter();
	Object.defineProperty(exports, "filter", {
		enumerable: true,
		get: function() {
			return filter_1$2.filter;
		}
	});
	var finalize_1$1 = require_finalize();
	Object.defineProperty(exports, "finalize", {
		enumerable: true,
		get: function() {
			return finalize_1$1.finalize;
		}
	});
	var find_1$1 = require_find();
	Object.defineProperty(exports, "find", {
		enumerable: true,
		get: function() {
			return find_1$1.find;
		}
	});
	var findIndex_1$1 = require_findIndex();
	Object.defineProperty(exports, "findIndex", {
		enumerable: true,
		get: function() {
			return findIndex_1$1.findIndex;
		}
	});
	var first_1$1 = require_first();
	Object.defineProperty(exports, "first", {
		enumerable: true,
		get: function() {
			return first_1$1.first;
		}
	});
	var groupBy_1$1 = require_groupBy();
	Object.defineProperty(exports, "groupBy", {
		enumerable: true,
		get: function() {
			return groupBy_1$1.groupBy;
		}
	});
	var ignoreElements_1$1 = require_ignoreElements();
	Object.defineProperty(exports, "ignoreElements", {
		enumerable: true,
		get: function() {
			return ignoreElements_1$1.ignoreElements;
		}
	});
	var isEmpty_1$1 = require_isEmpty();
	Object.defineProperty(exports, "isEmpty", {
		enumerable: true,
		get: function() {
			return isEmpty_1$1.isEmpty;
		}
	});
	var last_1$1 = require_last();
	Object.defineProperty(exports, "last", {
		enumerable: true,
		get: function() {
			return last_1$1.last;
		}
	});
	var map_1$3 = require_map();
	Object.defineProperty(exports, "map", {
		enumerable: true,
		get: function() {
			return map_1$3.map;
		}
	});
	var mapTo_1$1 = require_mapTo();
	Object.defineProperty(exports, "mapTo", {
		enumerable: true,
		get: function() {
			return mapTo_1$1.mapTo;
		}
	});
	var materialize_1$1 = require_materialize();
	Object.defineProperty(exports, "materialize", {
		enumerable: true,
		get: function() {
			return materialize_1$1.materialize;
		}
	});
	var max_1$1 = require_max();
	Object.defineProperty(exports, "max", {
		enumerable: true,
		get: function() {
			return max_1$1.max;
		}
	});
	var mergeAll_1$1 = require_mergeAll();
	Object.defineProperty(exports, "mergeAll", {
		enumerable: true,
		get: function() {
			return mergeAll_1$1.mergeAll;
		}
	});
	var flatMap_1$1 = require_flatMap();
	Object.defineProperty(exports, "flatMap", {
		enumerable: true,
		get: function() {
			return flatMap_1$1.flatMap;
		}
	});
	var mergeMap_1$1 = require_mergeMap();
	Object.defineProperty(exports, "mergeMap", {
		enumerable: true,
		get: function() {
			return mergeMap_1$1.mergeMap;
		}
	});
	var mergeMapTo_1$1 = require_mergeMapTo();
	Object.defineProperty(exports, "mergeMapTo", {
		enumerable: true,
		get: function() {
			return mergeMapTo_1$1.mergeMapTo;
		}
	});
	var mergeScan_1$1 = require_mergeScan();
	Object.defineProperty(exports, "mergeScan", {
		enumerable: true,
		get: function() {
			return mergeScan_1$1.mergeScan;
		}
	});
	var mergeWith_1$1 = require_mergeWith();
	Object.defineProperty(exports, "mergeWith", {
		enumerable: true,
		get: function() {
			return mergeWith_1$1.mergeWith;
		}
	});
	var min_1$1 = require_min();
	Object.defineProperty(exports, "min", {
		enumerable: true,
		get: function() {
			return min_1$1.min;
		}
	});
	var multicast_1$1 = require_multicast();
	Object.defineProperty(exports, "multicast", {
		enumerable: true,
		get: function() {
			return multicast_1$1.multicast;
		}
	});
	var observeOn_1$1 = require_observeOn();
	Object.defineProperty(exports, "observeOn", {
		enumerable: true,
		get: function() {
			return observeOn_1$1.observeOn;
		}
	});
	var onErrorResumeNextWith_1$1 = require_onErrorResumeNextWith();
	Object.defineProperty(exports, "onErrorResumeNextWith", {
		enumerable: true,
		get: function() {
			return onErrorResumeNextWith_1$1.onErrorResumeNextWith;
		}
	});
	var pairwise_1$1 = require_pairwise();
	Object.defineProperty(exports, "pairwise", {
		enumerable: true,
		get: function() {
			return pairwise_1$1.pairwise;
		}
	});
	var pluck_1$1 = require_pluck();
	Object.defineProperty(exports, "pluck", {
		enumerable: true,
		get: function() {
			return pluck_1$1.pluck;
		}
	});
	var publish_1$1 = require_publish();
	Object.defineProperty(exports, "publish", {
		enumerable: true,
		get: function() {
			return publish_1$1.publish;
		}
	});
	var publishBehavior_1$1 = require_publishBehavior();
	Object.defineProperty(exports, "publishBehavior", {
		enumerable: true,
		get: function() {
			return publishBehavior_1$1.publishBehavior;
		}
	});
	var publishLast_1$1 = require_publishLast();
	Object.defineProperty(exports, "publishLast", {
		enumerable: true,
		get: function() {
			return publishLast_1$1.publishLast;
		}
	});
	var publishReplay_1$1 = require_publishReplay();
	Object.defineProperty(exports, "publishReplay", {
		enumerable: true,
		get: function() {
			return publishReplay_1$1.publishReplay;
		}
	});
	var raceWith_1$2 = require_raceWith();
	Object.defineProperty(exports, "raceWith", {
		enumerable: true,
		get: function() {
			return raceWith_1$2.raceWith;
		}
	});
	var reduce_1$1 = require_reduce();
	Object.defineProperty(exports, "reduce", {
		enumerable: true,
		get: function() {
			return reduce_1$1.reduce;
		}
	});
	var repeat_1$1 = require_repeat();
	Object.defineProperty(exports, "repeat", {
		enumerable: true,
		get: function() {
			return repeat_1$1.repeat;
		}
	});
	var repeatWhen_1$1 = require_repeatWhen();
	Object.defineProperty(exports, "repeatWhen", {
		enumerable: true,
		get: function() {
			return repeatWhen_1$1.repeatWhen;
		}
	});
	var retry_1$1 = require_retry();
	Object.defineProperty(exports, "retry", {
		enumerable: true,
		get: function() {
			return retry_1$1.retry;
		}
	});
	var retryWhen_1$1 = require_retryWhen();
	Object.defineProperty(exports, "retryWhen", {
		enumerable: true,
		get: function() {
			return retryWhen_1$1.retryWhen;
		}
	});
	var refCount_1$1 = require_refCount();
	Object.defineProperty(exports, "refCount", {
		enumerable: true,
		get: function() {
			return refCount_1$1.refCount;
		}
	});
	var sample_1$1 = require_sample();
	Object.defineProperty(exports, "sample", {
		enumerable: true,
		get: function() {
			return sample_1$1.sample;
		}
	});
	var sampleTime_1$1 = require_sampleTime();
	Object.defineProperty(exports, "sampleTime", {
		enumerable: true,
		get: function() {
			return sampleTime_1$1.sampleTime;
		}
	});
	var scan_1$1 = require_scan();
	Object.defineProperty(exports, "scan", {
		enumerable: true,
		get: function() {
			return scan_1$1.scan;
		}
	});
	var sequenceEqual_1$1 = require_sequenceEqual();
	Object.defineProperty(exports, "sequenceEqual", {
		enumerable: true,
		get: function() {
			return sequenceEqual_1$1.sequenceEqual;
		}
	});
	var share_1$1 = require_share();
	Object.defineProperty(exports, "share", {
		enumerable: true,
		get: function() {
			return share_1$1.share;
		}
	});
	var shareReplay_1$1 = require_shareReplay();
	Object.defineProperty(exports, "shareReplay", {
		enumerable: true,
		get: function() {
			return shareReplay_1$1.shareReplay;
		}
	});
	var single_1$1 = require_single();
	Object.defineProperty(exports, "single", {
		enumerable: true,
		get: function() {
			return single_1$1.single;
		}
	});
	var skip_1$1 = require_skip();
	Object.defineProperty(exports, "skip", {
		enumerable: true,
		get: function() {
			return skip_1$1.skip;
		}
	});
	var skipLast_1$1 = require_skipLast();
	Object.defineProperty(exports, "skipLast", {
		enumerable: true,
		get: function() {
			return skipLast_1$1.skipLast;
		}
	});
	var skipUntil_1$1 = require_skipUntil();
	Object.defineProperty(exports, "skipUntil", {
		enumerable: true,
		get: function() {
			return skipUntil_1$1.skipUntil;
		}
	});
	var skipWhile_1$1 = require_skipWhile();
	Object.defineProperty(exports, "skipWhile", {
		enumerable: true,
		get: function() {
			return skipWhile_1$1.skipWhile;
		}
	});
	var startWith_1$1 = require_startWith();
	Object.defineProperty(exports, "startWith", {
		enumerable: true,
		get: function() {
			return startWith_1$1.startWith;
		}
	});
	var subscribeOn_1$1 = require_subscribeOn();
	Object.defineProperty(exports, "subscribeOn", {
		enumerable: true,
		get: function() {
			return subscribeOn_1$1.subscribeOn;
		}
	});
	var switchAll_1$1 = require_switchAll();
	Object.defineProperty(exports, "switchAll", {
		enumerable: true,
		get: function() {
			return switchAll_1$1.switchAll;
		}
	});
	var switchMap_1$1 = require_switchMap();
	Object.defineProperty(exports, "switchMap", {
		enumerable: true,
		get: function() {
			return switchMap_1$1.switchMap;
		}
	});
	var switchMapTo_1$1 = require_switchMapTo();
	Object.defineProperty(exports, "switchMapTo", {
		enumerable: true,
		get: function() {
			return switchMapTo_1$1.switchMapTo;
		}
	});
	var switchScan_1$1 = require_switchScan();
	Object.defineProperty(exports, "switchScan", {
		enumerable: true,
		get: function() {
			return switchScan_1$1.switchScan;
		}
	});
	var take_1$1 = require_take();
	Object.defineProperty(exports, "take", {
		enumerable: true,
		get: function() {
			return take_1$1.take;
		}
	});
	var takeLast_1$1 = require_takeLast();
	Object.defineProperty(exports, "takeLast", {
		enumerable: true,
		get: function() {
			return takeLast_1$1.takeLast;
		}
	});
	var takeUntil_1$1 = require_takeUntil();
	Object.defineProperty(exports, "takeUntil", {
		enumerable: true,
		get: function() {
			return takeUntil_1$1.takeUntil;
		}
	});
	var takeWhile_1$1 = require_takeWhile();
	Object.defineProperty(exports, "takeWhile", {
		enumerable: true,
		get: function() {
			return takeWhile_1$1.takeWhile;
		}
	});
	var tap_1$1 = require_tap();
	Object.defineProperty(exports, "tap", {
		enumerable: true,
		get: function() {
			return tap_1$1.tap;
		}
	});
	var throttle_1$1 = require_throttle();
	Object.defineProperty(exports, "throttle", {
		enumerable: true,
		get: function() {
			return throttle_1$1.throttle;
		}
	});
	var throttleTime_1$1 = require_throttleTime();
	Object.defineProperty(exports, "throttleTime", {
		enumerable: true,
		get: function() {
			return throttleTime_1$1.throttleTime;
		}
	});
	var throwIfEmpty_1$1 = require_throwIfEmpty();
	Object.defineProperty(exports, "throwIfEmpty", {
		enumerable: true,
		get: function() {
			return throwIfEmpty_1$1.throwIfEmpty;
		}
	});
	var timeInterval_1$1 = require_timeInterval();
	Object.defineProperty(exports, "timeInterval", {
		enumerable: true,
		get: function() {
			return timeInterval_1$1.timeInterval;
		}
	});
	var timeout_2 = require_timeout();
	Object.defineProperty(exports, "timeout", {
		enumerable: true,
		get: function() {
			return timeout_2.timeout;
		}
	});
	var timeoutWith_1$1 = require_timeoutWith();
	Object.defineProperty(exports, "timeoutWith", {
		enumerable: true,
		get: function() {
			return timeoutWith_1$1.timeoutWith;
		}
	});
	var timestamp_1$1 = require_timestamp$1();
	Object.defineProperty(exports, "timestamp", {
		enumerable: true,
		get: function() {
			return timestamp_1$1.timestamp;
		}
	});
	var toArray_1$1 = require_toArray();
	Object.defineProperty(exports, "toArray", {
		enumerable: true,
		get: function() {
			return toArray_1$1.toArray;
		}
	});
	var window_1$1 = require_window();
	Object.defineProperty(exports, "window", {
		enumerable: true,
		get: function() {
			return window_1$1.window;
		}
	});
	var windowCount_1$1 = require_windowCount();
	Object.defineProperty(exports, "windowCount", {
		enumerable: true,
		get: function() {
			return windowCount_1$1.windowCount;
		}
	});
	var windowTime_1$1 = require_windowTime();
	Object.defineProperty(exports, "windowTime", {
		enumerable: true,
		get: function() {
			return windowTime_1$1.windowTime;
		}
	});
	var windowToggle_1$1 = require_windowToggle();
	Object.defineProperty(exports, "windowToggle", {
		enumerable: true,
		get: function() {
			return windowToggle_1$1.windowToggle;
		}
	});
	var windowWhen_1$1 = require_windowWhen();
	Object.defineProperty(exports, "windowWhen", {
		enumerable: true,
		get: function() {
			return windowWhen_1$1.windowWhen;
		}
	});
	var withLatestFrom_1$1 = require_withLatestFrom();
	Object.defineProperty(exports, "withLatestFrom", {
		enumerable: true,
		get: function() {
			return withLatestFrom_1$1.withLatestFrom;
		}
	});
	var zipAll_1$1 = require_zipAll();
	Object.defineProperty(exports, "zipAll", {
		enumerable: true,
		get: function() {
			return zipAll_1$1.zipAll;
		}
	});
	var zipWith_1$1 = require_zipWith();
	Object.defineProperty(exports, "zipWith", {
		enumerable: true,
		get: function() {
			return zipWith_1$1.zipWith;
		}
	});
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/partition.js
var require_partition = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/partition.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var not_1 = require_not();
	var filter_1$1 = require_filter();
	function partition(predicate, thisArg) {
		return function(source) {
			return [filter_1$1.filter(predicate, thisArg)(source), filter_1$1.filter(not_1.not(predicate, thisArg))(source)];
		};
	}
	exports.partition = partition;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/internal/operators/race.js
var require_race = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/internal/operators/race.js": ((exports) => {
	var __read = exports && exports.__read || function(o, n$2) {
		var m$1 = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m$1) return o;
		var i = m$1.call(o), r, ar = [], e;
		try {
			while ((n$2 === void 0 || n$2-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = { error };
		} finally {
			try {
				if (r && !r.done && (m$1 = i["return"])) m$1.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	};
	var __spreadArray = exports && exports.__spreadArray || function(to$1, from$1) {
		for (var i = 0, il = from$1.length, j = to$1.length; i < il; i++, j++) to$1[j] = from$1[i];
		return to$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var argsOrArgArray_1 = require_argsOrArgArray();
	var raceWith_1$1 = require_raceWith();
	function race() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		return raceWith_1$1.raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray_1.argsOrArgArray(args))));
	}
	exports.race = race;
}) });

//#endregion
//#region node_modules/rxjs/dist/cjs/operators/index.js
var require_operators = /* @__PURE__ */ __commonJS({ "node_modules/rxjs/dist/cjs/operators/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.mergeAll = exports.merge = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.concat = exports.combineLatestWith = exports.combineLatest = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = void 0;
	exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.race = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.partition = exports.pairwise = exports.onErrorResumeNext = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = void 0;
	exports.zipWith = exports.zipAll = exports.zip = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = void 0;
	var audit_1 = require_audit();
	Object.defineProperty(exports, "audit", {
		enumerable: true,
		get: function() {
			return audit_1.audit;
		}
	});
	var auditTime_1 = require_auditTime();
	Object.defineProperty(exports, "auditTime", {
		enumerable: true,
		get: function() {
			return auditTime_1.auditTime;
		}
	});
	var buffer_1 = require_buffer();
	Object.defineProperty(exports, "buffer", {
		enumerable: true,
		get: function() {
			return buffer_1.buffer;
		}
	});
	var bufferCount_1 = require_bufferCount();
	Object.defineProperty(exports, "bufferCount", {
		enumerable: true,
		get: function() {
			return bufferCount_1.bufferCount;
		}
	});
	var bufferTime_1 = require_bufferTime();
	Object.defineProperty(exports, "bufferTime", {
		enumerable: true,
		get: function() {
			return bufferTime_1.bufferTime;
		}
	});
	var bufferToggle_1 = require_bufferToggle();
	Object.defineProperty(exports, "bufferToggle", {
		enumerable: true,
		get: function() {
			return bufferToggle_1.bufferToggle;
		}
	});
	var bufferWhen_1 = require_bufferWhen();
	Object.defineProperty(exports, "bufferWhen", {
		enumerable: true,
		get: function() {
			return bufferWhen_1.bufferWhen;
		}
	});
	var catchError_1 = require_catchError();
	Object.defineProperty(exports, "catchError", {
		enumerable: true,
		get: function() {
			return catchError_1.catchError;
		}
	});
	var combineAll_1 = require_combineAll();
	Object.defineProperty(exports, "combineAll", {
		enumerable: true,
		get: function() {
			return combineAll_1.combineAll;
		}
	});
	var combineLatestAll_1 = require_combineLatestAll();
	Object.defineProperty(exports, "combineLatestAll", {
		enumerable: true,
		get: function() {
			return combineLatestAll_1.combineLatestAll;
		}
	});
	var combineLatest_1 = require_combineLatest();
	Object.defineProperty(exports, "combineLatest", {
		enumerable: true,
		get: function() {
			return combineLatest_1.combineLatest;
		}
	});
	var combineLatestWith_1 = require_combineLatestWith();
	Object.defineProperty(exports, "combineLatestWith", {
		enumerable: true,
		get: function() {
			return combineLatestWith_1.combineLatestWith;
		}
	});
	var concat_1 = require_concat();
	Object.defineProperty(exports, "concat", {
		enumerable: true,
		get: function() {
			return concat_1.concat;
		}
	});
	var concatAll_1 = require_concatAll();
	Object.defineProperty(exports, "concatAll", {
		enumerable: true,
		get: function() {
			return concatAll_1.concatAll;
		}
	});
	var concatMap_1 = require_concatMap();
	Object.defineProperty(exports, "concatMap", {
		enumerable: true,
		get: function() {
			return concatMap_1.concatMap;
		}
	});
	var concatMapTo_1 = require_concatMapTo();
	Object.defineProperty(exports, "concatMapTo", {
		enumerable: true,
		get: function() {
			return concatMapTo_1.concatMapTo;
		}
	});
	var concatWith_1 = require_concatWith();
	Object.defineProperty(exports, "concatWith", {
		enumerable: true,
		get: function() {
			return concatWith_1.concatWith;
		}
	});
	var connect_1 = require_connect();
	Object.defineProperty(exports, "connect", {
		enumerable: true,
		get: function() {
			return connect_1.connect;
		}
	});
	var count_1 = require_count();
	Object.defineProperty(exports, "count", {
		enumerable: true,
		get: function() {
			return count_1.count;
		}
	});
	var debounce_1 = require_debounce();
	Object.defineProperty(exports, "debounce", {
		enumerable: true,
		get: function() {
			return debounce_1.debounce;
		}
	});
	var debounceTime_1 = require_debounceTime();
	Object.defineProperty(exports, "debounceTime", {
		enumerable: true,
		get: function() {
			return debounceTime_1.debounceTime;
		}
	});
	var defaultIfEmpty_1 = require_defaultIfEmpty();
	Object.defineProperty(exports, "defaultIfEmpty", {
		enumerable: true,
		get: function() {
			return defaultIfEmpty_1.defaultIfEmpty;
		}
	});
	var delay_1 = require_delay();
	Object.defineProperty(exports, "delay", {
		enumerable: true,
		get: function() {
			return delay_1.delay;
		}
	});
	var delayWhen_1 = require_delayWhen();
	Object.defineProperty(exports, "delayWhen", {
		enumerable: true,
		get: function() {
			return delayWhen_1.delayWhen;
		}
	});
	var dematerialize_1 = require_dematerialize();
	Object.defineProperty(exports, "dematerialize", {
		enumerable: true,
		get: function() {
			return dematerialize_1.dematerialize;
		}
	});
	var distinct_1 = require_distinct();
	Object.defineProperty(exports, "distinct", {
		enumerable: true,
		get: function() {
			return distinct_1.distinct;
		}
	});
	var distinctUntilChanged_1 = require_distinctUntilChanged();
	Object.defineProperty(exports, "distinctUntilChanged", {
		enumerable: true,
		get: function() {
			return distinctUntilChanged_1.distinctUntilChanged;
		}
	});
	var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
	Object.defineProperty(exports, "distinctUntilKeyChanged", {
		enumerable: true,
		get: function() {
			return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
		}
	});
	var elementAt_1 = require_elementAt();
	Object.defineProperty(exports, "elementAt", {
		enumerable: true,
		get: function() {
			return elementAt_1.elementAt;
		}
	});
	var endWith_1 = require_endWith();
	Object.defineProperty(exports, "endWith", {
		enumerable: true,
		get: function() {
			return endWith_1.endWith;
		}
	});
	var every_1 = require_every();
	Object.defineProperty(exports, "every", {
		enumerable: true,
		get: function() {
			return every_1.every;
		}
	});
	var exhaust_1 = require_exhaust();
	Object.defineProperty(exports, "exhaust", {
		enumerable: true,
		get: function() {
			return exhaust_1.exhaust;
		}
	});
	var exhaustAll_1 = require_exhaustAll();
	Object.defineProperty(exports, "exhaustAll", {
		enumerable: true,
		get: function() {
			return exhaustAll_1.exhaustAll;
		}
	});
	var exhaustMap_1 = require_exhaustMap();
	Object.defineProperty(exports, "exhaustMap", {
		enumerable: true,
		get: function() {
			return exhaustMap_1.exhaustMap;
		}
	});
	var expand_1 = require_expand();
	Object.defineProperty(exports, "expand", {
		enumerable: true,
		get: function() {
			return expand_1.expand;
		}
	});
	var filter_1 = require_filter();
	Object.defineProperty(exports, "filter", {
		enumerable: true,
		get: function() {
			return filter_1.filter;
		}
	});
	var finalize_1 = require_finalize();
	Object.defineProperty(exports, "finalize", {
		enumerable: true,
		get: function() {
			return finalize_1.finalize;
		}
	});
	var find_1 = require_find();
	Object.defineProperty(exports, "find", {
		enumerable: true,
		get: function() {
			return find_1.find;
		}
	});
	var findIndex_1 = require_findIndex();
	Object.defineProperty(exports, "findIndex", {
		enumerable: true,
		get: function() {
			return findIndex_1.findIndex;
		}
	});
	var first_1 = require_first();
	Object.defineProperty(exports, "first", {
		enumerable: true,
		get: function() {
			return first_1.first;
		}
	});
	var groupBy_1 = require_groupBy();
	Object.defineProperty(exports, "groupBy", {
		enumerable: true,
		get: function() {
			return groupBy_1.groupBy;
		}
	});
	var ignoreElements_1 = require_ignoreElements();
	Object.defineProperty(exports, "ignoreElements", {
		enumerable: true,
		get: function() {
			return ignoreElements_1.ignoreElements;
		}
	});
	var isEmpty_1 = require_isEmpty();
	Object.defineProperty(exports, "isEmpty", {
		enumerable: true,
		get: function() {
			return isEmpty_1.isEmpty;
		}
	});
	var last_1 = require_last();
	Object.defineProperty(exports, "last", {
		enumerable: true,
		get: function() {
			return last_1.last;
		}
	});
	var map_1$2 = require_map();
	Object.defineProperty(exports, "map", {
		enumerable: true,
		get: function() {
			return map_1$2.map;
		}
	});
	var mapTo_1 = require_mapTo();
	Object.defineProperty(exports, "mapTo", {
		enumerable: true,
		get: function() {
			return mapTo_1.mapTo;
		}
	});
	var materialize_1 = require_materialize();
	Object.defineProperty(exports, "materialize", {
		enumerable: true,
		get: function() {
			return materialize_1.materialize;
		}
	});
	var max_1 = require_max();
	Object.defineProperty(exports, "max", {
		enumerable: true,
		get: function() {
			return max_1.max;
		}
	});
	var merge_1 = require_merge$1();
	Object.defineProperty(exports, "merge", {
		enumerable: true,
		get: function() {
			return merge_1.merge;
		}
	});
	var mergeAll_1 = require_mergeAll();
	Object.defineProperty(exports, "mergeAll", {
		enumerable: true,
		get: function() {
			return mergeAll_1.mergeAll;
		}
	});
	var flatMap_1 = require_flatMap();
	Object.defineProperty(exports, "flatMap", {
		enumerable: true,
		get: function() {
			return flatMap_1.flatMap;
		}
	});
	var mergeMap_1 = require_mergeMap();
	Object.defineProperty(exports, "mergeMap", {
		enumerable: true,
		get: function() {
			return mergeMap_1.mergeMap;
		}
	});
	var mergeMapTo_1 = require_mergeMapTo();
	Object.defineProperty(exports, "mergeMapTo", {
		enumerable: true,
		get: function() {
			return mergeMapTo_1.mergeMapTo;
		}
	});
	var mergeScan_1 = require_mergeScan();
	Object.defineProperty(exports, "mergeScan", {
		enumerable: true,
		get: function() {
			return mergeScan_1.mergeScan;
		}
	});
	var mergeWith_1 = require_mergeWith();
	Object.defineProperty(exports, "mergeWith", {
		enumerable: true,
		get: function() {
			return mergeWith_1.mergeWith;
		}
	});
	var min_1 = require_min();
	Object.defineProperty(exports, "min", {
		enumerable: true,
		get: function() {
			return min_1.min;
		}
	});
	var multicast_1 = require_multicast();
	Object.defineProperty(exports, "multicast", {
		enumerable: true,
		get: function() {
			return multicast_1.multicast;
		}
	});
	var observeOn_1 = require_observeOn();
	Object.defineProperty(exports, "observeOn", {
		enumerable: true,
		get: function() {
			return observeOn_1.observeOn;
		}
	});
	var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
	Object.defineProperty(exports, "onErrorResumeNext", {
		enumerable: true,
		get: function() {
			return onErrorResumeNextWith_1.onErrorResumeNext;
		}
	});
	var pairwise_1 = require_pairwise();
	Object.defineProperty(exports, "pairwise", {
		enumerable: true,
		get: function() {
			return pairwise_1.pairwise;
		}
	});
	var partition_1 = require_partition();
	Object.defineProperty(exports, "partition", {
		enumerable: true,
		get: function() {
			return partition_1.partition;
		}
	});
	var pluck_1 = require_pluck();
	Object.defineProperty(exports, "pluck", {
		enumerable: true,
		get: function() {
			return pluck_1.pluck;
		}
	});
	var publish_1 = require_publish();
	Object.defineProperty(exports, "publish", {
		enumerable: true,
		get: function() {
			return publish_1.publish;
		}
	});
	var publishBehavior_1 = require_publishBehavior();
	Object.defineProperty(exports, "publishBehavior", {
		enumerable: true,
		get: function() {
			return publishBehavior_1.publishBehavior;
		}
	});
	var publishLast_1 = require_publishLast();
	Object.defineProperty(exports, "publishLast", {
		enumerable: true,
		get: function() {
			return publishLast_1.publishLast;
		}
	});
	var publishReplay_1 = require_publishReplay();
	Object.defineProperty(exports, "publishReplay", {
		enumerable: true,
		get: function() {
			return publishReplay_1.publishReplay;
		}
	});
	var race_1 = require_race();
	Object.defineProperty(exports, "race", {
		enumerable: true,
		get: function() {
			return race_1.race;
		}
	});
	var raceWith_1 = require_raceWith();
	Object.defineProperty(exports, "raceWith", {
		enumerable: true,
		get: function() {
			return raceWith_1.raceWith;
		}
	});
	var reduce_1 = require_reduce();
	Object.defineProperty(exports, "reduce", {
		enumerable: true,
		get: function() {
			return reduce_1.reduce;
		}
	});
	var repeat_1 = require_repeat();
	Object.defineProperty(exports, "repeat", {
		enumerable: true,
		get: function() {
			return repeat_1.repeat;
		}
	});
	var repeatWhen_1 = require_repeatWhen();
	Object.defineProperty(exports, "repeatWhen", {
		enumerable: true,
		get: function() {
			return repeatWhen_1.repeatWhen;
		}
	});
	var retry_1 = require_retry();
	Object.defineProperty(exports, "retry", {
		enumerable: true,
		get: function() {
			return retry_1.retry;
		}
	});
	var retryWhen_1 = require_retryWhen();
	Object.defineProperty(exports, "retryWhen", {
		enumerable: true,
		get: function() {
			return retryWhen_1.retryWhen;
		}
	});
	var refCount_1 = require_refCount();
	Object.defineProperty(exports, "refCount", {
		enumerable: true,
		get: function() {
			return refCount_1.refCount;
		}
	});
	var sample_1 = require_sample();
	Object.defineProperty(exports, "sample", {
		enumerable: true,
		get: function() {
			return sample_1.sample;
		}
	});
	var sampleTime_1 = require_sampleTime();
	Object.defineProperty(exports, "sampleTime", {
		enumerable: true,
		get: function() {
			return sampleTime_1.sampleTime;
		}
	});
	var scan_1 = require_scan();
	Object.defineProperty(exports, "scan", {
		enumerable: true,
		get: function() {
			return scan_1.scan;
		}
	});
	var sequenceEqual_1 = require_sequenceEqual();
	Object.defineProperty(exports, "sequenceEqual", {
		enumerable: true,
		get: function() {
			return sequenceEqual_1.sequenceEqual;
		}
	});
	var share_1 = require_share();
	Object.defineProperty(exports, "share", {
		enumerable: true,
		get: function() {
			return share_1.share;
		}
	});
	var shareReplay_1 = require_shareReplay();
	Object.defineProperty(exports, "shareReplay", {
		enumerable: true,
		get: function() {
			return shareReplay_1.shareReplay;
		}
	});
	var single_1 = require_single();
	Object.defineProperty(exports, "single", {
		enumerable: true,
		get: function() {
			return single_1.single;
		}
	});
	var skip_1 = require_skip();
	Object.defineProperty(exports, "skip", {
		enumerable: true,
		get: function() {
			return skip_1.skip;
		}
	});
	var skipLast_1 = require_skipLast();
	Object.defineProperty(exports, "skipLast", {
		enumerable: true,
		get: function() {
			return skipLast_1.skipLast;
		}
	});
	var skipUntil_1 = require_skipUntil();
	Object.defineProperty(exports, "skipUntil", {
		enumerable: true,
		get: function() {
			return skipUntil_1.skipUntil;
		}
	});
	var skipWhile_1 = require_skipWhile();
	Object.defineProperty(exports, "skipWhile", {
		enumerable: true,
		get: function() {
			return skipWhile_1.skipWhile;
		}
	});
	var startWith_1 = require_startWith();
	Object.defineProperty(exports, "startWith", {
		enumerable: true,
		get: function() {
			return startWith_1.startWith;
		}
	});
	var subscribeOn_1 = require_subscribeOn();
	Object.defineProperty(exports, "subscribeOn", {
		enumerable: true,
		get: function() {
			return subscribeOn_1.subscribeOn;
		}
	});
	var switchAll_1 = require_switchAll();
	Object.defineProperty(exports, "switchAll", {
		enumerable: true,
		get: function() {
			return switchAll_1.switchAll;
		}
	});
	var switchMap_1 = require_switchMap();
	Object.defineProperty(exports, "switchMap", {
		enumerable: true,
		get: function() {
			return switchMap_1.switchMap;
		}
	});
	var switchMapTo_1 = require_switchMapTo();
	Object.defineProperty(exports, "switchMapTo", {
		enumerable: true,
		get: function() {
			return switchMapTo_1.switchMapTo;
		}
	});
	var switchScan_1 = require_switchScan();
	Object.defineProperty(exports, "switchScan", {
		enumerable: true,
		get: function() {
			return switchScan_1.switchScan;
		}
	});
	var take_1 = require_take();
	Object.defineProperty(exports, "take", {
		enumerable: true,
		get: function() {
			return take_1.take;
		}
	});
	var takeLast_1 = require_takeLast();
	Object.defineProperty(exports, "takeLast", {
		enumerable: true,
		get: function() {
			return takeLast_1.takeLast;
		}
	});
	var takeUntil_1 = require_takeUntil();
	Object.defineProperty(exports, "takeUntil", {
		enumerable: true,
		get: function() {
			return takeUntil_1.takeUntil;
		}
	});
	var takeWhile_1 = require_takeWhile();
	Object.defineProperty(exports, "takeWhile", {
		enumerable: true,
		get: function() {
			return takeWhile_1.takeWhile;
		}
	});
	var tap_1 = require_tap();
	Object.defineProperty(exports, "tap", {
		enumerable: true,
		get: function() {
			return tap_1.tap;
		}
	});
	var throttle_1 = require_throttle();
	Object.defineProperty(exports, "throttle", {
		enumerable: true,
		get: function() {
			return throttle_1.throttle;
		}
	});
	var throttleTime_1 = require_throttleTime();
	Object.defineProperty(exports, "throttleTime", {
		enumerable: true,
		get: function() {
			return throttleTime_1.throttleTime;
		}
	});
	var throwIfEmpty_1 = require_throwIfEmpty();
	Object.defineProperty(exports, "throwIfEmpty", {
		enumerable: true,
		get: function() {
			return throwIfEmpty_1.throwIfEmpty;
		}
	});
	var timeInterval_1 = require_timeInterval();
	Object.defineProperty(exports, "timeInterval", {
		enumerable: true,
		get: function() {
			return timeInterval_1.timeInterval;
		}
	});
	var timeout_1 = require_timeout();
	Object.defineProperty(exports, "timeout", {
		enumerable: true,
		get: function() {
			return timeout_1.timeout;
		}
	});
	var timeoutWith_1 = require_timeoutWith();
	Object.defineProperty(exports, "timeoutWith", {
		enumerable: true,
		get: function() {
			return timeoutWith_1.timeoutWith;
		}
	});
	var timestamp_1 = require_timestamp$1();
	Object.defineProperty(exports, "timestamp", {
		enumerable: true,
		get: function() {
			return timestamp_1.timestamp;
		}
	});
	var toArray_1 = require_toArray();
	Object.defineProperty(exports, "toArray", {
		enumerable: true,
		get: function() {
			return toArray_1.toArray;
		}
	});
	var window_1 = require_window();
	Object.defineProperty(exports, "window", {
		enumerable: true,
		get: function() {
			return window_1.window;
		}
	});
	var windowCount_1 = require_windowCount();
	Object.defineProperty(exports, "windowCount", {
		enumerable: true,
		get: function() {
			return windowCount_1.windowCount;
		}
	});
	var windowTime_1 = require_windowTime();
	Object.defineProperty(exports, "windowTime", {
		enumerable: true,
		get: function() {
			return windowTime_1.windowTime;
		}
	});
	var windowToggle_1 = require_windowToggle();
	Object.defineProperty(exports, "windowToggle", {
		enumerable: true,
		get: function() {
			return windowToggle_1.windowToggle;
		}
	});
	var windowWhen_1 = require_windowWhen();
	Object.defineProperty(exports, "windowWhen", {
		enumerable: true,
		get: function() {
			return windowWhen_1.windowWhen;
		}
	});
	var withLatestFrom_1 = require_withLatestFrom();
	Object.defineProperty(exports, "withLatestFrom", {
		enumerable: true,
		get: function() {
			return withLatestFrom_1.withLatestFrom;
		}
	});
	var zip_1 = require_zip();
	Object.defineProperty(exports, "zip", {
		enumerable: true,
		get: function() {
			return zip_1.zip;
		}
	});
	var zipAll_1 = require_zipAll();
	Object.defineProperty(exports, "zipAll", {
		enumerable: true,
		get: function() {
			return zipAll_1.zipAll;
		}
	});
	var zipWith_1 = require_zipWith();
	Object.defineProperty(exports, "zipWith", {
		enumerable: true,
		get: function() {
			return zipWith_1.zipWith;
		}
	});
}) });

//#endregion
//#region node_modules/sass-embedded/node_modules/supports-color/browser.js
var require_browser = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/node_modules/supports-color/browser.js": ((exports, module) => {
	function getChromeVersion() {
		const matches = /(Chrome|Chromium)\/(?<chromeVersion>\d+)\./.exec(navigator.userAgent);
		if (!matches) return;
		return Number.parseInt(matches.groups.chromeVersion, 10);
	}
	var colorSupport = getChromeVersion() >= 69 ? {
		level: 1,
		hasBasic: true,
		has256: false,
		has16m: false
	} : false;
	module.exports = {
		stdout: colorSupport,
		stderr: colorSupport
	};
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/types.js
var require_types = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/types.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/timestamp_pb.js
var require_timestamp_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/timestamp_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TimestampSchema = exports.file_google_protobuf_timestamp = void 0;
	var file_js_1$13 = require_file();
	var message_js_1$13 = require_message();
	/**
	* Describes the file google/protobuf/timestamp.proto.
	*/
	exports.file_google_protobuf_timestamp = (0, file_js_1$13.fileDesc)("Ch9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvEg9nb29nbGUucHJvdG9idWYiKwoJVGltZXN0YW1wEg8KB3NlY29uZHMYASABKAMSDQoFbmFub3MYAiABKAVChQEKE2NvbS5nb29nbGUucHJvdG9idWZCDlRpbWVzdGFtcFByb3RvUAFaMmdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3RpbWVzdGFtcHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM");
	/**
	* Describes the message google.protobuf.Timestamp.
	* Use `create(TimestampSchema)` to create a new message.
	*/
	exports.TimestampSchema = (0, message_js_1$13.messageDesc)(exports.file_google_protobuf_timestamp, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/timestamp.js
var require_timestamp = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/timestamp.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.timestampNow = timestampNow;
	exports.timestampFromDate = timestampFromDate;
	exports.timestampDate = timestampDate;
	exports.timestampFromMs = timestampFromMs;
	exports.timestampMs = timestampMs;
	var timestamp_pb_js_1 = require_timestamp_pb();
	var create_js_1$4 = require_create();
	var proto_int64_js_1$2 = require_proto_int64();
	/**
	* Create a google.protobuf.Timestamp for the current time.
	*/
	function timestampNow() {
		return timestampFromDate(/* @__PURE__ */ new Date());
	}
	/**
	* Create a google.protobuf.Timestamp message from an ECMAScript Date.
	*/
	function timestampFromDate(date) {
		return timestampFromMs(date.getTime());
	}
	/**
	* Convert a google.protobuf.Timestamp message to an ECMAScript Date.
	*/
	function timestampDate(timestamp$1) {
		return new Date(timestampMs(timestamp$1));
	}
	/**
	* Create a google.protobuf.Timestamp message from a Unix timestamp in milliseconds.
	*/
	function timestampFromMs(timestampMs$1) {
		const seconds = Math.floor(timestampMs$1 / 1e3);
		return (0, create_js_1$4.create)(timestamp_pb_js_1.TimestampSchema, {
			seconds: proto_int64_js_1$2.protoInt64.parse(seconds),
			nanos: (timestampMs$1 - seconds * 1e3) * 1e6
		});
	}
	/**
	* Convert a google.protobuf.Timestamp to a Unix timestamp in milliseconds.
	*/
	function timestampMs(timestamp$1) {
		return Number(timestamp$1.seconds) * 1e3 + Math.round(timestamp$1.nanos / 1e6);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/duration_pb.js
var require_duration_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/duration_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DurationSchema = exports.file_google_protobuf_duration = void 0;
	var file_js_1$12 = require_file();
	var message_js_1$12 = require_message();
	/**
	* Describes the file google/protobuf/duration.proto.
	*/
	exports.file_google_protobuf_duration = (0, file_js_1$12.fileDesc)("Ch5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8SD2dvb2dsZS5wcm90b2J1ZiIqCghEdXJhdGlvbhIPCgdzZWNvbmRzGAEgASgDEg0KBW5hbm9zGAIgASgFQoMBChNjb20uZ29vZ2xlLnByb3RvYnVmQg1EdXJhdGlvblByb3RvUAFaMWdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2R1cmF0aW9ucGL4AQGiAgNHUEKqAh5Hb29nbGUuUHJvdG9idWYuV2VsbEtub3duVHlwZXNiBnByb3RvMw");
	/**
	* Describes the message google.protobuf.Duration.
	* Use `create(DurationSchema)` to create a new message.
	*/
	exports.DurationSchema = (0, message_js_1$12.messageDesc)(exports.file_google_protobuf_duration, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/duration.js
var require_duration = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/duration.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.durationFromMs = durationFromMs;
	exports.durationMs = durationMs;
	var duration_pb_js_1 = require_duration_pb();
	var create_js_1$3 = require_create();
	var proto_int64_js_1$1 = require_proto_int64();
	/**
	* Create a google.protobuf.Duration message from a Unix timestamp in milliseconds.
	*/
	function durationFromMs(durationMs$1) {
		const sign = durationMs$1 < 0 ? -1 : 1;
		const absDurationMs = Math.abs(durationMs$1);
		const absSeconds = Math.floor(absDurationMs / 1e3);
		const absNanos = (absDurationMs - absSeconds * 1e3) * 1e6;
		return (0, create_js_1$3.create)(duration_pb_js_1.DurationSchema, {
			seconds: proto_int64_js_1$1.protoInt64.parse(absSeconds * sign),
			nanos: absNanos === 0 ? 0 : absNanos * sign
		});
	}
	/**
	* Convert a google.protobuf.Duration to a Unix timestamp in milliseconds.
	*/
	function durationMs(duration) {
		return Number(duration.seconds) * 1e3 + Math.round(duration.nanos / 1e6);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/any_pb.js
var require_any_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/any_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AnySchema = exports.file_google_protobuf_any = void 0;
	var file_js_1$11 = require_file();
	var message_js_1$11 = require_message();
	/**
	* Describes the file google/protobuf/any.proto.
	*/
	exports.file_google_protobuf_any = (0, file_js_1$11.fileDesc)("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM");
	/**
	* Describes the message google.protobuf.Any.
	* Use `create(AnySchema)` to create a new message.
	*/
	exports.AnySchema = (0, message_js_1$11.messageDesc)(exports.file_google_protobuf_any, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/any.js
var require_any = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/any.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.anyPack = anyPack;
	exports.anyIs = anyIs;
	exports.anyUnpack = anyUnpack;
	exports.anyUnpackTo = anyUnpackTo;
	var any_pb_js_1$1 = require_any_pb();
	var create_js_1$2 = require_create();
	var to_binary_js_1$3 = require_to_binary();
	var from_binary_js_1$3 = require_from_binary();
	function anyPack(schema, message, into) {
		let ret = false;
		if (!into) {
			into = (0, create_js_1$2.create)(any_pb_js_1$1.AnySchema);
			ret = true;
		}
		into.value = (0, to_binary_js_1$3.toBinary)(schema, message);
		into.typeUrl = typeNameToUrl(message.$typeName);
		return ret ? into : void 0;
	}
	function anyIs(any, descOrTypeName) {
		if (any.typeUrl === "") return false;
		return (typeof descOrTypeName == "string" ? descOrTypeName : descOrTypeName.typeName) === typeUrlToName(any.typeUrl);
	}
	function anyUnpack(any, registryOrMessageDesc) {
		if (any.typeUrl === "") return;
		const desc = registryOrMessageDesc.kind == "message" ? registryOrMessageDesc : registryOrMessageDesc.getMessage(typeUrlToName(any.typeUrl));
		if (!desc || !anyIs(any, desc)) return;
		return (0, from_binary_js_1$3.fromBinary)(desc, any.value);
	}
	/**
	* Same as anyUnpack but unpacks into the target message.
	*/
	function anyUnpackTo(any, schema, message) {
		if (!anyIs(any, schema)) return;
		return (0, from_binary_js_1$3.mergeFromBinary)(schema, message, any.value);
	}
	function typeNameToUrl(name) {
		return `type.googleapis.com/${name}`;
	}
	function typeUrlToName(url$1) {
		const slash = url$1.lastIndexOf("/");
		const name = slash >= 0 ? url$1.substring(slash + 1) : url$1;
		if (!name.length) throw new Error(`invalid type url: ${url$1}`);
		return name;
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/source_context_pb.js
var require_source_context_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/source_context_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SourceContextSchema = exports.file_google_protobuf_source_context = void 0;
	var file_js_1$10 = require_file();
	var message_js_1$10 = require_message();
	/**
	* Describes the file google/protobuf/source_context.proto.
	*/
	exports.file_google_protobuf_source_context = (0, file_js_1$10.fileDesc)("CiRnb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQucHJvdG8SD2dvb2dsZS5wcm90b2J1ZiIiCg1Tb3VyY2VDb250ZXh0EhEKCWZpbGVfbmFtZRgBIAEoCUKKAQoTY29tLmdvb2dsZS5wcm90b2J1ZkISU291cmNlQ29udGV4dFByb3RvUAFaNmdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3NvdXJjZWNvbnRleHRwYqICA0dQQqoCHkdvb2dsZS5Qcm90b2J1Zi5XZWxsS25vd25UeXBlc2IGcHJvdG8z");
	/**
	* Describes the message google.protobuf.SourceContext.
	* Use `create(SourceContextSchema)` to create a new message.
	*/
	exports.SourceContextSchema = (0, message_js_1$10.messageDesc)(exports.file_google_protobuf_source_context, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/type_pb.js
var require_type_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/type_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SyntaxSchema = exports.Syntax = exports.OptionSchema = exports.EnumValueSchema = exports.EnumSchema = exports.Field_CardinalitySchema = exports.Field_Cardinality = exports.Field_KindSchema = exports.Field_Kind = exports.FieldSchema = exports.TypeSchema = exports.file_google_protobuf_type = void 0;
	var file_js_1$9 = require_file();
	var any_pb_js_1 = require_any_pb();
	var source_context_pb_js_1$1 = require_source_context_pb();
	var message_js_1$9 = require_message();
	var enum_js_1$5 = require_enum();
	/**
	* Describes the file google/protobuf/type.proto.
	*/
	exports.file_google_protobuf_type = (0, file_js_1$9.fileDesc)("Chpnb29nbGUvcHJvdG9idWYvdHlwZS5wcm90bxIPZ29vZ2xlLnByb3RvYnVmIugBCgRUeXBlEgwKBG5hbWUYASABKAkSJgoGZmllbGRzGAIgAygLMhYuZ29vZ2xlLnByb3RvYnVmLkZpZWxkEg4KBm9uZW9mcxgDIAMoCRIoCgdvcHRpb25zGAQgAygLMhcuZ29vZ2xlLnByb3RvYnVmLk9wdGlvbhI2Cg5zb3VyY2VfY29udGV4dBgFIAEoCzIeLmdvb2dsZS5wcm90b2J1Zi5Tb3VyY2VDb250ZXh0EicKBnN5bnRheBgGIAEoDjIXLmdvb2dsZS5wcm90b2J1Zi5TeW50YXgSDwoHZWRpdGlvbhgHIAEoCSLVBQoFRmllbGQSKQoEa2luZBgBIAEoDjIbLmdvb2dsZS5wcm90b2J1Zi5GaWVsZC5LaW5kEjcKC2NhcmRpbmFsaXR5GAIgASgOMiIuZ29vZ2xlLnByb3RvYnVmLkZpZWxkLkNhcmRpbmFsaXR5Eg4KBm51bWJlchgDIAEoBRIMCgRuYW1lGAQgASgJEhAKCHR5cGVfdXJsGAYgASgJEhMKC29uZW9mX2luZGV4GAcgASgFEg4KBnBhY2tlZBgIIAEoCBIoCgdvcHRpb25zGAkgAygLMhcuZ29vZ2xlLnByb3RvYnVmLk9wdGlvbhIRCglqc29uX25hbWUYCiABKAkSFQoNZGVmYXVsdF92YWx1ZRgLIAEoCSLIAgoES2luZBIQCgxUWVBFX1VOS05PV04QABIPCgtUWVBFX0RPVUJMRRABEg4KClRZUEVfRkxPQVQQAhIOCgpUWVBFX0lOVDY0EAMSDwoLVFlQRV9VSU5UNjQQBBIOCgpUWVBFX0lOVDMyEAUSEAoMVFlQRV9GSVhFRDY0EAYSEAoMVFlQRV9GSVhFRDMyEAcSDQoJVFlQRV9CT09MEAgSDwoLVFlQRV9TVFJJTkcQCRIOCgpUWVBFX0dST1VQEAoSEAoMVFlQRV9NRVNTQUdFEAsSDgoKVFlQRV9CWVRFUxAMEg8KC1RZUEVfVUlOVDMyEA0SDQoJVFlQRV9FTlVNEA4SEQoNVFlQRV9TRklYRUQzMhAPEhEKDVRZUEVfU0ZJWEVENjQQEBIPCgtUWVBFX1NJTlQzMhAREg8KC1RZUEVfU0lOVDY0EBIidAoLQ2FyZGluYWxpdHkSFwoTQ0FSRElOQUxJVFlfVU5LTk9XThAAEhgKFENBUkRJTkFMSVRZX09QVElPTkFMEAESGAoUQ0FSRElOQUxJVFlfUkVRVUlSRUQQAhIYChRDQVJESU5BTElUWV9SRVBFQVRFRBADIt8BCgRFbnVtEgwKBG5hbWUYASABKAkSLQoJZW51bXZhbHVlGAIgAygLMhouZ29vZ2xlLnByb3RvYnVmLkVudW1WYWx1ZRIoCgdvcHRpb25zGAMgAygLMhcuZ29vZ2xlLnByb3RvYnVmLk9wdGlvbhI2Cg5zb3VyY2VfY29udGV4dBgEIAEoCzIeLmdvb2dsZS5wcm90b2J1Zi5Tb3VyY2VDb250ZXh0EicKBnN5bnRheBgFIAEoDjIXLmdvb2dsZS5wcm90b2J1Zi5TeW50YXgSDwoHZWRpdGlvbhgGIAEoCSJTCglFbnVtVmFsdWUSDAoEbmFtZRgBIAEoCRIOCgZudW1iZXIYAiABKAUSKAoHb3B0aW9ucxgDIAMoCzIXLmdvb2dsZS5wcm90b2J1Zi5PcHRpb24iOwoGT3B0aW9uEgwKBG5hbWUYASABKAkSIwoFdmFsdWUYAiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55KkMKBlN5bnRheBIRCg1TWU5UQVhfUFJPVE8yEAASEQoNU1lOVEFYX1BST1RPMxABEhMKD1NZTlRBWF9FRElUSU9OUxACQnsKE2NvbS5nb29nbGUucHJvdG9idWZCCVR5cGVQcm90b1ABWi1nb29nbGUuZ29sYW5nLm9yZy9wcm90b2J1Zi90eXBlcy9rbm93bi90eXBlcGL4AQGiAgNHUEKqAh5Hb29nbGUuUHJvdG9idWYuV2VsbEtub3duVHlwZXNiBnByb3RvMw", [any_pb_js_1.file_google_protobuf_any, source_context_pb_js_1$1.file_google_protobuf_source_context]);
	/**
	* Describes the message google.protobuf.Type.
	* Use `create(TypeSchema)` to create a new message.
	*/
	exports.TypeSchema = (0, message_js_1$9.messageDesc)(exports.file_google_protobuf_type, 0);
	/**
	* Describes the message google.protobuf.Field.
	* Use `create(FieldSchema)` to create a new message.
	*/
	exports.FieldSchema = (0, message_js_1$9.messageDesc)(exports.file_google_protobuf_type, 1);
	/**
	* Basic field types.
	*
	* @generated from enum google.protobuf.Field.Kind
	*/
	var Field_Kind;
	(function(Field_Kind$1) {
		/**
		* Field type unknown.
		*
		* @generated from enum value: TYPE_UNKNOWN = 0;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_UNKNOWN"] = 0] = "TYPE_UNKNOWN";
		/**
		* Field type double.
		*
		* @generated from enum value: TYPE_DOUBLE = 1;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
		/**
		* Field type float.
		*
		* @generated from enum value: TYPE_FLOAT = 2;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
		/**
		* Field type int64.
		*
		* @generated from enum value: TYPE_INT64 = 3;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_INT64"] = 3] = "TYPE_INT64";
		/**
		* Field type uint64.
		*
		* @generated from enum value: TYPE_UINT64 = 4;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_UINT64"] = 4] = "TYPE_UINT64";
		/**
		* Field type int32.
		*
		* @generated from enum value: TYPE_INT32 = 5;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_INT32"] = 5] = "TYPE_INT32";
		/**
		* Field type fixed64.
		*
		* @generated from enum value: TYPE_FIXED64 = 6;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
		/**
		* Field type fixed32.
		*
		* @generated from enum value: TYPE_FIXED32 = 7;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
		/**
		* Field type bool.
		*
		* @generated from enum value: TYPE_BOOL = 8;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_BOOL"] = 8] = "TYPE_BOOL";
		/**
		* Field type string.
		*
		* @generated from enum value: TYPE_STRING = 9;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_STRING"] = 9] = "TYPE_STRING";
		/**
		* Field type group. Proto2 syntax only, and deprecated.
		*
		* @generated from enum value: TYPE_GROUP = 10;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_GROUP"] = 10] = "TYPE_GROUP";
		/**
		* Field type message.
		*
		* @generated from enum value: TYPE_MESSAGE = 11;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
		/**
		* Field type bytes.
		*
		* @generated from enum value: TYPE_BYTES = 12;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_BYTES"] = 12] = "TYPE_BYTES";
		/**
		* Field type uint32.
		*
		* @generated from enum value: TYPE_UINT32 = 13;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_UINT32"] = 13] = "TYPE_UINT32";
		/**
		* Field type enum.
		*
		* @generated from enum value: TYPE_ENUM = 14;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_ENUM"] = 14] = "TYPE_ENUM";
		/**
		* Field type sfixed32.
		*
		* @generated from enum value: TYPE_SFIXED32 = 15;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
		/**
		* Field type sfixed64.
		*
		* @generated from enum value: TYPE_SFIXED64 = 16;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
		/**
		* Field type sint32.
		*
		* @generated from enum value: TYPE_SINT32 = 17;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_SINT32"] = 17] = "TYPE_SINT32";
		/**
		* Field type sint64.
		*
		* @generated from enum value: TYPE_SINT64 = 18;
		*/
		Field_Kind$1[Field_Kind$1["TYPE_SINT64"] = 18] = "TYPE_SINT64";
	})(Field_Kind || (exports.Field_Kind = Field_Kind = {}));
	/**
	* Describes the enum google.protobuf.Field.Kind.
	*/
	exports.Field_KindSchema = (0, enum_js_1$5.enumDesc)(exports.file_google_protobuf_type, 1, 0);
	/**
	* Whether a field is optional, required, or repeated.
	*
	* @generated from enum google.protobuf.Field.Cardinality
	*/
	var Field_Cardinality;
	(function(Field_Cardinality$1) {
		/**
		* For fields with unknown cardinality.
		*
		* @generated from enum value: CARDINALITY_UNKNOWN = 0;
		*/
		Field_Cardinality$1[Field_Cardinality$1["UNKNOWN"] = 0] = "UNKNOWN";
		/**
		* For optional fields.
		*
		* @generated from enum value: CARDINALITY_OPTIONAL = 1;
		*/
		Field_Cardinality$1[Field_Cardinality$1["OPTIONAL"] = 1] = "OPTIONAL";
		/**
		* For required fields. Proto2 syntax only.
		*
		* @generated from enum value: CARDINALITY_REQUIRED = 2;
		*/
		Field_Cardinality$1[Field_Cardinality$1["REQUIRED"] = 2] = "REQUIRED";
		/**
		* For repeated fields.
		*
		* @generated from enum value: CARDINALITY_REPEATED = 3;
		*/
		Field_Cardinality$1[Field_Cardinality$1["REPEATED"] = 3] = "REPEATED";
	})(Field_Cardinality || (exports.Field_Cardinality = Field_Cardinality = {}));
	/**
	* Describes the enum google.protobuf.Field.Cardinality.
	*/
	exports.Field_CardinalitySchema = (0, enum_js_1$5.enumDesc)(exports.file_google_protobuf_type, 1, 1);
	/**
	* Describes the message google.protobuf.Enum.
	* Use `create(EnumSchema)` to create a new message.
	*/
	exports.EnumSchema = (0, message_js_1$9.messageDesc)(exports.file_google_protobuf_type, 2);
	/**
	* Describes the message google.protobuf.EnumValue.
	* Use `create(EnumValueSchema)` to create a new message.
	*/
	exports.EnumValueSchema = (0, message_js_1$9.messageDesc)(exports.file_google_protobuf_type, 3);
	/**
	* Describes the message google.protobuf.Option.
	* Use `create(OptionSchema)` to create a new message.
	*/
	exports.OptionSchema = (0, message_js_1$9.messageDesc)(exports.file_google_protobuf_type, 4);
	/**
	* The syntax in which a protocol buffer element is defined.
	*
	* @generated from enum google.protobuf.Syntax
	*/
	var Syntax;
	(function(Syntax$2) {
		/**
		* Syntax `proto2`.
		*
		* @generated from enum value: SYNTAX_PROTO2 = 0;
		*/
		Syntax$2[Syntax$2["PROTO2"] = 0] = "PROTO2";
		/**
		* Syntax `proto3`.
		*
		* @generated from enum value: SYNTAX_PROTO3 = 1;
		*/
		Syntax$2[Syntax$2["PROTO3"] = 1] = "PROTO3";
		/**
		* Syntax `editions`.
		*
		* @generated from enum value: SYNTAX_EDITIONS = 2;
		*/
		Syntax$2[Syntax$2["EDITIONS"] = 2] = "EDITIONS";
	})(Syntax || (exports.Syntax = Syntax = {}));
	/**
	* Describes the enum google.protobuf.Syntax.
	*/
	exports.SyntaxSchema = (0, enum_js_1$5.enumDesc)(exports.file_google_protobuf_type, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/api_pb.js
var require_api_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/api_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MixinSchema = exports.MethodSchema = exports.ApiSchema = exports.file_google_protobuf_api = void 0;
	var file_js_1$8 = require_file();
	var source_context_pb_js_1 = require_source_context_pb();
	var type_pb_js_1 = require_type_pb();
	var message_js_1$8 = require_message();
	/**
	* Describes the file google/protobuf/api.proto.
	*/
	exports.file_google_protobuf_api = (0, file_js_1$8.fileDesc)("Chlnb29nbGUvcHJvdG9idWYvYXBpLnByb3RvEg9nb29nbGUucHJvdG9idWYikgIKA0FwaRIMCgRuYW1lGAEgASgJEigKB21ldGhvZHMYAiADKAsyFy5nb29nbGUucHJvdG9idWYuTWV0aG9kEigKB29wdGlvbnMYAyADKAsyFy5nb29nbGUucHJvdG9idWYuT3B0aW9uEg8KB3ZlcnNpb24YBCABKAkSNgoOc291cmNlX2NvbnRleHQYBSABKAsyHi5nb29nbGUucHJvdG9idWYuU291cmNlQ29udGV4dBImCgZtaXhpbnMYBiADKAsyFi5nb29nbGUucHJvdG9idWYuTWl4aW4SJwoGc3ludGF4GAcgASgOMhcuZ29vZ2xlLnByb3RvYnVmLlN5bnRheBIPCgdlZGl0aW9uGAggASgJIu4BCgZNZXRob2QSDAoEbmFtZRgBIAEoCRIYChByZXF1ZXN0X3R5cGVfdXJsGAIgASgJEhkKEXJlcXVlc3Rfc3RyZWFtaW5nGAMgASgIEhkKEXJlc3BvbnNlX3R5cGVfdXJsGAQgASgJEhoKEnJlc3BvbnNlX3N0cmVhbWluZxgFIAEoCBIoCgdvcHRpb25zGAYgAygLMhcuZ29vZ2xlLnByb3RvYnVmLk9wdGlvbhIrCgZzeW50YXgYByABKA4yFy5nb29nbGUucHJvdG9idWYuU3ludGF4QgIYARITCgdlZGl0aW9uGAggASgJQgIYASIjCgVNaXhpbhIMCgRuYW1lGAEgASgJEgwKBHJvb3QYAiABKAlCdgoTY29tLmdvb2dsZS5wcm90b2J1ZkIIQXBpUHJvdG9QAVosZ29vZ2xlLmdvbGFuZy5vcmcvcHJvdG9idWYvdHlwZXMva25vd24vYXBpcGKiAgNHUEKqAh5Hb29nbGUuUHJvdG9idWYuV2VsbEtub3duVHlwZXNiBnByb3RvMw", [source_context_pb_js_1.file_google_protobuf_source_context, type_pb_js_1.file_google_protobuf_type]);
	/**
	* Describes the message google.protobuf.Api.
	* Use `create(ApiSchema)` to create a new message.
	*/
	exports.ApiSchema = (0, message_js_1$8.messageDesc)(exports.file_google_protobuf_api, 0);
	/**
	* Describes the message google.protobuf.Method.
	* Use `create(MethodSchema)` to create a new message.
	*/
	exports.MethodSchema = (0, message_js_1$8.messageDesc)(exports.file_google_protobuf_api, 1);
	/**
	* Describes the message google.protobuf.Mixin.
	* Use `create(MixinSchema)` to create a new message.
	*/
	exports.MixinSchema = (0, message_js_1$8.messageDesc)(exports.file_google_protobuf_api, 2);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/cpp_features_pb.js
var require_cpp_features_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/cpp_features_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cpp = exports.CppFeatures_StringTypeSchema = exports.CppFeatures_StringType = exports.CppFeaturesSchema = exports.file_google_protobuf_cpp_features = void 0;
	var file_js_1$7 = require_file();
	var descriptor_pb_js_1$3 = require_descriptor_pb();
	var message_js_1$7 = require_message();
	var enum_js_1$4 = require_enum();
	var extension_js_1$2 = require_extension();
	/**
	* Describes the file google/protobuf/cpp_features.proto.
	*/
	exports.file_google_protobuf_cpp_features = (0, file_js_1$7.fileDesc)("CiJnb29nbGUvcHJvdG9idWYvY3BwX2ZlYXR1cmVzLnByb3RvEgJwYiL8AwoLQ3BwRmVhdHVyZXMS+wEKEmxlZ2FjeV9jbG9zZWRfZW51bRgBIAEoCELeAYgBAZgBBJgBAaIBCRIEdHJ1ZRiEB6IBChIFZmFsc2UY5weyAbgBCOgHEOgHGq8BVGhlIGxlZ2FjeSBjbG9zZWQgZW51bSBiZWhhdmlvciBpbiBDKysgaXMgZGVwcmVjYXRlZCBhbmQgaXMgc2NoZWR1bGVkIHRvIGJlIHJlbW92ZWQgaW4gZWRpdGlvbiAyMDI1LiAgU2VlIGh0dHA6Ly9wcm90b2J1Zi5kZXYvcHJvZ3JhbW1pbmctZ3VpZGVzL2VudW0vI2NwcCBmb3IgbW9yZSBpbmZvcm1hdGlvbhJaCgtzdHJpbmdfdHlwZRgCIAEoDjIaLnBiLkNwcEZlYXR1cmVzLlN0cmluZ1R5cGVCKYgBAZgBBJgBAaIBCxIGU1RSSU5HGIQHogEJEgRWSUVXGOkHsgEDCOgHEkwKGmVudW1fbmFtZV91c2VzX3N0cmluZ192aWV3GAMgASgIQiiIAQGYAQaYAQGiAQoSBWZhbHNlGIQHogEJEgR0cnVlGOkHsgEDCOkHIkUKClN0cmluZ1R5cGUSFwoTU1RSSU5HX1RZUEVfVU5LTk9XThAAEggKBFZJRVcQARIICgRDT1JEEAISCgoGU1RSSU5HEAM6PwoDY3BwEhsuZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQY6AcgASgLMg8ucGIuQ3BwRmVhdHVyZXNSA2NwcA", [descriptor_pb_js_1$3.file_google_protobuf_descriptor]);
	/**
	* Describes the message pb.CppFeatures.
	* Use `create(CppFeaturesSchema)` to create a new message.
	*/
	exports.CppFeaturesSchema = (0, message_js_1$7.messageDesc)(exports.file_google_protobuf_cpp_features, 0);
	/**
	* @generated from enum pb.CppFeatures.StringType
	*/
	var CppFeatures_StringType;
	(function(CppFeatures_StringType$1) {
		/**
		* @generated from enum value: STRING_TYPE_UNKNOWN = 0;
		*/
		CppFeatures_StringType$1[CppFeatures_StringType$1["STRING_TYPE_UNKNOWN"] = 0] = "STRING_TYPE_UNKNOWN";
		/**
		* @generated from enum value: VIEW = 1;
		*/
		CppFeatures_StringType$1[CppFeatures_StringType$1["VIEW"] = 1] = "VIEW";
		/**
		* @generated from enum value: CORD = 2;
		*/
		CppFeatures_StringType$1[CppFeatures_StringType$1["CORD"] = 2] = "CORD";
		/**
		* @generated from enum value: STRING = 3;
		*/
		CppFeatures_StringType$1[CppFeatures_StringType$1["STRING"] = 3] = "STRING";
	})(CppFeatures_StringType || (exports.CppFeatures_StringType = CppFeatures_StringType = {}));
	/**
	* Describes the enum pb.CppFeatures.StringType.
	*/
	exports.CppFeatures_StringTypeSchema = (0, enum_js_1$4.enumDesc)(exports.file_google_protobuf_cpp_features, 0, 0);
	/**
	* @generated from extension: optional pb.CppFeatures cpp = 1000;
	*/
	exports.cpp = (0, extension_js_1$2.extDesc)(exports.file_google_protobuf_cpp_features, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/empty_pb.js
var require_empty_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/empty_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.EmptySchema = exports.file_google_protobuf_empty = void 0;
	var file_js_1$6 = require_file();
	var message_js_1$6 = require_message();
	/**
	* Describes the file google/protobuf/empty.proto.
	*/
	exports.file_google_protobuf_empty = (0, file_js_1$6.fileDesc)("Chtnb29nbGUvcHJvdG9idWYvZW1wdHkucHJvdG8SD2dvb2dsZS5wcm90b2J1ZiIHCgVFbXB0eUJ9ChNjb20uZ29vZ2xlLnByb3RvYnVmQgpFbXB0eVByb3RvUAFaLmdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2VtcHR5cGL4AQGiAgNHUEKqAh5Hb29nbGUuUHJvdG9idWYuV2VsbEtub3duVHlwZXNiBnByb3RvMw");
	/**
	* Describes the message google.protobuf.Empty.
	* Use `create(EmptySchema)` to create a new message.
	*/
	exports.EmptySchema = (0, message_js_1$6.messageDesc)(exports.file_google_protobuf_empty, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/field_mask_pb.js
var require_field_mask_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/field_mask_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FieldMaskSchema = exports.file_google_protobuf_field_mask = void 0;
	var file_js_1$5 = require_file();
	var message_js_1$5 = require_message();
	/**
	* Describes the file google/protobuf/field_mask.proto.
	*/
	exports.file_google_protobuf_field_mask = (0, file_js_1$5.fileDesc)("CiBnb29nbGUvcHJvdG9idWYvZmllbGRfbWFzay5wcm90bxIPZ29vZ2xlLnByb3RvYnVmIhoKCUZpZWxkTWFzaxINCgVwYXRocxgBIAMoCUKFAQoTY29tLmdvb2dsZS5wcm90b2J1ZkIORmllbGRNYXNrUHJvdG9QAVoyZ29vZ2xlLmdvbGFuZy5vcmcvcHJvdG9idWYvdHlwZXMva25vd24vZmllbGRtYXNrcGL4AQGiAgNHUEKqAh5Hb29nbGUuUHJvdG9idWYuV2VsbEtub3duVHlwZXNiBnByb3RvMw");
	/**
	* Describes the message google.protobuf.FieldMask.
	* Use `create(FieldMaskSchema)` to create a new message.
	*/
	exports.FieldMaskSchema = (0, message_js_1$5.messageDesc)(exports.file_google_protobuf_field_mask, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/go_features_pb.js
var require_go_features_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/go_features_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.go = exports.GoFeatures_StripEnumPrefixSchema = exports.GoFeatures_StripEnumPrefix = exports.GoFeatures_APILevelSchema = exports.GoFeatures_APILevel = exports.GoFeaturesSchema = exports.file_google_protobuf_go_features = void 0;
	var file_js_1$4 = require_file();
	var descriptor_pb_js_1$2 = require_descriptor_pb();
	var message_js_1$4 = require_message();
	var enum_js_1$3 = require_enum();
	var extension_js_1$1 = require_extension();
	/**
	* Describes the file google/protobuf/go_features.proto.
	*/
	exports.file_google_protobuf_go_features = (0, file_js_1$4.fileDesc)("CiFnb29nbGUvcHJvdG9idWYvZ29fZmVhdHVyZXMucHJvdG8SAnBiIvcECgpHb0ZlYXR1cmVzEqUBChpsZWdhY3lfdW5tYXJzaGFsX2pzb25fZW51bRgBIAEoCEKAAYgBAZgBBpgBAaIBCRIEdHJ1ZRiEB6IBChIFZmFsc2UY5weyAVsI6AcQ6AcaU1RoZSBsZWdhY3kgVW5tYXJzaGFsSlNPTiBBUEkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIGVkaXRpb24uEmoKCWFwaV9sZXZlbBgCIAEoDjIXLnBiLkdvRmVhdHVyZXMuQVBJTGV2ZWxCPogBAZgBA5gBAaIBGhIVQVBJX0xFVkVMX1VOU1BFQ0lGSUVEGIQHogEPEgpBUElfT1BBUVVFGOkHsgEDCOgHEmsKEXN0cmlwX2VudW1fcHJlZml4GAMgASgOMh4ucGIuR29GZWF0dXJlcy5TdHJpcEVudW1QcmVmaXhCMIgBAZgBBpgBB5gBAaIBGxIWU1RSSVBfRU5VTV9QUkVGSVhfS0VFUBiEB7IBAwjpByJTCghBUElMZXZlbBIZChVBUElfTEVWRUxfVU5TUEVDSUZJRUQQABIMCghBUElfT1BFThABEg4KCkFQSV9IWUJSSUQQAhIOCgpBUElfT1BBUVVFEAMikgEKD1N0cmlwRW51bVByZWZpeBIhCh1TVFJJUF9FTlVNX1BSRUZJWF9VTlNQRUNJRklFRBAAEhoKFlNUUklQX0VOVU1fUFJFRklYX0tFRVAQARIjCh9TVFJJUF9FTlVNX1BSRUZJWF9HRU5FUkFURV9CT1RIEAISGwoXU1RSSVBfRU5VTV9QUkVGSVhfU1RSSVAQAzo8CgJnbxIbLmdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0GOoHIAEoCzIOLnBiLkdvRmVhdHVyZXNSAmdvQi9aLWdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2dvZmVhdHVyZXNwYg", [descriptor_pb_js_1$2.file_google_protobuf_descriptor]);
	/**
	* Describes the message pb.GoFeatures.
	* Use `create(GoFeaturesSchema)` to create a new message.
	*/
	exports.GoFeaturesSchema = (0, message_js_1$4.messageDesc)(exports.file_google_protobuf_go_features, 0);
	/**
	* @generated from enum pb.GoFeatures.APILevel
	*/
	var GoFeatures_APILevel;
	(function(GoFeatures_APILevel$1) {
		/**
		* API_LEVEL_UNSPECIFIED results in selecting the OPEN API,
		* but needs to be a separate value to distinguish between
		* an explicitly set api level or a missing api level.
		*
		* @generated from enum value: API_LEVEL_UNSPECIFIED = 0;
		*/
		GoFeatures_APILevel$1[GoFeatures_APILevel$1["API_LEVEL_UNSPECIFIED"] = 0] = "API_LEVEL_UNSPECIFIED";
		/**
		* @generated from enum value: API_OPEN = 1;
		*/
		GoFeatures_APILevel$1[GoFeatures_APILevel$1["API_OPEN"] = 1] = "API_OPEN";
		/**
		* @generated from enum value: API_HYBRID = 2;
		*/
		GoFeatures_APILevel$1[GoFeatures_APILevel$1["API_HYBRID"] = 2] = "API_HYBRID";
		/**
		* @generated from enum value: API_OPAQUE = 3;
		*/
		GoFeatures_APILevel$1[GoFeatures_APILevel$1["API_OPAQUE"] = 3] = "API_OPAQUE";
	})(GoFeatures_APILevel || (exports.GoFeatures_APILevel = GoFeatures_APILevel = {}));
	/**
	* Describes the enum pb.GoFeatures.APILevel.
	*/
	exports.GoFeatures_APILevelSchema = (0, enum_js_1$3.enumDesc)(exports.file_google_protobuf_go_features, 0, 0);
	/**
	* @generated from enum pb.GoFeatures.StripEnumPrefix
	*/
	var GoFeatures_StripEnumPrefix;
	(function(GoFeatures_StripEnumPrefix$1) {
		/**
		* @generated from enum value: STRIP_ENUM_PREFIX_UNSPECIFIED = 0;
		*/
		GoFeatures_StripEnumPrefix$1[GoFeatures_StripEnumPrefix$1["UNSPECIFIED"] = 0] = "UNSPECIFIED";
		/**
		* @generated from enum value: STRIP_ENUM_PREFIX_KEEP = 1;
		*/
		GoFeatures_StripEnumPrefix$1[GoFeatures_StripEnumPrefix$1["KEEP"] = 1] = "KEEP";
		/**
		* @generated from enum value: STRIP_ENUM_PREFIX_GENERATE_BOTH = 2;
		*/
		GoFeatures_StripEnumPrefix$1[GoFeatures_StripEnumPrefix$1["GENERATE_BOTH"] = 2] = "GENERATE_BOTH";
		/**
		* @generated from enum value: STRIP_ENUM_PREFIX_STRIP = 3;
		*/
		GoFeatures_StripEnumPrefix$1[GoFeatures_StripEnumPrefix$1["STRIP"] = 3] = "STRIP";
	})(GoFeatures_StripEnumPrefix || (exports.GoFeatures_StripEnumPrefix = GoFeatures_StripEnumPrefix = {}));
	/**
	* Describes the enum pb.GoFeatures.StripEnumPrefix.
	*/
	exports.GoFeatures_StripEnumPrefixSchema = (0, enum_js_1$3.enumDesc)(exports.file_google_protobuf_go_features, 0, 1);
	/**
	* @generated from extension: optional pb.GoFeatures go = 1002;
	*/
	exports.go = (0, extension_js_1$1.extDesc)(exports.file_google_protobuf_go_features, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/java_features_pb.js
var require_java_features_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/java_features_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.java = exports.JavaFeatures_Utf8ValidationSchema = exports.JavaFeatures_Utf8Validation = exports.JavaFeatures_NestInFileClassFeature_NestInFileClassSchema = exports.JavaFeatures_NestInFileClassFeature_NestInFileClass = exports.JavaFeatures_NestInFileClassFeatureSchema = exports.JavaFeaturesSchema = exports.file_google_protobuf_java_features = void 0;
	var file_js_1$3 = require_file();
	var descriptor_pb_js_1$1 = require_descriptor_pb();
	var message_js_1$3 = require_message();
	var enum_js_1$2 = require_enum();
	var extension_js_1 = require_extension();
	/**
	* Describes the file google/protobuf/java_features.proto.
	*/
	exports.file_google_protobuf_java_features = (0, file_js_1$3.fileDesc)("CiNnb29nbGUvcHJvdG9idWYvamF2YV9mZWF0dXJlcy5wcm90bxICcGIigwgKDEphdmFGZWF0dXJlcxL+AQoSbGVnYWN5X2Nsb3NlZF9lbnVtGAEgASgIQuEBiAEBmAEEmAEBogEJEgR0cnVlGIQHogEKEgVmYWxzZRjnB7IBuwEI6AcQ6AcasgFUaGUgbGVnYWN5IGNsb3NlZCBlbnVtIGJlaGF2aW9yIGluIEphdmEgaXMgZGVwcmVjYXRlZCBhbmQgaXMgc2NoZWR1bGVkIHRvIGJlIHJlbW92ZWQgaW4gZWRpdGlvbiAyMDI1LiAgU2VlIGh0dHA6Ly9wcm90b2J1Zi5kZXYvcHJvZ3JhbW1pbmctZ3VpZGVzL2VudW0vI2phdmEgZm9yIG1vcmUgaW5mb3JtYXRpb24uEp8CCg91dGY4X3ZhbGlkYXRpb24YAiABKA4yHy5wYi5KYXZhRmVhdHVyZXMuVXRmOFZhbGlkYXRpb25C5AGIAQGYAQSYAQGiAQwSB0RFRkFVTFQYhAeyAcgBCOgHEOkHGr8BVGhlIEphdmEtc3BlY2lmaWMgdXRmOCB2YWxpZGF0aW9uIGZlYXR1cmUgaXMgZGVwcmVjYXRlZCBhbmQgaXMgc2NoZWR1bGVkIHRvIGJlIHJlbW92ZWQgaW4gZWRpdGlvbiAyMDI1LiAgVXRmOCB2YWxpZGF0aW9uIGJlaGF2aW9yIHNob3VsZCB1c2UgdGhlIGdsb2JhbCBjcm9zcy1sYW5ndWFnZSB1dGY4X3ZhbGlkYXRpb24gZmVhdHVyZS4SMAoKbGFyZ2VfZW51bRgDIAEoCEIciAEBmAEGmAEBogEKEgVmYWxzZRiEB7IBAwjpBxJRCh91c2Vfb2xkX291dGVyX2NsYXNzbmFtZV9kZWZhdWx0GAQgASgIQiiIAQGYAQGiAQkSBHRydWUYhAeiAQoSBWZhbHNlGOkHsgEGCOkHIOkHEn8KEm5lc3RfaW5fZmlsZV9jbGFzcxgFIAEoDjI3LnBiLkphdmFGZWF0dXJlcy5OZXN0SW5GaWxlQ2xhc3NGZWF0dXJlLk5lc3RJbkZpbGVDbGFzc0IqiAEBmAEDmAEGmAEIogELEgZMRUdBQ1kYhAeiAQcSAk5PGOkHsgEDCOkHGnwKFk5lc3RJbkZpbGVDbGFzc0ZlYXR1cmUiWAoPTmVzdEluRmlsZUNsYXNzEh4KGk5FU1RfSU5fRklMRV9DTEFTU19VTktOT1dOEAASBgoCTk8QARIHCgNZRVMQAhIUCgZMRUdBQ1kQAxoIIgYI6Qcg6QdKCAgBEICAgIACIkYKDlV0ZjhWYWxpZGF0aW9uEhsKF1VURjhfVkFMSURBVElPTl9VTktOT1dOEAASCwoHREVGQVVMVBABEgoKBlZFUklGWRACSgQIBhAHOkIKBGphdmESGy5nb29nbGUucHJvdG9idWYuRmVhdHVyZVNldBjpByABKAsyEC5wYi5KYXZhRmVhdHVyZXNSBGphdmFCKAoTY29tLmdvb2dsZS5wcm90b2J1ZkIRSmF2YUZlYXR1cmVzUHJvdG8", [descriptor_pb_js_1$1.file_google_protobuf_descriptor]);
	/**
	* Describes the message pb.JavaFeatures.
	* Use `create(JavaFeaturesSchema)` to create a new message.
	*/
	exports.JavaFeaturesSchema = (0, message_js_1$3.messageDesc)(exports.file_google_protobuf_java_features, 0);
	/**
	* Describes the message pb.JavaFeatures.NestInFileClassFeature.
	* Use `create(JavaFeatures_NestInFileClassFeatureSchema)` to create a new message.
	*/
	exports.JavaFeatures_NestInFileClassFeatureSchema = (0, message_js_1$3.messageDesc)(exports.file_google_protobuf_java_features, 0, 0);
	/**
	* @generated from enum pb.JavaFeatures.NestInFileClassFeature.NestInFileClass
	*/
	var JavaFeatures_NestInFileClassFeature_NestInFileClass;
	(function(JavaFeatures_NestInFileClassFeature_NestInFileClass$1) {
		/**
		* Invalid default, which should never be used.
		*
		* @generated from enum value: NEST_IN_FILE_CLASS_UNKNOWN = 0;
		*/
		JavaFeatures_NestInFileClassFeature_NestInFileClass$1[JavaFeatures_NestInFileClassFeature_NestInFileClass$1["NEST_IN_FILE_CLASS_UNKNOWN"] = 0] = "NEST_IN_FILE_CLASS_UNKNOWN";
		/**
		* Do not nest the generated class in the file class.
		*
		* @generated from enum value: NO = 1;
		*/
		JavaFeatures_NestInFileClassFeature_NestInFileClass$1[JavaFeatures_NestInFileClassFeature_NestInFileClass$1["NO"] = 1] = "NO";
		/**
		* Nest the generated class in the file class.
		*
		* @generated from enum value: YES = 2;
		*/
		JavaFeatures_NestInFileClassFeature_NestInFileClass$1[JavaFeatures_NestInFileClassFeature_NestInFileClass$1["YES"] = 2] = "YES";
		/**
		* Fall back to the `java_multiple_files` option. Users won't be able to
		* set this option.
		*
		* @generated from enum value: LEGACY = 3;
		*/
		JavaFeatures_NestInFileClassFeature_NestInFileClass$1[JavaFeatures_NestInFileClassFeature_NestInFileClass$1["LEGACY"] = 3] = "LEGACY";
	})(JavaFeatures_NestInFileClassFeature_NestInFileClass || (exports.JavaFeatures_NestInFileClassFeature_NestInFileClass = JavaFeatures_NestInFileClassFeature_NestInFileClass = {}));
	/**
	* Describes the enum pb.JavaFeatures.NestInFileClassFeature.NestInFileClass.
	*/
	exports.JavaFeatures_NestInFileClassFeature_NestInFileClassSchema = (0, enum_js_1$2.enumDesc)(exports.file_google_protobuf_java_features, 0, 0, 0);
	/**
	* The UTF8 validation strategy to use.
	*
	* @generated from enum pb.JavaFeatures.Utf8Validation
	*/
	var JavaFeatures_Utf8Validation;
	(function(JavaFeatures_Utf8Validation$1) {
		/**
		* Invalid default, which should never be used.
		*
		* @generated from enum value: UTF8_VALIDATION_UNKNOWN = 0;
		*/
		JavaFeatures_Utf8Validation$1[JavaFeatures_Utf8Validation$1["UTF8_VALIDATION_UNKNOWN"] = 0] = "UTF8_VALIDATION_UNKNOWN";
		/**
		* Respect the UTF8 validation behavior specified by the global
		* utf8_validation feature.
		*
		* @generated from enum value: DEFAULT = 1;
		*/
		JavaFeatures_Utf8Validation$1[JavaFeatures_Utf8Validation$1["DEFAULT"] = 1] = "DEFAULT";
		/**
		* Verifies UTF8 validity overriding the global utf8_validation
		* feature. This represents the legacy java_string_check_utf8 option.
		*
		* @generated from enum value: VERIFY = 2;
		*/
		JavaFeatures_Utf8Validation$1[JavaFeatures_Utf8Validation$1["VERIFY"] = 2] = "VERIFY";
	})(JavaFeatures_Utf8Validation || (exports.JavaFeatures_Utf8Validation = JavaFeatures_Utf8Validation = {}));
	/**
	* Describes the enum pb.JavaFeatures.Utf8Validation.
	*/
	exports.JavaFeatures_Utf8ValidationSchema = (0, enum_js_1$2.enumDesc)(exports.file_google_protobuf_java_features, 0, 0);
	/**
	* @generated from extension: optional pb.JavaFeatures java = 1001;
	*/
	exports.java = (0, extension_js_1.extDesc)(exports.file_google_protobuf_java_features, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/struct_pb.js
var require_struct_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/struct_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.NullValueSchema = exports.NullValue = exports.ListValueSchema = exports.ValueSchema = exports.StructSchema = exports.file_google_protobuf_struct = void 0;
	var file_js_1$2 = require_file();
	var message_js_1$2 = require_message();
	var enum_js_1$1 = require_enum();
	/**
	* Describes the file google/protobuf/struct.proto.
	*/
	exports.file_google_protobuf_struct = (0, file_js_1$2.fileDesc)("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM");
	/**
	* Describes the message google.protobuf.Struct.
	* Use `create(StructSchema)` to create a new message.
	*/
	exports.StructSchema = (0, message_js_1$2.messageDesc)(exports.file_google_protobuf_struct, 0);
	/**
	* Describes the message google.protobuf.Value.
	* Use `create(ValueSchema)` to create a new message.
	*/
	exports.ValueSchema = (0, message_js_1$2.messageDesc)(exports.file_google_protobuf_struct, 1);
	/**
	* Describes the message google.protobuf.ListValue.
	* Use `create(ListValueSchema)` to create a new message.
	*/
	exports.ListValueSchema = (0, message_js_1$2.messageDesc)(exports.file_google_protobuf_struct, 2);
	/**
	* `NullValue` is a singleton enumeration to represent the null value for the
	* `Value` type union.
	*
	* The JSON representation for `NullValue` is JSON `null`.
	*
	* @generated from enum google.protobuf.NullValue
	*/
	var NullValue;
	(function(NullValue$1) {
		/**
		* Null value.
		*
		* @generated from enum value: NULL_VALUE = 0;
		*/
		NullValue$1[NullValue$1["NULL_VALUE"] = 0] = "NULL_VALUE";
	})(NullValue || (exports.NullValue = NullValue = {}));
	/**
	* Describes the enum google.protobuf.NullValue.
	*/
	exports.NullValueSchema = (0, enum_js_1$1.enumDesc)(exports.file_google_protobuf_struct, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/wrappers_pb.js
var require_wrappers_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/wrappers_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BytesValueSchema = exports.StringValueSchema = exports.BoolValueSchema = exports.UInt32ValueSchema = exports.Int32ValueSchema = exports.UInt64ValueSchema = exports.Int64ValueSchema = exports.FloatValueSchema = exports.DoubleValueSchema = exports.file_google_protobuf_wrappers = void 0;
	var file_js_1$1 = require_file();
	var message_js_1$1 = require_message();
	/**
	* Describes the file google/protobuf/wrappers.proto.
	*/
	exports.file_google_protobuf_wrappers = (0, file_js_1$1.fileDesc)("Ch5nb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8SD2dvb2dsZS5wcm90b2J1ZiIcCgtEb3VibGVWYWx1ZRINCgV2YWx1ZRgBIAEoASIbCgpGbG9hdFZhbHVlEg0KBXZhbHVlGAEgASgCIhsKCkludDY0VmFsdWUSDQoFdmFsdWUYASABKAMiHAoLVUludDY0VmFsdWUSDQoFdmFsdWUYASABKAQiGwoKSW50MzJWYWx1ZRINCgV2YWx1ZRgBIAEoBSIcCgtVSW50MzJWYWx1ZRINCgV2YWx1ZRgBIAEoDSIaCglCb29sVmFsdWUSDQoFdmFsdWUYASABKAgiHAoLU3RyaW5nVmFsdWUSDQoFdmFsdWUYASABKAkiGwoKQnl0ZXNWYWx1ZRINCgV2YWx1ZRgBIAEoDEKDAQoTY29tLmdvb2dsZS5wcm90b2J1ZkINV3JhcHBlcnNQcm90b1ABWjFnb29nbGUuZ29sYW5nLm9yZy9wcm90b2J1Zi90eXBlcy9rbm93bi93cmFwcGVyc3Bi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM");
	/**
	* Describes the message google.protobuf.DoubleValue.
	* Use `create(DoubleValueSchema)` to create a new message.
	*/
	exports.DoubleValueSchema = (0, message_js_1$1.messageDesc)(exports.file_google_protobuf_wrappers, 0);
	/**
	* Describes the message google.protobuf.FloatValue.
	* Use `create(FloatValueSchema)` to create a new message.
	*/
	exports.FloatValueSchema = (0, message_js_1$1.messageDesc)(exports.file_google_protobuf_wrappers, 1);
	/**
	* Describes the message google.protobuf.Int64Value.
	* Use `create(Int64ValueSchema)` to create a new message.
	*/
	exports.Int64ValueSchema = (0, message_js_1$1.messageDesc)(exports.file_google_protobuf_wrappers, 2);
	/**
	* Describes the message google.protobuf.UInt64Value.
	* Use `create(UInt64ValueSchema)` to create a new message.
	*/
	exports.UInt64ValueSchema = (0, message_js_1$1.messageDesc)(exports.file_google_protobuf_wrappers, 3);
	/**
	* Describes the message google.protobuf.Int32Value.
	* Use `create(Int32ValueSchema)` to create a new message.
	*/
	exports.Int32ValueSchema = (0, message_js_1$1.messageDesc)(exports.file_google_protobuf_wrappers, 4);
	/**
	* Describes the message google.protobuf.UInt32Value.
	* Use `create(UInt32ValueSchema)` to create a new message.
	*/
	exports.UInt32ValueSchema = (0, message_js_1$1.messageDesc)(exports.file_google_protobuf_wrappers, 5);
	/**
	* Describes the message google.protobuf.BoolValue.
	* Use `create(BoolValueSchema)` to create a new message.
	*/
	exports.BoolValueSchema = (0, message_js_1$1.messageDesc)(exports.file_google_protobuf_wrappers, 6);
	/**
	* Describes the message google.protobuf.StringValue.
	* Use `create(StringValueSchema)` to create a new message.
	*/
	exports.StringValueSchema = (0, message_js_1$1.messageDesc)(exports.file_google_protobuf_wrappers, 7);
	/**
	* Describes the message google.protobuf.BytesValue.
	* Use `create(BytesValueSchema)` to create a new message.
	*/
	exports.BytesValueSchema = (0, message_js_1$1.messageDesc)(exports.file_google_protobuf_wrappers, 8);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/compiler/plugin_pb.js
var require_plugin_pb = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/compiler/plugin_pb.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGeneratorResponse_FeatureSchema = exports.CodeGeneratorResponse_Feature = exports.CodeGeneratorResponse_FileSchema = exports.CodeGeneratorResponseSchema = exports.CodeGeneratorRequestSchema = exports.VersionSchema = exports.file_google_protobuf_compiler_plugin = void 0;
	var file_js_1 = require_file();
	var descriptor_pb_js_1 = require_descriptor_pb();
	var message_js_1 = require_message();
	var enum_js_1 = require_enum();
	/**
	* Describes the file google/protobuf/compiler/plugin.proto.
	*/
	exports.file_google_protobuf_compiler_plugin = (0, file_js_1.fileDesc)("CiVnb29nbGUvcHJvdG9idWYvY29tcGlsZXIvcGx1Z2luLnByb3RvEhhnb29nbGUucHJvdG9idWYuY29tcGlsZXIiRgoHVmVyc2lvbhINCgVtYWpvchgBIAEoBRINCgVtaW5vchgCIAEoBRINCgVwYXRjaBgDIAEoBRIOCgZzdWZmaXgYBCABKAkigQIKFENvZGVHZW5lcmF0b3JSZXF1ZXN0EhgKEGZpbGVfdG9fZ2VuZXJhdGUYASADKAkSEQoJcGFyYW1ldGVyGAIgASgJEjgKCnByb3RvX2ZpbGUYDyADKAsyJC5nb29nbGUucHJvdG9idWYuRmlsZURlc2NyaXB0b3JQcm90bxJFChdzb3VyY2VfZmlsZV9kZXNjcmlwdG9ycxgRIAMoCzIkLmdvb2dsZS5wcm90b2J1Zi5GaWxlRGVzY3JpcHRvclByb3RvEjsKEGNvbXBpbGVyX3ZlcnNpb24YAyABKAsyIS5nb29nbGUucHJvdG9idWYuY29tcGlsZXIuVmVyc2lvbiKSAwoVQ29kZUdlbmVyYXRvclJlc3BvbnNlEg0KBWVycm9yGAEgASgJEhoKEnN1cHBvcnRlZF9mZWF0dXJlcxgCIAEoBBIXCg9taW5pbXVtX2VkaXRpb24YAyABKAUSFwoPbWF4aW11bV9lZGl0aW9uGAQgASgFEkIKBGZpbGUYDyADKAsyNC5nb29nbGUucHJvdG9idWYuY29tcGlsZXIuQ29kZUdlbmVyYXRvclJlc3BvbnNlLkZpbGUafwoERmlsZRIMCgRuYW1lGAEgASgJEhcKD2luc2VydGlvbl9wb2ludBgCIAEoCRIPCgdjb250ZW50GA8gASgJEj8KE2dlbmVyYXRlZF9jb2RlX2luZm8YECABKAsyIi5nb29nbGUucHJvdG9idWYuR2VuZXJhdGVkQ29kZUluZm8iVwoHRmVhdHVyZRIQCgxGRUFUVVJFX05PTkUQABIbChdGRUFUVVJFX1BST1RPM19PUFRJT05BTBABEh0KGUZFQVRVUkVfU1VQUE9SVFNfRURJVElPTlMQAkJyChxjb20uZ29vZ2xlLnByb3RvYnVmLmNvbXBpbGVyQgxQbHVnaW5Qcm90b3NaKWdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL3BsdWdpbnBiqgIYR29vZ2xlLlByb3RvYnVmLkNvbXBpbGVy", [descriptor_pb_js_1.file_google_protobuf_descriptor]);
	/**
	* Describes the message google.protobuf.compiler.Version.
	* Use `create(VersionSchema)` to create a new message.
	*/
	exports.VersionSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_compiler_plugin, 0);
	/**
	* Describes the message google.protobuf.compiler.CodeGeneratorRequest.
	* Use `create(CodeGeneratorRequestSchema)` to create a new message.
	*/
	exports.CodeGeneratorRequestSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_compiler_plugin, 1);
	/**
	* Describes the message google.protobuf.compiler.CodeGeneratorResponse.
	* Use `create(CodeGeneratorResponseSchema)` to create a new message.
	*/
	exports.CodeGeneratorResponseSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_compiler_plugin, 2);
	/**
	* Describes the message google.protobuf.compiler.CodeGeneratorResponse.File.
	* Use `create(CodeGeneratorResponse_FileSchema)` to create a new message.
	*/
	exports.CodeGeneratorResponse_FileSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_compiler_plugin, 2, 0);
	/**
	* Sync with code_generator.h.
	*
	* @generated from enum google.protobuf.compiler.CodeGeneratorResponse.Feature
	*/
	var CodeGeneratorResponse_Feature;
	(function(CodeGeneratorResponse_Feature$1) {
		/**
		* @generated from enum value: FEATURE_NONE = 0;
		*/
		CodeGeneratorResponse_Feature$1[CodeGeneratorResponse_Feature$1["NONE"] = 0] = "NONE";
		/**
		* @generated from enum value: FEATURE_PROTO3_OPTIONAL = 1;
		*/
		CodeGeneratorResponse_Feature$1[CodeGeneratorResponse_Feature$1["PROTO3_OPTIONAL"] = 1] = "PROTO3_OPTIONAL";
		/**
		* @generated from enum value: FEATURE_SUPPORTS_EDITIONS = 2;
		*/
		CodeGeneratorResponse_Feature$1[CodeGeneratorResponse_Feature$1["SUPPORTS_EDITIONS"] = 2] = "SUPPORTS_EDITIONS";
	})(CodeGeneratorResponse_Feature || (exports.CodeGeneratorResponse_Feature = CodeGeneratorResponse_Feature = {}));
	/**
	* Describes the enum google.protobuf.compiler.CodeGeneratorResponse.Feature.
	*/
	exports.CodeGeneratorResponse_FeatureSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_compiler_plugin, 2, 0);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wkt/index.js
var require_wkt = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wkt/index.js": ((exports) => {
	var __createBinding$2 = exports && exports.__createBinding || (Object.create ? (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	}));
	var __exportStar$2 = exports && exports.__exportStar || function(m$1, exports$1) {
		for (var p$10 in m$1) if (p$10 !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p$10)) __createBinding$2(exports$1, m$1, p$10);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar$2(require_timestamp(), exports);
	__exportStar$2(require_duration(), exports);
	__exportStar$2(require_any(), exports);
	__exportStar$2(require_wrappers(), exports);
	__exportStar$2(require_any_pb(), exports);
	__exportStar$2(require_api_pb(), exports);
	__exportStar$2(require_cpp_features_pb(), exports);
	__exportStar$2(require_descriptor_pb(), exports);
	__exportStar$2(require_duration_pb(), exports);
	__exportStar$2(require_empty_pb(), exports);
	__exportStar$2(require_field_mask_pb(), exports);
	__exportStar$2(require_go_features_pb(), exports);
	__exportStar$2(require_java_features_pb(), exports);
	__exportStar$2(require_source_context_pb(), exports);
	__exportStar$2(require_struct_pb(), exports);
	__exportStar$2(require_timestamp_pb(), exports);
	__exportStar$2(require_type_pb(), exports);
	__exportStar$2(require_wrappers_pb(), exports);
	__exportStar$2(require_plugin_pb(), exports);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/extensions.js
var require_extensions = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/extensions.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getExtension = getExtension;
	exports.setExtension = setExtension;
	exports.clearExtension = clearExtension;
	exports.hasExtension = hasExtension;
	exports.hasOption = hasOption;
	exports.getOption = getOption;
	exports.createExtensionContainer = createExtensionContainer;
	var create_js_1$1 = require_create();
	var from_binary_js_1$2 = require_from_binary();
	var reflect_js_1$4 = require_reflect();
	var scalar_js_1$2 = require_scalar$1();
	var to_binary_js_1$2 = require_to_binary();
	var binary_encoding_js_1$1 = require_binary_encoding();
	var wrappers_js_1$1 = require_wrappers();
	/**
	* Retrieve an extension value from a message.
	*
	* The function never returns undefined. Use hasExtension() to check whether an
	* extension is set. If the extension is not set, this function returns the
	* default value (if one was specified in the protobuf source), or the zero value
	* (for example `0` for numeric types, `[]` for repeated extension fields, and
	* an empty message instance for message fields).
	*
	* Extensions are stored as unknown fields on a message. To mutate an extension
	* value, make sure to store the new value with setExtension() after mutating.
	*
	* If the extension does not extend the given message, an error is raised.
	*/
	function getExtension(message, extension) {
		assertExtendee(extension, message);
		const ufs = filterUnknownFields(message.$unknown, extension);
		const [container, field, get$2] = createExtensionContainer(extension);
		for (const uf of ufs) (0, from_binary_js_1$2.readField)(container, new binary_encoding_js_1$1.BinaryReader(uf.data), field, uf.wireType, { readUnknownFields: true });
		return get$2();
	}
	/**
	* Set an extension value on a message. If the message already has a value for
	* this extension, the value is replaced.
	*
	* If the extension does not extend the given message, an error is raised.
	*/
	function setExtension(message, extension, value) {
		var _a;
		assertExtendee(extension, message);
		const ufs = ((_a = message.$unknown) !== null && _a !== void 0 ? _a : []).filter((uf) => uf.no !== extension.number);
		const [container, field] = createExtensionContainer(extension, value);
		const writer = new binary_encoding_js_1$1.BinaryWriter();
		(0, to_binary_js_1$2.writeField)(writer, { writeUnknownFields: true }, container, field);
		const reader = new binary_encoding_js_1$1.BinaryReader(writer.finish());
		while (reader.pos < reader.len) {
			const [no, wireType] = reader.tag();
			const data = reader.skip(wireType, no);
			ufs.push({
				no,
				wireType,
				data
			});
		}
		message.$unknown = ufs;
	}
	/**
	* Remove an extension value from a message.
	*
	* If the extension does not extend the given message, an error is raised.
	*/
	function clearExtension(message, extension) {
		assertExtendee(extension, message);
		if (message.$unknown === void 0) return;
		message.$unknown = message.$unknown.filter((uf) => uf.no !== extension.number);
	}
	/**
	* Check whether an extension is set on a message.
	*/
	function hasExtension(message, extension) {
		var _a;
		return extension.extendee.typeName === message.$typeName && !!((_a = message.$unknown) === null || _a === void 0 ? void 0 : _a.find((uf) => uf.no === extension.number));
	}
	/**
	* Check whether an option is set on a descriptor.
	*
	* Options are extensions to the `google.protobuf.*Options` messages defined in
	* google/protobuf/descriptor.proto. This function gets the option message from
	* the descriptor, and calls hasExtension().
	*/
	function hasOption(element, option) {
		const message = element.proto.options;
		if (!message) return false;
		return hasExtension(message, option);
	}
	/**
	* Retrieve an option value from a descriptor.
	*
	* Options are extensions to the `google.protobuf.*Options` messages defined in
	* google/protobuf/descriptor.proto. This function gets the option message from
	* the descriptor, and calls getExtension(). Same as getExtension(), this
	* function never returns undefined.
	*/
	function getOption(element, option) {
		const message = element.proto.options;
		if (!message) {
			const [, , get$2] = createExtensionContainer(option);
			return get$2();
		}
		return getExtension(message, option);
	}
	function filterUnknownFields(unknownFields, extension) {
		if (unknownFields === void 0) return [];
		if (extension.fieldKind === "enum" || extension.fieldKind === "scalar") {
			for (let i = unknownFields.length - 1; i >= 0; --i) if (unknownFields[i].no == extension.number) return [unknownFields[i]];
			return [];
		}
		return unknownFields.filter((uf) => uf.no === extension.number);
	}
	/**
	* @private
	*/
	function createExtensionContainer(extension, value) {
		const localName = extension.typeName;
		const field = Object.assign(Object.assign({}, extension), {
			kind: "field",
			parent: extension.extendee,
			localName
		});
		const desc = Object.assign(Object.assign({}, extension.extendee), {
			fields: [field],
			members: [field],
			oneofs: []
		});
		const container = (0, create_js_1$1.create)(desc, value !== void 0 ? { [localName]: value } : void 0);
		return [
			(0, reflect_js_1$4.reflect)(desc, container),
			field,
			() => {
				const value$1 = container[localName];
				if (value$1 === void 0) {
					const desc$1 = extension.message;
					if ((0, wrappers_js_1$1.isWrapperDesc)(desc$1)) return (0, scalar_js_1$2.scalarZeroValue)(desc$1.fields[0].scalar, desc$1.fields[0].longAsString);
					return (0, create_js_1$1.create)(desc$1);
				}
				return value$1;
			}
		];
	}
	function assertExtendee(extension, message) {
		if (extension.extendee.typeName != message.$typeName) throw new Error(`extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/equals.js
var require_equals = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/equals.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.equals = equals;
	var scalar_js_1$1 = require_scalar$1();
	var reflect_js_1$3 = require_reflect();
	var descriptors_js_1$2 = require_descriptors();
	var index_js_1$2 = require_wkt();
	var extensions_js_1$3 = require_extensions();
	/**
	* Compare two messages of the same type.
	*
	* Note that this function disregards extensions and unknown fields, and that
	* NaN is not equal NaN, following the IEEE standard.
	*/
	function equals(schema, a$1, b$2, options) {
		if (a$1.$typeName != schema.typeName || b$2.$typeName != schema.typeName) return false;
		if (a$1 === b$2) return true;
		return reflectEquals((0, reflect_js_1$3.reflect)(schema, a$1), (0, reflect_js_1$3.reflect)(schema, b$2), options);
	}
	function reflectEquals(a$1, b$2, opts) {
		if (a$1.desc.typeName === "google.protobuf.Any" && (opts === null || opts === void 0 ? void 0 : opts.unpackAny) == true) return anyUnpackedEquals(a$1.message, b$2.message, opts);
		for (const f of a$1.fields) if (!fieldEquals(f, a$1, b$2, opts)) return false;
		if ((opts === null || opts === void 0 ? void 0 : opts.unknown) == true && !unknownEquals(a$1, b$2, opts.registry)) return false;
		if ((opts === null || opts === void 0 ? void 0 : opts.extensions) == true && !extensionsEquals(a$1, b$2, opts)) return false;
		return true;
	}
	function fieldEquals(f, a$1, b$2, opts) {
		if (!a$1.isSet(f) && !b$2.isSet(f)) return true;
		if (!a$1.isSet(f) || !b$2.isSet(f)) return false;
		switch (f.fieldKind) {
			case "scalar": return (0, scalar_js_1$1.scalarEquals)(f.scalar, a$1.get(f), b$2.get(f));
			case "enum": return a$1.get(f) === b$2.get(f);
			case "message": return reflectEquals(a$1.get(f), b$2.get(f), opts);
			case "map": {
				const mapA = a$1.get(f);
				const mapB = b$2.get(f);
				const keys = [];
				for (const k of mapA.keys()) {
					if (!mapB.has(k)) return false;
					keys.push(k);
				}
				for (const k of mapB.keys()) if (!mapA.has(k)) return false;
				for (const key of keys) {
					const va = mapA.get(key);
					const vb = mapB.get(key);
					if (va === vb) continue;
					switch (f.mapKind) {
						case "enum": return false;
						case "message":
							if (!reflectEquals(va, vb, opts)) return false;
							break;
						case "scalar":
							if (!(0, scalar_js_1$1.scalarEquals)(f.scalar, va, vb)) return false;
							break;
					}
				}
				break;
			}
			case "list": {
				const listA = a$1.get(f);
				const listB = b$2.get(f);
				if (listA.size != listB.size) return false;
				for (let i = 0; i < listA.size; i++) {
					const va = listA.get(i);
					const vb = listB.get(i);
					if (va === vb) continue;
					switch (f.listKind) {
						case "enum": return false;
						case "message":
							if (!reflectEquals(va, vb, opts)) return false;
							break;
						case "scalar":
							if (!(0, scalar_js_1$1.scalarEquals)(f.scalar, va, vb)) return false;
							break;
					}
				}
				break;
			}
		}
		return true;
	}
	function anyUnpackedEquals(a$1, b$2, opts) {
		if (a$1.typeUrl !== b$2.typeUrl) return false;
		const unpackedA = (0, index_js_1$2.anyUnpack)(a$1, opts.registry);
		const unpackedB = (0, index_js_1$2.anyUnpack)(b$2, opts.registry);
		if (unpackedA && unpackedB) {
			const schema = opts.registry.getMessage(unpackedA.$typeName);
			if (schema) return equals(schema, unpackedA, unpackedB, opts);
		}
		return (0, scalar_js_1$1.scalarEquals)(descriptors_js_1$2.ScalarType.BYTES, a$1.value, b$2.value);
	}
	function unknownEquals(a$1, b$2, registry) {
		function getTrulyUnknown(msg, registry$1) {
			var _a;
			const u = (_a = msg.getUnknown()) !== null && _a !== void 0 ? _a : [];
			return registry$1 ? u.filter((uf) => !registry$1.getExtensionFor(msg.desc, uf.no)) : u;
		}
		const unknownA = getTrulyUnknown(a$1, registry);
		const unknownB = getTrulyUnknown(b$2, registry);
		if (unknownA.length != unknownB.length) return false;
		for (let i = 0; i < unknownA.length; i++) {
			const a$2 = unknownA[i];
			const b$3 = unknownB[i];
			if (a$2.no != b$3.no) return false;
			if (a$2.wireType != b$3.wireType) return false;
			if (!(0, scalar_js_1$1.scalarEquals)(descriptors_js_1$2.ScalarType.BYTES, a$2.data, b$3.data)) return false;
		}
		return true;
	}
	function extensionsEquals(a$1, b$2, opts) {
		function getSetExtensions(msg, registry) {
			var _a;
			return ((_a = msg.getUnknown()) !== null && _a !== void 0 ? _a : []).map((uf) => registry.getExtensionFor(msg.desc, uf.no)).filter((e) => e != void 0).filter((e, index, arr) => arr.indexOf(e) === index);
		}
		const extensionsA = getSetExtensions(a$1, opts.registry);
		const extensionsB = getSetExtensions(b$2, opts.registry);
		if (extensionsA.length != extensionsB.length || extensionsA.some((e) => !extensionsB.includes(e))) return false;
		for (const extension of extensionsA) {
			const [containerA, field] = (0, extensions_js_1$3.createExtensionContainer)(extension, (0, extensions_js_1$3.getExtension)(a$1.message, extension));
			const [containerB] = (0, extensions_js_1$3.createExtensionContainer)(extension, (0, extensions_js_1$3.getExtension)(b$2.message, extension));
			if (!fieldEquals(field, containerA, containerB, opts)) return false;
		}
		return true;
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wire/size-delimited.js
var require_size_delimited = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wire/size-delimited.js": ((exports) => {
	var __asyncValues = exports && exports.__asyncValues || function(o) {
		if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
		var m$1 = o[Symbol.asyncIterator], i;
		return m$1 ? m$1.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
			return this;
		}, i);
		function verb(n$2) {
			i[n$2] = o[n$2] && function(v) {
				return new Promise(function(resolve, reject) {
					v = o[n$2](v), settle(resolve, reject, v.done, v.value);
				});
			};
		}
		function settle(resolve, reject, d$1, v) {
			Promise.resolve(v).then(function(v$1) {
				resolve({
					value: v$1,
					done: d$1
				});
			}, reject);
		}
	};
	var __await = exports && exports.__await || function(v) {
		return this instanceof __await ? (this.v = v, this) : new __await(v);
	};
	var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
		if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
		var g$1 = generator.apply(thisArg, _arguments || []), i, q = [];
		return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
			return this;
		}, i;
		function awaitReturn(f) {
			return function(v) {
				return Promise.resolve(v).then(f, reject);
			};
		}
		function verb(n$2, f) {
			if (g$1[n$2]) {
				i[n$2] = function(v) {
					return new Promise(function(a$1, b$2) {
						q.push([
							n$2,
							v,
							a$1,
							b$2
						]) > 1 || resume(n$2, v);
					});
				};
				if (f) i[n$2] = f(i[n$2]);
			}
		}
		function resume(n$2, v) {
			try {
				step(g$1[n$2](v));
			} catch (e) {
				settle(q[0][3], e);
			}
		}
		function step(r) {
			r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
		}
		function fulfill(value) {
			resume("next", value);
		}
		function reject(value) {
			resume("throw", value);
		}
		function settle(f, v) {
			if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
		}
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sizeDelimitedEncode = sizeDelimitedEncode;
	exports.sizeDelimitedDecodeStream = sizeDelimitedDecodeStream;
	exports.sizeDelimitedPeek = sizeDelimitedPeek;
	var to_binary_js_1$1 = require_to_binary();
	var binary_encoding_js_1 = require_binary_encoding();
	var from_binary_js_1$1 = require_from_binary();
	/**
	* Serialize a message, prefixing it with its size.
	*
	* A size-delimited message is a varint size in bytes, followed by exactly
	* that many bytes of a message serialized with the binary format.
	*
	* This size-delimited format is compatible with other implementations.
	* For details, see https://github.com/protocolbuffers/protobuf/issues/10229
	*/
	function sizeDelimitedEncode(messageDesc$1, message, options) {
		const writer = new binary_encoding_js_1.BinaryWriter();
		writer.bytes((0, to_binary_js_1$1.toBinary)(messageDesc$1, message, options));
		return writer.finish();
	}
	/**
	* Parse a stream of size-delimited messages.
	*
	* A size-delimited message is a varint size in bytes, followed by exactly
	* that many bytes of a message serialized with the binary format.
	*
	* This size-delimited format is compatible with other implementations.
	* For details, see https://github.com/protocolbuffers/protobuf/issues/10229
	*/
	function sizeDelimitedDecodeStream(messageDesc$1, iterable, options) {
		return __asyncGenerator(this, arguments, function* sizeDelimitedDecodeStream_1() {
			var _a, e_1, _b, _c;
			function append(buffer$2, chunk) {
				const n$2 = new Uint8Array(buffer$2.byteLength + chunk.byteLength);
				n$2.set(buffer$2);
				n$2.set(chunk, buffer$2.length);
				return n$2;
			}
			let buffer$1 = new Uint8Array(0);
			try {
				for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), _a = iterable_1_1.done, !_a; _d = true) {
					_c = iterable_1_1.value;
					_d = false;
					buffer$1 = append(buffer$1, _c);
					for (;;) {
						const size = sizeDelimitedPeek(buffer$1);
						if (size.eof) break;
						if (size.offset + size.size > buffer$1.byteLength) break;
						yield yield __await((0, from_binary_js_1$1.fromBinary)(messageDesc$1, buffer$1.subarray(size.offset, size.offset + size.size), options));
						buffer$1 = buffer$1.subarray(size.offset + size.size);
					}
				}
			} catch (e_1_1) {
				e_1 = { error: e_1_1 };
			} finally {
				try {
					if (!_d && !_a && (_b = iterable_1.return)) yield __await(_b.call(iterable_1));
				} finally {
					if (e_1) throw e_1.error;
				}
			}
			if (buffer$1.byteLength > 0) throw new Error("incomplete data");
		});
	}
	/**
	* Decodes the size from the given size-delimited message, which may be
	* incomplete.
	*
	* Returns an object with the following properties:
	* - size: The size of the delimited message in bytes
	* - offset: The offset in the given byte array where the message starts
	* - eof: true
	*
	* If the size-delimited data does not include all bytes of the varint size,
	* the following object is returned:
	* - size: null
	* - offset: null
	* - eof: false
	*
	* This function can be used to implement parsing of size-delimited messages
	* from a stream.
	*/
	function sizeDelimitedPeek(data) {
		const sizeEof = {
			eof: true,
			size: null,
			offset: null
		};
		for (let i = 0; i < 10; i++) {
			if (i > data.byteLength) return sizeEof;
			if ((data[i] & 128) == 0) {
				const reader = new binary_encoding_js_1.BinaryReader(data);
				let size;
				try {
					size = reader.uint32();
				} catch (e) {
					if (e instanceof RangeError) return sizeEof;
					throw e;
				}
				return {
					eof: false,
					size,
					offset: reader.pos
				};
			}
		}
		throw new Error("invalid varint");
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/wire/index.js
var require_wire = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/wire/index.js": ((exports) => {
	var __createBinding$1 = exports && exports.__createBinding || (Object.create ? (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	}));
	var __exportStar$1 = exports && exports.__exportStar || function(m$1, exports$1) {
		for (var p$10 in m$1) if (p$10 !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p$10)) __createBinding$1(exports$1, m$1, p$10);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar$1(require_binary_encoding(), exports);
	__exportStar$1(require_base64_encoding(), exports);
	__exportStar$1(require_text_encoding(), exports);
	__exportStar$1(require_text_format(), exports);
	__exportStar$1(require_size_delimited(), exports);
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/to-json.js
var require_to_json = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/to-json.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toJson = toJson;
	exports.toJsonString = toJsonString;
	exports.enumToJson = enumToJson;
	var descriptors_js_1$1 = require_descriptors();
	var names_js_1 = require_names();
	var reflect_js_1$2 = require_reflect();
	var index_js_1$1 = require_wkt();
	var wrappers_js_1 = require_wrappers();
	var index_js_2 = require_wire();
	var extensions_js_1$2 = require_extensions();
	var reflect_check_js_1$1 = require_reflect_check();
	var LEGACY_REQUIRED = 3;
	var IMPLICIT = 2;
	var jsonWriteDefaults = {
		alwaysEmitImplicit: false,
		enumAsInteger: false,
		useProtoFieldName: false
	};
	function makeWriteOptions(options) {
		return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
	}
	/**
	* Serialize the message to a JSON value, a JavaScript value that can be
	* passed to JSON.stringify().
	*/
	function toJson(schema, message, options) {
		return reflectToJson((0, reflect_js_1$2.reflect)(schema, message), makeWriteOptions(options));
	}
	/**
	* Serialize the message to a JSON string.
	*/
	function toJsonString(schema, message, options) {
		var _a;
		const jsonValue = toJson(schema, message, options);
		return JSON.stringify(jsonValue, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
	}
	/**
	* Serialize a single enum value to JSON.
	*/
	function enumToJson(descEnum, value) {
		var _a;
		if (descEnum.typeName == "google.protobuf.NullValue") return null;
		const name = (_a = descEnum.value[value]) === null || _a === void 0 ? void 0 : _a.name;
		if (name === void 0) throw new Error(`${value} is not a value in ${descEnum}`);
		return name;
	}
	function reflectToJson(msg, opts) {
		var _a;
		const wktJson = tryWktToJson(msg, opts);
		if (wktJson !== void 0) return wktJson;
		const json = {};
		for (const f of msg.sortedFields) {
			if (!msg.isSet(f)) {
				if (f.presence == LEGACY_REQUIRED) throw new Error(`cannot encode ${f} to JSON: required field not set`);
				if (!opts.alwaysEmitImplicit || f.presence !== IMPLICIT) continue;
			}
			const jsonValue = fieldToJson(f, msg.get(f), opts);
			if (jsonValue !== void 0) json[jsonName(f, opts)] = jsonValue;
		}
		if (opts.registry) {
			const tagSeen = /* @__PURE__ */ new Set();
			for (const { no } of (_a = msg.getUnknown()) !== null && _a !== void 0 ? _a : []) if (!tagSeen.has(no)) {
				tagSeen.add(no);
				const extension = opts.registry.getExtensionFor(msg.desc, no);
				if (!extension) continue;
				const value = (0, extensions_js_1$2.getExtension)(msg.message, extension);
				const [container, field] = (0, extensions_js_1$2.createExtensionContainer)(extension, value);
				const jsonValue = fieldToJson(field, container.get(field), opts);
				if (jsonValue !== void 0) json[extension.jsonName] = jsonValue;
			}
		}
		return json;
	}
	function fieldToJson(f, val, opts) {
		switch (f.fieldKind) {
			case "scalar": return scalarToJson(f, val);
			case "message": return reflectToJson(val, opts);
			case "enum": return enumToJsonInternal(f.enum, val, opts.enumAsInteger);
			case "list": return listToJson(val, opts);
			case "map": return mapToJson(val, opts);
		}
	}
	function mapToJson(map$1, opts) {
		const f = map$1.field();
		const jsonObj = {};
		switch (f.mapKind) {
			case "scalar":
				for (const [entryKey, entryValue] of map$1) jsonObj[entryKey] = scalarToJson(f, entryValue);
				break;
			case "message":
				for (const [entryKey, entryValue] of map$1) jsonObj[entryKey] = reflectToJson(entryValue, opts);
				break;
			case "enum":
				for (const [entryKey, entryValue] of map$1) jsonObj[entryKey] = enumToJsonInternal(f.enum, entryValue, opts.enumAsInteger);
				break;
		}
		return opts.alwaysEmitImplicit || map$1.size > 0 ? jsonObj : void 0;
	}
	function listToJson(list, opts) {
		const f = list.field();
		const jsonArr = [];
		switch (f.listKind) {
			case "scalar":
				for (const item of list) jsonArr.push(scalarToJson(f, item));
				break;
			case "enum":
				for (const item of list) jsonArr.push(enumToJsonInternal(f.enum, item, opts.enumAsInteger));
				break;
			case "message":
				for (const item of list) jsonArr.push(reflectToJson(item, opts));
				break;
		}
		return opts.alwaysEmitImplicit || jsonArr.length > 0 ? jsonArr : void 0;
	}
	function enumToJsonInternal(desc, value, enumAsInteger) {
		var _a;
		if (typeof value != "number") throw new Error(`cannot encode ${desc} to JSON: expected number, got ${(0, reflect_check_js_1$1.formatVal)(value)}`);
		if (desc.typeName == "google.protobuf.NullValue") return null;
		if (enumAsInteger) return value;
		const val = desc.value[value];
		return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
	}
	function scalarToJson(field, value) {
		var _a, _b, _c, _d, _e, _f;
		switch (field.scalar) {
			case descriptors_js_1$1.ScalarType.INT32:
			case descriptors_js_1$1.ScalarType.SFIXED32:
			case descriptors_js_1$1.ScalarType.SINT32:
			case descriptors_js_1$1.ScalarType.FIXED32:
			case descriptors_js_1$1.ScalarType.UINT32:
				if (typeof value != "number") throw new Error(`cannot encode ${field} to JSON: ${(_a = (0, reflect_check_js_1$1.checkField)(field, value)) === null || _a === void 0 ? void 0 : _a.message}`);
				return value;
			case descriptors_js_1$1.ScalarType.FLOAT:
			case descriptors_js_1$1.ScalarType.DOUBLE:
				if (typeof value != "number") throw new Error(`cannot encode ${field} to JSON: ${(_b = (0, reflect_check_js_1$1.checkField)(field, value)) === null || _b === void 0 ? void 0 : _b.message}`);
				if (Number.isNaN(value)) return "NaN";
				if (value === Number.POSITIVE_INFINITY) return "Infinity";
				if (value === Number.NEGATIVE_INFINITY) return "-Infinity";
				return value;
			case descriptors_js_1$1.ScalarType.STRING:
				if (typeof value != "string") throw new Error(`cannot encode ${field} to JSON: ${(_c = (0, reflect_check_js_1$1.checkField)(field, value)) === null || _c === void 0 ? void 0 : _c.message}`);
				return value;
			case descriptors_js_1$1.ScalarType.BOOL:
				if (typeof value != "boolean") throw new Error(`cannot encode ${field} to JSON: ${(_d = (0, reflect_check_js_1$1.checkField)(field, value)) === null || _d === void 0 ? void 0 : _d.message}`);
				return value;
			case descriptors_js_1$1.ScalarType.UINT64:
			case descriptors_js_1$1.ScalarType.FIXED64:
			case descriptors_js_1$1.ScalarType.INT64:
			case descriptors_js_1$1.ScalarType.SFIXED64:
			case descriptors_js_1$1.ScalarType.SINT64:
				if (typeof value != "bigint" && typeof value != "string") throw new Error(`cannot encode ${field} to JSON: ${(_e = (0, reflect_check_js_1$1.checkField)(field, value)) === null || _e === void 0 ? void 0 : _e.message}`);
				return value.toString();
			case descriptors_js_1$1.ScalarType.BYTES:
				if (value instanceof Uint8Array) return (0, index_js_2.base64Encode)(value);
				throw new Error(`cannot encode ${field} to JSON: ${(_f = (0, reflect_check_js_1$1.checkField)(field, value)) === null || _f === void 0 ? void 0 : _f.message}`);
		}
	}
	function jsonName(f, opts) {
		return opts.useProtoFieldName ? f.name : f.jsonName;
	}
	function tryWktToJson(msg, opts) {
		if (!msg.desc.typeName.startsWith("google.protobuf.")) return;
		switch (msg.desc.typeName) {
			case "google.protobuf.Any": return anyToJson(msg.message, opts);
			case "google.protobuf.Timestamp": return timestampToJson(msg.message);
			case "google.protobuf.Duration": return durationToJson(msg.message);
			case "google.protobuf.FieldMask": return fieldMaskToJson(msg.message);
			case "google.protobuf.Struct": return structToJson(msg.message);
			case "google.protobuf.Value": return valueToJson(msg.message);
			case "google.protobuf.ListValue": return listValueToJson(msg.message);
			default:
				if ((0, wrappers_js_1.isWrapperDesc)(msg.desc)) {
					const valueField = msg.desc.fields[0];
					return scalarToJson(valueField, msg.get(valueField));
				}
				return;
		}
	}
	function anyToJson(val, opts) {
		if (val.typeUrl === "") return {};
		const { registry } = opts;
		let message;
		let desc;
		if (registry) {
			message = (0, index_js_1$1.anyUnpack)(val, registry);
			if (message) desc = registry.getMessage(message.$typeName);
		}
		if (!desc || !message) throw new Error(`cannot encode message ${val.$typeName} to JSON: "${val.typeUrl}" is not in the type registry`);
		let json = reflectToJson((0, reflect_js_1$2.reflect)(desc, message), opts);
		if (desc.typeName.startsWith("google.protobuf.") || json === null || Array.isArray(json) || typeof json !== "object") json = { value: json };
		json["@type"] = val.typeUrl;
		return json;
	}
	function durationToJson(val) {
		const seconds = Number(val.seconds);
		const nanos = val.nanos;
		if (seconds > 315576e6 || seconds < -315576e6) throw new Error(`cannot encode message ${val.$typeName} to JSON: value out of range`);
		if (seconds > 0 && nanos < 0 || seconds < 0 && nanos > 0) throw new Error(`cannot encode message ${val.$typeName} to JSON: nanos sign must match seconds sign`);
		let text = val.seconds.toString();
		if (nanos !== 0) {
			let nanosStr = Math.abs(nanos).toString();
			nanosStr = "0".repeat(9 - nanosStr.length) + nanosStr;
			if (nanosStr.substring(3) === "000000") nanosStr = nanosStr.substring(0, 3);
			else if (nanosStr.substring(6) === "000") nanosStr = nanosStr.substring(0, 6);
			text += "." + nanosStr;
			if (nanos < 0 && seconds == 0) text = "-" + text;
		}
		return text + "s";
	}
	function fieldMaskToJson(val) {
		return val.paths.map((p$10) => {
			if (p$10.match(/_[0-9]?_/g) || p$10.match(/[A-Z]/g)) throw new Error(`cannot encode message ${val.$typeName} to JSON: lowerCamelCase of path name "` + p$10 + "\" is irreversible");
			return (0, names_js_1.protoCamelCase)(p$10);
		}).join(",");
	}
	function structToJson(val) {
		const json = {};
		for (const [k, v] of Object.entries(val.fields)) json[k] = valueToJson(v);
		return json;
	}
	function valueToJson(val) {
		switch (val.kind.case) {
			case "nullValue": return null;
			case "numberValue":
				if (!Number.isFinite(val.kind.value)) throw new Error(`${val.$typeName} cannot be NaN or Infinity`);
				return val.kind.value;
			case "boolValue": return val.kind.value;
			case "stringValue": return val.kind.value;
			case "structValue": return structToJson(val.kind.value);
			case "listValue": return listValueToJson(val.kind.value);
			default: throw new Error(`${val.$typeName} must have a value`);
		}
	}
	function listValueToJson(val) {
		return val.values.map(valueToJson);
	}
	function timestampToJson(val) {
		const ms = Number(val.seconds) * 1e3;
		if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) throw new Error(`cannot encode message ${val.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
		if (val.nanos < 0) throw new Error(`cannot encode message ${val.$typeName} to JSON: nanos must not be negative`);
		if (val.nanos > 999999999) throw new Error(`cannot encode message ${val.$typeName} to JSON: nanos must not be greater than 99999999`);
		let z = "Z";
		if (val.nanos > 0) {
			const nanosStr = (val.nanos + 1e9).toString().substring(1);
			if (nanosStr.substring(3) === "000000") z = "." + nanosStr.substring(0, 3) + "Z";
			else if (nanosStr.substring(6) === "000") z = "." + nanosStr.substring(0, 6) + "Z";
			else z = "." + nanosStr + "Z";
		}
		return new Date(ms).toISOString().replace(".000Z", z);
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/from-json.js
var require_from_json = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/from-json.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fromJsonString = fromJsonString;
	exports.mergeFromJsonString = mergeFromJsonString;
	exports.fromJson = fromJson;
	exports.mergeFromJson = mergeFromJson;
	exports.enumFromJson = enumFromJson;
	exports.isEnumJson = isEnumJson;
	var descriptors_js_1 = require_descriptors();
	var proto_int64_js_1 = require_proto_int64();
	var create_js_1 = require_create();
	var reflect_js_1$1 = require_reflect();
	var error_js_1 = require_error();
	var reflect_check_js_1 = require_reflect_check();
	var scalar_js_1 = require_scalar$1();
	var base64_encoding_js_1 = require_base64_encoding();
	var index_js_1 = require_wkt();
	var extensions_js_1$1 = require_extensions();
	var jsonReadDefaults = { ignoreUnknownFields: false };
	function makeReadOptions(options) {
		return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
	}
	/**
	* Parse a message from a JSON string.
	*/
	function fromJsonString(schema, json, options) {
		return fromJson(schema, parseJsonString(json, schema.typeName), options);
	}
	/**
	* Parse a message from a JSON string, merging fields.
	*
	* Repeated fields are appended. Map entries are added, overwriting
	* existing keys.
	*
	* If a message field is already present, it will be merged with the
	* new data.
	*/
	function mergeFromJsonString(schema, target, json, options) {
		return mergeFromJson(schema, target, parseJsonString(json, schema.typeName), options);
	}
	/**
	* Parse a message from a JSON value.
	*/
	function fromJson(schema, json, options) {
		const msg = (0, reflect_js_1$1.reflect)(schema);
		try {
			readMessage(msg, json, makeReadOptions(options));
		} catch (e) {
			if ((0, error_js_1.isFieldError)(e)) throw new Error(`cannot decode ${e.field()} from JSON: ${e.message}`, { cause: e });
			throw e;
		}
		return msg.message;
	}
	/**
	* Parse a message from a JSON value, merging fields.
	*
	* Repeated fields are appended. Map entries are added, overwriting
	* existing keys.
	*
	* If a message field is already present, it will be merged with the
	* new data.
	*/
	function mergeFromJson(schema, target, json, options) {
		try {
			readMessage((0, reflect_js_1$1.reflect)(schema, target), json, makeReadOptions(options));
		} catch (e) {
			if ((0, error_js_1.isFieldError)(e)) throw new Error(`cannot decode ${e.field()} from JSON: ${e.message}`, { cause: e });
			throw e;
		}
		return target;
	}
	/**
	* Parses an enum value from JSON.
	*/
	function enumFromJson(descEnum, json) {
		const val = readEnum(descEnum, json, false, false);
		if (val === tokenIgnoredUnknownEnum) throw new Error(`cannot decode ${descEnum} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
		return val;
	}
	/**
	* Is the given value a JSON enum value?
	*/
	function isEnumJson(descEnum, value) {
		return void 0 !== descEnum.values.find((v) => v.name === value);
	}
	function readMessage(msg, json, opts) {
		var _a;
		if (tryWktFromJson(msg, json, opts)) return;
		if (json == null || Array.isArray(json) || typeof json != "object") throw new Error(`cannot decode ${msg.desc} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
		const oneofSeen = /* @__PURE__ */ new Map();
		const jsonNames = /* @__PURE__ */ new Map();
		for (const field of msg.desc.fields) jsonNames.set(field.name, field).set(field.jsonName, field);
		for (const [jsonKey, jsonValue] of Object.entries(json)) {
			const field = jsonNames.get(jsonKey);
			if (field) {
				if (field.oneof) {
					if (jsonValue === null && field.fieldKind == "scalar") continue;
					const seen = oneofSeen.get(field.oneof);
					if (seen !== void 0) throw new error_js_1.FieldError(field.oneof, `oneof set multiple times by ${seen.name} and ${field.name}`);
					oneofSeen.set(field.oneof, field);
				}
				readField(msg, field, jsonValue, opts);
			} else {
				let extension = void 0;
				if (jsonKey.startsWith("[") && jsonKey.endsWith("]") && (extension = (_a = opts.registry) === null || _a === void 0 ? void 0 : _a.getExtension(jsonKey.substring(1, jsonKey.length - 1))) && extension.extendee.typeName === msg.desc.typeName) {
					const [container, field$1, get$2] = (0, extensions_js_1$1.createExtensionContainer)(extension);
					readField(container, field$1, jsonValue, opts);
					(0, extensions_js_1$1.setExtension)(msg.message, extension, get$2());
				}
				if (!extension && !opts.ignoreUnknownFields) throw new Error(`cannot decode ${msg.desc} from JSON: key "${jsonKey}" is unknown`);
			}
		}
	}
	function readField(msg, field, json, opts) {
		switch (field.fieldKind) {
			case "scalar":
				readScalarField(msg, field, json);
				break;
			case "enum":
				readEnumField(msg, field, json, opts);
				break;
			case "message":
				readMessageField(msg, field, json, opts);
				break;
			case "list":
				readListField(msg.get(field), json, opts);
				break;
			case "map":
				readMapField(msg.get(field), json, opts);
				break;
		}
	}
	function readMapField(map$1, json, opts) {
		if (json === null) return;
		const field = map$1.field();
		if (typeof json != "object" || Array.isArray(json)) throw new error_js_1.FieldError(field, "expected object, got " + (0, reflect_check_js_1.formatVal)(json));
		for (const [jsonMapKey, jsonMapValue] of Object.entries(json)) {
			if (jsonMapValue === null) throw new error_js_1.FieldError(field, "map value must not be null");
			let value;
			switch (field.mapKind) {
				case "message":
					const msgValue = (0, reflect_js_1$1.reflect)(field.message);
					readMessage(msgValue, jsonMapValue, opts);
					value = msgValue;
					break;
				case "enum":
					value = readEnum(field.enum, jsonMapValue, opts.ignoreUnknownFields, true);
					if (value === tokenIgnoredUnknownEnum) return;
					break;
				case "scalar":
					value = scalarFromJson(field, jsonMapValue, true);
					break;
			}
			const key = mapKeyFromJson(field.mapKey, jsonMapKey);
			map$1.set(key, value);
		}
	}
	function readListField(list, json, opts) {
		if (json === null) return;
		const field = list.field();
		if (!Array.isArray(json)) throw new error_js_1.FieldError(field, "expected Array, got " + (0, reflect_check_js_1.formatVal)(json));
		for (const jsonItem of json) {
			if (jsonItem === null) throw new error_js_1.FieldError(field, "list item must not be null");
			switch (field.listKind) {
				case "message":
					const msgValue = (0, reflect_js_1$1.reflect)(field.message);
					readMessage(msgValue, jsonItem, opts);
					list.add(msgValue);
					break;
				case "enum":
					const enumValue = readEnum(field.enum, jsonItem, opts.ignoreUnknownFields, true);
					if (enumValue !== tokenIgnoredUnknownEnum) list.add(enumValue);
					break;
				case "scalar":
					list.add(scalarFromJson(field, jsonItem, true));
					break;
			}
		}
	}
	function readMessageField(msg, field, json, opts) {
		if (json === null && field.message.typeName != "google.protobuf.Value") {
			msg.clear(field);
			return;
		}
		const msgValue = msg.isSet(field) ? msg.get(field) : (0, reflect_js_1$1.reflect)(field.message);
		readMessage(msgValue, json, opts);
		msg.set(field, msgValue);
	}
	function readEnumField(msg, field, json, opts) {
		const enumValue = readEnum(field.enum, json, opts.ignoreUnknownFields, false);
		if (enumValue === tokenNull) msg.clear(field);
		else if (enumValue !== tokenIgnoredUnknownEnum) msg.set(field, enumValue);
	}
	function readScalarField(msg, field, json) {
		const scalarValue = scalarFromJson(field, json, false);
		if (scalarValue === tokenNull) msg.clear(field);
		else msg.set(field, scalarValue);
	}
	var tokenIgnoredUnknownEnum = Symbol();
	function readEnum(desc, json, ignoreUnknownFields, nullAsZeroValue) {
		if (json === null) {
			if (desc.typeName == "google.protobuf.NullValue") return 0;
			return nullAsZeroValue ? desc.values[0].number : tokenNull;
		}
		switch (typeof json) {
			case "number":
				if (Number.isInteger(json)) return json;
				break;
			case "string":
				const value = desc.values.find((ev) => ev.name === json);
				if (value !== void 0) return value.number;
				if (ignoreUnknownFields) return tokenIgnoredUnknownEnum;
				break;
		}
		throw new Error(`cannot decode ${desc} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
	}
	var tokenNull = Symbol();
	function scalarFromJson(field, json, nullAsZeroValue) {
		if (json === null) {
			if (nullAsZeroValue) return (0, scalar_js_1.scalarZeroValue)(field.scalar, false);
			return tokenNull;
		}
		switch (field.scalar) {
			case descriptors_js_1.ScalarType.DOUBLE:
			case descriptors_js_1.ScalarType.FLOAT:
				if (json === "NaN") return NaN;
				if (json === "Infinity") return Number.POSITIVE_INFINITY;
				if (json === "-Infinity") return Number.NEGATIVE_INFINITY;
				if (typeof json == "number") {
					if (Number.isNaN(json)) throw new error_js_1.FieldError(field, "unexpected NaN number");
					if (!Number.isFinite(json)) throw new error_js_1.FieldError(field, "unexpected infinite number");
					break;
				}
				if (typeof json == "string") {
					if (json === "") break;
					if (json.trim().length !== json.length) break;
					const float = Number(json);
					if (!Number.isFinite(float)) break;
					return float;
				}
				break;
			case descriptors_js_1.ScalarType.INT32:
			case descriptors_js_1.ScalarType.FIXED32:
			case descriptors_js_1.ScalarType.SFIXED32:
			case descriptors_js_1.ScalarType.SINT32:
			case descriptors_js_1.ScalarType.UINT32: return int32FromJson(json);
			case descriptors_js_1.ScalarType.BYTES:
				if (typeof json == "string") {
					if (json === "") return new Uint8Array(0);
					try {
						return (0, base64_encoding_js_1.base64Decode)(json);
					} catch (e) {
						const message = e instanceof Error ? e.message : String(e);
						throw new error_js_1.FieldError(field, message);
					}
				}
				break;
		}
		return json;
	}
	/**
	* Try to parse a JSON value to a map key for the reflect API.
	*
	* Returns the input if the JSON value cannot be converted.
	*/
	function mapKeyFromJson(type$1, json) {
		switch (type$1) {
			case descriptors_js_1.ScalarType.BOOL:
				switch (json) {
					case "true": return true;
					case "false": return false;
				}
				return json;
			case descriptors_js_1.ScalarType.INT32:
			case descriptors_js_1.ScalarType.FIXED32:
			case descriptors_js_1.ScalarType.UINT32:
			case descriptors_js_1.ScalarType.SFIXED32:
			case descriptors_js_1.ScalarType.SINT32: return int32FromJson(json);
			default: return json;
		}
	}
	/**
	* Try to parse a JSON value to a 32-bit integer for the reflect API.
	*
	* Returns the input if the JSON value cannot be converted.
	*/
	function int32FromJson(json) {
		if (typeof json == "string") {
			if (json === "") return json;
			if (json.trim().length !== json.length) return json;
			const num = Number(json);
			if (Number.isNaN(num)) return json;
			return num;
		}
		return json;
	}
	function parseJsonString(jsonString, typeName) {
		try {
			return JSON.parse(jsonString);
		} catch (e) {
			const message = e instanceof Error ? e.message : String(e);
			throw new Error(`cannot decode message ${typeName} from JSON: ${message}`, { cause: e });
		}
	}
	function tryWktFromJson(msg, jsonValue, opts) {
		if (!msg.desc.typeName.startsWith("google.protobuf.")) return false;
		switch (msg.desc.typeName) {
			case "google.protobuf.Any":
				anyFromJson(msg.message, jsonValue, opts);
				return true;
			case "google.protobuf.Timestamp":
				timestampFromJson(msg.message, jsonValue);
				return true;
			case "google.protobuf.Duration":
				durationFromJson(msg.message, jsonValue);
				return true;
			case "google.protobuf.FieldMask":
				fieldMaskFromJson(msg.message, jsonValue);
				return true;
			case "google.protobuf.Struct":
				structFromJson(msg.message, jsonValue);
				return true;
			case "google.protobuf.Value":
				valueFromJson(msg.message, jsonValue);
				return true;
			case "google.protobuf.ListValue":
				listValueFromJson(msg.message, jsonValue);
				return true;
			default:
				if ((0, index_js_1.isWrapperDesc)(msg.desc)) {
					const valueField = msg.desc.fields[0];
					if (jsonValue === null) msg.clear(valueField);
					else msg.set(valueField, scalarFromJson(valueField, jsonValue, true));
					return true;
				}
				return false;
		}
	}
	function anyFromJson(any, json, opts) {
		var _a;
		if (json === null || Array.isArray(json) || typeof json != "object") throw new Error(`cannot decode message ${any.$typeName} from JSON: expected object but got ${(0, reflect_check_js_1.formatVal)(json)}`);
		if (Object.keys(json).length == 0) return;
		const typeUrl = json["@type"];
		if (typeof typeUrl != "string" || typeUrl == "") throw new Error(`cannot decode message ${any.$typeName} from JSON: "@type" is empty`);
		const typeName = typeUrl.includes("/") ? typeUrl.substring(typeUrl.lastIndexOf("/") + 1) : typeUrl;
		if (!typeName.length) throw new Error(`cannot decode message ${any.$typeName} from JSON: "@type" is invalid`);
		const desc = (_a = opts.registry) === null || _a === void 0 ? void 0 : _a.getMessage(typeName);
		if (!desc) throw new Error(`cannot decode message ${any.$typeName} from JSON: ${typeUrl} is not in the type registry`);
		const msg = (0, reflect_js_1$1.reflect)(desc);
		if (typeName.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(json, "value")) {
			const value = json.value;
			readMessage(msg, value, opts);
		} else {
			const copy = Object.assign({}, json);
			delete copy["@type"];
			readMessage(msg, copy, opts);
		}
		(0, index_js_1.anyPack)(msg.desc, msg.message, any);
	}
	function timestampFromJson(timestamp$1, json) {
		if (typeof json !== "string") throw new Error(`cannot decode message ${timestamp$1.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
		const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
		if (!matches) throw new Error(`cannot decode message ${timestamp$1.$typeName} from JSON: invalid RFC 3339 string`);
		const ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
		if (Number.isNaN(ms)) throw new Error(`cannot decode message ${timestamp$1.$typeName} from JSON: invalid RFC 3339 string`);
		if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) throw new Error(`cannot decode message ${timestamp$1.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
		timestamp$1.seconds = proto_int64_js_1.protoInt64.parse(ms / 1e3);
		timestamp$1.nanos = 0;
		if (matches[7]) timestamp$1.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
	}
	function durationFromJson(duration, json) {
		if (typeof json !== "string") throw new Error(`cannot decode message ${duration.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
		const match = json.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
		if (match === null) throw new Error(`cannot decode message ${duration.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
		const longSeconds = Number(match[1]);
		if (longSeconds > 315576e6 || longSeconds < -315576e6) throw new Error(`cannot decode message ${duration.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
		duration.seconds = proto_int64_js_1.protoInt64.parse(longSeconds);
		if (typeof match[2] !== "string") return;
		const nanosStr = match[2] + "0".repeat(9 - match[2].length);
		duration.nanos = parseInt(nanosStr);
		if (longSeconds < 0 || Object.is(longSeconds, -0)) duration.nanos = -duration.nanos;
	}
	function fieldMaskFromJson(fieldMask, json) {
		if (typeof json !== "string") throw new Error(`cannot decode message ${fieldMask.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
		if (json === "") return;
		function camelToSnake(str) {
			if (str.includes("_")) throw new Error(`cannot decode message ${fieldMask.$typeName} from JSON: path names must be lowerCamelCase`);
			const sc = str.replace(/[A-Z]/g, (letter) => "_" + letter.toLowerCase());
			return sc[0] === "_" ? sc.substring(1) : sc;
		}
		fieldMask.paths = json.split(",").map(camelToSnake);
	}
	function structFromJson(struct, json) {
		if (typeof json != "object" || json == null || Array.isArray(json)) throw new Error(`cannot decode message ${struct.$typeName} from JSON ${(0, reflect_check_js_1.formatVal)(json)}`);
		for (const [k, v] of Object.entries(json)) {
			const parsedV = (0, create_js_1.create)(index_js_1.ValueSchema);
			valueFromJson(parsedV, v);
			struct.fields[k] = parsedV;
		}
	}
	function valueFromJson(value, json) {
		switch (typeof json) {
			case "number":
				value.kind = {
					case: "numberValue",
					value: json
				};
				break;
			case "string":
				value.kind = {
					case: "stringValue",
					value: json
				};
				break;
			case "boolean":
				value.kind = {
					case: "boolValue",
					value: json
				};
				break;
			case "object":
				if (json === null) value.kind = {
					case: "nullValue",
					value: index_js_1.NullValue.NULL_VALUE
				};
				else if (Array.isArray(json)) {
					const listValue = (0, create_js_1.create)(index_js_1.ListValueSchema);
					listValueFromJson(listValue, json);
					value.kind = {
						case: "listValue",
						value: listValue
					};
				} else {
					const struct = (0, create_js_1.create)(index_js_1.StructSchema);
					structFromJson(struct, json);
					value.kind = {
						case: "structValue",
						value: struct
					};
				}
				break;
			default: throw new Error(`cannot decode message ${value.$typeName} from JSON ${(0, reflect_check_js_1.formatVal)(json)}`);
		}
		return value;
	}
	function listValueFromJson(listValue, json) {
		if (!Array.isArray(json)) throw new Error(`cannot decode message ${listValue.$typeName} from JSON ${(0, reflect_check_js_1.formatVal)(json)}`);
		for (const e of json) {
			const value = (0, create_js_1.create)(index_js_1.ValueSchema);
			valueFromJson(value, e);
			listValue.values.push(value);
		}
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/merge.js
var require_merge = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/merge.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.merge = merge;
	var reflect_js_1 = require_reflect();
	/**
	* Merge message `source` into message `target`, following Protobuf semantics.
	*
	* This is the same as serializing the source message, then deserializing it
	* into the target message via `mergeFromBinary()`, with one difference:
	* While serialization will create a copy of all values, `merge()` will copy
	* the reference for `bytes` and messages.
	*
	* Also see https://protobuf.com/docs/language-spec#merging-protobuf-messages
	*/
	function merge(schema, target, source) {
		reflectMerge((0, reflect_js_1.reflect)(schema, target), (0, reflect_js_1.reflect)(schema, source));
	}
	function reflectMerge(target, source) {
		var _a;
		var _b;
		const sourceUnknown = source.message.$unknown;
		if (sourceUnknown !== void 0 && sourceUnknown.length > 0) {
			(_a = (_b = target.message).$unknown) !== null && _a !== void 0 || (_b.$unknown = []);
			target.message.$unknown.push(...sourceUnknown);
		}
		for (const f of target.fields) {
			if (!source.isSet(f)) continue;
			switch (f.fieldKind) {
				case "scalar":
				case "enum":
					target.set(f, source.get(f));
					break;
				case "message":
					if (target.isSet(f)) reflectMerge(target.get(f), source.get(f));
					else target.set(f, source.get(f));
					break;
				case "list":
					const list = target.get(f);
					for (const e of source.get(f)) list.add(e);
					break;
				case "map":
					const map$1 = target.get(f);
					for (const [k, v] of source.get(f)) map$1.set(k, v);
					break;
			}
		}
	}
}) });

//#endregion
//#region node_modules/@bufbuild/protobuf/dist/cjs/index.js
var require_cjs = /* @__PURE__ */ __commonJS({ "node_modules/@bufbuild/protobuf/dist/cjs/index.js": ((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	}));
	var __exportStar = exports && exports.__exportStar || function(m$1, exports$1) {
		for (var p$10 in m$1) if (p$10 !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p$10)) __createBinding(exports$1, m$1, p$10);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOption = exports.hasOption = exports.clearExtension = exports.setExtension = exports.getExtension = exports.hasExtension = exports.mergeFromBinary = exports.fromBinary = exports.toBinary = void 0;
	__exportStar(require_types(), exports);
	__exportStar(require_is_message(), exports);
	__exportStar(require_create(), exports);
	__exportStar(require_clone(), exports);
	__exportStar(require_descriptors(), exports);
	__exportStar(require_equals(), exports);
	__exportStar(require_fields(), exports);
	__exportStar(require_registry(), exports);
	var to_binary_js_1 = require_to_binary();
	Object.defineProperty(exports, "toBinary", {
		enumerable: true,
		get: function() {
			return to_binary_js_1.toBinary;
		}
	});
	var from_binary_js_1 = require_from_binary();
	Object.defineProperty(exports, "fromBinary", {
		enumerable: true,
		get: function() {
			return from_binary_js_1.fromBinary;
		}
	});
	Object.defineProperty(exports, "mergeFromBinary", {
		enumerable: true,
		get: function() {
			return from_binary_js_1.mergeFromBinary;
		}
	});
	__exportStar(require_to_json(), exports);
	__exportStar(require_from_json(), exports);
	__exportStar(require_merge(), exports);
	var extensions_js_1 = require_extensions();
	Object.defineProperty(exports, "hasExtension", {
		enumerable: true,
		get: function() {
			return extensions_js_1.hasExtension;
		}
	});
	Object.defineProperty(exports, "getExtension", {
		enumerable: true,
		get: function() {
			return extensions_js_1.getExtension;
		}
	});
	Object.defineProperty(exports, "setExtension", {
		enumerable: true,
		get: function() {
			return extensions_js_1.setExtension;
		}
	});
	Object.defineProperty(exports, "clearExtension", {
		enumerable: true,
		get: function() {
			return extensions_js_1.clearExtension;
		}
	});
	Object.defineProperty(exports, "hasOption", {
		enumerable: true,
		get: function() {
			return extensions_js_1.hasOption;
		}
	});
	Object.defineProperty(exports, "getOption", {
		enumerable: true,
		get: function() {
			return extensions_js_1.getOption;
		}
	});
	__exportStar(require_proto_int64(), exports);
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/request-tracker.js
var require_request_tracker = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/request-tracker.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* Manages pending inbound and outbound requests. Ensures that requests and
	* responses interact correctly and obey the Embedded Protocol.
	*/
	var RequestTracker = class {
		requests = [];
		/** The next available request ID. */
		get nextId() {
			for (let i = 0; i < this.requests.length; i++) if (this.requests[i] === void 0 || this.requests[i] === null) return i;
			return this.requests.length;
		}
		/**
		* Adds an entry for a pending request with ID `id`. The entry stores the
		* expected response type. Throws an error if the Protocol Error is violated.
		*/
		add(id, expectedResponseType) {
			if (id < 0) throw Error(`Invalid request ID ${id}.`);
			else if (this.requests[id]) throw Error(`Request ID ${id} is already in use by an in-flight request.`);
			this.requests[id] = expectedResponseType;
		}
		/**
		* Resolves a pending request with matching ID `id` and expected response type
		* `type`. Throws an error if the Protocol Error is violated.
		*/
		resolve(id, type$1) {
			if (this.requests[id] === void 0 || this.requests[id] === null) throw Error(`Response ID ${id} does not match any pending requests.`);
			else if (this.requests[id] !== type$1) throw Error(`Response with ID ${id} does not match pending request's type. Expected ${this.requests[id]} but received ${type$1}.`);
			this.requests[id] = null;
		}
	};
	exports.RequestTracker = RequestTracker;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/dispatcher.js
var require_dispatcher = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/dispatcher.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var rxjs_1$4 = require_cjs$1();
	var operators_1$3 = require_operators();
	var protobuf_1$5 = require_cjs();
	var proto$4 = require_embedded_sass_pb();
	var request_tracker_1 = require_request_tracker();
	var utils_1$9 = require_utils$3();
	/**
	* Dispatches requests, responses, and events for a single compilation.
	*
	* Accepts callbacks for processing different types of outbound requests. When
	* an outbound request arrives, this runs the appropriate callback to process
	* it, and then sends the result inbound. A single callback must be provided for
	* each outbound request type. The callback does not need to set the response
	* ID; the dispatcher handles it.
	*
	* Consumers can send an inbound request. This returns a promise that will
	* either resolve with the corresponding outbound response, or error if any
	* Protocol Errors were encountered. The consumer does not need to set the
	* request ID; the dispatcher handles it.
	*
	* Outbound events are exposed as Observables.
	*
	* Errors are not otherwise exposed to the top-level. Instead, they are surfaced
	* as an Observable that consumers may choose to subscribe to. Subscribers must
	* perform proper error handling.
	*/
	var Dispatcher = class {
		compilationId;
		outboundMessages$;
		writeInboundMessage;
		outboundRequestHandlers;
		pendingOutboundRequests = new request_tracker_1.RequestTracker();
		messages$ = new rxjs_1$4.Subject();
		unsubscribe$ = new rxjs_1$4.Subject();
		errorInternal$ = new rxjs_1$4.Subject();
		/**
		* If the dispatcher encounters an error, this errors out. Upon error, the
		* dispatcher rejects all promises awaiting an outbound response, and silently
		* closes all subscriptions to outbound events.
		*/
		error$ = this.errorInternal$.pipe();
		/**
		* Outbound log events. If an error occurs, the dispatcher closes this
		* silently.
		*/
		logEvents$ = this.messages$.pipe((0, operators_1$3.filter)((message) => message.message.case === "logEvent"), (0, operators_1$3.map)((message) => message.message.value));
		constructor(compilationId, outboundMessages$, writeInboundMessage, outboundRequestHandlers) {
			this.compilationId = compilationId;
			this.outboundMessages$ = outboundMessages$;
			this.writeInboundMessage = writeInboundMessage;
			this.outboundRequestHandlers = outboundRequestHandlers;
			if (compilationId < 1) throw Error(`Invalid compilation ID ${compilationId}.`);
			this.outboundMessages$.pipe((0, operators_1$3.filter)(([compilationId$1]) => compilationId$1 === this.compilationId), (0, operators_1$3.map)(([, message]) => message), (0, operators_1$3.mergeMap)((message) => {
				const result = this.handleOutboundMessage(message);
				return result instanceof Promise ? result.then(() => message) : [message];
			}), (0, operators_1$3.takeUntil)(this.unsubscribe$)).subscribe({
				next: (message) => this.messages$.next(message),
				error: (error) => this.throwAndClose(error),
				complete: () => {
					this.messages$.complete();
					this.errorInternal$.complete();
				}
			});
		}
		/**
		* Sends a CompileRequest inbound. Passes the corresponding outbound
		* CompileResponse or an error to `callback` and unsubscribes from all
		* outbound events.
		*
		* This uses an old-style callback argument so that it can work either
		* synchronously or asynchronously. If the underlying stdout stream emits
		* events synchronously, `callback` will be called synchronously.
		*/
		sendCompileRequest(request, callback) {
			const callback_ = (err, response) => {
				this.unsubscribe();
				return callback(err, response);
			};
			if (this.messages$.isStopped) {
				callback_(/* @__PURE__ */ new Error("Tried writing to closed dispatcher"), void 0);
				return;
			}
			this.messages$.pipe((0, operators_1$3.filter)((message) => message.message.case === "compileResponse"), (0, operators_1$3.map)((message) => message.message.value)).subscribe({ next: (response) => callback_(null, response) });
			this.error$.subscribe({ error: (error) => callback_(error, void 0) });
			try {
				this.writeInboundMessage([this.compilationId, (0, protobuf_1$5.create)(proto$4.InboundMessageSchema, { message: {
					value: request,
					case: "compileRequest"
				} })]);
			} catch (error) {
				this.throwAndClose(error);
			}
		}
		unsubscribe() {
			this.unsubscribe$.next(void 0);
			this.unsubscribe$.complete();
		}
		throwAndClose(error) {
			this.messages$.complete();
			this.errorInternal$.error(error);
			this.unsubscribe();
		}
		handleOutboundMessage(message) {
			switch (message.message.case) {
				case "logEvent": return;
				case "compileResponse": return;
				case "importRequest": {
					const request = message.message.value;
					const id = request.id;
					const type$1 = "importResponse";
					this.pendingOutboundRequests.add(id, type$1);
					return (0, utils_1$9.thenOr)(this.outboundRequestHandlers.handleImportRequest(request), (response) => {
						this.sendInboundMessage(id, {
							case: type$1,
							value: response
						});
					});
				}
				case "fileImportRequest": {
					const request = message.message.value;
					const id = request.id;
					const type$1 = "fileImportResponse";
					this.pendingOutboundRequests.add(id, type$1);
					return (0, utils_1$9.thenOr)(this.outboundRequestHandlers.handleFileImportRequest(request), (response) => {
						this.sendInboundMessage(id, {
							case: type$1,
							value: response
						});
					});
				}
				case "canonicalizeRequest": {
					const request = message.message.value;
					const id = request.id;
					const type$1 = "canonicalizeResponse";
					this.pendingOutboundRequests.add(id, type$1);
					return (0, utils_1$9.thenOr)(this.outboundRequestHandlers.handleCanonicalizeRequest(request), (response) => {
						this.sendInboundMessage(id, {
							case: type$1,
							value: response
						});
					});
				}
				case "functionCallRequest": {
					const request = message.message.value;
					const id = request.id;
					const type$1 = "functionCallResponse";
					this.pendingOutboundRequests.add(id, type$1);
					return (0, utils_1$9.thenOr)(this.outboundRequestHandlers.handleFunctionCallRequest(request), (response) => {
						this.sendInboundMessage(id, {
							case: type$1,
							value: response
						});
					});
				}
				case "error": throw (0, utils_1$9.hostError)(message.message.value.message);
				default: throw (0, utils_1$9.compilerError)(`Unknown message type ${message.message.case}`);
			}
		}
		sendInboundMessage(requestId, message) {
			message.value.id = requestId;
			if (message.case === "importResponse" || message.case === "fileImportResponse" || message.case === "canonicalizeResponse" || message.case === "functionCallResponse") this.pendingOutboundRequests.resolve(requestId, message.case);
			else throw Error(`Unknown message type ${message.case}`);
			this.writeInboundMessage([this.compilationId, (0, protobuf_1$5.create)(proto$4.InboundMessageSchema, { message })]);
		}
	};
	exports.Dispatcher = Dispatcher;
}) });

//#endregion
//#region browser-external:assert
var require_browser_external_assert = /* @__PURE__ */ __commonJS({ "browser-external:assert": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region browser-external:fs
var require_browser_external_fs = /* @__PURE__ */ __commonJS({ "browser-external:fs": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/resolve-path.js
var require_resolve_path = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/resolve-path.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.resolvePath = resolvePath;
	var fs$4 = require_browser_external_fs();
	var p$7 = require_browser_external_path();
	/**
	* Resolves a path using the same logic as the filesystem importer.
	*
	* This tries to fill in extensions and partial prefixes and check for a
	* directory default. If no file can be found, it returns `null`.
	*/
	function resolvePath(path$2, fromImport) {
		const extension = p$7.extname(path$2);
		if (extension === ".sass" || extension === ".scss" || extension === ".css") return (fromImport ? exactlyOne(tryPath(`${withoutExtension(path$2)}.import${extension}`)) : null) ?? exactlyOne(tryPath(path$2));
		return (fromImport ? exactlyOne(tryPathWithExtensions(`${path$2}.import`)) : null) ?? exactlyOne(tryPathWithExtensions(path$2)) ?? tryPathAsDirectory(path$2, fromImport);
	}
	function tryPathWithExtensions(path$2) {
		const result = [...tryPath(path$2 + ".sass"), ...tryPath(path$2 + ".scss")];
		return result.length > 0 ? result : tryPath(path$2 + ".css");
	}
	function tryPath(path$2) {
		const partial = p$7.join(p$7.dirname(path$2), `_${p$7.basename(path$2)}`);
		const result = [];
		if (fileExists(partial)) result.push(partial);
		if (fileExists(path$2)) result.push(path$2);
		return result;
	}
	function tryPathAsDirectory(path$2, fromImport) {
		if (!dirExists(path$2)) return null;
		return (fromImport ? exactlyOne(tryPathWithExtensions(p$7.join(path$2, "index.import"))) : null) ?? exactlyOne(tryPathWithExtensions(p$7.join(path$2, "index")));
	}
	function exactlyOne(paths) {
		if (paths.length === 0) return null;
		if (paths.length === 1) return paths[0];
		throw new Error("It's not clear which file to import. Found:\n" + paths.map((path$2) => "  " + path$2).join("\n"));
	}
	function fileExists(path$2) {
		if (!fs$4.existsSync(path$2)) return false;
		try {
			return fs$4.statSync(path$2).isFile();
		} catch (error) {
			if (error.code === "ENOENT") return false;
			throw error;
		}
	}
	function dirExists(path$2) {
		if (!fs$4.existsSync(path$2)) return false;
		try {
			return fs$4.statSync(path$2).isDirectory();
		} catch (error) {
			if (error.code === "ENOENT") return false;
			throw error;
		}
	}
	function withoutExtension(path$2) {
		const extension = p$7.extname(path$2);
		return path$2.substring(0, path$2.length - extension.length);
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/importer.js
var require_importer = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/importer.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LegacyImporterWrapper = exports.metaNamespace = exports.legacyImporterFileProtocol = exports.endOfLoadProtocol = void 0;
	var assert_1$2 = require_browser_external_assert();
	var fs$3 = require_browser_external_fs();
	var p$6 = require_browser_external_path();
	var util = require_browser_external_util();
	var resolve_path_1 = require_resolve_path();
	var utils_1$8 = require_utils$3();
	var utils_2$1 = require_utils$1();
	/**
	* A special URL protocol we use to signal when a stylesheet has finished
	* loading. This allows us to determine which stylesheet is "current" when
	* resolving a new load, which in turn allows us to pass in an accurate `prev`
	* parameter to the legacy callback.
	*/
	exports.endOfLoadProtocol = "sass-embedded-legacy-load-done:";
	/**
	* The `file:` URL protocol with [legacyImporterProtocolPrefix] at the beginning.
	*/
	exports.legacyImporterFileProtocol = "legacy-importer-file:";
	/**
	* A random namespace for `sass:meta`, so we can use `meta.load-css()` at the end
	* of the file to signal that a load has finished without polluting a namespace
	* a user might actually use.
	*/
	exports.metaNamespace = `---${Math.random().toString(36).substring(2)}`;
	var endOfLoadCount = 0;
	/**
	* A wrapper around a `LegacyImporter` callback that exposes it as a new-API
	* `Importer`.
	*/
	var LegacyImporterWrapper = class {
		self;
		callbacks;
		loadPaths;
		sync;
		prev = [];
		lastContents;
		constructor(self, callbacks, loadPaths, initialPrev, sync) {
			this.self = self;
			this.callbacks = callbacks;
			this.loadPaths = loadPaths;
			this.sync = sync;
			const path$2 = initialPrev !== "stdin";
			this.prev.push({
				url: path$2 ? p$6.resolve(initialPrev) : "stdin",
				path: path$2
			});
		}
		canonicalize(url$1, options) {
			if (url$1.startsWith(exports.endOfLoadProtocol)) return new URL(url$1);
			if (options.containingUrl !== null) try {
				const absoluteUrl = new URL(url$1, options.containingUrl).toString();
				const resolved$1 = this.canonicalize(absoluteUrl, {
					fromImport: options.fromImport,
					containingUrl: null
				});
				if (resolved$1 !== null) return resolved$1;
			} catch (error) {
				if (error instanceof TypeError && (0, utils_1$8.isErrnoException)(error) && error.code === "ERR_INVALID_URL") {} else throw error;
			}
			if (url$1.startsWith(utils_2$1.legacyImporterProtocolPrefix) || url$1.startsWith(utils_2$1.legacyImporterProtocol)) {
				const urlWithoutPrefix = url$1.substring(utils_2$1.legacyImporterProtocolPrefix.length);
				if (urlWithoutPrefix.startsWith("file:")) {
					let resolved$1 = null;
					try {
						const path$2 = (0, utils_1$8.fileUrlToPathCrossPlatform)(urlWithoutPrefix);
						resolved$1 = (0, resolve_path_1.resolvePath)(path$2, options.fromImport);
					} catch (error) {
						if (error instanceof TypeError && (0, utils_1$8.isErrnoException)(error) && (error.code === "ERR_INVALID_URL" || error.code === "ERR_INVALID_FILE_URL_PATH")) {} else throw error;
					}
					if (resolved$1 !== null) {
						this.prev.push({
							url: resolved$1,
							path: true
						});
						return (0, utils_2$1.pathToLegacyFileUrl)(resolved$1);
					}
				}
				return null;
			}
			const prev = this.prev[this.prev.length - 1];
			return (0, utils_1$8.thenOr)((0, utils_1$8.thenOr)(this.invokeCallbacks(url$1, prev.url, options), (result) => {
				if (result instanceof Error) throw result;
				if (result === null) return null;
				if (typeof result !== "object") throw `Expected importer to return an object, got ${util.inspect(result)}.`;
				if ("contents" in result || !("file" in result)) {
					this.lastContents = result.contents ?? "";
					if ("file" in result) return new URL(utils_2$1.legacyImporterProtocol + encodeURI(result.file));
					else if (/^[A-Za-z+.-]+:/.test(url$1)) return new URL(`${utils_2$1.legacyImporterProtocolPrefix}${url$1}`);
					else return new URL(utils_2$1.legacyImporterProtocol + encodeURI(url$1));
				} else {
					if (p$6.isAbsolute(result.file)) {
						const resolved$1 = (0, resolve_path_1.resolvePath)(result.file, options.fromImport);
						return resolved$1 ? (0, utils_2$1.pathToLegacyFileUrl)(resolved$1) : null;
					}
					const prefixes = [...this.loadPaths, "."];
					if (prev.path) prefixes.unshift(p$6.dirname(prev.url));
					for (const prefix of prefixes) {
						const resolved$1 = (0, resolve_path_1.resolvePath)(p$6.join(prefix, result.file), options.fromImport);
						if (resolved$1 !== null) return (0, utils_2$1.pathToLegacyFileUrl)(resolved$1);
					}
					return null;
				}
			}), (result) => {
				if (result !== null) {
					const path$2 = result.protocol === exports.legacyImporterFileProtocol;
					this.prev.push({
						url: path$2 ? (0, utils_2$1.legacyFileUrlToPath)(result) : url$1,
						path: path$2
					});
					return result;
				} else {
					for (const loadPath of this.loadPaths) {
						const resolved$1 = (0, resolve_path_1.resolvePath)(p$6.join(loadPath, url$1), options.fromImport);
						if (resolved$1 !== null) return (0, utils_2$1.pathToLegacyFileUrl)(resolved$1);
					}
					return null;
				}
			});
		}
		load(canonicalUrl) {
			if (canonicalUrl.protocol === exports.endOfLoadProtocol) {
				this.prev.pop();
				return {
					contents: "",
					syntax: "scss",
					sourceMapUrl: new URL(exports.endOfLoadProtocol)
				};
			}
			if (canonicalUrl.protocol === exports.legacyImporterFileProtocol) {
				const syntax = canonicalUrl.pathname.endsWith(".sass") ? "indented" : canonicalUrl.pathname.endsWith(".css") ? "css" : "scss";
				let contents = this.lastContents ?? fs$3.readFileSync((0, utils_2$1.legacyFileUrlToPath)(canonicalUrl), "utf-8");
				this.lastContents = void 0;
				if (syntax === "css") this.prev.pop();
				else contents = this.wrapContents(contents, syntax);
				return {
					contents,
					syntax,
					sourceMapUrl: canonicalUrl
				};
			}
			const lastContents = this.lastContents;
			assert_1$2.strict.notEqual(lastContents, void 0);
			this.lastContents = void 0;
			return {
				contents: this.wrapContents(lastContents, "scss"),
				syntax: "scss",
				sourceMapUrl: canonicalUrl
			};
		}
		invokeCallbacks(url$1, prev, { fromImport }) {
			(0, assert_1$2.strict)(this.callbacks.length > 0);
			const self = {
				...this.self,
				fromImport
			};
			self.options = {
				...self.options,
				context: self
			};
			const invokeNthCallback = (n$2) => (0, utils_1$8.thenOr)(this.invokeCallback(this.callbacks[n$2], self, url$1, prev), (result) => {
				if (result === null) {
					if (n$2 === this.callbacks.length - 1) return null;
					return invokeNthCallback(n$2 + 1);
				}
				if ("contents" in result && result.contents && typeof result.contents !== "string") throw new Error(`Invalid argument (contents): must be a string but was: ${result.contents.constructor.name}`);
				return result;
			});
			return invokeNthCallback(0);
		}
		invokeCallback(callback, self, url$1, prev) {
			if (this.sync) return callback.call(self, url$1, prev);
			return new Promise((resolve) => {
				const syncResult = callback.call(self, url$1, prev, resolve);
				if (syncResult !== void 0) resolve(syncResult);
			});
		}
		wrapContents(contents, syntax) {
			const url$1 = `"${exports.endOfLoadProtocol}${endOfLoadCount++}"`;
			if (syntax === "scss") return `@use "sass:meta" as ${exports.metaNamespace};` + contents + `\n;@include ${exports.metaNamespace}.load-css(${url$1});`;
			else return `@use "sass:meta" as ${exports.metaNamespace}\n` + contents + `\n@include ${exports.metaNamespace}.load-css(${url$1})`;
		}
	};
	exports.LegacyImporterWrapper = LegacyImporterWrapper;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/utils.js
var require_utils$1 = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/utils.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.legacyImporterProtocolPrefix = exports.legacyImporterProtocol = void 0;
	exports.removeLegacyImporter = removeLegacyImporter;
	exports.removeLegacyImporterFromSpan = removeLegacyImporterFromSpan;
	exports.pathToLegacyFileUrl = pathToLegacyFileUrl;
	exports.legacyFileUrlToPath = legacyFileUrlToPath;
	var assert_1$1 = require_browser_external_assert();
	var url_1$2 = require_browser_external_url();
	var utils_1$7 = require_utils$3();
	var importer_1$1 = require_importer();
	/**
	* The URL protocol to use for URLs canonicalized using `LegacyImporterWrapper`.
	*/
	exports.legacyImporterProtocol = "legacy-importer:";
	/**
	* The prefix for absolute URLs canonicalized using `LegacyImporterWrapper`.
	*
	* This is used to distinguish imports resolved relative to URLs returned by a
	* legacy importer from manually-specified absolute URLs.
	*/
	exports.legacyImporterProtocolPrefix = "legacy-importer-";
	var removeLegacyImporterRegExp = new RegExp(`${exports.legacyImporterProtocol}|${exports.legacyImporterProtocolPrefix}`, "g");
	function removeLegacyImporter(string) {
		return string.replace(removeLegacyImporterRegExp, "");
	}
	function removeLegacyImporterFromSpan(span) {
		if (!span.url) return span;
		return {
			...span,
			url: new URL(removeLegacyImporter(span.url.toString()), (0, url_1$2.pathToFileURL)(process.cwd()))
		};
	}
	function pathToLegacyFileUrl(path$2) {
		return new URL(`${exports.legacyImporterProtocolPrefix}${(0, url_1$2.pathToFileURL)(path$2)}`);
	}
	function legacyFileUrlToPath(url$1) {
		assert_1$1.strict.equal(url$1.protocol, importer_1$1.legacyImporterFileProtocol);
		const originalUrl = url$1.toString().substring(exports.legacyImporterProtocolPrefix.length);
		return (0, utils_1$7.fileUrlToPathCrossPlatform)(originalUrl);
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/logger.js
var require_logger = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/logger.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Logger = { silent: {
		warn() {},
		debug() {}
	} };
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/compiler/utils.js
var require_utils = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/compiler/utils.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createDispatcher = createDispatcher;
	exports.newCompilePathRequest = newCompilePathRequest;
	exports.newCompileStringRequest = newCompileStringRequest;
	exports.handleLogEvent = handleLogEvent;
	exports.handleCompileResponse = handleCompileResponse;
	var p$5 = require_browser_external_path();
	var supportsColor = require_browser();
	var protobuf_1$4 = require_cjs();
	var deprecations_1$4 = require_deprecations();
	var deprotofy_span_1 = require_deprotofy_span();
	var dispatcher_1 = require_dispatcher();
	var exception_1$2 = require_exception();
	var utils_1$6 = require_utils$1();
	var logger_1$1 = require_logger();
	var utils$5 = require_utils$3();
	var proto$3 = require_embedded_sass_pb();
	/**
	* Creates a dispatcher that dispatches messages from the given `stdout` stream.
	*/
	function createDispatcher(compilationId, messageTransformer, handlers) {
		return new dispatcher_1.Dispatcher(compilationId, messageTransformer.outboundMessages$, (message) => messageTransformer.writeInboundMessage(message), handlers);
	}
	function newCompileRequest(importers, options) {
		const request = (0, protobuf_1$4.create)(proto$3.InboundMessage_CompileRequestSchema, {
			importers: importers.importers,
			globalFunctions: Object.keys(options?.functions ?? {}),
			sourceMap: !!options?.sourceMap,
			sourceMapIncludeSources: !!options?.sourceMapIncludeSources,
			alertColor: options?.alertColor ?? !!supportsColor.stdout,
			alertAscii: !!options?.alertAscii,
			quietDeps: !!options?.quietDeps,
			verbose: !!options?.verbose,
			charset: !!(options?.charset ?? true),
			silent: options?.logger === logger_1$1.Logger.silent,
			fatalDeprecation: (0, deprecations_1$4.getDeprecationIds)(options?.fatalDeprecations ?? []),
			silenceDeprecation: (0, deprecations_1$4.getDeprecationIds)(options?.silenceDeprecations ?? []),
			futureDeprecation: (0, deprecations_1$4.getDeprecationIds)(options?.futureDeprecations ?? [])
		});
		switch (options?.style ?? "expanded") {
			case "expanded":
				request.style = proto$3.OutputStyle.EXPANDED;
				break;
			case "compressed":
				request.style = proto$3.OutputStyle.COMPRESSED;
				break;
			default: throw new Error(`Unknown options.style: "${options?.style}"`);
		}
		return request;
	}
	function newCompilePathRequest(path$2, importers, options) {
		const absPath = p$5.resolve(path$2);
		const request = newCompileRequest(importers, options);
		request.input = {
			case: "path",
			value: absPath
		};
		return request;
	}
	function newCompileStringRequest(source, importers, options) {
		const input = (0, protobuf_1$4.create)(proto$3.InboundMessage_CompileRequest_StringInputSchema, {
			source,
			syntax: utils$5.protofySyntax(options?.syntax ?? "scss")
		});
		const url$1 = options?.url?.toString();
		if (url$1 && url$1 !== utils_1$6.legacyImporterProtocol) input.url = url$1;
		if (options && "importer" in options && options.importer) input.importer = importers.register(options.importer);
		else if (url$1 === utils_1$6.legacyImporterProtocol) input.importer = (0, protobuf_1$4.create)(proto$3.InboundMessage_CompileRequest_ImporterSchema, { importer: {
			case: "path",
			value: p$5.resolve(".")
		} });
		const request = newCompileRequest(importers, options);
		request.input = {
			case: "string",
			value: input
		};
		return request;
	}
	/** Type guard to check that `id` is a valid deprecation ID. */
	function validDeprecationId(id) {
		return !!id && id in deprecations_1$4.deprecations;
	}
	/** Handles a log event according to `options`. */
	function handleLogEvent(options, event) {
		let span = event.span ? (0, deprotofy_span_1.deprotofySourceSpan)(event.span) : null;
		if (span && options?.legacy) span = (0, utils_1$6.removeLegacyImporterFromSpan)(span);
		let message = event.message;
		if (options?.legacy) message = (0, utils_1$6.removeLegacyImporter)(message);
		let formatted = event.formatted;
		if (options?.legacy) formatted = (0, utils_1$6.removeLegacyImporter)(formatted);
		const deprecationType = validDeprecationId(event.deprecationType) ? deprecations_1$4.deprecations[event.deprecationType] : null;
		if (event.type === proto$3.LogEventType.DEBUG) if (options?.logger?.debug) options.logger.debug(message, { span });
		else console.error(formatted);
		else if (options?.logger?.warn) {
			const params = deprecationType ? {
				deprecation: true,
				deprecationType
			} : { deprecation: false };
			if (span) params.span = span;
			const stack = event.stackTrace;
			if (stack) params.stack = options?.legacy ? (0, utils_1$6.removeLegacyImporter)(stack) : stack;
			options.logger.warn(message, params);
		} else console.error(formatted);
	}
	/**
	* Converts a `CompileResponse` into a `CompileResult`.
	*
	* Throws a `SassException` if the compilation failed.
	*/
	function handleCompileResponse(response) {
		if (response.result.case === "success") {
			const success = response.result.value;
			const result = {
				css: success.css,
				loadedUrls: response.loadedUrls.map((url$1) => new URL(url$1))
			};
			const sourceMap = success.sourceMap;
			if (sourceMap) result.sourceMap = JSON.parse(sourceMap);
			return result;
		} else if (response.result.case === "failure") throw new exception_1$2.Exception(response.result.value);
		else throw utils$5.compilerError("Compiler sent empty CompileResponse.");
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/elf.js
var require_elf = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/elf.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getElfInterpreter = getElfInterpreter;
	var fs$2 = require_browser_external_fs();
	/** Read a chunk of data from a file descriptor into a new Buffer. */
	function readFileDescriptor(fd, position, length) {
		const buffer$1 = Buffer.alloc(length);
		let offset = 0;
		while (offset < length) {
			const bytesRead = fs$2.readSync(fd, buffer$1, {
				offset,
				position: position + offset
			});
			if (bytesRead === 0) throw new Error(`failed to read fd ${fd}`);
			offset += bytesRead;
		}
		return buffer$1;
	}
	/** Parse an ELF file and return its interpreter. */
	function getElfInterpreter(path$2) {
		const fd = fs$2.openSync(path$2, "r");
		try {
			const elfIdentification = new DataView(readFileDescriptor(fd, 0, 64).buffer);
			if (elfIdentification.getUint8(0) !== 127 || elfIdentification.getUint8(1) !== 69 || elfIdentification.getUint8(2) !== 76 || elfIdentification.getUint8(3) !== 70) throw new Error(`${path$2} is not an ELF file.`);
			const elfIdentificationClass = elfIdentification.getUint8(4);
			if (elfIdentificationClass !== 1 && elfIdentificationClass !== 2) throw new Error(`${path$2} has an invalid ELF class.`);
			const elfClass32 = elfIdentificationClass === 1;
			const elfIdentificationData = elfIdentification.getUint8(5);
			if (elfIdentificationData !== 1 && elfIdentificationData !== 2) throw new Error(`${path$2} has an invalid endianness.`);
			const littleEndian = elfIdentificationData === 1;
			const programHeadersOffset = elfClass32 ? elfIdentification.getUint32(28, littleEndian) : Number(elfIdentification.getBigUint64(32, littleEndian));
			const programHeadersEntrySize = elfClass32 ? elfIdentification.getUint16(42, littleEndian) : elfIdentification.getUint16(54, littleEndian);
			const programHeadersEntryCount = elfClass32 ? elfIdentification.getUint16(44, littleEndian) : elfIdentification.getUint16(56, littleEndian);
			const programHeaders = new DataView(readFileDescriptor(fd, programHeadersOffset, programHeadersEntrySize * programHeadersEntryCount).buffer);
			for (let i = 0; i < programHeadersEntryCount; i++) {
				const byteOffset = i * programHeadersEntrySize;
				if (programHeaders.getUint32(byteOffset, littleEndian) !== 3) continue;
				const segmentOffset = elfClass32 ? programHeaders.getUint32(byteOffset + 4, littleEndian) : Number(programHeaders.getBigUint64(byteOffset + 8, littleEndian));
				const segmentFileSize = elfClass32 ? programHeaders.getUint32(byteOffset + 16, littleEndian) : Number(programHeaders.getBigUint64(byteOffset + 32, littleEndian));
				const buffer$1 = readFileDescriptor(fd, segmentOffset, segmentFileSize);
				if (buffer$1[segmentFileSize - 1] !== 0) throw new Error(`${path$2} is corrupted.`);
				return buffer$1.toString("utf8", 0, segmentFileSize - 1);
			}
			throw new Error(`${path$2} does not contain an interpreter entry.`);
		} finally {
			fs$2.closeSync(fd);
		}
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/compiler-module.js
var require_compiler_module = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/compiler-module.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var p$4 = require_browser_external_path();
	var elf_1 = require_elf();
	/**
	* Detect if the given binary is linked with musl libc by checking if
	* the interpreter basename starts with "ld-musl-"
	*/
	function isLinuxMusl(path$2) {
		try {
			const interpreter = (0, elf_1.getElfInterpreter)(path$2);
			return p$4.basename(interpreter).startsWith("ld-musl-");
		} catch (error) {
			console.warn(`Warning: Failed to detect linux-musl, fallback to linux-gnu: ${error.message}`);
			return false;
		}
	}
	/** The module name for the embedded compiler executable. */
	exports.compilerModule = (() => {
		return `sass-embedded-${process.platform === "linux" && isLinuxMusl(process.execPath) ? "linux-musl" : process.platform}-${process.arch}`;
	})();
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/compiler-path.js
var require_compiler_path = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/compiler-path.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var p$3 = require_browser_external_path();
	var compiler_module_1 = require_compiler_module();
	/** The full command for the embedded compiler executable. */
	exports.compilerCommand = (() => {
		try {
			return [__require.resolve(`${compiler_module_1.compilerModule}/dart-sass/src/dart` + (process.platform === "win32" ? ".exe" : "")), __require.resolve(`${compiler_module_1.compilerModule}/dart-sass/src/sass.snapshot`)];
		} catch (e) {
			if (e.code !== "MODULE_NOT_FOUND") throw e;
		}
		try {
			return [__require.resolve(`${compiler_module_1.compilerModule}/dart-sass/sass` + (process.platform === "win32" ? ".bat" : ""))];
		} catch (e) {
			if (e.code !== "MODULE_NOT_FOUND") throw e;
		}
		try {
			return [process.execPath, p$3.join(p$3.dirname(__require.resolve("sass")), "sass.js")];
		} catch (e) {
			if (e.code !== "MODULE_NOT_FOUND") throw e;
		}
		throw new Error(`Embedded Dart Sass couldn't find the embedded compiler executable. Please make sure the optional dependency ${compiler_module_1.compilerModule} or sass is installed in node_modules.`);
	})();
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/protofier.js
var require_protofier = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/protofier.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
	var protobuf_1$3 = require_cjs();
	var proto$2 = require_embedded_sass_pb();
	var utils$4 = require_utils$3();
	var argument_list_1$1 = require_argument_list();
	var color_1$1 = require_color$1();
	var function_1$1 = require_function();
	var list_1$1 = require_list$1();
	var map_1$1 = require_map$2();
	var number_1$1 = require_number$1();
	var string_1$1 = require_string$1();
	var null_1$1 = require_null();
	var boolean_1$1 = require_boolean();
	var calculations_1$1 = require_calculations();
	var mixin_1$1 = require_mixin();
	/**
	* A class that converts [Value] objects into protobufs.
	*
	* A given [Protofier] instance is valid only within the scope of a single
	* custom function call.
	*/
	var Protofier = class {
		functions;
		/** All the argument lists returned by `deprotofy()`. */
		argumentLists = [];
		/**
		* Returns IDs of all argument lists passed to `deprotofy()` whose keywords
		* have been accessed.
		*/
		get accessedArgumentLists() {
			return this.argumentLists.filter((list) => list.keywordsAccessed).map((list) => list.id);
		}
		constructor(functions) {
			this.functions = functions;
		}
		/** Converts `value` to its protocol buffer representation. */
		protofy(value) {
			const result = (0, protobuf_1$3.create)(proto$2.ValueSchema, {});
			if (value instanceof string_1$1.SassString) result.value = {
				case: "string",
				value: (0, protobuf_1$3.create)(proto$2.Value_StringSchema, {
					text: value.text,
					quoted: value.hasQuotes
				})
			};
			else if (value instanceof number_1$1.SassNumber) result.value = {
				case: "number",
				value: this.protofyNumber(value)
			};
			else if (value instanceof color_1$1.SassColor) {
				const channels = value.channelsOrNull;
				result.value = {
					case: "color",
					value: (0, protobuf_1$3.create)(proto$2.Value_ColorSchema, {
						channel1: channels.get(0),
						channel2: channels.get(1),
						channel3: channels.get(2),
						alpha: value.isChannelMissing("alpha") ? void 0 : value.alpha,
						space: value.space
					})
				};
			} else if (value instanceof list_1$1.SassList) result.value = {
				case: "list",
				value: (0, protobuf_1$3.create)(proto$2.Value_ListSchema, {
					separator: this.protofySeparator(value.separator),
					hasBrackets: value.hasBrackets,
					contents: value.asList.map((element) => this.protofy(element)).toArray()
				})
			};
			else if (value instanceof argument_list_1$1.SassArgumentList) if (value.compileContext === this.functions.compileContext) result.value = {
				case: "argumentList",
				value: (0, protobuf_1$3.create)(proto$2.Value_ArgumentListSchema, { id: value.id })
			};
			else {
				const list = (0, protobuf_1$3.create)(proto$2.Value_ArgumentListSchema, {
					separator: this.protofySeparator(value.separator),
					contents: value.asList.map((element) => this.protofy(element)).toArray()
				});
				for (const [key, mapValue] of value.keywordsInternal) list.keywords[key] = this.protofy(mapValue);
				result.value = {
					case: "argumentList",
					value: list
				};
			}
			else if (value instanceof map_1$1.SassMap) result.value = {
				case: "map",
				value: (0, protobuf_1$3.create)(proto$2.Value_MapSchema, { entries: value.contents.toArray().map(([key, value$1]) => ({
					key: this.protofy(key),
					value: this.protofy(value$1)
				})) })
			};
			else if (value instanceof function_1$1.SassFunction) if (value.id !== void 0) {
				if (value.compileContext !== this.functions.compileContext) throw utils$4.compilerError(`Value ${value} does not belong to this compilation`);
				result.value = {
					case: "compilerFunction",
					value: (0, protobuf_1$3.create)(proto$2.Value_CompilerFunctionSchema, value)
				};
			} else result.value = {
				case: "hostFunction",
				value: (0, protobuf_1$3.create)(proto$2.Value_HostFunctionSchema, {
					id: this.functions.register(value.callback),
					signature: value.signature
				})
			};
			else if (value instanceof mixin_1$1.SassMixin) {
				if (value.compileContext !== this.functions.compileContext) throw utils$4.compilerError(`Value ${value} does not belong to this compilation`);
				result.value = {
					case: "compilerMixin",
					value: (0, protobuf_1$3.create)(proto$2.Value_CompilerMixinSchema, value)
				};
			} else if (value instanceof calculations_1$1.SassCalculation) result.value = {
				case: "calculation",
				value: this.protofyCalculation(value)
			};
			else if (value === boolean_1$1.sassTrue) result.value = {
				case: "singleton",
				value: proto$2.SingletonValue.TRUE
			};
			else if (value === boolean_1$1.sassFalse) result.value = {
				case: "singleton",
				value: proto$2.SingletonValue.FALSE
			};
			else if (value === null_1$1.sassNull) result.value = {
				case: "singleton",
				value: proto$2.SingletonValue.NULL
			};
			else throw utils$4.compilerError(`Unknown Value ${value}`);
			return result;
		}
		/** Converts `number` to its protocol buffer representation. */
		protofyNumber(number) {
			return (0, protobuf_1$3.create)(proto$2.Value_NumberSchema, {
				value: number.value,
				numerators: number.numeratorUnits.toArray(),
				denominators: number.denominatorUnits.toArray()
			});
		}
		/** Converts `separator` to its protocol buffer representation. */
		protofySeparator(separator) {
			switch (separator) {
				case ",": return proto$2.ListSeparator.COMMA;
				case " ": return proto$2.ListSeparator.SPACE;
				case "/": return proto$2.ListSeparator.SLASH;
				case null: return proto$2.ListSeparator.UNDECIDED;
				default: throw utils$4.compilerError(`Unknown ListSeparator ${separator}`);
			}
		}
		/** Converts `calculation` to its protocol buffer representation. */
		protofyCalculation(calculation) {
			return (0, protobuf_1$3.create)(proto$2.Value_CalculationSchema, {
				name: calculation.name,
				arguments: calculation.arguments.map(this.protofyCalculationValue.bind(this)).toArray()
			});
		}
		/** Converts a CalculationValue that appears within a `SassCalculation` to
		* its protocol buffer representation. */
		protofyCalculationValue(value) {
			const result = (0, protobuf_1$3.create)(proto$2.Value_Calculation_CalculationValueSchema, {});
			if (value instanceof calculations_1$1.SassCalculation) result.value = {
				case: "calculation",
				value: this.protofyCalculation(value)
			};
			else if (value instanceof calculations_1$1.CalculationOperation) result.value = {
				case: "operation",
				value: (0, protobuf_1$3.create)(proto$2.Value_Calculation_CalculationOperationSchema, {
					operator: this.protofyCalculationOperator(value.operator),
					left: this.protofyCalculationValue(value.left),
					right: this.protofyCalculationValue(value.right)
				})
			};
			else if (value instanceof calculations_1$1.CalculationInterpolation) result.value = {
				case: "interpolation",
				value: value.value
			};
			else if (value instanceof string_1$1.SassString) result.value = {
				case: "string",
				value: value.text
			};
			else if (value instanceof number_1$1.SassNumber) result.value = {
				case: "number",
				value: this.protofyNumber(value)
			};
			else throw utils$4.compilerError(`Unknown CalculationValue ${value}`);
			return result;
		}
		/** Converts `operator` to its protocol buffer representation. */
		protofyCalculationOperator(operator) {
			switch (operator) {
				case "+": return proto$2.CalculationOperator.PLUS;
				case "-": return proto$2.CalculationOperator.MINUS;
				case "*": return proto$2.CalculationOperator.TIMES;
				case "/": return proto$2.CalculationOperator.DIVIDE;
				default: throw utils$4.compilerError(`Unknown CalculationOperator ${operator}`);
			}
		}
		/** Converts `value` to its JS representation. */
		deprotofy(value) {
			switch (value.value.case) {
				case "string": {
					const string = value.value.value;
					return string.text.length === 0 ? string_1$1.SassString.empty({ quotes: string.quoted }) : new string_1$1.SassString(string.text, { quotes: string.quoted });
				}
				case "number": return this.deprotofyNumber(value.value.value);
				case "color": {
					const color = value.value.value;
					const channel1 = color.channel1 ?? null;
					const channel2 = color.channel2 ?? null;
					const channel3 = color.channel3 ?? null;
					const alpha = color.alpha ?? null;
					const space = color.space;
					switch (color.space.toLowerCase()) {
						case "rgb":
						case "srgb":
						case "srgb-linear":
						case "display-p3":
						case "a98-rgb":
						case "prophoto-rgb":
						case "rec2020": return new color_1$1.SassColor({
							red: channel1,
							green: channel2,
							blue: channel3,
							alpha,
							space
						});
						case "hsl": return new color_1$1.SassColor({
							hue: channel1,
							saturation: channel2,
							lightness: channel3,
							alpha,
							space
						});
						case "hwb": return new color_1$1.SassColor({
							hue: channel1,
							whiteness: channel2,
							blackness: channel3,
							alpha,
							space
						});
						case "lab":
						case "oklab": return new color_1$1.SassColor({
							lightness: channel1,
							a: channel2,
							b: channel3,
							alpha,
							space
						});
						case "lch":
						case "oklch": return new color_1$1.SassColor({
							lightness: channel1,
							chroma: channel2,
							hue: channel3,
							alpha,
							space
						});
						case "xyz":
						case "xyz-d65":
						case "xyz-d50": return new color_1$1.SassColor({
							x: channel1,
							y: channel2,
							z: channel3,
							alpha,
							space
						});
						default: throw utils$4.compilerError(`Unknown color space "${color.space}".`);
					}
				}
				case "list": {
					const list = value.value.value;
					const separator = this.deprotofySeparator(list.separator);
					if (separator === null && list.contents.length > 1) throw utils$4.compilerError(`Value.List ${list} can't have an undecided separator because it has ${list.contents.length} elements`);
					return new list_1$1.SassList(list.contents.map((element) => this.deprotofy(element)), {
						separator,
						brackets: list.hasBrackets
					});
				}
				case "argumentList": {
					const list = value.value.value;
					const separator = this.deprotofySeparator(list.separator);
					if (separator === null && list.contents.length > 1) throw utils$4.compilerError(`Value.List ${list} can't have an undecided separator because it has ${list.contents.length} elements`);
					const result = new argument_list_1$1.SassArgumentList(list.contents.map((element) => this.deprotofy(element)), (0, immutable_1.OrderedMap)(Object.entries(list.keywords).map(([key, value$1]) => [key, this.deprotofy(value$1)])), separator, list.id, this.functions.compileContext);
					this.argumentLists.push(result);
					return result;
				}
				case "map": return new map_1$1.SassMap((0, immutable_1.OrderedMap)(value.value.value.entries.map((entry) => {
					const key = entry.key;
					if (!key) throw utils$4.mandatoryError("Value.Map.Entry.key");
					const value$1 = entry.value;
					if (!value$1) throw utils$4.mandatoryError("Value.Map.Entry.value");
					return [this.deprotofy(key), this.deprotofy(value$1)];
				})));
				case "compilerFunction": return new function_1$1.SassFunction(value.value.value.id, this.functions.compileContext);
				case "hostFunction": throw utils$4.compilerError("The compiler may not send Value.host_function.");
				case "compilerMixin": return new mixin_1$1.SassMixin(value.value.value.id, this.functions.compileContext);
				case "calculation": return this.deprotofyCalculation(value.value.value);
				case "singleton": switch (value.value.value) {
					case proto$2.SingletonValue.TRUE: return boolean_1$1.sassTrue;
					case proto$2.SingletonValue.FALSE: return boolean_1$1.sassFalse;
					case proto$2.SingletonValue.NULL: return null_1$1.sassNull;
				}
				default: throw utils$4.mandatoryError("Value.value");
			}
		}
		/** Converts `number` to its JS representation. */
		deprotofyNumber(number) {
			return new number_1$1.SassNumber(number.value, {
				numeratorUnits: number.numerators,
				denominatorUnits: number.denominators
			});
		}
		/** Converts `separator` to its JS representation. */
		deprotofySeparator(separator) {
			switch (separator) {
				case proto$2.ListSeparator.COMMA: return ",";
				case proto$2.ListSeparator.SPACE: return " ";
				case proto$2.ListSeparator.SLASH: return "/";
				case proto$2.ListSeparator.UNDECIDED: return null;
				default: throw utils$4.compilerError(`Unknown separator ${separator}`);
			}
		}
		/** Converts `calculation` to its Sass representation. */
		deprotofyCalculation(calculation) {
			switch (calculation.name) {
				case "calc":
					if (calculation.arguments.length !== 1) throw utils$4.compilerError("Value.Calculation.arguments must have exactly one argument for calc().");
					return calculations_1$1.SassCalculation.calc(this.deprotofyCalculationValue(calculation.arguments[0]));
				case "clamp":
					if (calculation.arguments.length === 0 || calculation.arguments.length > 3) throw utils$4.compilerError("Value.Calculation.arguments must have 1 to 3 arguments for clamp().");
					return calculations_1$1.SassCalculation.clamp(this.deprotofyCalculationValue(calculation.arguments[0]), calculation.arguments.length > 1 ? this.deprotofyCalculationValue(calculation.arguments[1]) : void 0, calculation.arguments.length > 2 ? this.deprotofyCalculationValue(calculation.arguments[2]) : void 0);
				case "min":
					if (calculation.arguments.length === 0) throw utils$4.compilerError("Value.Calculation.arguments must have at least 1 argument for min().");
					return calculations_1$1.SassCalculation.min(calculation.arguments.map(this.deprotofyCalculationValue));
				case "max":
					if (calculation.arguments.length === 0) throw utils$4.compilerError("Value.Calculation.arguments must have at least 1 argument for max().");
					return calculations_1$1.SassCalculation.max(calculation.arguments.map(this.deprotofyCalculationValue));
				default: throw utils$4.compilerError(`Value.Calculation.name "${calculation.name}" is not a recognized calculation type.`);
			}
		}
		/** Converts `value` to its Sass representation. */
		deprotofyCalculationValue(value) {
			switch (value.value.case) {
				case "number": return this.deprotofyNumber(value.value.value);
				case "calculation": return this.deprotofyCalculation(value.value.value);
				case "string": return new string_1$1.SassString(value.value.value, { quotes: false });
				case "operation": return new calculations_1$1.CalculationOperation(this.deprotofyCalculationOperator(value.value.value.operator), this.deprotofyCalculationValue(value.value.value.left), this.deprotofyCalculationValue(value.value.value.right));
				case "interpolation": return new calculations_1$1.CalculationInterpolation(value.value.value);
				default: throw utils$4.mandatoryError("Calculation.CalculationValue.value");
			}
		}
		/** Converts `operator` to its Sass representation. */
		deprotofyCalculationOperator(operator) {
			switch (operator) {
				case proto$2.CalculationOperator.PLUS: return "+";
				case proto$2.CalculationOperator.MINUS: return "-";
				case proto$2.CalculationOperator.TIMES: return "*";
				case proto$2.CalculationOperator.DIVIDE: return "/";
				default: throw utils$4.compilerError(`Unknown CalculationOperator ${operator}`);
			}
		}
	};
	exports.Protofier = Protofier;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/function-registry.js
var require_function_registry = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/function-registry.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var util_1$1 = require_browser_external_util();
	var protobuf_1$2 = require_cjs();
	var utils$3 = require_utils$3();
	var proto$1 = require_embedded_sass_pb();
	var utils_1$5 = require_utils$3();
	var protofier_1 = require_protofier();
	var value_1$1 = require_value$1();
	/**
	* Tracks functions that are defined on the host so that the compiler can
	* execute them.
	*/
	var FunctionRegistry = class {
		/**
		* The globally unique identifier of the current compilation used for tracking
		* the ownership of CompilerFunction and CompilerMixin objects.
		*/
		compileContext = Symbol();
		functionsByName = /* @__PURE__ */ new Map();
		functionsById = /* @__PURE__ */ new Map();
		idsByFunction = /* @__PURE__ */ new Map();
		/** The next ID to use for a function. */
		id = 0;
		constructor(functionsBySignature) {
			for (const [signature, fn] of Object.entries(functionsBySignature ?? {})) {
				const openParen = signature.indexOf("(");
				if (openParen === -1) throw new Error(`options.functions: "${signature}" is missing "("`);
				this.functionsByName.set(signature.substring(0, openParen), fn);
			}
		}
		/** Registers `fn` as a function that can be called using the returned ID. */
		register(fn) {
			return utils$3.putIfAbsent(this.idsByFunction, fn, () => {
				const id = this.id;
				this.id += 1;
				this.functionsById.set(id, fn);
				return id;
			});
		}
		/**
		* Returns the function to which `request` refers and returns its response.
		*/
		call(request) {
			const protofier = new protofier_1.Protofier(this);
			const fn = this.get(request);
			return (0, utils_1$5.catchOr)(() => {
				return (0, utils_1$5.thenOr)(fn(request.arguments.map((value) => protofier.deprotofy(value))), (result) => {
					if (!(result instanceof value_1$1.Value)) throw `options.functions: ${request.identifier.case === "name" ? `"${request.identifier.value}"` : "anonymous function"} returned non-Value: ` + (0, util_1$1.inspect)(result);
					return (0, protobuf_1$2.create)(proto$1.InboundMessage_FunctionCallResponseSchema, {
						result: {
							case: "success",
							value: protofier.protofy(result)
						},
						accessedArgumentLists: protofier.accessedArgumentLists
					});
				});
			}, (error) => (0, protobuf_1$2.create)(proto$1.InboundMessage_FunctionCallResponseSchema, { result: {
				case: "error",
				value: `${error}`
			} }));
		}
		/** Returns the function to which `request` refers. */
		get(request) {
			if (request.identifier.case === "name") {
				const fn = this.functionsByName.get(request.identifier.value);
				if (fn) return fn;
				throw (0, utils_1$5.compilerError)(`Invalid OutboundMessage_FunctionCallRequest: there is no function named "${request.identifier.value}"`);
			} else if (request.identifier.case === "functionId") {
				const fn = this.functionsById.get(request.identifier.value);
				if (fn) return fn;
				throw (0, utils_1$5.compilerError)(`Invalid OutboundMessage_FunctionCallRequest: there is no function with ID "${request.identifier.value}"`);
			} else throw (0, utils_1$5.compilerError)("Invalid OutboundMessage_FunctionCallRequest: function identifier is unset");
		}
	};
	exports.FunctionRegistry = FunctionRegistry;
}) });

//#endregion
//#region browser-external:module
var require_browser_external_module = /* @__PURE__ */ __commonJS({ "browser-external:module": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "module" has been externalized for browser compatibility. Cannot access "module.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/canonicalize-context.js
var require_canonicalize_context = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/canonicalize-context.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var CanonicalizeContext = class {
		fromImport;
		_containingUrl;
		get containingUrl() {
			this._containingUrlAccessed = true;
			return this._containingUrl;
		}
		_containingUrlAccessed = false;
		/**
		* Whether the `containingUrl` getter has been accessed.
		*
		* This is marked as public so that the importer registry can access it, but
		* it's not part of the package's public API and should not be accessed by
		* user code. It may be renamed or removed without warning in the future.
		*/
		get containingUrlAccessed() {
			return this._containingUrlAccessed;
		}
		constructor(containingUrl, fromImport) {
			this._containingUrl = containingUrl;
			this.fromImport = fromImport;
		}
	};
	exports.CanonicalizeContext = CanonicalizeContext;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/importer-registry.js
var require_importer_registry = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/importer-registry.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var module_1 = require_browser_external_module();
	var p$2 = require_browser_external_path();
	var url_1$1 = require_browser_external_url();
	var util_1 = require_browser_external_util();
	var protobuf_1$1 = require_cjs();
	var canonicalize_context_1 = require_canonicalize_context();
	var utils$2 = require_utils$3();
	var proto = require_embedded_sass_pb();
	var utils_1$4 = require_utils$3();
	var entryPointDirectoryKey = Symbol();
	var NodePackageImporter$1 = class {
		[entryPointDirectoryKey];
		constructor(entryPointDirectory) {
			entryPointDirectory = entryPointDirectory ? p$2.resolve(entryPointDirectory) : __require.main?.filename ? p$2.dirname(__require.main.filename) : process.argv[1] ? (0, module_1.createRequire)(process.argv[1]).resolve(process.argv[1]) : void 0;
			if (!entryPointDirectory) throw new Error("The Node package importer cannot determine an entry point because `require.main.filename` is not defined. Please provide an `entryPointDirectory` to the `NodePackageImporter`.");
			this[entryPointDirectoryKey] = entryPointDirectory;
		}
	};
	exports.NodePackageImporter = NodePackageImporter$1;
	/**
	* A registry of importers defined in the host that can be invoked by the
	* compiler.
	*/
	var ImporterRegistry = class {
		/** Protocol buffer representations of the registered importers. */
		importers;
		/** A map from importer IDs to their corresponding importers. */
		importersById = /* @__PURE__ */ new Map();
		/** A map from file importer IDs to their corresponding importers. */
		fileImportersById = /* @__PURE__ */ new Map();
		/** The next ID to use for an importer. */
		id = 0;
		constructor(options) {
			this.importers = (options?.importers ?? []).map((importer) => this.register(importer)).concat((options?.loadPaths ?? []).map((path$2) => (0, protobuf_1$1.create)(proto.InboundMessage_CompileRequest_ImporterSchema, { importer: {
				case: "path",
				value: p$2.resolve(path$2)
			} })));
		}
		/** Converts an importer to a proto without adding it to `this.importers`. */
		register(importer) {
			const message = (0, protobuf_1$1.create)(proto.InboundMessage_CompileRequest_ImporterSchema, {});
			if (importer instanceof NodePackageImporter$1) message.importer = {
				case: "nodePackageImporter",
				value: (0, protobuf_1$1.create)(proto.NodePackageImporterSchema, { entryPointDirectory: importer[entryPointDirectoryKey] })
			};
			else if ("canonicalize" in importer) {
				if ("findFileUrl" in importer) throw new Error("Importer may not contain both canonicalize() and findFileUrl(): " + (0, util_1.inspect)(importer));
				message.importer = {
					case: "importerId",
					value: this.id
				};
				message.nonCanonicalScheme = typeof importer.nonCanonicalScheme === "string" ? [importer.nonCanonicalScheme] : importer.nonCanonicalScheme ?? [];
				this.importersById.set(this.id, importer);
			} else {
				message.importer = {
					case: "fileImporterId",
					value: this.id
				};
				this.fileImportersById.set(this.id, importer);
			}
			this.id += 1;
			return message;
		}
		/** Handles a canonicalization request. */
		canonicalize(request) {
			const importer = this.importersById.get(request.importerId);
			if (!importer) throw utils$2.compilerError("Unknown CanonicalizeRequest.importer_id");
			const canonicalizeContext = new canonicalize_context_1.CanonicalizeContext(request.containingUrl ? new url_1$1.URL(request.containingUrl) : null, request.fromImport);
			return (0, utils_1$4.catchOr)(() => {
				return (0, utils_1$4.thenOr)(importer.canonicalize(request.url, canonicalizeContext), (url$1) => (0, protobuf_1$1.create)(proto.InboundMessage_CanonicalizeResponseSchema, {
					result: url$1 === null ? { case: void 0 } : {
						case: "url",
						value: url$1.toString()
					},
					containingUrlUnused: !canonicalizeContext.containingUrlAccessed
				}));
			}, (error) => (0, protobuf_1$1.create)(proto.InboundMessage_CanonicalizeResponseSchema, { result: {
				case: "error",
				value: `${error}`
			} }));
		}
		/** Handles an import request. */
		import(request) {
			const importer = this.importersById.get(request.importerId);
			if (!importer) throw utils$2.compilerError("Unknown ImportRequest.importer_id");
			return (0, utils_1$4.catchOr)(() => {
				return (0, utils_1$4.thenOr)(importer.load(new url_1$1.URL(request.url)), (result) => {
					if (!result) return (0, protobuf_1$1.create)(proto.InboundMessage_ImportResponseSchema, {});
					if (typeof result.contents !== "string") throw Error(`Invalid argument (contents): must be a string but was: ${result.contents.constructor.name}`);
					if (result.sourceMapUrl && !result.sourceMapUrl.protocol) throw Error("Invalid argument (sourceMapUrl): must be absolute but was: " + result.sourceMapUrl);
					return (0, protobuf_1$1.create)(proto.InboundMessage_ImportResponseSchema, { result: {
						case: "success",
						value: {
							contents: result.contents,
							syntax: utils$2.protofySyntax(result.syntax),
							sourceMapUrl: result.sourceMapUrl?.toString() ?? ""
						}
					} });
				});
			}, (error) => (0, protobuf_1$1.create)(proto.InboundMessage_ImportResponseSchema, { result: {
				case: "error",
				value: `${error}`
			} }));
		}
		/** Handles a file import request. */
		fileImport(request) {
			const importer = this.fileImportersById.get(request.importerId);
			if (!importer) throw utils$2.compilerError("Unknown FileImportRequest.importer_id");
			const canonicalizeContext = new canonicalize_context_1.CanonicalizeContext(request.containingUrl ? new url_1$1.URL(request.containingUrl) : null, request.fromImport);
			return (0, utils_1$4.catchOr)(() => {
				return (0, utils_1$4.thenOr)(importer.findFileUrl(request.url, canonicalizeContext), (url$1) => {
					if (!url$1) return (0, protobuf_1$1.create)(proto.InboundMessage_FileImportResponseSchema, { containingUrlUnused: !canonicalizeContext.containingUrlAccessed });
					if (url$1.protocol !== "file:") throw `FileImporter ${(0, util_1.inspect)(importer)} returned non-file: URL ` + +`"${url$1}" for URL "${request.url}".`;
					return (0, protobuf_1$1.create)(proto.InboundMessage_FileImportResponseSchema, {
						result: {
							case: "fileUrl",
							value: url$1.toString()
						},
						containingUrlUnused: !canonicalizeContext.containingUrlAccessed
					});
				});
			}, (error) => (0, protobuf_1$1.create)(proto.InboundMessage_FileImportResponseSchema, { result: {
				case: "error",
				value: `${error}`
			} }));
		}
	};
	exports.ImporterRegistry = ImporterRegistry;
}) });

//#endregion
//#region node_modules/varint/encode.js
var require_encode = /* @__PURE__ */ __commonJS({ "node_modules/varint/encode.js": ((exports, module) => {
	module.exports = encode;
	var MSB$1 = 128, MSBALL = -128, INT = Math.pow(2, 31);
	function encode(num, out, offset) {
		if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
			encode.bytes = 0;
			throw new RangeError("Could not encode varint");
		}
		out = out || [];
		offset = offset || 0;
		var oldOffset = offset;
		while (num >= INT) {
			out[offset++] = num & 255 | MSB$1;
			num /= 128;
		}
		while (num & MSBALL) {
			out[offset++] = num & 255 | MSB$1;
			num >>>= 7;
		}
		out[offset] = num | 0;
		encode.bytes = offset - oldOffset + 1;
		return out;
	}
}) });

//#endregion
//#region node_modules/varint/decode.js
var require_decode = /* @__PURE__ */ __commonJS({ "node_modules/varint/decode.js": ((exports, module) => {
	module.exports = read;
	var MSB = 128, REST = 127;
	function read(buf, offset) {
		var res = 0, offset = offset || 0, shift = 0, counter = offset, b$2, l = buf.length;
		do {
			if (counter >= l || shift > 49) {
				read.bytes = 0;
				throw new RangeError("Could not decode varint");
			}
			b$2 = buf[counter++];
			res += shift < 28 ? (b$2 & REST) << shift : (b$2 & REST) * Math.pow(2, shift);
			shift += 7;
		} while (b$2 >= MSB);
		read.bytes = counter - offset;
		return res;
	}
}) });

//#endregion
//#region node_modules/varint/length.js
var require_length = /* @__PURE__ */ __commonJS({ "node_modules/varint/length.js": ((exports, module) => {
	var N1 = Math.pow(2, 7);
	var N2 = Math.pow(2, 14);
	var N3 = Math.pow(2, 21);
	var N4 = Math.pow(2, 28);
	var N5 = Math.pow(2, 35);
	var N6 = Math.pow(2, 42);
	var N7 = Math.pow(2, 49);
	var N8 = Math.pow(2, 56);
	var N9 = Math.pow(2, 63);
	module.exports = function(value) {
		return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
	};
}) });

//#endregion
//#region node_modules/varint/index.js
var require_varint = /* @__PURE__ */ __commonJS({ "node_modules/varint/index.js": ((exports, module) => {
	module.exports = {
		encode: require_encode(),
		decode: require_decode(),
		encodingLength: require_length()
	};
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/message-transformer.js
var require_message_transformer = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/message-transformer.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var rxjs_1$3 = require_cjs$1();
	var operators_1$2 = require_operators();
	var protobuf_1 = require_cjs();
	var varint = require_varint();
	var utils_1$3 = require_utils$3();
	var embedded_sass_pb_1 = require_embedded_sass_pb();
	/**
	* Encodes InboundMessages into protocol buffers and decodes protocol buffers
	* into OutboundMessages.
	*/
	var MessageTransformer = class {
		outboundProtobufs$;
		writeInboundProtobuf;
		outboundMessagesInternal$ = new rxjs_1$3.Subject();
		/**
		* The OutboundMessages, decoded from protocol buffers. If this fails to
		* decode a message, it will emit an error.
		*/
		outboundMessages$ = this.outboundMessagesInternal$.pipe();
		constructor(outboundProtobufs$, writeInboundProtobuf) {
			this.outboundProtobufs$ = outboundProtobufs$;
			this.writeInboundProtobuf = writeInboundProtobuf;
			this.outboundProtobufs$.pipe((0, operators_1$2.map)(decode)).subscribe(this.outboundMessagesInternal$);
		}
		/**
		* Converts the inbound `compilationId` and `message` to a protocol buffer.
		*/
		writeInboundMessage([compilationId, message]) {
			const compilationIdLength = varint.encodingLength(compilationId);
			const encodedMessage = (0, protobuf_1.toBinary)(embedded_sass_pb_1.InboundMessageSchema, message);
			const buffer$1 = new Uint8Array(compilationIdLength + encodedMessage.length);
			varint.encode(compilationId, buffer$1);
			buffer$1.set(encodedMessage, compilationIdLength);
			try {
				this.writeInboundProtobuf(buffer$1);
			} catch (error) {
				this.outboundMessagesInternal$.error(error);
			}
		}
	};
	exports.MessageTransformer = MessageTransformer;
	function decode(buffer$1) {
		let compilationId;
		try {
			compilationId = varint.decode(buffer$1);
		} catch (error) {
			throw (0, utils_1$3.compilerError)(`Invalid compilation ID varint: ${error}`);
		}
		try {
			return [compilationId, (0, protobuf_1.fromBinary)(embedded_sass_pb_1.OutboundMessageSchema, new Uint8Array(buffer$1.buffer, varint.decode.bytes))];
		} catch (error) {
			throw (0, utils_1$3.compilerError)(`Invalid protobuf: ${error}`);
		}
	}
}) });

//#endregion
//#region node_modules/buffer-builder/buffer-builder.js
var require_buffer_builder = /* @__PURE__ */ __commonJS({ "node_modules/buffer-builder/buffer-builder.js": ((exports, module) => {
	module.exports = BufferBuilder$1;
	function BufferBuilder$1(initialCapacity) {
		this.buffers = [Buffer.isBuffer(initialCapacity) ? initialCapacity : new Buffer(initialCapacity || 512)];
		this.writeIndex = 0;
		this.length = 0;
	}
	BufferBuilder$1.prototype.appendBuffer = function(source) {
		if (source.length === 0) return this;
		var tail = this.buffers[this.buffers.length - 1];
		var spaceInCurrent = tail.length - this.writeIndex;
		if (source.length <= spaceInCurrent) {
			source.copy(tail, this.writeIndex);
			this.writeIndex += source.length;
		} else {
			if (spaceInCurrent) source.copy(tail, this.writeIndex);
			var newBuf = new Buffer(Math.max(tail.length * 2, source.length));
			this.buffers.push(newBuf);
			this.writeIndex = source.copy(newBuf, 0, spaceInCurrent);
		}
		this.length += source.length;
		return this;
	};
	function makeAppender(encoder, size) {
		return function(x) {
			var buf = this.buffers[this.buffers.length - 1];
			if (this.writeIndex + size <= buf.length) {
				encoder.call(buf, x, this.writeIndex, true);
				this.writeIndex += size;
				this.length += size;
			} else {
				var scratchBuffer = new Buffer(size);
				encoder.call(scratchBuffer, x, 0, true);
				this.appendBuffer(scratchBuffer);
			}
			return this;
		};
	}
	BufferBuilder$1.prototype.appendUInt8 = makeAppender(Buffer.prototype.writeUInt8, 1);
	BufferBuilder$1.prototype.appendUInt16LE = makeAppender(Buffer.prototype.writeUInt16LE, 2);
	BufferBuilder$1.prototype.appendUInt16BE = makeAppender(Buffer.prototype.writeUInt16BE, 2);
	BufferBuilder$1.prototype.appendUInt32LE = makeAppender(Buffer.prototype.writeUInt32LE, 4);
	BufferBuilder$1.prototype.appendUInt32BE = makeAppender(Buffer.prototype.writeUInt32BE, 4);
	BufferBuilder$1.prototype.appendInt8 = makeAppender(Buffer.prototype.writeInt8, 1);
	BufferBuilder$1.prototype.appendInt16LE = makeAppender(Buffer.prototype.writeInt16LE, 2);
	BufferBuilder$1.prototype.appendInt16BE = makeAppender(Buffer.prototype.writeInt16BE, 2);
	BufferBuilder$1.prototype.appendInt32LE = makeAppender(Buffer.prototype.writeInt32LE, 4);
	BufferBuilder$1.prototype.appendInt32BE = makeAppender(Buffer.prototype.writeInt32BE, 4);
	BufferBuilder$1.prototype.appendFloatLE = makeAppender(Buffer.prototype.writeFloatLE, 4);
	BufferBuilder$1.prototype.appendFloatBE = makeAppender(Buffer.prototype.writeFloatBE, 4);
	BufferBuilder$1.prototype.appendDoubleLE = makeAppender(Buffer.prototype.writeDoubleLE, 8);
	BufferBuilder$1.prototype.appendDoubleBE = makeAppender(Buffer.prototype.writeDoubleBE, 8);
	BufferBuilder$1.prototype.appendString = function(str, encoding) {
		return this.appendBuffer(new Buffer(str, encoding));
	};
	BufferBuilder$1.prototype.appendStringZero = function(str, encoding) {
		return this.appendString(str + "\0", encoding);
	};
	BufferBuilder$1.prototype.appendFill = function(value, count$1) {
		if (!count$1) return;
		var tail = this.buffers[this.buffers.length - 1];
		var spaceInCurrent = tail.length - this.writeIndex;
		if (count$1 <= spaceInCurrent) {
			tail.fill(value, this.writeIndex, this.writeIndex + count$1);
			this.writeIndex += count$1;
		} else {
			if (spaceInCurrent) tail.fill(value, this.writeIndex);
			var newBuf = new Buffer(Math.max(tail.length * 2, count$1));
			var couldNotFit = count$1 - spaceInCurrent;
			newBuf.fill(value, 0, couldNotFit);
			this.buffers.push(newBuf);
			this.writeIndex = couldNotFit;
		}
		this.length += count$1;
		return this;
	};
	BufferBuilder$1.prototype.get = function() {
		var concatted = new Buffer(this.length);
		this.copy(concatted);
		return concatted;
	};
	BufferBuilder$1.prototype.copy = function(targetBuffer, targetStart, sourceStart, sourceEnd) {
		targetStart || (targetStart = 0);
		sourceStart || (sourceStart = 0);
		sourceEnd !== void 0 || (sourceEnd = this.length);
		if (targetStart < 0 || targetStart > 0 && targetStart >= targetBuffer.length) throw new Error("targetStart is out of bounds");
		if (sourceEnd < sourceStart) throw new Error("sourceEnd < sourceStart");
		if (sourceStart < 0 || sourceStart > 0 && sourceStart >= this.length) throw new Error("sourceStart is out of bounds");
		if (sourceEnd > this.length) throw new Error("sourceEnd out of bounds");
		sourceEnd = Math.min(sourceEnd, sourceStart + (targetBuffer.length - targetStart));
		var targetWriteIdx = targetStart;
		var readBuffer = 0;
		var copyLength = sourceEnd - sourceStart;
		var skipped = 0;
		while (skipped < sourceStart) {
			var buffer$1 = this.buffers[readBuffer];
			if (buffer$1.length + skipped < targetStart) skipped += buffer$1.length;
			else {
				var copyStart = sourceStart - skipped;
				var inThisBuffer = Math.min(copyLength, buffer$1.length - copyStart);
				buffer$1.copy(targetBuffer, targetWriteIdx, copyStart, copyStart + inThisBuffer);
				targetWriteIdx += inThisBuffer;
				copyLength -= inThisBuffer;
				readBuffer++;
				break;
			}
			readBuffer++;
		}
		while (copyLength > 0) {
			var buffer$1 = this.buffers[readBuffer];
			var toCopy = Math.min(buffer$1.length, copyLength);
			buffer$1.copy(targetBuffer, targetWriteIdx, 0, toCopy);
			copyLength -= toCopy;
			targetWriteIdx += toCopy;
			readBuffer++;
		}
		return sourceEnd - sourceStart;
	};
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/packet-transformer.js
var require_packet_transformer = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/packet-transformer.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var rxjs_1$2 = require_cjs$1();
	var operators_1$1 = require_operators();
	var BufferBuilder = require_buffer_builder();
	/**
	* Decodes arbitrarily-chunked buffers, for example
	*   [ 0 1 2 3 4 5 6 7 ... ],
	* into packets of set length in the form
	*   +---------+------------- ...
	*   | 0 1 2 3 | 4 5 6 7 ...
	*   +---------+------------- ...
	*   | HEADER  | PAYLOAD (PROTOBUF)
	*   +---------+------------- ...
	* and emits the payload of each packet.
	*
	* Encodes packets by attaching a header to a protobuf that describes the
	* protobuf's length.
	*/
	var PacketTransformer = class {
		outboundBuffers$;
		writeInboundBuffer;
		packet = new Packet();
		outboundProtobufsInternal$ = new rxjs_1$2.Subject();
		/**
		* The fully-decoded, outbound protobufs. If any errors are encountered
		* during encoding/decoding, this Observable will error out.
		*/
		outboundProtobufs$ = this.outboundProtobufsInternal$.pipe();
		constructor(outboundBuffers$, writeInboundBuffer) {
			this.outboundBuffers$ = outboundBuffers$;
			this.writeInboundBuffer = writeInboundBuffer;
			this.outboundBuffers$.pipe((0, operators_1$1.mergeMap)((buffer$1) => this.decode(buffer$1))).subscribe(this.outboundProtobufsInternal$);
		}
		/**
		* Encodes a packet by pre-fixing `protobuf` with a header that describes its
		* length.
		*/
		writeInboundProtobuf(protobuf) {
			try {
				let length = protobuf.length;
				if (length === 0) {
					this.writeInboundBuffer(Buffer.alloc(1));
					return;
				}
				const header = new BufferBuilder(8);
				while (length > 0) {
					header.appendUInt8((length > 127 ? 128 : 0) | length & 127);
					length >>= 7;
				}
				const packet = Buffer.alloc(header.length + protobuf.length);
				header.copy(packet);
				packet.set(protobuf, header.length);
				this.writeInboundBuffer(packet);
			} catch (error) {
				this.outboundProtobufsInternal$.error(error);
			}
		}
		decode(buffer$1) {
			const payloads = [];
			let decodedBytes = 0;
			while (decodedBytes < buffer$1.length) {
				decodedBytes += this.packet.write(buffer$1.slice(decodedBytes));
				if (this.packet.isComplete && this.packet.payload) {
					payloads.push(this.packet.payload);
					this.packet = new Packet();
				}
			}
			return payloads;
		}
	};
	exports.PacketTransformer = PacketTransformer;
	/** A length-delimited packet comprised of a header and payload. */
	var Packet = class {
		payloadLengthBits = 0;
		payloadLength = 0;
		/**
		* The packet's payload. Constructed by calls to write().
		* @see write
		*/
		payload;
		payloadOffset = 0;
		/** Whether the packet construction is complete. */
		get isComplete() {
			return !!(this.payload && this.payloadOffset >= this.payloadLength);
		}
		/**
		* Takes arbitrary binary input and slots it into the header and payload
		* appropriately. Returns the number of bytes that were written into the
		* packet. This method can be called repeatedly, incrementally building
		* up the packet until it is complete.
		*/
		write(source) {
			if (this.isComplete) throw Error("Cannot write to a completed Packet.");
			let i = 0;
			if (!this.payload) for (;;) {
				const byte = source[i];
				this.payloadLength += (byte & 127) << this.payloadLengthBits;
				this.payloadLengthBits += 7;
				i++;
				if (byte <= 127) {
					this.payload = Buffer.alloc(this.payloadLength);
					break;
				} else if (i === source.length) return i;
			}
			const bytesToWrite = Math.min(this.payload.length - this.payloadOffset, source.length - i);
			this.payload.set(source.subarray(i, i + bytesToWrite), this.payloadOffset);
			this.payloadOffset += bytesToWrite;
			return i + bytesToWrite;
		}
	};
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/compiler/async.js
var require_async = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/compiler/async.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.initAsyncCompiler = initAsyncCompiler$1;
	var child_process = require_browser_external_child_process();
	var rxjs_1$1 = require_cjs$1();
	var operators_1 = require_operators();
	var path$1 = require_browser_external_path();
	var utils_1$2 = require_utils();
	var compiler_path_1$1 = require_compiler_path();
	var deprecations_1$3 = require_deprecations();
	var function_registry_1$1 = require_function_registry();
	var importer_registry_1$3 = require_importer_registry();
	var message_transformer_1$1 = require_message_transformer();
	var packet_transformer_1$1 = require_packet_transformer();
	var utils$1 = require_utils$3();
	/**
	* Flag allowing the constructor passed by `initAsyncCompiler` so we can
	* differentiate and throw an error if the `AsyncCompiler` is constructed via
	* `new AsyncCompiler`.
	*/
	var initFlag$1 = Symbol();
	/** An asynchronous wrapper for the embedded Sass compiler */
	var AsyncCompiler$1 = class {
		/** The underlying process that's being wrapped. */
		process = (() => {
			let command = compiler_path_1$1.compilerCommand[0];
			let args = [...compiler_path_1$1.compilerCommand.slice(1), "--embedded"];
			const options = {
				cwd: path$1.dirname(compiler_path_1$1.compilerCommand[0]),
				windowsHide: true
			};
			if ([".bat", ".cmd"].includes(path$1.extname(command).toLowerCase())) {
				command = `${command} ${args.join(" ")}`;
				args = [];
				options.shell = true;
			}
			return child_process.spawn(command, args, options);
		})();
		/** The next compilation ID. */
		compilationId = 1;
		/** A list of active compilations. */
		compilations = /* @__PURE__ */ new Set();
		/** Whether the underlying compiler has already exited. */
		disposed = false;
		/** Reusable message transformer for all compilations.  */
		messageTransformer;
		/** The child process's exit event. */
		exit$ = new Promise((resolve) => {
			this.process.on("exit", (code) => resolve(code));
		});
		/** The buffers emitted by the child process's stdout. */
		stdout$ = new rxjs_1$1.Observable((observer) => {
			this.process.stdout.on("data", (buffer$1) => observer.next(buffer$1));
		}).pipe((0, operators_1.takeUntil)(this.exit$));
		/** The buffers emitted by the child process's stderr. */
		stderr$ = new rxjs_1$1.Observable((observer) => {
			this.process.stderr.on("data", (buffer$1) => observer.next(buffer$1));
		}).pipe((0, operators_1.takeUntil)(this.exit$));
		/** Writes `buffer` to the child process's stdin. */
		writeStdin(buffer$1) {
			this.process.stdin.write(buffer$1);
		}
		/** Guards against using a disposed compiler. */
		throwIfDisposed() {
			if (this.disposed) throw utils$1.compilerError("Async compiler has already been disposed.");
		}
		/**
		* Sends a compile request to the child process and returns a Promise that
		* resolves with the CompileResult. Rejects the promise if there were any
		* protocol or compilation errors.
		*/
		async compileRequestAsync(request, importers, options) {
			const optionsKey = Symbol();
			deprecations_1$3.activeDeprecationOptions.set(optionsKey, options ?? {});
			try {
				const functions = new function_registry_1$1.FunctionRegistry(options?.functions);
				const dispatcher = (0, utils_1$2.createDispatcher)(this.compilationId++, this.messageTransformer, {
					handleImportRequest: (request$1) => importers.import(request$1),
					handleFileImportRequest: (request$1) => importers.fileImport(request$1),
					handleCanonicalizeRequest: (request$1) => importers.canonicalize(request$1),
					handleFunctionCallRequest: (request$1) => functions.call(request$1)
				});
				dispatcher.logEvents$.subscribe((event) => (0, utils_1$2.handleLogEvent)(options, event));
				const compilation = new Promise((resolve, reject) => dispatcher.sendCompileRequest(request, (err, response) => {
					this.compilations.delete(compilation);
					if (this.compilations.size === 0) this.compilationId = 1;
					if (err) reject(err);
					else resolve(response);
				}));
				this.compilations.add(compilation);
				return (0, utils_1$2.handleCompileResponse)(await compilation);
			} finally {
				deprecations_1$3.activeDeprecationOptions.delete(optionsKey);
			}
		}
		/** Initialize resources shared across compilations. */
		constructor(flag) {
			if (flag !== initFlag$1) throw utils$1.compilerError("AsyncCompiler can not be directly constructed. Please use `sass.initAsyncCompiler()` instead.");
			this.stderr$.subscribe((data) => process.stderr.write(data));
			const packetTransformer = new packet_transformer_1$1.PacketTransformer(this.stdout$, (buffer$1) => {
				this.writeStdin(buffer$1);
			});
			this.messageTransformer = new message_transformer_1$1.MessageTransformer(packetTransformer.outboundProtobufs$, (packet) => packetTransformer.writeInboundProtobuf(packet));
		}
		compileAsync(path$2, options) {
			this.throwIfDisposed();
			const importers = new importer_registry_1$3.ImporterRegistry(options);
			return this.compileRequestAsync((0, utils_1$2.newCompilePathRequest)(path$2, importers, options), importers, options);
		}
		compileStringAsync(source, options) {
			this.throwIfDisposed();
			const importers = new importer_registry_1$3.ImporterRegistry(options);
			return this.compileRequestAsync((0, utils_1$2.newCompileStringRequest)(source, importers, options), importers, options);
		}
		async dispose() {
			this.disposed = true;
			await Promise.all(this.compilations);
			this.process.stdin.end();
			await this.exit$;
		}
	};
	exports.AsyncCompiler = AsyncCompiler$1;
	async function initAsyncCompiler$1() {
		return new AsyncCompiler$1(initFlag$1);
	}
}) });

//#endregion
//#region browser-external:stream
var require_browser_external_stream = /* @__PURE__ */ __commonJS({ "browser-external:stream": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region browser-external:worker_threads
var require_browser_external_worker_threads = /* @__PURE__ */ __commonJS({ "browser-external:worker_threads": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "worker_threads" has been externalized for browser compatibility. Cannot access "worker_threads.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region browser-external:events
var require_browser_external_events = /* @__PURE__ */ __commonJS({ "browser-external:events": ((exports, module) => {
	module.exports = Object.create(new Proxy({}, { get(_, key) {
		if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See http://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
	} }));
}) });

//#endregion
//#region node_modules/sync-message-port/dist/lib/index.js
var require_lib$2 = /* @__PURE__ */ __commonJS({ "node_modules/sync-message-port/dist/lib/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = require_browser_external_assert();
	var events_1 = require_browser_external_events();
	var worker_threads_1$1 = require_browser_external_worker_threads();
	/**
	* An enum of possible states for the shared buffer that two `SyncMessagePort`s
	* use to communicate.
	*/
	var BufferState;
	(function(BufferState$1) {
		/**
		* The initial state. When an endpoint is ready to receive messages, it'll set
		* the buffer to this state so that it can use `Atomics.wait()` to be notified
		* when it switches to `MessageSent`.
		*/
		BufferState$1[BufferState$1["AwaitingMessage"] = 0] = "AwaitingMessage";
		/**
		* The state indicating that a message has been sent. Whenever an endpoint
		* sends a message, it'll set the buffer to this state so that the other
		* endpoint's `Atomics.wait()` call terminates.
		*/
		BufferState$1[BufferState$1["MessageSent"] = 1] = "MessageSent";
		/**
		* The bitmask indicating that the channel has been closed. This is masked on
		* top of AwaitingMessage and MessageSent state. It never transitions to any
		* other states once closed.
		*/
		BufferState$1[BufferState$1["Closed"] = 2] = "Closed";
	})(BufferState || (BufferState = {}));
	/**
	* An exception thrown by {@link SyncMessagePort.receiveMessage} if a message
	* isn't received within {@link ReceivedMessageOptions.timeout} milliseconds.
	*/
	var TimeoutException = class extends Error {
		constructor(message) {
			super(message);
		}
	};
	exports.TimeoutException = TimeoutException;
	/**
	* A communication port that can receive messages synchronously from another
	* `SyncMessagePort`.
	*
	* This also emits the same asynchronous events as `MessagePort`.
	*/
	var SyncMessagePort = class extends events_1.EventEmitter {
		port;
		/** Creates a channel whose ports can be passed to `new SyncMessagePort()`. */
		static createChannel() {
			const channel = new worker_threads_1$1.MessageChannel();
			const buffer$1 = new SharedArrayBuffer(4);
			channel.port1.postMessage(buffer$1);
			channel.port2.postMessage(buffer$1);
			return channel;
		}
		/**
		* An Int32 view of the shared buffer.
		*
		* Each port sets this to `BufferState.AwaitingMessage` before checking for
		* new messages in `receiveMessage()`, and each port sets it to
		* `BufferState.MessageSent` after sending a new message. It's set to
		* `BufferState.Closed` when the channel is closed.
		*/
		buffer;
		/**
		* Creates a new message port. The `port` must be created by
		* `SyncMessagePort.createChannel()` and must connect to a port passed to
		* another `SyncMessagePort` in another worker.
		*/
		constructor(port) {
			super();
			this.port = port;
			const buffer$1 = (0, worker_threads_1$1.receiveMessageOnPort)(this.port)?.message;
			if (!buffer$1) throw new Error("new SyncMessagePort() must be passed a port from SyncMessagePort.createChannel().");
			this.buffer = new Int32Array(buffer$1);
			this.on("newListener", (event, listener) => {
				this.port.on(event, listener);
			});
			this.on("removeListener", (event, listener) => this.port.removeListener(event, listener));
		}
		/** See `MessagePort.postMesage()`. */
		postMessage(value, transferList) {
			this.port.postMessage(value, transferList);
			if (Atomics.compareExchange(this.buffer, 0, BufferState.AwaitingMessage, BufferState.MessageSent) === BufferState.AwaitingMessage) Atomics.notify(this.buffer, 0);
		}
		/**
		* Returns the message sent by the other port, if one is available. This *does
		* not* block, and will return `undefined` immediately if no message is
		* available. In order to distinguish between a message with value `undefined`
		* and no message, a message is return in an object with a `message` field.
		*
		* This may not be called while this has a listener for the `'message'` event.
		* It does *not* throw an error if the port is closed when this is called;
		* instead, it just returns `undefined`.
		*/
		receiveMessageIfAvailable() {
			if (this.listenerCount("message")) throw new Error("SyncMessageChannel.receiveMessageIfAvailable() may not be called while there are message listeners.");
			return (0, worker_threads_1$1.receiveMessageOnPort)(this.port);
		}
		/**
		* Blocks and returns the next message sent by the other port.
		*
		* This may not be called while this has a listener for the `'message'` event.
		* Throws an error if the channel is closed, including if it closes while this
		* is waiting for a message, unless {@link ReceiveMessageOptions.closedValue}
		* is passed.
		*/
		receiveMessage(options) {
			if (this.listenerCount("message")) throw new Error("SyncMessageChannel.receiveMessage() may not be called while there are message listeners.");
			if (Atomics.compareExchange(this.buffer, 0, BufferState.MessageSent, BufferState.AwaitingMessage) === BufferState.Closed) {
				if (options && "closedValue" in options) return options.closedValue;
				throw new Error("The SyncMessagePort's channel is closed.");
			}
			let message = (0, worker_threads_1$1.receiveMessageOnPort)(this.port);
			if (message) return message.message;
			const result = Atomics.wait(this.buffer, 0, BufferState.AwaitingMessage, options?.timeout);
			message = (0, worker_threads_1$1.receiveMessageOnPort)(this.port);
			if (message) return message.message;
			if (result === "timed-out") {
				if ("timeoutValue" in options) return options.timeoutValue;
				throw new TimeoutException("SyncMessagePort.receiveMessage() timed out.");
			}
			const oldState = Atomics.and(this.buffer, 0, BufferState.Closed);
			assert_1.strict.equal(oldState & BufferState.Closed, BufferState.Closed);
			if (options && "closedValue" in options) return options.closedValue;
			throw new Error("The SyncMessagePort's channel is closed.");
		}
		/** See `MessagePort.close()`. */
		close() {
			Atomics.or(this.buffer, 0, BufferState.Closed);
			Atomics.notify(this.buffer, 0);
			this.port.close();
		}
	};
	exports.SyncMessagePort = SyncMessagePort;
}) });

//#endregion
//#region node_modules/sync-child-process/dist/lib/index.js
var require_lib$1 = /* @__PURE__ */ __commonJS({ "node_modules/sync-child-process/dist/lib/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var fs$1 = require_browser_external_fs();
	var p$1 = require_browser_external_path();
	var stream = require_browser_external_stream();
	var worker_threads_1 = require_browser_external_worker_threads();
	var worker_threads = require_browser_external_worker_threads();
	var sync_message_port_1 = require_lib$2();
	/** Whether {@link object} can't be transferred between threads, only cloned. */
	function isMarkedAsUntransferable(object) {
		return "isMarkedAsUntransferable" in worker_threads ? worker_threads.isMarkedAsUntransferable(object) : false;
	}
	/**
	* A child process that runs synchronously while also allowing the user to
	* interact with it before it shuts down.
	*/
	var SyncChildProcess = class {
		/** The port that communicates with the worker thread. */
		port;
		/** The worker in which the child process runs. */
		worker;
		/** The standard input stream to write to the process. */
		stdin;
		constructor(command, argsOrOptions, options) {
			let args;
			if (Array.isArray(argsOrOptions)) args = argsOrOptions;
			else {
				args = [];
				options = argsOrOptions;
			}
			const { port1, port2 } = sync_message_port_1.SyncMessagePort.createChannel();
			this.port = new sync_message_port_1.SyncMessagePort(port1);
			this.worker = spawnWorker(p$1.join(p$1.dirname(__filename), "worker"), {
				workerData: {
					port: port2,
					command,
					args,
					options
				},
				transferList: [port2]
			});
			this.worker.on("error", console.error);
			this.stdin = new stream.Writable({
				write: (chunk, encoding, callback) => {
					this.port.postMessage({
						type: "stdin",
						data: chunk
					}, isMarkedAsUntransferable(chunk.buffer) ? void 0 : [chunk.buffer]);
					callback();
				},
				final: () => this.port.postMessage({ type: "stdinClosed" })
			});
		}
		/**
		* Blocks until the child process is ready to emit another event, then returns
		* that event. This will return an [IteratorReturnResult] with an [ExitEvent]
		* once when the process exits. If it's called again after that, it will
		* return `{done: true}` without a value.
		*
		* If there's an error running the child process, this will throw that error.
		*/
		next() {
			if (this.stdin.destroyed) return {
				done: true,
				value: void 0
			};
			const message = this.port.receiveMessage();
			switch (message.type) {
				case "stdout": return { value: {
					type: "stdout",
					data: Buffer.from(message.data.buffer)
				} };
				case "stderr": return { value: {
					type: "stderr",
					data: Buffer.from(message.data.buffer)
				} };
				case "error":
					this.close();
					throw message.error;
				case "exit":
					this.close();
					return {
						done: true,
						value: message
					};
			}
		}
		/**
		* Sends a signal (`SIGTERM` by default) to the child process.
		*
		* This has no effect if the process has already exited.
		*/
		kill(signal) {
			this.port.postMessage({
				type: "kill",
				signal
			});
		}
		/** Closes down the worker thread and the stdin stream. */
		close() {
			this.port.close();
			this.worker.terminate();
			this.stdin.destroy();
		}
	};
	exports.SyncChildProcess = SyncChildProcess;
	/**
	* Spawns a worker for the given `fileWithoutExtension` in either a JS or TS
	* worker, depending on which file exists.
	*/
	function spawnWorker(fileWithoutExtension, options) {
		const jsFile = fileWithoutExtension + ".js";
		if (fs$1.existsSync(jsFile)) return new worker_threads_1.Worker(jsFile, options);
		const tsFile = fileWithoutExtension + ".ts";
		if (fs$1.existsSync(tsFile)) return new worker_threads_1.Worker(`
        require('ts-node').register();
        require(${JSON.stringify(tsFile)});
      `, {
			...options,
			eval: true
		});
		throw new Error(`Neither "${jsFile}" nor ".ts" exists.`);
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/compiler/sync.js
var require_sync = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/compiler/sync.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.initCompiler = initCompiler$1;
	var path = require_browser_external_path();
	var rxjs_1 = require_cjs$1();
	var sync_child_process = require_lib$1();
	var utils_1$1 = require_utils();
	var compiler_path_1 = require_compiler_path();
	var deprecations_1$2 = require_deprecations();
	var function_registry_1 = require_function_registry();
	var importer_registry_1$2 = require_importer_registry();
	var message_transformer_1 = require_message_transformer();
	var packet_transformer_1 = require_packet_transformer();
	var utils = require_utils$3();
	/**
	* Flag allowing the constructor passed by `initCompiler` so we can
	* differentiate and throw an error if the `Compiler` is constructed via `new
	* Compiler`.
	*/
	var initFlag = Symbol();
	/** A synchronous wrapper for the embedded Sass compiler */
	var Compiler$1 = class {
		/** The underlying process that's being wrapped. */
		process = (() => {
			let command = compiler_path_1.compilerCommand[0];
			let args = [...compiler_path_1.compilerCommand.slice(1), "--embedded"];
			const options = {
				cwd: path.dirname(compiler_path_1.compilerCommand[0]),
				windowsHide: true
			};
			if ([".bat", ".cmd"].includes(path.extname(command).toLowerCase())) {
				command = `${command} ${args.join(" ")}`;
				args = [];
				options.shell = true;
			}
			return new sync_child_process.SyncChildProcess(command, args, options);
		})();
		/** The next compilation ID. */
		compilationId = 1;
		/** A list of active dispatchers. */
		dispatchers = /* @__PURE__ */ new Set();
		/** The buffers emitted by the child process's stdout. */
		stdout$ = new rxjs_1.Subject();
		/** The buffers emitted by the child process's stderr. */
		stderr$ = new rxjs_1.Subject();
		/** Whether the underlying compiler has already exited. */
		disposed = false;
		/** Reusable message transformer for all compilations.  */
		messageTransformer;
		/** Writes `buffer` to the child process's stdin. */
		writeStdin(buffer$1) {
			this.process.stdin.write(buffer$1);
		}
		/** Yields the next event from the underlying process. */
		yield() {
			const result = this.process.next();
			if (result.done) {
				this.disposed = true;
				return false;
			}
			const event = result.value;
			switch (event.type) {
				case "stdout":
					this.stdout$.next(event.data);
					return true;
				case "stderr":
					this.stderr$.next(event.data);
					return true;
			}
		}
		/** Blocks until the underlying process exits. */
		yieldUntilExit() {
			while (!this.disposed) this.yield();
		}
		/**
		* Sends a compile request to the child process and returns the CompileResult.
		* Throws if there were any protocol or compilation errors.
		*/
		compileRequestSync(request, importers, options) {
			const optionsKey = Symbol();
			deprecations_1$2.activeDeprecationOptions.set(optionsKey, options ?? {});
			try {
				const functions = new function_registry_1.FunctionRegistry(options?.functions);
				const dispatcher = (0, utils_1$1.createDispatcher)(this.compilationId++, this.messageTransformer, {
					handleImportRequest: (request$1) => importers.import(request$1),
					handleFileImportRequest: (request$1) => importers.fileImport(request$1),
					handleCanonicalizeRequest: (request$1) => importers.canonicalize(request$1),
					handleFunctionCallRequest: (request$1) => functions.call(request$1)
				});
				this.dispatchers.add(dispatcher);
				dispatcher.logEvents$.subscribe((event) => (0, utils_1$1.handleLogEvent)(options, event));
				let error;
				let response;
				dispatcher.sendCompileRequest(request, (error_, response_) => {
					this.dispatchers.delete(dispatcher);
					if (this.dispatchers.size === 0) this.compilationId = 1;
					if (error_) error = error_;
					else response = response_;
				});
				for (;;) {
					if (!this.yield()) throw utils.compilerError("Embedded compiler exited unexpectedly.");
					if (error) throw error;
					if (response) return (0, utils_1$1.handleCompileResponse)(response);
				}
			} finally {
				deprecations_1$2.activeDeprecationOptions.delete(optionsKey);
			}
		}
		/** Guards against using a disposed compiler. */
		throwIfDisposed() {
			if (this.disposed) throw utils.compilerError("Sync compiler has already been disposed.");
		}
		/** Initialize resources shared across compilations. */
		constructor(flag) {
			if (flag !== initFlag) throw utils.compilerError("Compiler can not be directly constructed. Please use `sass.initAsyncCompiler()` instead.");
			this.stderr$.subscribe((data) => process.stderr.write(data));
			const packetTransformer = new packet_transformer_1.PacketTransformer(this.stdout$, (buffer$1) => {
				this.writeStdin(buffer$1);
			});
			this.messageTransformer = new message_transformer_1.MessageTransformer(packetTransformer.outboundProtobufs$, (packet) => packetTransformer.writeInboundProtobuf(packet));
		}
		compile(path$2, options) {
			this.throwIfDisposed();
			const importers = new importer_registry_1$2.ImporterRegistry(options);
			return this.compileRequestSync((0, utils_1$1.newCompilePathRequest)(path$2, importers, options), importers, options);
		}
		compileString(source, options) {
			this.throwIfDisposed();
			const importers = new importer_registry_1$2.ImporterRegistry(options);
			return this.compileRequestSync((0, utils_1$1.newCompileStringRequest)(source, importers, options), importers, options);
		}
		dispose() {
			this.process.stdin.end();
			this.yieldUntilExit();
		}
	};
	exports.Compiler = Compiler$1;
	function initCompiler$1() {
		return new Compiler$1(initFlag);
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/compile.js
var require_compile = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/compile.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.NodePackageImporter = void 0;
	exports.compile = compile$1;
	exports.compileString = compileString$1;
	exports.compileAsync = compileAsync$1;
	exports.compileStringAsync = compileStringAsync$1;
	var async_1$1 = require_async();
	var sync_1$1 = require_sync();
	var importer_registry_1$1 = require_importer_registry();
	Object.defineProperty(exports, "NodePackageImporter", {
		enumerable: true,
		get: function() {
			return importer_registry_1$1.NodePackageImporter;
		}
	});
	function compile$1(path$2, options) {
		const compiler = (0, sync_1$1.initCompiler)();
		try {
			return compiler.compile(path$2, options);
		} finally {
			compiler.dispose();
		}
	}
	function compileString$1(source, options) {
		const compiler = (0, sync_1$1.initCompiler)();
		try {
			return compiler.compileString(source, options);
		} finally {
			compiler.dispose();
		}
	}
	async function compileAsync$1(path$2, options) {
		const compiler = await (0, async_1$1.initAsyncCompiler)();
		try {
			return await compiler.compileAsync(path$2, options);
		} finally {
			await compiler.dispose();
		}
	}
	async function compileStringAsync$1(source, options) {
		const compiler = await (0, async_1$1.initAsyncCompiler)();
		try {
			return await compiler.compileStringAsync(source, options);
		} finally {
			await compiler.dispose();
		}
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/src/legacy/index.js
var require_legacy = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/src/legacy/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.render = render$1;
	exports.renderSync = renderSync$1;
	var fs = require_browser_external_fs();
	var p = require_browser_external_path();
	var url_1 = require_browser_external_url();
	var importer_registry_1 = require_importer_registry();
	var exception_1$1 = require_exception();
	var compile_1$1 = require_compile();
	var deprecations_1$1 = require_deprecations();
	var utils_1 = require_utils$3();
	var wrap_1 = require_wrap();
	var importer_1 = require_importer();
	var utils_2 = require_utils$1();
	function render$1(options, callback) {
		try {
			options = adjustOptions(options);
			const start = Date.now();
			(0, deprecations_1$1.warnForHostSideDeprecation)("The legacy JS API is deprecated and will be removed in Dart Sass 2.0.0.\n\nMore info: https://sass-lang.com/d/legacy-js-api", deprecations_1$1.deprecations["legacy-js-api"], options);
			(isStringOptions(options) ? (0, compile_1$1.compileStringAsync)(options.data, convertStringOptions(options, false)) : (0, compile_1$1.compileAsync)(options.file, convertOptions(options, false))).then((result) => callback(void 0, newLegacyResult(options, start, result)), (error) => callback(newLegacyException(error)));
		} catch (error) {
			if (error instanceof Error) callback(newLegacyException(error));
			throw error;
		}
	}
	function renderSync$1(options) {
		const start = Date.now();
		try {
			options = adjustOptions(options);
			(0, deprecations_1$1.warnForHostSideDeprecation)("The legacy JS API is deprecated and will be removed in Dart Sass 2.0.0.\n\nMore info: https://sass-lang.com/d/legacy-js-api", deprecations_1$1.deprecations["legacy-js-api"], options);
			const result = isStringOptions(options) ? (0, compile_1$1.compileString)(options.data, convertStringOptions(options, true)) : (0, compile_1$1.compile)(options.file, convertOptions(options, true));
			return newLegacyResult(options, start, result);
		} catch (error) {
			throw newLegacyException(error);
		}
	}
	function adjustOptions(options) {
		if (!("file" in options && options.file) && !("data" in options)) throw new Error("Either options.data or options.file must be set.");
		options.includePaths = [process.cwd(), ...options.includePaths ?? []];
		if (!isStringOptions(options) && (options.indentedSyntax !== void 0 || options.importer)) return {
			...options,
			data: fs.readFileSync(options.file, "utf8"),
			indentedSyntax: !!options.indentedSyntax
		};
		else return options;
	}
	function isStringOptions(options) {
		return "data" in options;
	}
	function convertOptions(options, sync) {
		if ("outputStyle" in options && options.outputStyle !== "compressed" && options.outputStyle !== "expanded") throw new Error(`Unknown output style: "${options.outputStyle}"`);
		const self = pluginThis(options);
		const functions = {};
		for (let [signature, callback] of Object.entries(options.functions ?? {})) {
			if (!signature.includes("(")) signature += "()";
			functions[signature.trimLeft()] = (0, wrap_1.wrapFunction)(self, callback, sync);
		}
		const importers = options.importer && (!(options.importer instanceof Array) || options.importer.length > 0) ? [new importer_1.LegacyImporterWrapper(self, options.importer instanceof Array ? options.importer : [options.importer], options.includePaths ?? [], options.file ?? "stdin", sync)] : void 0;
		return {
			functions,
			importers: options.pkgImporter instanceof importer_registry_1.NodePackageImporter ? [options.pkgImporter, ...importers ?? []] : importers,
			sourceMap: wasSourceMapRequested(options),
			sourceMapIncludeSources: options.sourceMapContents,
			loadPaths: importers ? void 0 : options.includePaths,
			style: options.outputStyle,
			quietDeps: options.quietDeps,
			verbose: options.verbose,
			charset: options.charset,
			logger: options.logger,
			fatalDeprecations: options.fatalDeprecations,
			futureDeprecations: options.futureDeprecations,
			silenceDeprecations: options.silenceDeprecations,
			legacy: true
		};
	}
	function convertStringOptions(options, sync) {
		const modernOptions = convertOptions(options, sync);
		const importer = modernOptions.importers?.some((importer$1) => importer$1 instanceof importer_1.LegacyImporterWrapper) ? {
			canonicalize() {
				return null;
			},
			load() {
				return null;
			}
		} : void 0;
		return {
			...modernOptions,
			url: options.file ? options.importer ? (0, utils_2.pathToLegacyFileUrl)(options.file) : (0, url_1.pathToFileURL)(options.file) : new url_1.URL(utils_2.legacyImporterProtocol),
			importer,
			syntax: options.indentedSyntax ? "indented" : "scss"
		};
	}
	function wasSourceMapRequested(options) {
		return typeof options.sourceMap === "string" || options.sourceMap === true && !!options.outFile;
	}
	function pluginThis(options) {
		const pluginThis$1 = { options: {
			context: void 0,
			file: options.file,
			data: options.data,
			includePaths: (options.includePaths ?? []).join(p.delimiter),
			precision: 10,
			style: 1,
			indentType: 0,
			indentWidth: 2,
			linefeed: "\n",
			result: { stats: {
				start: Date.now(),
				entry: options.file ?? "data"
			} }
		} };
		pluginThis$1.options.context = pluginThis$1;
		return pluginThis$1;
	}
	function newLegacyResult(options, start, result) {
		const end = Date.now();
		let css = result.css;
		let sourceMapBytes;
		if (result.sourceMap) {
			const sourceMap = result.sourceMap;
			sourceMap.sourceRoot = options.sourceMapRoot ?? "";
			const sourceMapPath = typeof options.sourceMap === "string" ? options.sourceMap : options.outFile + ".map";
			const sourceMapDir = p.dirname(sourceMapPath);
			if (options.outFile) sourceMap.file = (0, utils_1.pathToUrlString)(p.relative(sourceMapDir, options.outFile));
			else if (options.file) sourceMap.file = (0, utils_1.pathToUrlString)((0, utils_1.withoutExtension)(options.file) + ".css");
			else sourceMap.file = "stdin.css";
			sourceMap.sources = sourceMap.sources.filter((source) => !source.startsWith(importer_1.endOfLoadProtocol)).map((source) => {
				source = (0, utils_2.removeLegacyImporter)(source);
				if (source.startsWith("file://")) return (0, utils_1.pathToUrlString)(p.relative(sourceMapDir, (0, utils_1.fileUrlToPathCrossPlatform)(source)));
				else if (source.startsWith("data:")) return "stdin";
				else return source;
			});
			sourceMapBytes = Buffer.from(JSON.stringify(sourceMap));
			if (!options.omitSourceMapUrl) {
				let url$1;
				if (options.sourceMapEmbed) url$1 = `data:application/json;base64,${sourceMapBytes.toString("base64")}`;
				else if (options.outFile) url$1 = (0, utils_1.pathToUrlString)(p.relative(p.dirname(options.outFile), sourceMapPath));
				else url$1 = (0, utils_1.pathToUrlString)(sourceMapPath);
				css += `\n\n/*# sourceMappingURL=${url$1} */`;
			}
		}
		return {
			css: Buffer.from(css),
			map: sourceMapBytes,
			stats: {
				entry: options.file ?? "data",
				start,
				end,
				duration: end - start,
				includedFiles: result.loadedUrls.filter((url$1) => url$1.protocol !== importer_1.endOfLoadProtocol).map((url$1) => {
					if (url$1.protocol === utils_2.legacyImporterProtocol) return decodeURI(url$1.pathname);
					const urlString = (0, utils_2.removeLegacyImporter)(url$1.toString());
					return urlString.startsWith("file:") ? (0, utils_1.fileUrlToPathCrossPlatform)(urlString) : urlString;
				})
			}
		};
	}
	function newLegacyException(error) {
		if (!(error instanceof exception_1$1.Exception)) return Object.assign(error, {
			formatted: error.toString(),
			status: 3
		});
		const span = error.span ? (0, utils_2.removeLegacyImporterFromSpan)(error.span) : null;
		let file;
		if (!span?.url) file = "stdin";
		else if (span.url.protocol === "file:") file = (0, utils_1.fileUrlToPathCrossPlatform)(span.url);
		else file = span.url.toString();
		const errorString = (0, utils_2.removeLegacyImporter)(error.toString());
		return Object.assign(/* @__PURE__ */ new Error(), {
			status: 1,
			message: errorString.replace(/^Error: /, ""),
			formatted: errorString,
			toString: () => errorString,
			stack: error.stack ? (0, utils_2.removeLegacyImporter)(error.stack) : void 0,
			line: (0, utils_1.isNullOrUndefined)(error.span?.start.line) ? void 0 : error.span.start.line + 1,
			column: (0, utils_1.isNullOrUndefined)(error.span?.start.column) ? void 0 : error.span.start.column + 1,
			file
		});
	}
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/index.js
var require_lib = /* @__PURE__ */ __commonJS({ "node_modules/sass-embedded/dist/lib/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.NULL = exports.FALSE = exports.TRUE = exports.Logger = exports.info = exports.renderSync = exports.render = exports.Version = exports.deprecations = exports.Compiler = exports.initCompiler = exports.AsyncCompiler = exports.initAsyncCompiler = exports.NodePackageImporter = exports.compileStringAsync = exports.compileAsync = exports.compileString = exports.compile = exports.Exception = exports.types = exports.SassCalculation = exports.CalculationInterpolation = exports.CalculationOperation = exports.sassNull = exports.Value = exports.SassString = exports.SassNumber = exports.SassMixin = exports.SassMap = exports.SassFunction = exports.SassColor = exports.sassTrue = exports.sassFalse = exports.SassBoolean = exports.SassArgumentList = exports.SassList = void 0;
	var pkg = require_package();
	var boolean_1 = require_boolean();
	var null_1 = require_null();
	var list_1 = require_list$1();
	Object.defineProperty(exports, "SassList", {
		enumerable: true,
		get: function() {
			return list_1.SassList;
		}
	});
	var argument_list_1 = require_argument_list();
	Object.defineProperty(exports, "SassArgumentList", {
		enumerable: true,
		get: function() {
			return argument_list_1.SassArgumentList;
		}
	});
	var boolean_2 = require_boolean();
	Object.defineProperty(exports, "SassBoolean", {
		enumerable: true,
		get: function() {
			return boolean_2.SassBoolean;
		}
	});
	Object.defineProperty(exports, "sassFalse", {
		enumerable: true,
		get: function() {
			return boolean_2.sassFalse;
		}
	});
	Object.defineProperty(exports, "sassTrue", {
		enumerable: true,
		get: function() {
			return boolean_2.sassTrue;
		}
	});
	var color_1 = require_color$1();
	Object.defineProperty(exports, "SassColor", {
		enumerable: true,
		get: function() {
			return color_1.SassColor;
		}
	});
	var function_1 = require_function();
	Object.defineProperty(exports, "SassFunction", {
		enumerable: true,
		get: function() {
			return function_1.SassFunction;
		}
	});
	var map_1 = require_map$2();
	Object.defineProperty(exports, "SassMap", {
		enumerable: true,
		get: function() {
			return map_1.SassMap;
		}
	});
	var mixin_1 = require_mixin();
	Object.defineProperty(exports, "SassMixin", {
		enumerable: true,
		get: function() {
			return mixin_1.SassMixin;
		}
	});
	var number_1 = require_number$1();
	Object.defineProperty(exports, "SassNumber", {
		enumerable: true,
		get: function() {
			return number_1.SassNumber;
		}
	});
	var string_1 = require_string$1();
	Object.defineProperty(exports, "SassString", {
		enumerable: true,
		get: function() {
			return string_1.SassString;
		}
	});
	var value_1 = require_value$1();
	Object.defineProperty(exports, "Value", {
		enumerable: true,
		get: function() {
			return value_1.Value;
		}
	});
	var null_2 = require_null();
	Object.defineProperty(exports, "sassNull", {
		enumerable: true,
		get: function() {
			return null_2.sassNull;
		}
	});
	var calculations_1 = require_calculations();
	Object.defineProperty(exports, "CalculationOperation", {
		enumerable: true,
		get: function() {
			return calculations_1.CalculationOperation;
		}
	});
	Object.defineProperty(exports, "CalculationInterpolation", {
		enumerable: true,
		get: function() {
			return calculations_1.CalculationInterpolation;
		}
	});
	Object.defineProperty(exports, "SassCalculation", {
		enumerable: true,
		get: function() {
			return calculations_1.SassCalculation;
		}
	});
	exports.types = require_value();
	var exception_1 = require_exception();
	Object.defineProperty(exports, "Exception", {
		enumerable: true,
		get: function() {
			return exception_1.Exception;
		}
	});
	var compile_1 = require_compile();
	Object.defineProperty(exports, "compile", {
		enumerable: true,
		get: function() {
			return compile_1.compile;
		}
	});
	Object.defineProperty(exports, "compileString", {
		enumerable: true,
		get: function() {
			return compile_1.compileString;
		}
	});
	Object.defineProperty(exports, "compileAsync", {
		enumerable: true,
		get: function() {
			return compile_1.compileAsync;
		}
	});
	Object.defineProperty(exports, "compileStringAsync", {
		enumerable: true,
		get: function() {
			return compile_1.compileStringAsync;
		}
	});
	Object.defineProperty(exports, "NodePackageImporter", {
		enumerable: true,
		get: function() {
			return compile_1.NodePackageImporter;
		}
	});
	var async_1 = require_async();
	Object.defineProperty(exports, "initAsyncCompiler", {
		enumerable: true,
		get: function() {
			return async_1.initAsyncCompiler;
		}
	});
	Object.defineProperty(exports, "AsyncCompiler", {
		enumerable: true,
		get: function() {
			return async_1.AsyncCompiler;
		}
	});
	var sync_1 = require_sync();
	Object.defineProperty(exports, "initCompiler", {
		enumerable: true,
		get: function() {
			return sync_1.initCompiler;
		}
	});
	Object.defineProperty(exports, "Compiler", {
		enumerable: true,
		get: function() {
			return sync_1.Compiler;
		}
	});
	var deprecations_1 = require_deprecations();
	Object.defineProperty(exports, "deprecations", {
		enumerable: true,
		get: function() {
			return deprecations_1.deprecations;
		}
	});
	var version_1 = require_version();
	Object.defineProperty(exports, "Version", {
		enumerable: true,
		get: function() {
			return version_1.Version;
		}
	});
	var legacy_1 = require_legacy();
	Object.defineProperty(exports, "render", {
		enumerable: true,
		get: function() {
			return legacy_1.render;
		}
	});
	Object.defineProperty(exports, "renderSync", {
		enumerable: true,
		get: function() {
			return legacy_1.renderSync;
		}
	});
	exports.info = `sass-embedded\t${pkg.version}`;
	var logger_1 = require_logger();
	Object.defineProperty(exports, "Logger", {
		enumerable: true,
		get: function() {
			return logger_1.Logger;
		}
	});
	exports.TRUE = boolean_1.sassTrue;
	exports.FALSE = boolean_1.sassFalse;
	exports.NULL = null_1.sassNull;
}) });

//#endregion
//#region node_modules/sass-embedded/dist/lib/index.mjs
var import_lib = /* @__PURE__ */ __toESM(require_lib(), 1);
const compile = import_lib.compile;
const compileAsync = import_lib.compileAsync;
const compileString = import_lib.compileString;
const compileStringAsync = import_lib.compileStringAsync;
const NodePackageImporter = import_lib.NodePackageImporter;
const AsyncCompiler = import_lib.AsyncCompiler;
const Compiler = import_lib.Compiler;
const initAsyncCompiler = import_lib.initAsyncCompiler;
const initCompiler = import_lib.initCompiler;
const deprecations = import_lib.deprecations;
const Version = import_lib.Version;
const Logger = import_lib.Logger;
const CalculationInterpolation = import_lib.CalculationInterpolation;
const CalculationOperation = import_lib.CalculationOperation;
const CalculationOperator = import_lib.CalculationOperator;
const SassArgumentList = import_lib.SassArgumentList;
const SassBoolean = import_lib.SassBoolean;
const SassCalculation = import_lib.SassCalculation;
const SassColor = import_lib.SassColor;
const SassFunction = import_lib.SassFunction;
const SassMixin = import_lib.SassMixin;
const SassList = import_lib.SassList;
const SassMap = import_lib.SassMap;
const SassNumber = import_lib.SassNumber;
const SassString = import_lib.SassString;
const Value = import_lib.Value;
const CustomFunction = import_lib.CustomFunction;
const ListSeparator = import_lib.ListSeparator;
const sassFalse = import_lib.sassFalse;
const sassNull = import_lib.sassNull;
const sassTrue = import_lib.sassTrue;
const Exception = import_lib.Exception;
const PromiseOr = import_lib.PromiseOr;
const info = import_lib.info;
const render = import_lib.render;
const renderSync = import_lib.renderSync;
const TRUE = import_lib.TRUE;
const FALSE = import_lib.FALSE;
const NULL = import_lib.NULL;
const types = import_lib.types;
var printedDefaultExportDeprecation = false;
function defaultExportDeprecation() {
	if (printedDefaultExportDeprecation) return;
	printedDefaultExportDeprecation = true;
	console.error("`import sass from 'sass'` is deprecated.\nPlease use `import * as sass from 'sass'` instead.");
}
var lib_default = {
	get compile() {
		defaultExportDeprecation();
		return import_lib.compile;
	},
	get compileAsync() {
		defaultExportDeprecation();
		return import_lib.compileAsync;
	},
	get compileString() {
		defaultExportDeprecation();
		return import_lib.compileString;
	},
	get compileStringAsync() {
		defaultExportDeprecation();
		return import_lib.compileStringAsync;
	},
	get NodePackageImporter() {
		defaultExportDeprecation();
		return import_lib.NodePackageImporter;
	},
	get initAsyncCompiler() {
		defaultExportDeprecation();
		return import_lib.initAsyncCompiler;
	},
	get initCompiler() {
		defaultExportDeprecation();
		return import_lib.initCompiler;
	},
	get AsyncCompiler() {
		defaultExportDeprecation();
		return import_lib.AsyncCompiler;
	},
	get Compiler() {
		defaultExportDeprecation();
		return import_lib.Compiler;
	},
	get deprecations() {
		defaultExportDeprecation();
		return import_lib.deprecations;
	},
	get Version() {
		defaultExportDeprecation();
		return import_lib.Version;
	},
	get Logger() {
		defaultExportDeprecation();
		return import_lib.Logger;
	},
	get CalculationOperation() {
		defaultExportDeprecation();
		return import_lib.CalculationOperation;
	},
	get CalculationOperator() {
		defaultExportDeprecation();
		return import_lib.CalculationOperator;
	},
	get CalculationInterpolation() {
		defaultExportDeprecation();
		return import_lib.CalculationInterpolation;
	},
	get SassArgumentList() {
		defaultExportDeprecation();
		return import_lib.SassArgumentList;
	},
	get SassBoolean() {
		defaultExportDeprecation();
		return import_lib.SassBoolean;
	},
	get SassCalculation() {
		defaultExportDeprecation();
		return import_lib.SassCalculation;
	},
	get SassColor() {
		defaultExportDeprecation();
		return import_lib.SassColor;
	},
	get SassFunction() {
		defaultExportDeprecation();
		return import_lib.SassFunction;
	},
	get SassMixin() {
		defaultExportDeprecation();
		return import_lib.SassMixin;
	},
	get SassList() {
		defaultExportDeprecation();
		return import_lib.SassList;
	},
	get SassMap() {
		defaultExportDeprecation();
		return import_lib.SassMap;
	},
	get SassNumber() {
		defaultExportDeprecation();
		return import_lib.SassNumber;
	},
	get SassString() {
		defaultExportDeprecation();
		return import_lib.SassString;
	},
	get Value() {
		defaultExportDeprecation();
		return import_lib.Value;
	},
	get CustomFunction() {
		defaultExportDeprecation();
		return import_lib.CustomFunction;
	},
	get ListSeparator() {
		defaultExportDeprecation();
		return import_lib.ListSeparator;
	},
	get sassFalse() {
		defaultExportDeprecation();
		return import_lib.sassFalse;
	},
	get sassNull() {
		defaultExportDeprecation();
		return import_lib.sassNull;
	},
	get sassTrue() {
		defaultExportDeprecation();
		return import_lib.sassTrue;
	},
	get Exception() {
		defaultExportDeprecation();
		return import_lib.Exception;
	},
	get PromiseOr() {
		defaultExportDeprecation();
		return import_lib.PromiseOr;
	},
	get info() {
		defaultExportDeprecation();
		return import_lib.info;
	},
	get render() {
		defaultExportDeprecation();
		return import_lib.render;
	},
	get renderSync() {
		defaultExportDeprecation();
		return import_lib.renderSync;
	},
	get TRUE() {
		defaultExportDeprecation();
		return import_lib.TRUE;
	},
	get FALSE() {
		defaultExportDeprecation();
		return import_lib.FALSE;
	},
	get NULL() {
		defaultExportDeprecation();
		return import_lib.NULL;
	},
	get types() {
		defaultExportDeprecation();
		return import_lib.types;
	}
};

//#endregion
export { AsyncCompiler, CalculationInterpolation, CalculationOperation, CalculationOperator, Compiler, CustomFunction, Exception, FALSE, ListSeparator, Logger, NULL, NodePackageImporter, PromiseOr, SassArgumentList, SassBoolean, SassCalculation, SassColor, SassFunction, SassList, SassMap, SassMixin, SassNumber, SassString, TRUE, Value, Version, compile, compileAsync, compileString, compileStringAsync, lib_default as default, deprecations, info, initAsyncCompiler, initCompiler, render, renderSync, sassFalse, sassNull, sassTrue, types };
//# sourceMappingURL=sass-embedded.js.map