import { n as __export } from "./chunk-DUEDWNxO.js";

//#region node_modules/echarts/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(d, b) {
	extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
		d$1.__proto__ = b$1;
	} || function(d$1, b$1) {
		for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
	};
	return extendStatics$1(d, b);
};
function __extends(d, b) {
	if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	extendStatics$1(d, b);
	function __() {
		this.constructor = d;
	}
	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

//#endregion
//#region node_modules/zrender/lib/core/env.js
var Browser = function() {
	function Browser$1() {
		this.firefox = false;
		this.ie = false;
		this.edge = false;
		this.newEdge = false;
		this.weChat = false;
	}
	return Browser$1;
}();
var env = new (function() {
	function Env() {
		this.browser = new Browser();
		this.node = false;
		this.wxa = false;
		this.worker = false;
		this.svgSupported = false;
		this.touchEventsSupported = false;
		this.pointerEventsSupported = false;
		this.domSupported = false;
		this.transformSupported = false;
		this.transform3dSupported = false;
		this.hasGlobalWindow = typeof window !== "undefined";
	}
	return Env;
}())();
if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
	env.wxa = true;
	env.touchEventsSupported = true;
} else if (typeof document === "undefined" && typeof self !== "undefined") env.worker = true;
else if (!env.hasGlobalWindow || "Deno" in window || typeof navigator !== "undefined" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Node.js") > -1) {
	env.node = true;
	env.svgSupported = true;
} else detect(navigator.userAgent, env);
function detect(ua, env$1) {
	var browser = env$1.browser;
	var firefox = ua.match(/Firefox\/([\d.]+)/);
	var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	var edge = ua.match(/Edge?\/([\d.]+)/);
	var weChat = /micromessenger/i.test(ua);
	if (firefox) {
		browser.firefox = true;
		browser.version = firefox[1];
	}
	if (ie) {
		browser.ie = true;
		browser.version = ie[1];
	}
	if (edge) {
		browser.edge = true;
		browser.version = edge[1];
		browser.newEdge = +edge[1].split(".")[0] > 18;
	}
	if (weChat) browser.weChat = true;
	env$1.svgSupported = typeof SVGRect !== "undefined";
	env$1.touchEventsSupported = "ontouchstart" in window && !browser.ie && !browser.edge;
	env$1.pointerEventsSupported = "onpointerdown" in window && (browser.edge || browser.ie && +browser.version >= 11);
	if (env$1.domSupported = typeof document !== "undefined") {
		var style = document.documentElement.style;
		env$1.transform3dSupported = (browser.ie && "transition" in style || browser.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in style) && !("OTransition" in style);
		env$1.transformSupported = env$1.transform3dSupported || browser.ie && +browser.version >= 9;
	}
}
var env_default = env;

//#endregion
//#region node_modules/zrender/lib/core/platform.js
var DEFAULT_FONT_SIZE = 12;
var DEFAULT_FONT_FAMILY = "sans-serif";
var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
var OFFSET = 20;
var SCALE = 100;
var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(mapStr) {
	var map$2 = {};
	if (typeof JSON === "undefined") return map$2;
	for (var i$1 = 0; i$1 < mapStr.length; i$1++) {
		var char = String.fromCharCode(i$1 + 32);
		map$2[char] = (mapStr.charCodeAt(i$1) - OFFSET) / SCALE;
	}
	return map$2;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
var platformApi = {
	createCanvas: function() {
		return typeof document !== "undefined" && document.createElement("canvas");
	},
	measureText: (function() {
		var _ctx;
		var _cachedFont;
		return function(text, font) {
			if (!_ctx) {
				var canvas = platformApi.createCanvas();
				_ctx = canvas && canvas.getContext("2d");
			}
			if (_ctx) {
				if (_cachedFont !== font) _cachedFont = _ctx.font = font || DEFAULT_FONT;
				return _ctx.measureText(text);
			} else {
				text = text || "";
				font = font || DEFAULT_FONT;
				var res = /((?:\d+)?\.?\d*)px/.exec(font);
				var fontSize = res && +res[1] || DEFAULT_FONT_SIZE;
				var width = 0;
				if (font.indexOf("mono") >= 0) width = fontSize * text.length;
				else for (var i$1 = 0; i$1 < text.length; i$1++) {
					var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i$1]];
					width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
				}
				return { width };
			}
		};
	})(),
	loadImage: function(src, onload, onerror) {
		var image = new Image();
		image.onload = onload;
		image.onerror = onerror;
		image.src = src;
		return image;
	}
};
function setPlatformAPI(newPlatformApis) {
	for (var key$1 in platformApi) if (newPlatformApis[key$1]) platformApi[key$1] = newPlatformApis[key$1];
}

//#endregion
//#region node_modules/zrender/lib/core/util.js
var util_exports$1 = /* @__PURE__ */ __export({
	EPSILON: () => EPSILON$5,
	HashMap: () => HashMap,
	RADIAN_TO_DEGREE: () => RADIAN_TO_DEGREE,
	assert: () => assert,
	bind: () => bind,
	clone: () => clone,
	concatArray: () => concatArray,
	createCanvas: () => createCanvas,
	createHashMap: () => createHashMap,
	createObject: () => createObject,
	curry: () => curry,
	defaults: () => defaults,
	disableUserSelect: () => disableUserSelect,
	each: () => each,
	eqNaN: () => eqNaN,
	extend: () => extend,
	filter: () => filter,
	find: () => find,
	guid: () => guid,
	hasOwn: () => hasOwn,
	indexOf: () => indexOf,
	inherits: () => inherits,
	isArray: () => isArray,
	isArrayLike: () => isArrayLike,
	isBuiltInObject: () => isBuiltInObject,
	isDom: () => isDom,
	isFunction: () => isFunction,
	isGradientObject: () => isGradientObject,
	isImagePatternObject: () => isImagePatternObject,
	isNumber: () => isNumber,
	isObject: () => isObject,
	isPrimitive: () => isPrimitive,
	isRegExp: () => isRegExp,
	isString: () => isString,
	isStringSafe: () => isStringSafe,
	isTypedArray: () => isTypedArray,
	keys: () => keys,
	logError: () => logError,
	map: () => map,
	merge: () => merge,
	mergeAll: () => mergeAll,
	mixin: () => mixin,
	noop: () => noop,
	normalizeCssArray: () => normalizeCssArray$1,
	reduce: () => reduce,
	retrieve: () => retrieve,
	retrieve2: () => retrieve2,
	retrieve3: () => retrieve3,
	setAsPrimitive: () => setAsPrimitive,
	slice: () => slice,
	trim: () => trim
});
var BUILTIN_OBJECT = reduce([
	"Function",
	"RegExp",
	"Date",
	"Error",
	"CanvasGradient",
	"CanvasPattern",
	"Image",
	"Canvas"
], function(obj, val) {
	obj["[object " + val + "]"] = true;
	return obj;
}, {});
var TYPED_ARRAY = reduce([
	"Int8",
	"Uint8",
	"Uint8Clamped",
	"Int16",
	"Uint16",
	"Int32",
	"Uint32",
	"Float32",
	"Float64"
], function(obj, val) {
	obj["[object " + val + "Array]"] = true;
	return obj;
}, {});
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var ctorFunction = function() {}.constructor;
var protoFunction = ctorFunction ? ctorFunction.prototype : null;
var protoKey = "__proto__";
var idStart = 2311;
function guid() {
	return idStart++;
}
function logError() {
	var args = [];
	for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
	if (typeof console !== "undefined") console.error.apply(console, args);
}
function clone(source) {
	if (source == null || typeof source !== "object") return source;
	var result = source;
	var typeStr = objToString.call(source);
	if (typeStr === "[object Array]") {
		if (!isPrimitive(source)) {
			result = [];
			for (var i$1 = 0, len$1 = source.length; i$1 < len$1; i$1++) result[i$1] = clone(source[i$1]);
		}
	} else if (TYPED_ARRAY[typeStr]) {
		if (!isPrimitive(source)) {
			var Ctor = source.constructor;
			if (Ctor.from) result = Ctor.from(source);
			else {
				result = new Ctor(source.length);
				for (var i$1 = 0, len$1 = source.length; i$1 < len$1; i$1++) result[i$1] = source[i$1];
			}
		}
	} else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
		result = {};
		for (var key$1 in source) if (source.hasOwnProperty(key$1) && key$1 !== protoKey) result[key$1] = clone(source[key$1]);
	}
	return result;
}
function merge(target, source, overwrite) {
	if (!isObject(source) || !isObject(target)) return overwrite ? clone(source) : target;
	for (var key$1 in source) if (source.hasOwnProperty(key$1) && key$1 !== protoKey) {
		var targetProp = target[key$1];
		var sourceProp = source[key$1];
		if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) merge(targetProp, sourceProp, overwrite);
		else if (overwrite || !(key$1 in target)) target[key$1] = clone(source[key$1]);
	}
	return target;
}
function mergeAll(targetAndSources, overwrite) {
	var result = targetAndSources[0];
	for (var i$1 = 1, len$1 = targetAndSources.length; i$1 < len$1; i$1++) result = merge(result, targetAndSources[i$1], overwrite);
	return result;
}
function extend(target, source) {
	if (Object.assign) Object.assign(target, source);
	else for (var key$1 in source) if (source.hasOwnProperty(key$1) && key$1 !== protoKey) target[key$1] = source[key$1];
	return target;
}
function defaults(target, source, overlay) {
	var keysArr = keys(source);
	for (var i$1 = 0, len$1 = keysArr.length; i$1 < len$1; i$1++) {
		var key$1 = keysArr[i$1];
		if (overlay ? source[key$1] != null : target[key$1] == null) target[key$1] = source[key$1];
	}
	return target;
}
var createCanvas = platformApi.createCanvas;
function indexOf(array, value) {
	if (array) {
		if (array.indexOf) return array.indexOf(value);
		for (var i$1 = 0, len$1 = array.length; i$1 < len$1; i$1++) if (array[i$1] === value) return i$1;
	}
	return -1;
}
function inherits(clazz, baseClazz) {
	var clazzPrototype = clazz.prototype;
	function F() {}
	F.prototype = baseClazz.prototype;
	clazz.prototype = new F();
	for (var prop in clazzPrototype) if (clazzPrototype.hasOwnProperty(prop)) clazz.prototype[prop] = clazzPrototype[prop];
	clazz.prototype.constructor = clazz;
	clazz.superClass = baseClazz;
}
function mixin(target, source, override) {
	target = "prototype" in target ? target.prototype : target;
	source = "prototype" in source ? source.prototype : source;
	if (Object.getOwnPropertyNames) {
		var keyList = Object.getOwnPropertyNames(source);
		for (var i$1 = 0; i$1 < keyList.length; i$1++) {
			var key$1 = keyList[i$1];
			if (key$1 !== "constructor") {
				if (override ? source[key$1] != null : target[key$1] == null) target[key$1] = source[key$1];
			}
		}
	} else defaults(target, source, override);
}
function isArrayLike(data) {
	if (!data) return false;
	if (typeof data === "string") return false;
	return typeof data.length === "number";
}
function each(arr, cb, context) {
	if (!(arr && cb)) return;
	if (arr.forEach && arr.forEach === nativeForEach) arr.forEach(cb, context);
	else if (arr.length === +arr.length) for (var i$1 = 0, len$1 = arr.length; i$1 < len$1; i$1++) cb.call(context, arr[i$1], i$1, arr);
	else for (var key$1 in arr) if (arr.hasOwnProperty(key$1)) cb.call(context, arr[key$1], key$1, arr);
}
function map(arr, cb, context) {
	if (!arr) return [];
	if (!cb) return slice(arr);
	if (arr.map && arr.map === nativeMap) return arr.map(cb, context);
	else {
		var result = [];
		for (var i$1 = 0, len$1 = arr.length; i$1 < len$1; i$1++) result.push(cb.call(context, arr[i$1], i$1, arr));
		return result;
	}
}
function reduce(arr, cb, memo, context) {
	if (!(arr && cb)) return;
	for (var i$1 = 0, len$1 = arr.length; i$1 < len$1; i$1++) memo = cb.call(context, memo, arr[i$1], i$1, arr);
	return memo;
}
function filter(arr, cb, context) {
	if (!arr) return [];
	if (!cb) return slice(arr);
	if (arr.filter && arr.filter === nativeFilter) return arr.filter(cb, context);
	else {
		var result = [];
		for (var i$1 = 0, len$1 = arr.length; i$1 < len$1; i$1++) if (cb.call(context, arr[i$1], i$1, arr)) result.push(arr[i$1]);
		return result;
	}
}
function find(arr, cb, context) {
	if (!(arr && cb)) return;
	for (var i$1 = 0, len$1 = arr.length; i$1 < len$1; i$1++) if (cb.call(context, arr[i$1], i$1, arr)) return arr[i$1];
}
function keys(obj) {
	if (!obj) return [];
	if (Object.keys) return Object.keys(obj);
	var keyList = [];
	for (var key$1 in obj) if (obj.hasOwnProperty(key$1)) keyList.push(key$1);
	return keyList;
}
function bindPolyfill(func, context) {
	var args = [];
	for (var _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
	return function() {
		return func.apply(context, args.concat(nativeSlice.call(arguments)));
	};
}
var bind = protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry(func) {
	var args = [];
	for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
	return function() {
		return func.apply(this, args.concat(nativeSlice.call(arguments)));
	};
}
function isArray(value) {
	if (Array.isArray) return Array.isArray(value);
	return objToString.call(value) === "[object Array]";
}
function isFunction(value) {
	return typeof value === "function";
}
function isString(value) {
	return typeof value === "string";
}
function isStringSafe(value) {
	return objToString.call(value) === "[object String]";
}
function isNumber(value) {
	return typeof value === "number";
}
function isObject(value) {
	var type = typeof value;
	return type === "function" || !!value && type === "object";
}
function isBuiltInObject(value) {
	return !!BUILTIN_OBJECT[objToString.call(value)];
}
function isTypedArray(value) {
	return !!TYPED_ARRAY[objToString.call(value)];
}
function isDom(value) {
	return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
}
function isGradientObject(value) {
	return value.colorStops != null;
}
function isImagePatternObject(value) {
	return value.image != null;
}
function isRegExp(value) {
	return objToString.call(value) === "[object RegExp]";
}
function eqNaN(value) {
	return value !== value;
}
function retrieve() {
	var args = [];
	for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
	for (var i$1 = 0, len$1 = args.length; i$1 < len$1; i$1++) if (args[i$1] != null) return args[i$1];
}
function retrieve2(value0, value1) {
	return value0 != null ? value0 : value1;
}
function retrieve3(value0, value1, value2) {
	return value0 != null ? value0 : value1 != null ? value1 : value2;
}
function slice(arr) {
	var args = [];
	for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
	return nativeSlice.apply(arr, args);
}
function normalizeCssArray$1(val) {
	if (typeof val === "number") return [
		val,
		val,
		val,
		val
	];
	var len$1 = val.length;
	if (len$1 === 2) return [
		val[0],
		val[1],
		val[0],
		val[1]
	];
	else if (len$1 === 3) return [
		val[0],
		val[1],
		val[2],
		val[1]
	];
	return val;
}
function assert(condition, message) {
	if (!condition) throw new Error(message);
}
function trim(str) {
	if (str == null) return null;
	else if (typeof str.trim === "function") return str.trim();
	else return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(obj) {
	obj[primitiveKey] = true;
}
function isPrimitive(obj) {
	return obj[primitiveKey];
}
var MapPolyfill = function() {
	function MapPolyfill$1() {
		this.data = {};
	}
	MapPolyfill$1.prototype["delete"] = function(key$1) {
		var existed = this.has(key$1);
		if (existed) delete this.data[key$1];
		return existed;
	};
	MapPolyfill$1.prototype.has = function(key$1) {
		return this.data.hasOwnProperty(key$1);
	};
	MapPolyfill$1.prototype.get = function(key$1) {
		return this.data[key$1];
	};
	MapPolyfill$1.prototype.set = function(key$1, value) {
		this.data[key$1] = value;
		return this;
	};
	MapPolyfill$1.prototype.keys = function() {
		return keys(this.data);
	};
	MapPolyfill$1.prototype.forEach = function(callback) {
		var data = this.data;
		for (var key$1 in data) if (data.hasOwnProperty(key$1)) callback(data[key$1], key$1);
	};
	return MapPolyfill$1;
}();
var isNativeMapSupported = typeof Map === "function";
function maybeNativeMap() {
	return isNativeMapSupported ? /* @__PURE__ */ new Map() : new MapPolyfill();
}
var HashMap = function() {
	function HashMap$1(obj) {
		var isArr = isArray(obj);
		this.data = maybeNativeMap();
		var thisMap = this;
		obj instanceof HashMap$1 ? obj.each(visit) : obj && each(obj, visit);
		function visit(value, key$1) {
			isArr ? thisMap.set(value, key$1) : thisMap.set(key$1, value);
		}
	}
	HashMap$1.prototype.hasKey = function(key$1) {
		return this.data.has(key$1);
	};
	HashMap$1.prototype.get = function(key$1) {
		return this.data.get(key$1);
	};
	HashMap$1.prototype.set = function(key$1, value) {
		this.data.set(key$1, value);
		return value;
	};
	HashMap$1.prototype.each = function(cb, context) {
		this.data.forEach(function(value, key$1) {
			cb.call(context, value, key$1);
		});
	};
	HashMap$1.prototype.keys = function() {
		var keys$1 = this.data.keys();
		return isNativeMapSupported ? Array.from(keys$1) : keys$1;
	};
	HashMap$1.prototype.removeKey = function(key$1) {
		this.data["delete"](key$1);
	};
	return HashMap$1;
}();
function createHashMap(obj) {
	return new HashMap(obj);
}
function concatArray(a, b) {
	var newArray = new a.constructor(a.length + b.length);
	for (var i$1 = 0; i$1 < a.length; i$1++) newArray[i$1] = a[i$1];
	var offset = a.length;
	for (var i$1 = 0; i$1 < b.length; i$1++) newArray[i$1 + offset] = b[i$1];
	return newArray;
}
function createObject(proto, properties) {
	var obj;
	if (Object.create) obj = Object.create(proto);
	else {
		var StyleCtor = function() {};
		StyleCtor.prototype = proto;
		obj = new StyleCtor();
	}
	if (properties) extend(obj, properties);
	return obj;
}
function disableUserSelect(dom) {
	var domStyle = dom.style;
	domStyle.webkitUserSelect = "none";
	domStyle.userSelect = "none";
	domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
	domStyle["-webkit-touch-callout"] = "none";
}
function hasOwn(own, prop) {
	return own.hasOwnProperty(prop);
}
function noop() {}
var RADIAN_TO_DEGREE = 180 / Math.PI;
var EPSILON$5 = Number.EPSILON || Math.pow(2, -52);

//#endregion
//#region node_modules/zrender/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
	extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
		d$1.__proto__ = b$1;
	} || function(d$1, b$1) {
		for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
	};
	return extendStatics(d, b);
};
function __extends$1(d, b) {
	if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	extendStatics(d, b);
	function __() {
		this.constructor = d;
	}
	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

//#endregion
//#region node_modules/zrender/lib/core/vector.js
var vector_exports = /* @__PURE__ */ __export({
	add: () => add,
	applyTransform: () => applyTransform,
	clone: () => clone$3,
	copy: () => copy$1,
	create: () => create$1,
	dist: () => dist$1,
	distSquare: () => distSquare,
	distance: () => distance,
	distanceSquare: () => distanceSquare,
	div: () => div,
	dot: () => dot,
	len: () => len,
	lenSquare: () => lenSquare,
	length: () => length,
	lengthSquare: () => lengthSquare,
	lerp: () => lerp,
	max: () => max,
	min: () => min,
	mul: () => mul$1,
	negate: () => negate,
	normalize: () => normalize$3,
	scale: () => scale$1,
	scaleAndAdd: () => scaleAndAdd$1,
	set: () => set$1,
	sub: () => sub
});
function create$1(x, y) {
	if (x == null) x = 0;
	if (y == null) y = 0;
	return [x, y];
}
function copy$1(out$1, v) {
	out$1[0] = v[0];
	out$1[1] = v[1];
	return out$1;
}
function clone$3(v) {
	return [v[0], v[1]];
}
function set$1(out$1, a, b) {
	out$1[0] = a;
	out$1[1] = b;
	return out$1;
}
function add(out$1, v1$1, v2$1) {
	out$1[0] = v1$1[0] + v2$1[0];
	out$1[1] = v1$1[1] + v2$1[1];
	return out$1;
}
function scaleAndAdd$1(out$1, v1$1, v2$1, a) {
	out$1[0] = v1$1[0] + v2$1[0] * a;
	out$1[1] = v1$1[1] + v2$1[1] * a;
	return out$1;
}
function sub(out$1, v1$1, v2$1) {
	out$1[0] = v1$1[0] - v2$1[0];
	out$1[1] = v1$1[1] - v2$1[1];
	return out$1;
}
function len(v) {
	return Math.sqrt(lenSquare(v));
}
var length = len;
function lenSquare(v) {
	return v[0] * v[0] + v[1] * v[1];
}
var lengthSquare = lenSquare;
function mul$1(out$1, v1$1, v2$1) {
	out$1[0] = v1$1[0] * v2$1[0];
	out$1[1] = v1$1[1] * v2$1[1];
	return out$1;
}
function div(out$1, v1$1, v2$1) {
	out$1[0] = v1$1[0] / v2$1[0];
	out$1[1] = v1$1[1] / v2$1[1];
	return out$1;
}
function dot(v1$1, v2$1) {
	return v1$1[0] * v2$1[0] + v1$1[1] * v2$1[1];
}
function scale$1(out$1, v, s) {
	out$1[0] = v[0] * s;
	out$1[1] = v[1] * s;
	return out$1;
}
function normalize$3(out$1, v) {
	var d = len(v);
	if (d === 0) {
		out$1[0] = 0;
		out$1[1] = 0;
	} else {
		out$1[0] = v[0] / d;
		out$1[1] = v[1] / d;
	}
	return out$1;
}
function distance(v1$1, v2$1) {
	return Math.sqrt((v1$1[0] - v2$1[0]) * (v1$1[0] - v2$1[0]) + (v1$1[1] - v2$1[1]) * (v1$1[1] - v2$1[1]));
}
var dist$1 = distance;
function distanceSquare(v1$1, v2$1) {
	return (v1$1[0] - v2$1[0]) * (v1$1[0] - v2$1[0]) + (v1$1[1] - v2$1[1]) * (v1$1[1] - v2$1[1]);
}
var distSquare = distanceSquare;
function negate(out$1, v) {
	out$1[0] = -v[0];
	out$1[1] = -v[1];
	return out$1;
}
function lerp(out$1, v1$1, v2$1, t) {
	out$1[0] = v1$1[0] + t * (v2$1[0] - v1$1[0]);
	out$1[1] = v1$1[1] + t * (v2$1[1] - v1$1[1]);
	return out$1;
}
function applyTransform(out$1, v, m$1) {
	var x = v[0];
	var y = v[1];
	out$1[0] = m$1[0] * x + m$1[2] * y + m$1[4];
	out$1[1] = m$1[1] * x + m$1[3] * y + m$1[5];
	return out$1;
}
function min(out$1, v1$1, v2$1) {
	out$1[0] = Math.min(v1$1[0], v2$1[0]);
	out$1[1] = Math.min(v1$1[1], v2$1[1]);
	return out$1;
}
function max(out$1, v1$1, v2$1) {
	out$1[0] = Math.max(v1$1[0], v2$1[0]);
	out$1[1] = Math.max(v1$1[1], v2$1[1]);
	return out$1;
}

//#endregion
//#region node_modules/zrender/lib/mixin/Draggable.js
var Param = function() {
	function Param$1(target, e$1) {
		this.target = target;
		this.topTarget = e$1 && e$1.topTarget;
	}
	return Param$1;
}();
var Draggable = function() {
	function Draggable$1(handler) {
		this.handler = handler;
		handler.on("mousedown", this._dragStart, this);
		handler.on("mousemove", this._drag, this);
		handler.on("mouseup", this._dragEnd, this);
	}
	Draggable$1.prototype._dragStart = function(e$1) {
		var draggingTarget = e$1.target;
		while (draggingTarget && !draggingTarget.draggable) draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
		if (draggingTarget) {
			this._draggingTarget = draggingTarget;
			draggingTarget.dragging = true;
			this._x = e$1.offsetX;
			this._y = e$1.offsetY;
			this.handler.dispatchToElement(new Param(draggingTarget, e$1), "dragstart", e$1.event);
		}
	};
	Draggable$1.prototype._drag = function(e$1) {
		var draggingTarget = this._draggingTarget;
		if (draggingTarget) {
			var x = e$1.offsetX;
			var y = e$1.offsetY;
			var dx = x - this._x;
			var dy = y - this._y;
			this._x = x;
			this._y = y;
			draggingTarget.drift(dx, dy, e$1);
			this.handler.dispatchToElement(new Param(draggingTarget, e$1), "drag", e$1.event);
			var dropTarget = this.handler.findHover(x, y, draggingTarget).target;
			var lastDropTarget = this._dropTarget;
			this._dropTarget = dropTarget;
			if (draggingTarget !== dropTarget) {
				if (lastDropTarget && dropTarget !== lastDropTarget) this.handler.dispatchToElement(new Param(lastDropTarget, e$1), "dragleave", e$1.event);
				if (dropTarget && dropTarget !== lastDropTarget) this.handler.dispatchToElement(new Param(dropTarget, e$1), "dragenter", e$1.event);
			}
		}
	};
	Draggable$1.prototype._dragEnd = function(e$1) {
		var draggingTarget = this._draggingTarget;
		if (draggingTarget) draggingTarget.dragging = false;
		this.handler.dispatchToElement(new Param(draggingTarget, e$1), "dragend", e$1.event);
		if (this._dropTarget) this.handler.dispatchToElement(new Param(this._dropTarget, e$1), "drop", e$1.event);
		this._draggingTarget = null;
		this._dropTarget = null;
	};
	return Draggable$1;
}();
var Draggable_default = Draggable;

//#endregion
//#region node_modules/zrender/lib/core/Eventful.js
var Eventful = function() {
	function Eventful$1(eventProcessors) {
		if (eventProcessors) this._$eventProcessor = eventProcessors;
	}
	Eventful$1.prototype.on = function(event, query, handler, context) {
		if (!this._$handlers) this._$handlers = {};
		var _h = this._$handlers;
		if (typeof query === "function") {
			context = handler;
			handler = query;
			query = null;
		}
		if (!handler || !event) return this;
		var eventProcessor = this._$eventProcessor;
		if (query != null && eventProcessor && eventProcessor.normalizeQuery) query = eventProcessor.normalizeQuery(query);
		if (!_h[event]) _h[event] = [];
		for (var i$1 = 0; i$1 < _h[event].length; i$1++) if (_h[event][i$1].h === handler) return this;
		var wrap = {
			h: handler,
			query,
			ctx: context || this,
			callAtLast: handler.zrEventfulCallAtLast
		};
		var lastIndex = _h[event].length - 1;
		var lastWrap = _h[event][lastIndex];
		lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
		return this;
	};
	Eventful$1.prototype.isSilent = function(eventName) {
		var _h = this._$handlers;
		return !_h || !_h[eventName] || !_h[eventName].length;
	};
	Eventful$1.prototype.off = function(eventType, handler) {
		var _h = this._$handlers;
		if (!_h) return this;
		if (!eventType) {
			this._$handlers = {};
			return this;
		}
		if (handler) {
			if (_h[eventType]) {
				var newList = [];
				for (var i$1 = 0, l = _h[eventType].length; i$1 < l; i$1++) if (_h[eventType][i$1].h !== handler) newList.push(_h[eventType][i$1]);
				_h[eventType] = newList;
			}
			if (_h[eventType] && _h[eventType].length === 0) delete _h[eventType];
		} else delete _h[eventType];
		return this;
	};
	Eventful$1.prototype.trigger = function(eventType) {
		var args = [];
		for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
		if (!this._$handlers) return this;
		var _h = this._$handlers[eventType];
		var eventProcessor = this._$eventProcessor;
		if (_h) {
			var argLen = args.length;
			var len$1 = _h.length;
			for (var i$1 = 0; i$1 < len$1; i$1++) {
				var hItem = _h[i$1];
				if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType, hItem.query)) continue;
				switch (argLen) {
					case 0:
						hItem.h.call(hItem.ctx);
						break;
					case 1:
						hItem.h.call(hItem.ctx, args[0]);
						break;
					case 2:
						hItem.h.call(hItem.ctx, args[0], args[1]);
						break;
					default:
						hItem.h.apply(hItem.ctx, args);
						break;
				}
			}
		}
		eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType);
		return this;
	};
	Eventful$1.prototype.triggerWithContext = function(type) {
		var args = [];
		for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
		if (!this._$handlers) return this;
		var _h = this._$handlers[type];
		var eventProcessor = this._$eventProcessor;
		if (_h) {
			var argLen = args.length;
			var ctx = args[argLen - 1];
			var len$1 = _h.length;
			for (var i$1 = 0; i$1 < len$1; i$1++) {
				var hItem = _h[i$1];
				if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) continue;
				switch (argLen) {
					case 0:
						hItem.h.call(ctx);
						break;
					case 1:
						hItem.h.call(ctx, args[0]);
						break;
					case 2:
						hItem.h.call(ctx, args[0], args[1]);
						break;
					default:
						hItem.h.apply(ctx, args.slice(1, argLen - 1));
						break;
				}
			}
		}
		eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
		return this;
	};
	return Eventful$1;
}();
var Eventful_default = Eventful;

//#endregion
//#region node_modules/zrender/lib/core/fourPointsTransform.js
var LN2 = Math.log(2);
function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
	var cacheKey = rowMask + "-" + colMask;
	var fullRank = rows.length;
	if (detCache.hasOwnProperty(cacheKey)) return detCache[cacheKey];
	if (rank === 1) {
		var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
		return rows[rowStart][colStart];
	}
	var subRowMask = rowMask | 1 << rowStart;
	var subRowStart = rowStart + 1;
	while (rowMask & 1 << subRowStart) subRowStart++;
	var sum$1 = 0;
	for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
		var colTag = 1 << j;
		if (!(colTag & colMask)) {
			sum$1 += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
			colLocalIdx++;
		}
	}
	detCache[cacheKey] = sum$1;
	return sum$1;
}
function buildTransformer(src, dest) {
	var mA = [
		[
			src[0],
			src[1],
			1,
			0,
			0,
			0,
			-dest[0] * src[0],
			-dest[0] * src[1]
		],
		[
			0,
			0,
			0,
			src[0],
			src[1],
			1,
			-dest[1] * src[0],
			-dest[1] * src[1]
		],
		[
			src[2],
			src[3],
			1,
			0,
			0,
			0,
			-dest[2] * src[2],
			-dest[2] * src[3]
		],
		[
			0,
			0,
			0,
			src[2],
			src[3],
			1,
			-dest[3] * src[2],
			-dest[3] * src[3]
		],
		[
			src[4],
			src[5],
			1,
			0,
			0,
			0,
			-dest[4] * src[4],
			-dest[4] * src[5]
		],
		[
			0,
			0,
			0,
			src[4],
			src[5],
			1,
			-dest[5] * src[4],
			-dest[5] * src[5]
		],
		[
			src[6],
			src[7],
			1,
			0,
			0,
			0,
			-dest[6] * src[6],
			-dest[6] * src[7]
		],
		[
			0,
			0,
			0,
			src[6],
			src[7],
			1,
			-dest[7] * src[6],
			-dest[7] * src[7]
		]
	];
	var detCache = {};
	var det = determinant(mA, 8, 0, 0, 0, detCache);
	if (det === 0) return;
	var vh = [];
	for (var i$1 = 0; i$1 < 8; i$1++) for (var j = 0; j < 8; j++) {
		vh[j] ?? (vh[j] = 0);
		vh[j] += ((i$1 + j) % 2 ? -1 : 1) * determinant(mA, 7, i$1 === 0 ? 1 : 0, 1 << i$1, 1 << j, detCache) / det * dest[i$1];
	}
	return function(out$1, srcPointX, srcPointY) {
		var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
		out$1[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
		out$1[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
	};
}

//#endregion
//#region node_modules/zrender/lib/core/dom.js
var EVENT_SAVED_PROP = "___zrEVENTSAVED";
var _calcOut$1 = [];
function transformLocalCoord(out$1, elFrom, elTarget, inX, inY) {
	return transformCoordWithViewport(_calcOut$1, elFrom, inX, inY, true) && transformCoordWithViewport(out$1, elTarget, _calcOut$1[0], _calcOut$1[1]);
}
function transformLocalCoordClear(elFrom, elTarget) {
	elFrom && dealClear(elFrom);
	elTarget && dealClear(elTarget);
	function dealClear(el) {
		var saved = el[EVENT_SAVED_PROP];
		if (saved) {
			saved.clearMarkers && saved.clearMarkers();
			delete el[EVENT_SAVED_PROP];
		}
	}
}
function transformCoordWithViewport(out$1, el, inX, inY, inverse) {
	if (el.getBoundingClientRect && env_default.domSupported && !isCanvasEl(el)) {
		var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
		var transformer = preparePointerTransformer(prepareCoordMarkers(el, saved), saved, inverse);
		if (transformer) {
			transformer(out$1, inX, inY);
			return true;
		}
	}
	return false;
}
function prepareCoordMarkers(el, saved) {
	var markers = saved.markers;
	if (markers) return markers;
	markers = saved.markers = [];
	var propLR = ["left", "right"];
	var propTB = ["top", "bottom"];
	for (var i$1 = 0; i$1 < 4; i$1++) {
		var marker = document.createElement("div");
		var stl = marker.style;
		var idxLR = i$1 % 2;
		var idxTB = (i$1 >> 1) % 2;
		stl.cssText = [
			"position: absolute",
			"visibility: hidden",
			"padding: 0",
			"margin: 0",
			"border-width: 0",
			"user-select: none",
			"width:0",
			"height:0",
			propLR[idxLR] + ":0",
			propTB[idxTB] + ":0",
			propLR[1 - idxLR] + ":auto",
			propTB[1 - idxTB] + ":auto",
			""
		].join("!important;");
		el.appendChild(marker);
		markers.push(marker);
	}
	saved.clearMarkers = function() {
		each(markers, function(marker$1) {
			marker$1.parentNode && marker$1.parentNode.removeChild(marker$1);
		});
	};
	return markers;
}
function preparePointerTransformer(markers, saved, inverse) {
	var transformerName = inverse ? "invTrans" : "trans";
	var transformer = saved[transformerName];
	var oldSrcCoords = saved.srcCoords;
	var srcCoords = [];
	var destCoords = [];
	var oldCoordTheSame = true;
	for (var i$1 = 0; i$1 < 4; i$1++) {
		var rect = markers[i$1].getBoundingClientRect();
		var ii = 2 * i$1;
		var x = rect.left;
		var y = rect.top;
		srcCoords.push(x, y);
		oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
		destCoords.push(markers[i$1].offsetLeft, markers[i$1].offsetTop);
	}
	return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
}
function isCanvasEl(el) {
	return el.nodeName.toUpperCase() === "CANVAS";
}
var replaceReg = /([&<>"'])/g;
var replaceMap = {
	"&": "&amp;",
	"<": "&lt;",
	">": "&gt;",
	"\"": "&quot;",
	"'": "&#39;"
};
function encodeHTML(source) {
	return source == null ? "" : (source + "").replace(replaceReg, function(str, c) {
		return replaceMap[c];
	});
}

//#endregion
//#region node_modules/zrender/lib/core/event.js
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut = [];
var firefoxNotSupportOffsetXY = env_default.browser.firefox && +env_default.browser.version.split(".")[0] < 39;
function clientToLocal(el, e$1, out$1, calculate) {
	out$1 = out$1 || {};
	if (calculate) calculateZrXY(el, e$1, out$1);
	else if (firefoxNotSupportOffsetXY && e$1.layerX != null && e$1.layerX !== e$1.offsetX) {
		out$1.zrX = e$1.layerX;
		out$1.zrY = e$1.layerY;
	} else if (e$1.offsetX != null) {
		out$1.zrX = e$1.offsetX;
		out$1.zrY = e$1.offsetY;
	} else calculateZrXY(el, e$1, out$1);
	return out$1;
}
function calculateZrXY(el, e$1, out$1) {
	if (env_default.domSupported && el.getBoundingClientRect) {
		var ex = e$1.clientX;
		var ey = e$1.clientY;
		if (isCanvasEl(el)) {
			var box$1 = el.getBoundingClientRect();
			out$1.zrX = ex - box$1.left;
			out$1.zrY = ey - box$1.top;
			return;
		} else if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
			out$1.zrX = _calcOut[0];
			out$1.zrY = _calcOut[1];
			return;
		}
	}
	out$1.zrX = out$1.zrY = 0;
}
function getNativeEvent(e$1) {
	return e$1 || window.event;
}
function normalizeEvent(el, e$1, calculate) {
	e$1 = getNativeEvent(e$1);
	if (e$1.zrX != null) return e$1;
	var eventType = e$1.type;
	if (!(eventType && eventType.indexOf("touch") >= 0)) {
		clientToLocal(el, e$1, e$1, calculate);
		var wheelDelta = getWheelDeltaMayPolyfill(e$1);
		e$1.zrDelta = wheelDelta ? wheelDelta / 120 : -(e$1.detail || 0) / 3;
	} else {
		var touch = eventType !== "touchend" ? e$1.targetTouches[0] : e$1.changedTouches[0];
		touch && clientToLocal(el, touch, e$1, calculate);
	}
	var button = e$1.button;
	if (e$1.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e$1.type)) e$1.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
	return e$1;
}
function getWheelDeltaMayPolyfill(e$1) {
	var rawWheelDelta = e$1.wheelDelta;
	if (rawWheelDelta) return rawWheelDelta;
	var deltaX = e$1.deltaX;
	var deltaY = e$1.deltaY;
	if (deltaX == null || deltaY == null) return rawWheelDelta;
	var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
	var sign = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
	return 3 * delta * sign;
}
function addEventListener(el, name, handler, opt) {
	el.addEventListener(name, handler, opt);
}
function removeEventListener(el, name, handler, opt) {
	el.removeEventListener(name, handler, opt);
}
var stop = function(e$1) {
	e$1.preventDefault();
	e$1.stopPropagation();
	e$1.cancelBubble = true;
};
function isMiddleOrRightButtonOnMouseUpDown(e$1) {
	return e$1.which === 2 || e$1.which === 3;
}

//#endregion
//#region node_modules/zrender/lib/core/GestureMgr.js
var GestureMgr = function() {
	function GestureMgr$1() {
		this._track = [];
	}
	GestureMgr$1.prototype.recognize = function(event, target, root) {
		this._doTrack(event, target, root);
		return this._recognize(event);
	};
	GestureMgr$1.prototype.clear = function() {
		this._track.length = 0;
		return this;
	};
	GestureMgr$1.prototype._doTrack = function(event, target, root) {
		var touches = event.touches;
		if (!touches) return;
		var trackItem = {
			points: [],
			touches: [],
			target,
			event
		};
		for (var i$1 = 0, len$1 = touches.length; i$1 < len$1; i$1++) {
			var touch = touches[i$1];
			var pos = clientToLocal(root, touch, {});
			trackItem.points.push([pos.zrX, pos.zrY]);
			trackItem.touches.push(touch);
		}
		this._track.push(trackItem);
	};
	GestureMgr$1.prototype._recognize = function(event) {
		for (var eventName in recognizers) if (recognizers.hasOwnProperty(eventName)) {
			var gestureInfo = recognizers[eventName](this._track, event);
			if (gestureInfo) return gestureInfo;
		}
	};
	return GestureMgr$1;
}();
function dist(pointPair) {
	var dx = pointPair[1][0] - pointPair[0][0];
	var dy = pointPair[1][1] - pointPair[0][1];
	return Math.sqrt(dx * dx + dy * dy);
}
function center$1(pointPair) {
	return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
}
var recognizers = { pinch: function(tracks, event) {
	var trackLen = tracks.length;
	if (!trackLen) return;
	var pinchEnd = (tracks[trackLen - 1] || {}).points;
	var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
	if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
		var pinchScale = dist(pinchEnd) / dist(pinchPre);
		!isFinite(pinchScale) && (pinchScale = 1);
		event.pinchScale = pinchScale;
		var pinchCenter = center$1(pinchEnd);
		event.pinchX = pinchCenter[0];
		event.pinchY = pinchCenter[1];
		return {
			type: "pinch",
			target: tracks[0].target,
			event
		};
	}
} };

//#endregion
//#region node_modules/zrender/lib/core/matrix.js
var matrix_exports = /* @__PURE__ */ __export({
	clone: () => clone$4,
	copy: () => copy,
	create: () => create$2,
	identity: () => identity,
	invert: () => invert,
	mul: () => mul,
	rotate: () => rotate,
	scale: () => scale$2,
	translate: () => translate
});
function create$2() {
	return [
		1,
		0,
		0,
		1,
		0,
		0
	];
}
function identity(out$1) {
	out$1[0] = 1;
	out$1[1] = 0;
	out$1[2] = 0;
	out$1[3] = 1;
	out$1[4] = 0;
	out$1[5] = 0;
	return out$1;
}
function copy(out$1, m$1) {
	out$1[0] = m$1[0];
	out$1[1] = m$1[1];
	out$1[2] = m$1[2];
	out$1[3] = m$1[3];
	out$1[4] = m$1[4];
	out$1[5] = m$1[5];
	return out$1;
}
function mul(out$1, m1, m2) {
	var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	out$1[0] = out0;
	out$1[1] = out1;
	out$1[2] = out2;
	out$1[3] = out3;
	out$1[4] = out4;
	out$1[5] = out5;
	return out$1;
}
function translate(out$1, a, v) {
	out$1[0] = a[0];
	out$1[1] = a[1];
	out$1[2] = a[2];
	out$1[3] = a[3];
	out$1[4] = a[4] + v[0];
	out$1[5] = a[5] + v[1];
	return out$1;
}
function rotate(out$1, a, rad, pivot) {
	if (pivot === void 0) pivot = [0, 0];
	var aa = a[0];
	var ac = a[2];
	var atx = a[4];
	var ab = a[1];
	var ad = a[3];
	var aty = a[5];
	var st = Math.sin(rad);
	var ct = Math.cos(rad);
	out$1[0] = aa * ct + ab * st;
	out$1[1] = -aa * st + ab * ct;
	out$1[2] = ac * ct + ad * st;
	out$1[3] = -ac * st + ct * ad;
	out$1[4] = ct * (atx - pivot[0]) + st * (aty - pivot[1]) + pivot[0];
	out$1[5] = ct * (aty - pivot[1]) - st * (atx - pivot[0]) + pivot[1];
	return out$1;
}
function scale$2(out$1, a, v) {
	var vx = v[0];
	var vy = v[1];
	out$1[0] = a[0] * vx;
	out$1[1] = a[1] * vy;
	out$1[2] = a[2] * vx;
	out$1[3] = a[3] * vy;
	out$1[4] = a[4] * vx;
	out$1[5] = a[5] * vy;
	return out$1;
}
function invert(out$1, a) {
	var aa = a[0];
	var ac = a[2];
	var atx = a[4];
	var ab = a[1];
	var ad = a[3];
	var aty = a[5];
	var det = aa * ad - ab * ac;
	if (!det) return null;
	det = 1 / det;
	out$1[0] = ad * det;
	out$1[1] = -ab * det;
	out$1[2] = -ac * det;
	out$1[3] = aa * det;
	out$1[4] = (ac * aty - ad * atx) * det;
	out$1[5] = (ab * atx - aa * aty) * det;
	return out$1;
}
function clone$4(a) {
	var b = create$2();
	copy(b, a);
	return b;
}

//#endregion
//#region node_modules/zrender/lib/core/Point.js
var Point = function() {
	function Point$1(x, y) {
		this.x = x || 0;
		this.y = y || 0;
	}
	Point$1.prototype.copy = function(other) {
		this.x = other.x;
		this.y = other.y;
		return this;
	};
	Point$1.prototype.clone = function() {
		return new Point$1(this.x, this.y);
	};
	Point$1.prototype.set = function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	};
	Point$1.prototype.equal = function(other) {
		return other.x === this.x && other.y === this.y;
	};
	Point$1.prototype.add = function(other) {
		this.x += other.x;
		this.y += other.y;
		return this;
	};
	Point$1.prototype.scale = function(scalar) {
		this.x *= scalar;
		this.y *= scalar;
	};
	Point$1.prototype.scaleAndAdd = function(other, scalar) {
		this.x += other.x * scalar;
		this.y += other.y * scalar;
	};
	Point$1.prototype.sub = function(other) {
		this.x -= other.x;
		this.y -= other.y;
		return this;
	};
	Point$1.prototype.dot = function(other) {
		return this.x * other.x + this.y * other.y;
	};
	Point$1.prototype.len = function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	};
	Point$1.prototype.lenSquare = function() {
		return this.x * this.x + this.y * this.y;
	};
	Point$1.prototype.normalize = function() {
		var len$1 = this.len();
		this.x /= len$1;
		this.y /= len$1;
		return this;
	};
	Point$1.prototype.distance = function(other) {
		var dx = this.x - other.x;
		var dy = this.y - other.y;
		return Math.sqrt(dx * dx + dy * dy);
	};
	Point$1.prototype.distanceSquare = function(other) {
		var dx = this.x - other.x;
		var dy = this.y - other.y;
		return dx * dx + dy * dy;
	};
	Point$1.prototype.negate = function() {
		this.x = -this.x;
		this.y = -this.y;
		return this;
	};
	Point$1.prototype.transform = function(m$1) {
		if (!m$1) return;
		var x = this.x;
		var y = this.y;
		this.x = m$1[0] * x + m$1[2] * y + m$1[4];
		this.y = m$1[1] * x + m$1[3] * y + m$1[5];
		return this;
	};
	Point$1.prototype.toArray = function(out$1) {
		out$1[0] = this.x;
		out$1[1] = this.y;
		return out$1;
	};
	Point$1.prototype.fromArray = function(input) {
		this.x = input[0];
		this.y = input[1];
	};
	Point$1.set = function(p, x, y) {
		p.x = x;
		p.y = y;
	};
	Point$1.copy = function(p, p2) {
		p.x = p2.x;
		p.y = p2.y;
	};
	Point$1.len = function(p) {
		return Math.sqrt(p.x * p.x + p.y * p.y);
	};
	Point$1.lenSquare = function(p) {
		return p.x * p.x + p.y * p.y;
	};
	Point$1.dot = function(p0, p1) {
		return p0.x * p1.x + p0.y * p1.y;
	};
	Point$1.add = function(out$1, p0, p1) {
		out$1.x = p0.x + p1.x;
		out$1.y = p0.y + p1.y;
	};
	Point$1.sub = function(out$1, p0, p1) {
		out$1.x = p0.x - p1.x;
		out$1.y = p0.y - p1.y;
	};
	Point$1.scale = function(out$1, p0, scalar) {
		out$1.x = p0.x * scalar;
		out$1.y = p0.y * scalar;
	};
	Point$1.scaleAndAdd = function(out$1, p0, p1, scalar) {
		out$1.x = p0.x + p1.x * scalar;
		out$1.y = p0.y + p1.y * scalar;
	};
	Point$1.lerp = function(out$1, p0, p1, t) {
		var onet = 1 - t;
		out$1.x = onet * p0.x + t * p1.x;
		out$1.y = onet * p0.y + t * p1.y;
	};
	return Point$1;
}();
var Point_default = Point;

//#endregion
//#region node_modules/zrender/lib/core/BoundingRect.js
var mathMin$11 = Math.min;
var mathMax$11 = Math.max;
var mathAbs$5 = Math.abs;
var XY$3 = ["x", "y"];
var WH$3 = ["width", "height"];
var lt = new Point_default();
var rb = new Point_default();
var lb = new Point_default();
var rt = new Point_default();
var _intersectCtx$1 = createIntersectContext();
var _minTv$1 = _intersectCtx$1.minTv;
var _maxTv$1 = _intersectCtx$1.maxTv;
var _lenMinMax = [0, 0];
var BoundingRect = function() {
	function BoundingRect$1(x, y, width, height) {
		BoundingRect$1.set(this, x, y, width, height);
	}
	BoundingRect$1.set = function(target, x, y, width, height) {
		if (width < 0) {
			x = x + width;
			width = -width;
		}
		if (height < 0) {
			y = y + height;
			height = -height;
		}
		target.x = x;
		target.y = y;
		target.width = width;
		target.height = height;
		return target;
	};
	BoundingRect$1.prototype.union = function(other) {
		var x = mathMin$11(other.x, this.x);
		var y = mathMin$11(other.y, this.y);
		if (isFinite(this.x) && isFinite(this.width)) this.width = mathMax$11(other.x + other.width, this.x + this.width) - x;
		else this.width = other.width;
		if (isFinite(this.y) && isFinite(this.height)) this.height = mathMax$11(other.y + other.height, this.y + this.height) - y;
		else this.height = other.height;
		this.x = x;
		this.y = y;
	};
	BoundingRect$1.prototype.applyTransform = function(m$1) {
		BoundingRect$1.applyTransform(this, this, m$1);
	};
	BoundingRect$1.prototype.calculateTransform = function(b) {
		var a = this;
		var sx = b.width / a.width;
		var sy = b.height / a.height;
		var m$1 = create$2();
		translate(m$1, m$1, [-a.x, -a.y]);
		scale$2(m$1, m$1, [sx, sy]);
		translate(m$1, m$1, [b.x, b.y]);
		return m$1;
	};
	BoundingRect$1.prototype.intersect = function(b, mtv, opt) {
		return BoundingRect$1.intersect(this, b, mtv, opt);
	};
	BoundingRect$1.intersect = function(a, b, mtv, opt) {
		if (mtv) Point_default.set(mtv, 0, 0);
		var outIntersectRect = opt && opt.outIntersectRect || null;
		var clamp$1 = opt && opt.clamp;
		if (outIntersectRect) outIntersectRect.x = outIntersectRect.y = outIntersectRect.width = outIntersectRect.height = NaN;
		if (!a || !b) return false;
		if (!(a instanceof BoundingRect$1)) a = BoundingRect$1.set(_tmpIntersectA, a.x, a.y, a.width, a.height);
		if (!(b instanceof BoundingRect$1)) b = BoundingRect$1.set(_tmpIntersectB, b.x, b.y, b.width, b.height);
		var useMTV = !!mtv;
		_intersectCtx$1.reset(opt, useMTV);
		var touchThreshold = _intersectCtx$1.touchThreshold;
		var ax0 = a.x + touchThreshold;
		var ax1 = a.x + a.width - touchThreshold;
		var ay0 = a.y + touchThreshold;
		var ay1 = a.y + a.height - touchThreshold;
		var bx0 = b.x + touchThreshold;
		var bx1 = b.x + b.width - touchThreshold;
		var by0 = b.y + touchThreshold;
		var by1 = b.y + b.height - touchThreshold;
		if (ax0 > ax1 || ay0 > ay1 || bx0 > bx1 || by0 > by1) return false;
		var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
		if (useMTV || outIntersectRect) {
			_lenMinMax[0] = Infinity;
			_lenMinMax[1] = 0;
			intersectOneDim(ax0, ax1, bx0, bx1, 0, useMTV, outIntersectRect, clamp$1);
			intersectOneDim(ay0, ay1, by0, by1, 1, useMTV, outIntersectRect, clamp$1);
			if (useMTV) Point_default.copy(mtv, overlap ? _intersectCtx$1.useDir ? _intersectCtx$1.dirMinTv : _minTv$1 : _maxTv$1);
		}
		return overlap;
	};
	BoundingRect$1.contain = function(rect, x, y) {
		return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
	};
	BoundingRect$1.prototype.contain = function(x, y) {
		return BoundingRect$1.contain(this, x, y);
	};
	BoundingRect$1.prototype.clone = function() {
		return new BoundingRect$1(this.x, this.y, this.width, this.height);
	};
	BoundingRect$1.prototype.copy = function(other) {
		BoundingRect$1.copy(this, other);
	};
	BoundingRect$1.prototype.plain = function() {
		return {
			x: this.x,
			y: this.y,
			width: this.width,
			height: this.height
		};
	};
	BoundingRect$1.prototype.isFinite = function() {
		return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
	};
	BoundingRect$1.prototype.isZero = function() {
		return this.width === 0 || this.height === 0;
	};
	BoundingRect$1.create = function(rect) {
		return new BoundingRect$1(rect.x, rect.y, rect.width, rect.height);
	};
	BoundingRect$1.copy = function(target, source) {
		target.x = source.x;
		target.y = source.y;
		target.width = source.width;
		target.height = source.height;
		return target;
	};
	BoundingRect$1.applyTransform = function(target, source, m$1) {
		if (!m$1) {
			if (target !== source) BoundingRect$1.copy(target, source);
			return;
		}
		if (m$1[1] < 1e-5 && m$1[1] > -1e-5 && m$1[2] < 1e-5 && m$1[2] > -1e-5) {
			var sx = m$1[0];
			var sy = m$1[3];
			var tx = m$1[4];
			var ty = m$1[5];
			target.x = source.x * sx + tx;
			target.y = source.y * sy + ty;
			target.width = source.width * sx;
			target.height = source.height * sy;
			if (target.width < 0) {
				target.x += target.width;
				target.width = -target.width;
			}
			if (target.height < 0) {
				target.y += target.height;
				target.height = -target.height;
			}
			return;
		}
		lt.x = lb.x = source.x;
		lt.y = rt.y = source.y;
		rb.x = rt.x = source.x + source.width;
		rb.y = lb.y = source.y + source.height;
		lt.transform(m$1);
		rt.transform(m$1);
		rb.transform(m$1);
		lb.transform(m$1);
		target.x = mathMin$11(lt.x, rb.x, lb.x, rt.x);
		target.y = mathMin$11(lt.y, rb.y, lb.y, rt.y);
		var maxX = mathMax$11(lt.x, rb.x, lb.x, rt.x);
		var maxY = mathMax$11(lt.y, rb.y, lb.y, rt.y);
		target.width = maxX - target.x;
		target.height = maxY - target.y;
	};
	return BoundingRect$1;
}();
var _tmpIntersectA = new BoundingRect(0, 0, 0, 0);
var _tmpIntersectB = new BoundingRect(0, 0, 0, 0);
function intersectOneDim(a0, a1, b0, b1, updateDimIdx, useMTV, outIntersectRect, clamp$1) {
	var d0 = mathAbs$5(a1 - b0);
	var d1 = mathAbs$5(b1 - a0);
	var d01min = mathMin$11(d0, d1);
	var updateDim = XY$3[updateDimIdx];
	var zeroDim = XY$3[1 - updateDimIdx];
	var wh = WH$3[updateDimIdx];
	if (a1 < b0 || b1 < a0) if (d0 < d1) {
		if (useMTV) _maxTv$1[updateDim] = -d0;
		if (clamp$1) {
			outIntersectRect[updateDim] = a1;
			outIntersectRect[wh] = 0;
		}
	} else {
		if (useMTV) _maxTv$1[updateDim] = d1;
		if (clamp$1) {
			outIntersectRect[updateDim] = a0;
			outIntersectRect[wh] = 0;
		}
	}
	else {
		if (outIntersectRect) {
			outIntersectRect[updateDim] = mathMax$11(a0, b0);
			outIntersectRect[wh] = mathMin$11(a1, b1) - outIntersectRect[updateDim];
		}
		if (useMTV) {
			if (d01min < _lenMinMax[0] || _intersectCtx$1.useDir) {
				_lenMinMax[0] = mathMin$11(d01min, _lenMinMax[0]);
				if (d0 < d1 || !_intersectCtx$1.bidirectional) {
					_minTv$1[updateDim] = d0;
					_minTv$1[zeroDim] = 0;
					if (_intersectCtx$1.useDir) _intersectCtx$1.calcDirMTV();
				}
				if (d0 >= d1 || !_intersectCtx$1.bidirectional) {
					_minTv$1[updateDim] = -d1;
					_minTv$1[zeroDim] = 0;
					if (_intersectCtx$1.useDir) _intersectCtx$1.calcDirMTV();
				}
			}
		}
	}
}
function createIntersectContext() {
	var _direction = 0;
	var _dirCheckVec = new Point_default();
	var _dirTmp = new Point_default();
	var _ctx = {
		minTv: new Point_default(),
		maxTv: new Point_default(),
		useDir: false,
		dirMinTv: new Point_default(),
		touchThreshold: 0,
		bidirectional: true,
		negativeSize: false,
		reset: function(opt, useMTV) {
			_ctx.touchThreshold = 0;
			if (opt && opt.touchThreshold != null) _ctx.touchThreshold = mathMax$11(0, opt.touchThreshold);
			_ctx.negativeSize = false;
			if (!useMTV) return;
			_ctx.minTv.set(Infinity, Infinity);
			_ctx.maxTv.set(0, 0);
			_ctx.useDir = false;
			if (opt && opt.direction != null) {
				_ctx.useDir = true;
				_ctx.dirMinTv.copy(_ctx.minTv);
				_dirTmp.copy(_ctx.minTv);
				_direction = opt.direction;
				_ctx.bidirectional = opt.bidirectional == null || !!opt.bidirectional;
				if (!_ctx.bidirectional) _dirCheckVec.set(Math.cos(_direction), Math.sin(_direction));
			}
		},
		calcDirMTV: function() {
			var minTv = _ctx.minTv;
			var dirMinTv = _ctx.dirMinTv;
			var squareMag = minTv.y * minTv.y + minTv.x * minTv.x;
			var dirSin = Math.sin(_direction);
			var dirCos = Math.cos(_direction);
			var dotProd = dirSin * minTv.y + dirCos * minTv.x;
			if (nearZero$1(dotProd)) {
				if (nearZero$1(minTv.x) && nearZero$1(minTv.y)) dirMinTv.set(0, 0);
				return;
			}
			_dirTmp.x = squareMag * dirCos / dotProd;
			_dirTmp.y = squareMag * dirSin / dotProd;
			if (nearZero$1(_dirTmp.x) && nearZero$1(_dirTmp.y)) {
				dirMinTv.set(0, 0);
				return;
			}
			if ((_ctx.bidirectional || _dirCheckVec.dot(_dirTmp) > 0) && _dirTmp.len() < dirMinTv.len()) dirMinTv.copy(_dirTmp);
		}
	};
	function nearZero$1(val) {
		return mathAbs$5(val) < 1e-10;
	}
	return _ctx;
}
var BoundingRect_default = BoundingRect;

//#endregion
//#region node_modules/zrender/lib/Handler.js
var SILENT = "silent";
function makeEventPacket(eveType, targetInfo, event) {
	return {
		type: eveType,
		event,
		target: targetInfo.target,
		topTarget: targetInfo.topTarget,
		cancelBubble: false,
		offsetX: event.zrX,
		offsetY: event.zrY,
		gestureEvent: event.gestureEvent,
		pinchX: event.pinchX,
		pinchY: event.pinchY,
		pinchScale: event.pinchScale,
		wheelDelta: event.zrDelta,
		zrByTouch: event.zrByTouch,
		which: event.which,
		stop: stopEvent
	};
}
function stopEvent() {
	stop(this.event);
}
var EmptyProxy = function(_super) {
	__extends$1(EmptyProxy$1, _super);
	function EmptyProxy$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.handler = null;
		return _this;
	}
	EmptyProxy$1.prototype.dispose = function() {};
	EmptyProxy$1.prototype.setCursor = function() {};
	return EmptyProxy$1;
}(Eventful_default);
var HoveredResult = function() {
	function HoveredResult$1(x, y) {
		this.x = x;
		this.y = y;
	}
	return HoveredResult$1;
}();
var handlerNames = [
	"click",
	"dblclick",
	"mousewheel",
	"mouseout",
	"mouseup",
	"mousedown",
	"mousemove",
	"contextmenu"
];
var tmpRect$1 = new BoundingRect_default(0, 0, 0, 0);
var Handler = function(_super) {
	__extends$1(Handler$1, _super);
	function Handler$1(storage$1, painter, proxy, painterRoot, pointerSize) {
		var _this = _super.call(this) || this;
		_this._hovered = new HoveredResult(0, 0);
		_this.storage = storage$1;
		_this.painter = painter;
		_this.painterRoot = painterRoot;
		_this._pointerSize = pointerSize;
		proxy = proxy || new EmptyProxy();
		_this.proxy = null;
		_this.setHandlerProxy(proxy);
		_this._draggingMgr = new Draggable_default(_this);
		return _this;
	}
	Handler$1.prototype.setHandlerProxy = function(proxy) {
		if (this.proxy) this.proxy.dispose();
		if (proxy) {
			each(handlerNames, function(name) {
				proxy.on && proxy.on(name, this[name], this);
			}, this);
			proxy.handler = this;
		}
		this.proxy = proxy;
	};
	Handler$1.prototype.mousemove = function(event) {
		var x = event.zrX;
		var y = event.zrY;
		var isOutside = isOutsideBoundary(this, x, y);
		var lastHovered = this._hovered;
		var lastHoveredTarget = lastHovered.target;
		if (lastHoveredTarget && !lastHoveredTarget.__zr) {
			lastHovered = this.findHover(lastHovered.x, lastHovered.y);
			lastHoveredTarget = lastHovered.target;
		}
		var hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y);
		var hoveredTarget = hovered.target;
		var proxy = this.proxy;
		proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
		if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) this.dispatchToElement(lastHovered, "mouseout", event);
		this.dispatchToElement(hovered, "mousemove", event);
		if (hoveredTarget && hoveredTarget !== lastHoveredTarget) this.dispatchToElement(hovered, "mouseover", event);
	};
	Handler$1.prototype.mouseout = function(event) {
		var eventControl = event.zrEventControl;
		if (eventControl !== "only_globalout") this.dispatchToElement(this._hovered, "mouseout", event);
		if (eventControl !== "no_globalout") this.trigger("globalout", {
			type: "globalout",
			event
		});
	};
	Handler$1.prototype.resize = function() {
		this._hovered = new HoveredResult(0, 0);
	};
	Handler$1.prototype.dispatch = function(eventName, eventArgs) {
		var handler = this[eventName];
		handler && handler.call(this, eventArgs);
	};
	Handler$1.prototype.dispose = function() {
		this.proxy.dispose();
		this.storage = null;
		this.proxy = null;
		this.painter = null;
	};
	Handler$1.prototype.setCursorStyle = function(cursorStyle) {
		var proxy = this.proxy;
		proxy.setCursor && proxy.setCursor(cursorStyle);
	};
	Handler$1.prototype.dispatchToElement = function(targetInfo, eventName, event) {
		targetInfo = targetInfo || {};
		var el = targetInfo.target;
		if (el && el.silent) return;
		var eventKey = "on" + eventName;
		var eventPacket = makeEventPacket(eventName, targetInfo, event);
		while (el) {
			el[eventKey] && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
			el.trigger(eventName, eventPacket);
			el = el.__hostTarget ? el.__hostTarget : el.parent;
			if (eventPacket.cancelBubble) break;
		}
		if (!eventPacket.cancelBubble) {
			this.trigger(eventName, eventPacket);
			if (this.painter && this.painter.eachOtherLayer) this.painter.eachOtherLayer(function(layer) {
				if (typeof layer[eventKey] === "function") layer[eventKey].call(layer, eventPacket);
				if (layer.trigger) layer.trigger(eventName, eventPacket);
			});
		}
	};
	Handler$1.prototype.findHover = function(x, y, exclude) {
		var list = this.storage.getDisplayList();
		var out$1 = new HoveredResult(x, y);
		setHoverTarget(list, out$1, x, y, exclude);
		if (this._pointerSize && !out$1.target) {
			var candidates = [];
			var pointerSize = this._pointerSize;
			var targetSizeHalf = pointerSize / 2;
			var pointerRect = new BoundingRect_default(x - targetSizeHalf, y - targetSizeHalf, pointerSize, pointerSize);
			for (var i$1 = list.length - 1; i$1 >= 0; i$1--) {
				var el = list[i$1];
				if (el !== exclude && !el.ignore && !el.ignoreCoarsePointer && (!el.parent || !el.parent.ignoreCoarsePointer)) {
					tmpRect$1.copy(el.getBoundingRect());
					if (el.transform) tmpRect$1.applyTransform(el.transform);
					if (tmpRect$1.intersect(pointerRect)) candidates.push(el);
				}
			}
			if (candidates.length) {
				var rStep = 4;
				var thetaStep = Math.PI / 12;
				var PI2$9 = Math.PI * 2;
				for (var r = 0; r < targetSizeHalf; r += rStep) for (var theta = 0; theta < PI2$9; theta += thetaStep) {
					setHoverTarget(candidates, out$1, x + r * Math.cos(theta), y + r * Math.sin(theta), exclude);
					if (out$1.target) return out$1;
				}
			}
		}
		return out$1;
	};
	Handler$1.prototype.processGesture = function(event, stage) {
		if (!this._gestureMgr) this._gestureMgr = new GestureMgr();
		var gestureMgr = this._gestureMgr;
		stage === "start" && gestureMgr.clear();
		var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
		stage === "end" && gestureMgr.clear();
		if (gestureInfo) {
			var type = gestureInfo.type;
			event.gestureEvent = type;
			var res = new HoveredResult();
			res.target = gestureInfo.target;
			this.dispatchToElement(res, type, gestureInfo.event);
		}
	};
	return Handler$1;
}(Eventful_default);
each([
	"click",
	"mousedown",
	"mouseup",
	"mousewheel",
	"dblclick",
	"contextmenu"
], function(name) {
	Handler.prototype[name] = function(event) {
		var x = event.zrX;
		var y = event.zrY;
		var isOutside = isOutsideBoundary(this, x, y);
		var hovered;
		var hoveredTarget;
		if (name !== "mouseup" || !isOutside) {
			hovered = this.findHover(x, y);
			hoveredTarget = hovered.target;
		}
		if (name === "mousedown") {
			this._downEl = hoveredTarget;
			this._downPoint = [event.zrX, event.zrY];
			this._upEl = hoveredTarget;
		} else if (name === "mouseup") this._upEl = hoveredTarget;
		else if (name === "click") {
			if (this._downEl !== this._upEl || !this._downPoint || dist$1(this._downPoint, [event.zrX, event.zrY]) > 4) return;
			this._downPoint = null;
		}
		this.dispatchToElement(hovered, name, event);
	};
});
function isHover(displayable, x, y) {
	if (displayable[displayable.rectHover ? "rectContain" : "contain"](x, y)) {
		var el = displayable;
		var isSilent = void 0;
		var ignoreClip = false;
		while (el) {
			if (el.ignoreClip) ignoreClip = true;
			if (!ignoreClip) {
				var clipPath = el.getClipPath();
				if (clipPath && !clipPath.contain(x, y)) return false;
			}
			if (el.silent) isSilent = true;
			var hostEl = el.__hostTarget;
			el = hostEl ? el.ignoreHostSilent ? null : hostEl : el.parent;
		}
		return isSilent ? SILENT : true;
	}
	return false;
}
function setHoverTarget(list, out$1, x, y, exclude) {
	for (var i$1 = list.length - 1; i$1 >= 0; i$1--) {
		var el = list[i$1];
		var hoverCheckResult = void 0;
		if (el !== exclude && !el.ignore && (hoverCheckResult = isHover(el, x, y))) {
			!out$1.topTarget && (out$1.topTarget = el);
			if (hoverCheckResult !== SILENT) {
				out$1.target = el;
				break;
			}
		}
	}
}
function isOutsideBoundary(handlerInstance, x, y) {
	var painter = handlerInstance.painter;
	return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
}
var Handler_default = Handler;

//#endregion
//#region node_modules/zrender/lib/core/timsort.js
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
function minRunLength(n) {
	var r = 0;
	while (n >= DEFAULT_MIN_MERGE) {
		r |= n & 1;
		n >>= 1;
	}
	return n + r;
}
function makeAscendingRun(array, lo, hi, compare$1) {
	var runHi = lo + 1;
	if (runHi === hi) return 1;
	if (compare$1(array[runHi++], array[lo]) < 0) {
		while (runHi < hi && compare$1(array[runHi], array[runHi - 1]) < 0) runHi++;
		reverseRun(array, lo, runHi);
	} else while (runHi < hi && compare$1(array[runHi], array[runHi - 1]) >= 0) runHi++;
	return runHi - lo;
}
function reverseRun(array, lo, hi) {
	hi--;
	while (lo < hi) {
		var t = array[lo];
		array[lo++] = array[hi];
		array[hi--] = t;
	}
}
function binaryInsertionSort(array, lo, hi, start$1, compare$1) {
	if (start$1 === lo) start$1++;
	for (; start$1 < hi; start$1++) {
		var pivot = array[start$1];
		var left = lo;
		var right = start$1;
		var mid;
		while (left < right) {
			mid = left + right >>> 1;
			if (compare$1(pivot, array[mid]) < 0) right = mid;
			else left = mid + 1;
		}
		var n = start$1 - left;
		switch (n) {
			case 3: array[left + 3] = array[left + 2];
			case 2: array[left + 2] = array[left + 1];
			case 1:
				array[left + 1] = array[left];
				break;
			default: while (n > 0) {
				array[left + n] = array[left + n - 1];
				n--;
			}
		}
		array[left] = pivot;
	}
}
function gallopLeft(value, array, start$1, length$1, hint, compare$1) {
	var lastOffset = 0;
	var maxOffset = 0;
	var offset = 1;
	if (compare$1(value, array[start$1 + hint]) > 0) {
		maxOffset = length$1 - hint;
		while (offset < maxOffset && compare$1(value, array[start$1 + hint + offset]) > 0) {
			lastOffset = offset;
			offset = (offset << 1) + 1;
			if (offset <= 0) offset = maxOffset;
		}
		if (offset > maxOffset) offset = maxOffset;
		lastOffset += hint;
		offset += hint;
	} else {
		maxOffset = hint + 1;
		while (offset < maxOffset && compare$1(value, array[start$1 + hint - offset]) <= 0) {
			lastOffset = offset;
			offset = (offset << 1) + 1;
			if (offset <= 0) offset = maxOffset;
		}
		if (offset > maxOffset) offset = maxOffset;
		var tmp = lastOffset;
		lastOffset = hint - offset;
		offset = hint - tmp;
	}
	lastOffset++;
	while (lastOffset < offset) {
		var m$1 = lastOffset + (offset - lastOffset >>> 1);
		if (compare$1(value, array[start$1 + m$1]) > 0) lastOffset = m$1 + 1;
		else offset = m$1;
	}
	return offset;
}
function gallopRight(value, array, start$1, length$1, hint, compare$1) {
	var lastOffset = 0;
	var maxOffset = 0;
	var offset = 1;
	if (compare$1(value, array[start$1 + hint]) < 0) {
		maxOffset = hint + 1;
		while (offset < maxOffset && compare$1(value, array[start$1 + hint - offset]) < 0) {
			lastOffset = offset;
			offset = (offset << 1) + 1;
			if (offset <= 0) offset = maxOffset;
		}
		if (offset > maxOffset) offset = maxOffset;
		var tmp = lastOffset;
		lastOffset = hint - offset;
		offset = hint - tmp;
	} else {
		maxOffset = length$1 - hint;
		while (offset < maxOffset && compare$1(value, array[start$1 + hint + offset]) >= 0) {
			lastOffset = offset;
			offset = (offset << 1) + 1;
			if (offset <= 0) offset = maxOffset;
		}
		if (offset > maxOffset) offset = maxOffset;
		lastOffset += hint;
		offset += hint;
	}
	lastOffset++;
	while (lastOffset < offset) {
		var m$1 = lastOffset + (offset - lastOffset >>> 1);
		if (compare$1(value, array[start$1 + m$1]) < 0) offset = m$1;
		else lastOffset = m$1 + 1;
	}
	return offset;
}
function TimSort(array, compare$1) {
	var minGallop = DEFAULT_MIN_GALLOPING;
	var runStart;
	var runLength;
	var stackSize = 0;
	var tmp = [];
	runStart = [];
	runLength = [];
	function pushRun(_runStart, _runLength) {
		runStart[stackSize] = _runStart;
		runLength[stackSize] = _runLength;
		stackSize += 1;
	}
	function mergeRuns() {
		while (stackSize > 1) {
			var n = stackSize - 2;
			if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
				if (runLength[n - 1] < runLength[n + 1]) n--;
			} else if (runLength[n] > runLength[n + 1]) break;
			mergeAt(n);
		}
	}
	function forceMergeRuns() {
		while (stackSize > 1) {
			var n = stackSize - 2;
			if (n > 0 && runLength[n - 1] < runLength[n + 1]) n--;
			mergeAt(n);
		}
	}
	function mergeAt(i$1) {
		var start1 = runStart[i$1];
		var length1 = runLength[i$1];
		var start2 = runStart[i$1 + 1];
		var length2 = runLength[i$1 + 1];
		runLength[i$1] = length1 + length2;
		if (i$1 === stackSize - 3) {
			runStart[i$1 + 1] = runStart[i$1 + 2];
			runLength[i$1 + 1] = runLength[i$1 + 2];
		}
		stackSize--;
		var k$1 = gallopRight(array[start2], array, start1, length1, 0, compare$1);
		start1 += k$1;
		length1 -= k$1;
		if (length1 === 0) return;
		length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare$1);
		if (length2 === 0) return;
		if (length1 <= length2) mergeLow(start1, length1, start2, length2);
		else mergeHigh(start1, length1, start2, length2);
	}
	function mergeLow(start1, length1, start2, length2) {
		var i$1 = 0;
		for (i$1 = 0; i$1 < length1; i$1++) tmp[i$1] = array[start1 + i$1];
		var cursor1 = 0;
		var cursor2 = start2;
		var dest = start1;
		array[dest++] = array[cursor2++];
		if (--length2 === 0) {
			for (i$1 = 0; i$1 < length1; i$1++) array[dest + i$1] = tmp[cursor1 + i$1];
			return;
		}
		if (length1 === 1) {
			for (i$1 = 0; i$1 < length2; i$1++) array[dest + i$1] = array[cursor2 + i$1];
			array[dest + length2] = tmp[cursor1];
			return;
		}
		var _minGallop = minGallop;
		var count1;
		var count2;
		var exit;
		while (1) {
			count1 = 0;
			count2 = 0;
			exit = false;
			do
				if (compare$1(array[cursor2], tmp[cursor1]) < 0) {
					array[dest++] = array[cursor2++];
					count2++;
					count1 = 0;
					if (--length2 === 0) {
						exit = true;
						break;
					}
				} else {
					array[dest++] = tmp[cursor1++];
					count1++;
					count2 = 0;
					if (--length1 === 1) {
						exit = true;
						break;
					}
				}
			while ((count1 | count2) < _minGallop);
			if (exit) break;
			do {
				count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare$1);
				if (count1 !== 0) {
					for (i$1 = 0; i$1 < count1; i$1++) array[dest + i$1] = tmp[cursor1 + i$1];
					dest += count1;
					cursor1 += count1;
					length1 -= count1;
					if (length1 <= 1) {
						exit = true;
						break;
					}
				}
				array[dest++] = array[cursor2++];
				if (--length2 === 0) {
					exit = true;
					break;
				}
				count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare$1);
				if (count2 !== 0) {
					for (i$1 = 0; i$1 < count2; i$1++) array[dest + i$1] = array[cursor2 + i$1];
					dest += count2;
					cursor2 += count2;
					length2 -= count2;
					if (length2 === 0) {
						exit = true;
						break;
					}
				}
				array[dest++] = tmp[cursor1++];
				if (--length1 === 1) {
					exit = true;
					break;
				}
				_minGallop--;
			} while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
			if (exit) break;
			if (_minGallop < 0) _minGallop = 0;
			_minGallop += 2;
		}
		minGallop = _minGallop;
		minGallop < 1 && (minGallop = 1);
		if (length1 === 1) {
			for (i$1 = 0; i$1 < length2; i$1++) array[dest + i$1] = array[cursor2 + i$1];
			array[dest + length2] = tmp[cursor1];
		} else if (length1 === 0) throw new Error();
		else for (i$1 = 0; i$1 < length1; i$1++) array[dest + i$1] = tmp[cursor1 + i$1];
	}
	function mergeHigh(start1, length1, start2, length2) {
		var i$1 = 0;
		for (i$1 = 0; i$1 < length2; i$1++) tmp[i$1] = array[start2 + i$1];
		var cursor1 = start1 + length1 - 1;
		var cursor2 = length2 - 1;
		var dest = start2 + length2 - 1;
		var customCursor = 0;
		var customDest = 0;
		array[dest--] = array[cursor1--];
		if (--length1 === 0) {
			customCursor = dest - (length2 - 1);
			for (i$1 = 0; i$1 < length2; i$1++) array[customCursor + i$1] = tmp[i$1];
			return;
		}
		if (length2 === 1) {
			dest -= length1;
			cursor1 -= length1;
			customDest = dest + 1;
			customCursor = cursor1 + 1;
			for (i$1 = length1 - 1; i$1 >= 0; i$1--) array[customDest + i$1] = array[customCursor + i$1];
			array[dest] = tmp[cursor2];
			return;
		}
		var _minGallop = minGallop;
		while (true) {
			var count1 = 0;
			var count2 = 0;
			var exit = false;
			do
				if (compare$1(tmp[cursor2], array[cursor1]) < 0) {
					array[dest--] = array[cursor1--];
					count1++;
					count2 = 0;
					if (--length1 === 0) {
						exit = true;
						break;
					}
				} else {
					array[dest--] = tmp[cursor2--];
					count2++;
					count1 = 0;
					if (--length2 === 1) {
						exit = true;
						break;
					}
				}
			while ((count1 | count2) < _minGallop);
			if (exit) break;
			do {
				count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare$1);
				if (count1 !== 0) {
					dest -= count1;
					cursor1 -= count1;
					length1 -= count1;
					customDest = dest + 1;
					customCursor = cursor1 + 1;
					for (i$1 = count1 - 1; i$1 >= 0; i$1--) array[customDest + i$1] = array[customCursor + i$1];
					if (length1 === 0) {
						exit = true;
						break;
					}
				}
				array[dest--] = tmp[cursor2--];
				if (--length2 === 1) {
					exit = true;
					break;
				}
				count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare$1);
				if (count2 !== 0) {
					dest -= count2;
					cursor2 -= count2;
					length2 -= count2;
					customDest = dest + 1;
					customCursor = cursor2 + 1;
					for (i$1 = 0; i$1 < count2; i$1++) array[customDest + i$1] = tmp[customCursor + i$1];
					if (length2 <= 1) {
						exit = true;
						break;
					}
				}
				array[dest--] = array[cursor1--];
				if (--length1 === 0) {
					exit = true;
					break;
				}
				_minGallop--;
			} while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
			if (exit) break;
			if (_minGallop < 0) _minGallop = 0;
			_minGallop += 2;
		}
		minGallop = _minGallop;
		if (minGallop < 1) minGallop = 1;
		if (length2 === 1) {
			dest -= length1;
			cursor1 -= length1;
			customDest = dest + 1;
			customCursor = cursor1 + 1;
			for (i$1 = length1 - 1; i$1 >= 0; i$1--) array[customDest + i$1] = array[customCursor + i$1];
			array[dest] = tmp[cursor2];
		} else if (length2 === 0) throw new Error();
		else {
			customCursor = dest - (length2 - 1);
			for (i$1 = 0; i$1 < length2; i$1++) array[customCursor + i$1] = tmp[i$1];
		}
	}
	return {
		mergeRuns,
		forceMergeRuns,
		pushRun
	};
}
function sort$2(array, compare$1, lo, hi) {
	if (!lo) lo = 0;
	if (!hi) hi = array.length;
	var remaining = hi - lo;
	if (remaining < 2) return;
	var runLength = 0;
	if (remaining < DEFAULT_MIN_MERGE) {
		runLength = makeAscendingRun(array, lo, hi, compare$1);
		binaryInsertionSort(array, lo, hi, lo + runLength, compare$1);
		return;
	}
	var ts = TimSort(array, compare$1);
	var minRun = minRunLength(remaining);
	do {
		runLength = makeAscendingRun(array, lo, hi, compare$1);
		if (runLength < minRun) {
			var force = remaining;
			if (force > minRun) force = minRun;
			binaryInsertionSort(array, lo, lo + force, lo + runLength, compare$1);
			runLength = force;
		}
		ts.pushRun(lo, runLength);
		ts.mergeRuns();
		remaining -= runLength;
		lo += runLength;
	} while (remaining !== 0);
	ts.forceMergeRuns();
}

//#endregion
//#region node_modules/zrender/lib/graphic/constants.js
var REDRAW_BIT = 1;
var STYLE_CHANGED_BIT = 2;
var SHAPE_CHANGED_BIT = 4;

//#endregion
//#region node_modules/zrender/lib/Storage.js
var invalidZErrorLogged = false;
function logInvalidZError() {
	if (invalidZErrorLogged) return;
	invalidZErrorLogged = true;
	console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
}
function shapeCompareFunc(a, b) {
	if (a.zlevel === b.zlevel) {
		if (a.z === b.z) return a.z2 - b.z2;
		return a.z - b.z;
	}
	return a.zlevel - b.zlevel;
}
var Storage = function() {
	function Storage$1() {
		this._roots = [];
		this._displayList = [];
		this._displayListLen = 0;
		this.displayableSortFunc = shapeCompareFunc;
	}
	Storage$1.prototype.traverse = function(cb, context) {
		for (var i$1 = 0; i$1 < this._roots.length; i$1++) this._roots[i$1].traverse(cb, context);
	};
	Storage$1.prototype.getDisplayList = function(update, includeIgnore) {
		includeIgnore = includeIgnore || false;
		var displayList = this._displayList;
		if (update || !displayList.length) this.updateDisplayList(includeIgnore);
		return displayList;
	};
	Storage$1.prototype.updateDisplayList = function(includeIgnore) {
		this._displayListLen = 0;
		var roots$1 = this._roots;
		var displayList = this._displayList;
		for (var i$1 = 0, len$1 = roots$1.length; i$1 < len$1; i$1++) this._updateAndAddDisplayable(roots$1[i$1], null, includeIgnore);
		displayList.length = this._displayListLen;
		sort$2(displayList, shapeCompareFunc);
	};
	Storage$1.prototype._updateAndAddDisplayable = function(el, parentClipPaths, includeIgnore) {
		if (el.ignore && !includeIgnore) return;
		el.beforeUpdate();
		el.update();
		el.afterUpdate();
		var userSetClipPath = el.getClipPath();
		var parentHasClipPaths = parentClipPaths && parentClipPaths.length;
		var clipPathIdx = 0;
		var thisClipPaths = el.__clipPaths;
		if (!el.ignoreClip && (parentHasClipPaths || userSetClipPath)) {
			if (!thisClipPaths) thisClipPaths = el.__clipPaths = [];
			if (parentHasClipPaths) for (var idx = 0; idx < parentClipPaths.length; idx++) thisClipPaths[clipPathIdx++] = parentClipPaths[idx];
			var currentClipPath = userSetClipPath;
			var parentClipPath = el;
			while (currentClipPath) {
				currentClipPath.parent = parentClipPath;
				currentClipPath.updateTransform();
				thisClipPaths[clipPathIdx++] = currentClipPath;
				parentClipPath = currentClipPath;
				currentClipPath = currentClipPath.getClipPath();
			}
		}
		if (thisClipPaths) thisClipPaths.length = clipPathIdx;
		if (el.childrenRef) {
			var children = el.childrenRef();
			for (var i$1 = 0; i$1 < children.length; i$1++) {
				var child = children[i$1];
				if (el.__dirty) child.__dirty |= REDRAW_BIT;
				this._updateAndAddDisplayable(child, thisClipPaths, includeIgnore);
			}
			el.__dirty = 0;
		} else {
			var disp = el;
			if (isNaN(disp.z)) {
				logInvalidZError();
				disp.z = 0;
			}
			if (isNaN(disp.z2)) {
				logInvalidZError();
				disp.z2 = 0;
			}
			if (isNaN(disp.zlevel)) {
				logInvalidZError();
				disp.zlevel = 0;
			}
			this._displayList[this._displayListLen++] = disp;
		}
		var decalEl = el.getDecalElement && el.getDecalElement();
		if (decalEl) this._updateAndAddDisplayable(decalEl, thisClipPaths, includeIgnore);
		var textGuide = el.getTextGuideLine();
		if (textGuide) this._updateAndAddDisplayable(textGuide, thisClipPaths, includeIgnore);
		var textEl = el.getTextContent();
		if (textEl) this._updateAndAddDisplayable(textEl, thisClipPaths, includeIgnore);
	};
	Storage$1.prototype.addRoot = function(el) {
		if (el.__zr && el.__zr.storage === this) return;
		this._roots.push(el);
	};
	Storage$1.prototype.delRoot = function(el) {
		if (el instanceof Array) {
			for (var i$1 = 0, l = el.length; i$1 < l; i$1++) this.delRoot(el[i$1]);
			return;
		}
		var idx = indexOf(this._roots, el);
		if (idx >= 0) this._roots.splice(idx, 1);
	};
	Storage$1.prototype.delAllRoots = function() {
		this._roots = [];
		this._displayList = [];
		this._displayListLen = 0;
	};
	Storage$1.prototype.getRoots = function() {
		return this._roots;
	};
	Storage$1.prototype.dispose = function() {
		this._displayList = null;
		this._roots = null;
	};
	return Storage$1;
}();
var Storage_default = Storage;

//#endregion
//#region node_modules/zrender/lib/animation/requestAnimationFrame.js
var requestAnimationFrame = env_default.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
	return setTimeout(func, 16);
};
var requestAnimationFrame_default = requestAnimationFrame;

//#endregion
//#region node_modules/zrender/lib/animation/easing.js
var easingFuncs = {
	linear: function(k$1) {
		return k$1;
	},
	quadraticIn: function(k$1) {
		return k$1 * k$1;
	},
	quadraticOut: function(k$1) {
		return k$1 * (2 - k$1);
	},
	quadraticInOut: function(k$1) {
		if ((k$1 *= 2) < 1) return .5 * k$1 * k$1;
		return -.5 * (--k$1 * (k$1 - 2) - 1);
	},
	cubicIn: function(k$1) {
		return k$1 * k$1 * k$1;
	},
	cubicOut: function(k$1) {
		return --k$1 * k$1 * k$1 + 1;
	},
	cubicInOut: function(k$1) {
		if ((k$1 *= 2) < 1) return .5 * k$1 * k$1 * k$1;
		return .5 * ((k$1 -= 2) * k$1 * k$1 + 2);
	},
	quarticIn: function(k$1) {
		return k$1 * k$1 * k$1 * k$1;
	},
	quarticOut: function(k$1) {
		return 1 - --k$1 * k$1 * k$1 * k$1;
	},
	quarticInOut: function(k$1) {
		if ((k$1 *= 2) < 1) return .5 * k$1 * k$1 * k$1 * k$1;
		return -.5 * ((k$1 -= 2) * k$1 * k$1 * k$1 - 2);
	},
	quinticIn: function(k$1) {
		return k$1 * k$1 * k$1 * k$1 * k$1;
	},
	quinticOut: function(k$1) {
		return --k$1 * k$1 * k$1 * k$1 * k$1 + 1;
	},
	quinticInOut: function(k$1) {
		if ((k$1 *= 2) < 1) return .5 * k$1 * k$1 * k$1 * k$1 * k$1;
		return .5 * ((k$1 -= 2) * k$1 * k$1 * k$1 * k$1 + 2);
	},
	sinusoidalIn: function(k$1) {
		return 1 - Math.cos(k$1 * Math.PI / 2);
	},
	sinusoidalOut: function(k$1) {
		return Math.sin(k$1 * Math.PI / 2);
	},
	sinusoidalInOut: function(k$1) {
		return .5 * (1 - Math.cos(Math.PI * k$1));
	},
	exponentialIn: function(k$1) {
		return k$1 === 0 ? 0 : Math.pow(1024, k$1 - 1);
	},
	exponentialOut: function(k$1) {
		return k$1 === 1 ? 1 : 1 - Math.pow(2, -10 * k$1);
	},
	exponentialInOut: function(k$1) {
		if (k$1 === 0) return 0;
		if (k$1 === 1) return 1;
		if ((k$1 *= 2) < 1) return .5 * Math.pow(1024, k$1 - 1);
		return .5 * (-Math.pow(2, -10 * (k$1 - 1)) + 2);
	},
	circularIn: function(k$1) {
		return 1 - Math.sqrt(1 - k$1 * k$1);
	},
	circularOut: function(k$1) {
		return Math.sqrt(1 - --k$1 * k$1);
	},
	circularInOut: function(k$1) {
		if ((k$1 *= 2) < 1) return -.5 * (Math.sqrt(1 - k$1 * k$1) - 1);
		return .5 * (Math.sqrt(1 - (k$1 -= 2) * k$1) + 1);
	},
	elasticIn: function(k$1) {
		var s;
		var a = .1;
		var p = .4;
		if (k$1 === 0) return 0;
		if (k$1 === 1) return 1;
		if (!a || a < 1) {
			a = 1;
			s = p / 4;
		} else s = p * Math.asin(1 / a) / (2 * Math.PI);
		return -(a * Math.pow(2, 10 * (k$1 -= 1)) * Math.sin((k$1 - s) * (2 * Math.PI) / p));
	},
	elasticOut: function(k$1) {
		var s;
		var a = .1;
		var p = .4;
		if (k$1 === 0) return 0;
		if (k$1 === 1) return 1;
		if (!a || a < 1) {
			a = 1;
			s = p / 4;
		} else s = p * Math.asin(1 / a) / (2 * Math.PI);
		return a * Math.pow(2, -10 * k$1) * Math.sin((k$1 - s) * (2 * Math.PI) / p) + 1;
	},
	elasticInOut: function(k$1) {
		var s;
		var a = .1;
		var p = .4;
		if (k$1 === 0) return 0;
		if (k$1 === 1) return 1;
		if (!a || a < 1) {
			a = 1;
			s = p / 4;
		} else s = p * Math.asin(1 / a) / (2 * Math.PI);
		if ((k$1 *= 2) < 1) return -.5 * (a * Math.pow(2, 10 * (k$1 -= 1)) * Math.sin((k$1 - s) * (2 * Math.PI) / p));
		return a * Math.pow(2, -10 * (k$1 -= 1)) * Math.sin((k$1 - s) * (2 * Math.PI) / p) * .5 + 1;
	},
	backIn: function(k$1) {
		var s = 1.70158;
		return k$1 * k$1 * ((s + 1) * k$1 - s);
	},
	backOut: function(k$1) {
		var s = 1.70158;
		return --k$1 * k$1 * ((s + 1) * k$1 + s) + 1;
	},
	backInOut: function(k$1) {
		var s = 1.70158 * 1.525;
		if ((k$1 *= 2) < 1) return .5 * (k$1 * k$1 * ((s + 1) * k$1 - s));
		return .5 * ((k$1 -= 2) * k$1 * ((s + 1) * k$1 + s) + 2);
	},
	bounceIn: function(k$1) {
		return 1 - easingFuncs.bounceOut(1 - k$1);
	},
	bounceOut: function(k$1) {
		if (k$1 < 1 / 2.75) return 7.5625 * k$1 * k$1;
		else if (k$1 < 2 / 2.75) return 7.5625 * (k$1 -= 1.5 / 2.75) * k$1 + .75;
		else if (k$1 < 2.5 / 2.75) return 7.5625 * (k$1 -= 2.25 / 2.75) * k$1 + .9375;
		else return 7.5625 * (k$1 -= 2.625 / 2.75) * k$1 + .984375;
	},
	bounceInOut: function(k$1) {
		if (k$1 < .5) return easingFuncs.bounceIn(k$1 * 2) * .5;
		return easingFuncs.bounceOut(k$1 * 2 - 1) * .5 + .5;
	}
};
var easing_default = easingFuncs;

//#endregion
//#region node_modules/zrender/lib/core/curve.js
var mathPow$2 = Math.pow;
var mathSqrt$3 = Math.sqrt;
var EPSILON$4 = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt$3(3);
var ONE_THIRD = 1 / 3;
var _v0 = create$1();
var _v1 = create$1();
var _v2 = create$1();
function isAroundZero$1(val) {
	return val > -EPSILON$4 && val < EPSILON$4;
}
function isNotAroundZero$1(val) {
	return val > EPSILON$4 || val < -EPSILON$4;
}
function cubicAt(p0, p1, p2, p3, t) {
	var onet = 1 - t;
	return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function cubicDerivativeAt(p0, p1, p2, p3, t) {
	var onet = 1 - t;
	return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}
function cubicRootAt(p0, p1, p2, p3, val, roots$1) {
	var a = p3 + 3 * (p1 - p2) - p0;
	var b = 3 * (p2 - p1 * 2 + p0);
	var c = 3 * (p1 - p0);
	var d = p0 - val;
	var A = b * b - 3 * a * c;
	var B = b * c - 9 * a * d;
	var C = c * c - 3 * b * d;
	var n = 0;
	if (isAroundZero$1(A) && isAroundZero$1(B)) if (isAroundZero$1(b)) roots$1[0] = 0;
	else {
		var t1 = -c / b;
		if (t1 >= 0 && t1 <= 1) roots$1[n++] = t1;
	}
	else {
		var disc = B * B - 4 * A * C;
		if (isAroundZero$1(disc)) {
			var K = B / A;
			var t1 = -b / a + K;
			var t2 = -K / 2;
			if (t1 >= 0 && t1 <= 1) roots$1[n++] = t1;
			if (t2 >= 0 && t2 <= 1) roots$1[n++] = t2;
		} else if (disc > 0) {
			var discSqrt = mathSqrt$3(disc);
			var Y1 = A * b + 1.5 * a * (-B + discSqrt);
			var Y2 = A * b + 1.5 * a * (-B - discSqrt);
			if (Y1 < 0) Y1 = -mathPow$2(-Y1, ONE_THIRD);
			else Y1 = mathPow$2(Y1, ONE_THIRD);
			if (Y2 < 0) Y2 = -mathPow$2(-Y2, ONE_THIRD);
			else Y2 = mathPow$2(Y2, ONE_THIRD);
			var t1 = (-b - (Y1 + Y2)) / (3 * a);
			if (t1 >= 0 && t1 <= 1) roots$1[n++] = t1;
		} else {
			var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt$3(A * A * A));
			var theta = Math.acos(T) / 3;
			var ASqrt = mathSqrt$3(A);
			var tmp = Math.cos(theta);
			var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
			var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
			var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
			if (t1 >= 0 && t1 <= 1) roots$1[n++] = t1;
			if (t2 >= 0 && t2 <= 1) roots$1[n++] = t2;
			if (t3 >= 0 && t3 <= 1) roots$1[n++] = t3;
		}
	}
	return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema$1) {
	var b = 6 * p2 - 12 * p1 + 6 * p0;
	var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	var c = 3 * p1 - 3 * p0;
	var n = 0;
	if (isAroundZero$1(a)) {
		if (isNotAroundZero$1(b)) {
			var t1 = -c / b;
			if (t1 >= 0 && t1 <= 1) extrema$1[n++] = t1;
		}
	} else {
		var disc = b * b - 4 * a * c;
		if (isAroundZero$1(disc)) extrema$1[0] = -b / (2 * a);
		else if (disc > 0) {
			var discSqrt = mathSqrt$3(disc);
			var t1 = (-b + discSqrt) / (2 * a);
			var t2 = (-b - discSqrt) / (2 * a);
			if (t1 >= 0 && t1 <= 1) extrema$1[n++] = t1;
			if (t2 >= 0 && t2 <= 1) extrema$1[n++] = t2;
		}
	}
	return n;
}
function cubicSubdivide(p0, p1, p2, p3, t, out$1) {
	var p01 = (p1 - p0) * t + p0;
	var p12 = (p2 - p1) * t + p1;
	var p23 = (p3 - p2) * t + p2;
	var p012 = (p12 - p01) * t + p01;
	var p123 = (p23 - p12) * t + p12;
	var p0123 = (p123 - p012) * t + p012;
	out$1[0] = p0;
	out$1[1] = p01;
	out$1[2] = p012;
	out$1[3] = p0123;
	out$1[4] = p0123;
	out$1[5] = p123;
	out$1[6] = p23;
	out$1[7] = p3;
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out$1) {
	var t;
	var interval = .005;
	var d = Infinity;
	var prev;
	var next;
	var d1;
	var d2;
	_v0[0] = x;
	_v0[1] = y;
	for (var _t = 0; _t < 1; _t += .05) {
		_v1[0] = cubicAt(x0, x1, x2, x3, _t);
		_v1[1] = cubicAt(y0, y1, y2, y3, _t);
		d1 = distSquare(_v0, _v1);
		if (d1 < d) {
			t = _t;
			d = d1;
		}
	}
	d = Infinity;
	for (var i$1 = 0; i$1 < 32; i$1++) {
		if (interval < EPSILON_NUMERIC) break;
		prev = t - interval;
		next = t + interval;
		_v1[0] = cubicAt(x0, x1, x2, x3, prev);
		_v1[1] = cubicAt(y0, y1, y2, y3, prev);
		d1 = distSquare(_v1, _v0);
		if (prev >= 0 && d1 < d) {
			t = prev;
			d = d1;
		} else {
			_v2[0] = cubicAt(x0, x1, x2, x3, next);
			_v2[1] = cubicAt(y0, y1, y2, y3, next);
			d2 = distSquare(_v2, _v0);
			if (next <= 1 && d2 < d) {
				t = next;
				d = d2;
			} else interval *= .5;
		}
	}
	if (out$1) {
		out$1[0] = cubicAt(x0, x1, x2, x3, t);
		out$1[1] = cubicAt(y0, y1, y2, y3, t);
	}
	return mathSqrt$3(d);
}
function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
	var px = x0;
	var py = y0;
	var d = 0;
	var step = 1 / iteration;
	for (var i$1 = 1; i$1 <= iteration; i$1++) {
		var t = i$1 * step;
		var x = cubicAt(x0, x1, x2, x3, t);
		var y = cubicAt(y0, y1, y2, y3, t);
		var dx = x - px;
		var dy = y - py;
		d += Math.sqrt(dx * dx + dy * dy);
		px = x;
		py = y;
	}
	return d;
}
function quadraticAt$1(p0, p1, p2, t) {
	var onet = 1 - t;
	return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function quadraticDerivativeAt(p0, p1, p2, t) {
	return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}
function quadraticRootAt(p0, p1, p2, val, roots$1) {
	var a = p0 - 2 * p1 + p2;
	var b = 2 * (p1 - p0);
	var c = p0 - val;
	var n = 0;
	if (isAroundZero$1(a)) {
		if (isNotAroundZero$1(b)) {
			var t1 = -c / b;
			if (t1 >= 0 && t1 <= 1) roots$1[n++] = t1;
		}
	} else {
		var disc = b * b - 4 * a * c;
		if (isAroundZero$1(disc)) {
			var t1 = -b / (2 * a);
			if (t1 >= 0 && t1 <= 1) roots$1[n++] = t1;
		} else if (disc > 0) {
			var discSqrt = mathSqrt$3(disc);
			var t1 = (-b + discSqrt) / (2 * a);
			var t2 = (-b - discSqrt) / (2 * a);
			if (t1 >= 0 && t1 <= 1) roots$1[n++] = t1;
			if (t2 >= 0 && t2 <= 1) roots$1[n++] = t2;
		}
	}
	return n;
}
function quadraticExtremum(p0, p1, p2) {
	var divider = p0 + p2 - 2 * p1;
	if (divider === 0) return .5;
	else return (p0 - p1) / divider;
}
function quadraticSubdivide(p0, p1, p2, t, out$1) {
	var p01 = (p1 - p0) * t + p0;
	var p12 = (p2 - p1) * t + p1;
	var p012 = (p12 - p01) * t + p01;
	out$1[0] = p0;
	out$1[1] = p01;
	out$1[2] = p012;
	out$1[3] = p012;
	out$1[4] = p12;
	out$1[5] = p2;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out$1) {
	var t;
	var interval = .005;
	var d = Infinity;
	_v0[0] = x;
	_v0[1] = y;
	for (var _t = 0; _t < 1; _t += .05) {
		_v1[0] = quadraticAt$1(x0, x1, x2, _t);
		_v1[1] = quadraticAt$1(y0, y1, y2, _t);
		var d1 = distSquare(_v0, _v1);
		if (d1 < d) {
			t = _t;
			d = d1;
		}
	}
	d = Infinity;
	for (var i$1 = 0; i$1 < 32; i$1++) {
		if (interval < EPSILON_NUMERIC) break;
		var prev = t - interval;
		var next = t + interval;
		_v1[0] = quadraticAt$1(x0, x1, x2, prev);
		_v1[1] = quadraticAt$1(y0, y1, y2, prev);
		var d1 = distSquare(_v1, _v0);
		if (prev >= 0 && d1 < d) {
			t = prev;
			d = d1;
		} else {
			_v2[0] = quadraticAt$1(x0, x1, x2, next);
			_v2[1] = quadraticAt$1(y0, y1, y2, next);
			var d2 = distSquare(_v2, _v0);
			if (next <= 1 && d2 < d) {
				t = next;
				d = d2;
			} else interval *= .5;
		}
	}
	if (out$1) {
		out$1[0] = quadraticAt$1(x0, x1, x2, t);
		out$1[1] = quadraticAt$1(y0, y1, y2, t);
	}
	return mathSqrt$3(d);
}
function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
	var px = x0;
	var py = y0;
	var d = 0;
	var step = 1 / iteration;
	for (var i$1 = 1; i$1 <= iteration; i$1++) {
		var t = i$1 * step;
		var x = quadraticAt$1(x0, x1, x2, t);
		var y = quadraticAt$1(y0, y1, y2, t);
		var dx = x - px;
		var dy = y - py;
		d += Math.sqrt(dx * dx + dy * dy);
		px = x;
		py = y;
	}
	return d;
}

//#endregion
//#region node_modules/zrender/lib/animation/cubicEasing.js
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(cubicEasingStr) {
	var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);
	if (cubic) {
		var points$3 = cubic[1].split(",");
		var a_1 = +trim(points$3[0]);
		var b_1 = +trim(points$3[1]);
		var c_1 = +trim(points$3[2]);
		var d_1 = +trim(points$3[3]);
		if (isNaN(a_1 + b_1 + c_1 + d_1)) return;
		var roots_1 = [];
		return function(p) {
			return p <= 0 ? 0 : p >= 1 ? 1 : cubicRootAt(0, a_1, c_1, 1, p, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0]);
		};
	}
}

//#endregion
//#region node_modules/zrender/lib/animation/Clip.js
var Clip = function() {
	function Clip$1(opts) {
		this._inited = false;
		this._startTime = 0;
		this._pausedTime = 0;
		this._paused = false;
		this._life = opts.life || 1e3;
		this._delay = opts.delay || 0;
		this.loop = opts.loop || false;
		this.onframe = opts.onframe || noop;
		this.ondestroy = opts.ondestroy || noop;
		this.onrestart = opts.onrestart || noop;
		opts.easing && this.setEasing(opts.easing);
	}
	Clip$1.prototype.step = function(globalTime, deltaTime) {
		if (!this._inited) {
			this._startTime = globalTime + this._delay;
			this._inited = true;
		}
		if (this._paused) {
			this._pausedTime += deltaTime;
			return;
		}
		var life = this._life;
		var elapsedTime = globalTime - this._startTime - this._pausedTime;
		var percent = elapsedTime / life;
		if (percent < 0) percent = 0;
		percent = Math.min(percent, 1);
		var easingFunc = this.easingFunc;
		var schedule = easingFunc ? easingFunc(percent) : percent;
		this.onframe(schedule);
		if (percent === 1) if (this.loop) {
			this._startTime = globalTime - elapsedTime % life;
			this._pausedTime = 0;
			this.onrestart();
		} else return true;
		return false;
	};
	Clip$1.prototype.pause = function() {
		this._paused = true;
	};
	Clip$1.prototype.resume = function() {
		this._paused = false;
	};
	Clip$1.prototype.setEasing = function(easing) {
		this.easing = easing;
		this.easingFunc = isFunction(easing) ? easing : easing_default[easing] || createCubicEasingFunc(easing);
	};
	return Clip$1;
}();
var Clip_default = Clip;

//#endregion
//#region node_modules/zrender/lib/core/LRU.js
var Entry = function() {
	function Entry$1(val) {
		this.value = val;
	}
	return Entry$1;
}();
var LinkedList = function() {
	function LinkedList$1() {
		this._len = 0;
	}
	LinkedList$1.prototype.insert = function(val) {
		var entry = new Entry(val);
		this.insertEntry(entry);
		return entry;
	};
	LinkedList$1.prototype.insertEntry = function(entry) {
		if (!this.head) this.head = this.tail = entry;
		else {
			this.tail.next = entry;
			entry.prev = this.tail;
			entry.next = null;
			this.tail = entry;
		}
		this._len++;
	};
	LinkedList$1.prototype.remove = function(entry) {
		var prev = entry.prev;
		var next = entry.next;
		if (prev) prev.next = next;
		else this.head = next;
		if (next) next.prev = prev;
		else this.tail = prev;
		entry.next = entry.prev = null;
		this._len--;
	};
	LinkedList$1.prototype.len = function() {
		return this._len;
	};
	LinkedList$1.prototype.clear = function() {
		this.head = this.tail = null;
		this._len = 0;
	};
	return LinkedList$1;
}();
var LRU = function() {
	function LRU$1(maxSize) {
		this._list = new LinkedList();
		this._maxSize = 10;
		this._map = {};
		this._maxSize = maxSize;
	}
	LRU$1.prototype.put = function(key$1, value) {
		var list = this._list;
		var map$2 = this._map;
		var removed = null;
		if (map$2[key$1] == null) {
			var len$1 = list.len();
			var entry = this._lastRemovedEntry;
			if (len$1 >= this._maxSize && len$1 > 0) {
				var leastUsedEntry = list.head;
				list.remove(leastUsedEntry);
				delete map$2[leastUsedEntry.key];
				removed = leastUsedEntry.value;
				this._lastRemovedEntry = leastUsedEntry;
			}
			if (entry) entry.value = value;
			else entry = new Entry(value);
			entry.key = key$1;
			list.insertEntry(entry);
			map$2[key$1] = entry;
		}
		return removed;
	};
	LRU$1.prototype.get = function(key$1) {
		var entry = this._map[key$1];
		var list = this._list;
		if (entry != null) {
			if (entry !== list.tail) {
				list.remove(entry);
				list.insertEntry(entry);
			}
			return entry.value;
		}
	};
	LRU$1.prototype.clear = function() {
		this._list.clear();
		this._map = {};
	};
	LRU$1.prototype.len = function() {
		return this._list.len();
	};
	return LRU$1;
}();
var LRU_default = LRU;

//#endregion
//#region node_modules/zrender/lib/tool/color.js
var color_exports = /* @__PURE__ */ __export({
	fastLerp: () => fastLerp,
	fastMapToColor: () => fastMapToColor,
	lerp: () => lerp$1,
	lift: () => lift,
	liftColor: () => liftColor,
	lum: () => lum,
	mapToColor: () => mapToColor,
	modifyAlpha: () => modifyAlpha,
	modifyHSL: () => modifyHSL,
	parse: () => parse,
	parseCssFloat: () => parseCssFloat,
	parseCssInt: () => parseCssInt,
	random: () => random,
	stringify: () => stringify,
	toHex: () => toHex
});
var kCSSColorTable = {
	"transparent": [
		0,
		0,
		0,
		0
	],
	"aliceblue": [
		240,
		248,
		255,
		1
	],
	"antiquewhite": [
		250,
		235,
		215,
		1
	],
	"aqua": [
		0,
		255,
		255,
		1
	],
	"aquamarine": [
		127,
		255,
		212,
		1
	],
	"azure": [
		240,
		255,
		255,
		1
	],
	"beige": [
		245,
		245,
		220,
		1
	],
	"bisque": [
		255,
		228,
		196,
		1
	],
	"black": [
		0,
		0,
		0,
		1
	],
	"blanchedalmond": [
		255,
		235,
		205,
		1
	],
	"blue": [
		0,
		0,
		255,
		1
	],
	"blueviolet": [
		138,
		43,
		226,
		1
	],
	"brown": [
		165,
		42,
		42,
		1
	],
	"burlywood": [
		222,
		184,
		135,
		1
	],
	"cadetblue": [
		95,
		158,
		160,
		1
	],
	"chartreuse": [
		127,
		255,
		0,
		1
	],
	"chocolate": [
		210,
		105,
		30,
		1
	],
	"coral": [
		255,
		127,
		80,
		1
	],
	"cornflowerblue": [
		100,
		149,
		237,
		1
	],
	"cornsilk": [
		255,
		248,
		220,
		1
	],
	"crimson": [
		220,
		20,
		60,
		1
	],
	"cyan": [
		0,
		255,
		255,
		1
	],
	"darkblue": [
		0,
		0,
		139,
		1
	],
	"darkcyan": [
		0,
		139,
		139,
		1
	],
	"darkgoldenrod": [
		184,
		134,
		11,
		1
	],
	"darkgray": [
		169,
		169,
		169,
		1
	],
	"darkgreen": [
		0,
		100,
		0,
		1
	],
	"darkgrey": [
		169,
		169,
		169,
		1
	],
	"darkkhaki": [
		189,
		183,
		107,
		1
	],
	"darkmagenta": [
		139,
		0,
		139,
		1
	],
	"darkolivegreen": [
		85,
		107,
		47,
		1
	],
	"darkorange": [
		255,
		140,
		0,
		1
	],
	"darkorchid": [
		153,
		50,
		204,
		1
	],
	"darkred": [
		139,
		0,
		0,
		1
	],
	"darksalmon": [
		233,
		150,
		122,
		1
	],
	"darkseagreen": [
		143,
		188,
		143,
		1
	],
	"darkslateblue": [
		72,
		61,
		139,
		1
	],
	"darkslategray": [
		47,
		79,
		79,
		1
	],
	"darkslategrey": [
		47,
		79,
		79,
		1
	],
	"darkturquoise": [
		0,
		206,
		209,
		1
	],
	"darkviolet": [
		148,
		0,
		211,
		1
	],
	"deeppink": [
		255,
		20,
		147,
		1
	],
	"deepskyblue": [
		0,
		191,
		255,
		1
	],
	"dimgray": [
		105,
		105,
		105,
		1
	],
	"dimgrey": [
		105,
		105,
		105,
		1
	],
	"dodgerblue": [
		30,
		144,
		255,
		1
	],
	"firebrick": [
		178,
		34,
		34,
		1
	],
	"floralwhite": [
		255,
		250,
		240,
		1
	],
	"forestgreen": [
		34,
		139,
		34,
		1
	],
	"fuchsia": [
		255,
		0,
		255,
		1
	],
	"gainsboro": [
		220,
		220,
		220,
		1
	],
	"ghostwhite": [
		248,
		248,
		255,
		1
	],
	"gold": [
		255,
		215,
		0,
		1
	],
	"goldenrod": [
		218,
		165,
		32,
		1
	],
	"gray": [
		128,
		128,
		128,
		1
	],
	"green": [
		0,
		128,
		0,
		1
	],
	"greenyellow": [
		173,
		255,
		47,
		1
	],
	"grey": [
		128,
		128,
		128,
		1
	],
	"honeydew": [
		240,
		255,
		240,
		1
	],
	"hotpink": [
		255,
		105,
		180,
		1
	],
	"indianred": [
		205,
		92,
		92,
		1
	],
	"indigo": [
		75,
		0,
		130,
		1
	],
	"ivory": [
		255,
		255,
		240,
		1
	],
	"khaki": [
		240,
		230,
		140,
		1
	],
	"lavender": [
		230,
		230,
		250,
		1
	],
	"lavenderblush": [
		255,
		240,
		245,
		1
	],
	"lawngreen": [
		124,
		252,
		0,
		1
	],
	"lemonchiffon": [
		255,
		250,
		205,
		1
	],
	"lightblue": [
		173,
		216,
		230,
		1
	],
	"lightcoral": [
		240,
		128,
		128,
		1
	],
	"lightcyan": [
		224,
		255,
		255,
		1
	],
	"lightgoldenrodyellow": [
		250,
		250,
		210,
		1
	],
	"lightgray": [
		211,
		211,
		211,
		1
	],
	"lightgreen": [
		144,
		238,
		144,
		1
	],
	"lightgrey": [
		211,
		211,
		211,
		1
	],
	"lightpink": [
		255,
		182,
		193,
		1
	],
	"lightsalmon": [
		255,
		160,
		122,
		1
	],
	"lightseagreen": [
		32,
		178,
		170,
		1
	],
	"lightskyblue": [
		135,
		206,
		250,
		1
	],
	"lightslategray": [
		119,
		136,
		153,
		1
	],
	"lightslategrey": [
		119,
		136,
		153,
		1
	],
	"lightsteelblue": [
		176,
		196,
		222,
		1
	],
	"lightyellow": [
		255,
		255,
		224,
		1
	],
	"lime": [
		0,
		255,
		0,
		1
	],
	"limegreen": [
		50,
		205,
		50,
		1
	],
	"linen": [
		250,
		240,
		230,
		1
	],
	"magenta": [
		255,
		0,
		255,
		1
	],
	"maroon": [
		128,
		0,
		0,
		1
	],
	"mediumaquamarine": [
		102,
		205,
		170,
		1
	],
	"mediumblue": [
		0,
		0,
		205,
		1
	],
	"mediumorchid": [
		186,
		85,
		211,
		1
	],
	"mediumpurple": [
		147,
		112,
		219,
		1
	],
	"mediumseagreen": [
		60,
		179,
		113,
		1
	],
	"mediumslateblue": [
		123,
		104,
		238,
		1
	],
	"mediumspringgreen": [
		0,
		250,
		154,
		1
	],
	"mediumturquoise": [
		72,
		209,
		204,
		1
	],
	"mediumvioletred": [
		199,
		21,
		133,
		1
	],
	"midnightblue": [
		25,
		25,
		112,
		1
	],
	"mintcream": [
		245,
		255,
		250,
		1
	],
	"mistyrose": [
		255,
		228,
		225,
		1
	],
	"moccasin": [
		255,
		228,
		181,
		1
	],
	"navajowhite": [
		255,
		222,
		173,
		1
	],
	"navy": [
		0,
		0,
		128,
		1
	],
	"oldlace": [
		253,
		245,
		230,
		1
	],
	"olive": [
		128,
		128,
		0,
		1
	],
	"olivedrab": [
		107,
		142,
		35,
		1
	],
	"orange": [
		255,
		165,
		0,
		1
	],
	"orangered": [
		255,
		69,
		0,
		1
	],
	"orchid": [
		218,
		112,
		214,
		1
	],
	"palegoldenrod": [
		238,
		232,
		170,
		1
	],
	"palegreen": [
		152,
		251,
		152,
		1
	],
	"paleturquoise": [
		175,
		238,
		238,
		1
	],
	"palevioletred": [
		219,
		112,
		147,
		1
	],
	"papayawhip": [
		255,
		239,
		213,
		1
	],
	"peachpuff": [
		255,
		218,
		185,
		1
	],
	"peru": [
		205,
		133,
		63,
		1
	],
	"pink": [
		255,
		192,
		203,
		1
	],
	"plum": [
		221,
		160,
		221,
		1
	],
	"powderblue": [
		176,
		224,
		230,
		1
	],
	"purple": [
		128,
		0,
		128,
		1
	],
	"red": [
		255,
		0,
		0,
		1
	],
	"rosybrown": [
		188,
		143,
		143,
		1
	],
	"royalblue": [
		65,
		105,
		225,
		1
	],
	"saddlebrown": [
		139,
		69,
		19,
		1
	],
	"salmon": [
		250,
		128,
		114,
		1
	],
	"sandybrown": [
		244,
		164,
		96,
		1
	],
	"seagreen": [
		46,
		139,
		87,
		1
	],
	"seashell": [
		255,
		245,
		238,
		1
	],
	"sienna": [
		160,
		82,
		45,
		1
	],
	"silver": [
		192,
		192,
		192,
		1
	],
	"skyblue": [
		135,
		206,
		235,
		1
	],
	"slateblue": [
		106,
		90,
		205,
		1
	],
	"slategray": [
		112,
		128,
		144,
		1
	],
	"slategrey": [
		112,
		128,
		144,
		1
	],
	"snow": [
		255,
		250,
		250,
		1
	],
	"springgreen": [
		0,
		255,
		127,
		1
	],
	"steelblue": [
		70,
		130,
		180,
		1
	],
	"tan": [
		210,
		180,
		140,
		1
	],
	"teal": [
		0,
		128,
		128,
		1
	],
	"thistle": [
		216,
		191,
		216,
		1
	],
	"tomato": [
		255,
		99,
		71,
		1
	],
	"turquoise": [
		64,
		224,
		208,
		1
	],
	"violet": [
		238,
		130,
		238,
		1
	],
	"wheat": [
		245,
		222,
		179,
		1
	],
	"white": [
		255,
		255,
		255,
		1
	],
	"whitesmoke": [
		245,
		245,
		245,
		1
	],
	"yellow": [
		255,
		255,
		0,
		1
	],
	"yellowgreen": [
		154,
		205,
		50,
		1
	]
};
function clampCssByte(i$1) {
	i$1 = Math.round(i$1);
	return i$1 < 0 ? 0 : i$1 > 255 ? 255 : i$1;
}
function clampCssAngle(i$1) {
	i$1 = Math.round(i$1);
	return i$1 < 0 ? 0 : i$1 > 360 ? 360 : i$1;
}
function clampCssFloat(f) {
	return f < 0 ? 0 : f > 1 ? 1 : f;
}
function parseCssInt(val) {
	var str = val;
	if (str.length && str.charAt(str.length - 1) === "%") return clampCssByte(parseFloat(str) / 100 * 255);
	return clampCssByte(parseInt(str, 10));
}
function parseCssFloat(val) {
	var str = val;
	if (str.length && str.charAt(str.length - 1) === "%") return clampCssFloat(parseFloat(str) / 100);
	return clampCssFloat(parseFloat(str));
}
function cssHueToRgb(m1, m2, h) {
	if (h < 0) h += 1;
	else if (h > 1) h -= 1;
	if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
	if (h * 2 < 1) return m2;
	if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;
	return m1;
}
function lerpNumber(a, b, p) {
	return a + (b - a) * p;
}
function setRgba(out$1, r, g, b, a) {
	out$1[0] = r;
	out$1[1] = g;
	out$1[2] = b;
	out$1[3] = a;
	return out$1;
}
function copyRgba(out$1, a) {
	out$1[0] = a[0];
	out$1[1] = a[1];
	out$1[2] = a[2];
	out$1[3] = a[3];
	return out$1;
}
var colorCache = new LRU_default(20);
var lastRemovedArr = null;
function putToCache(colorStr, rgbaArr) {
	if (lastRemovedArr) copyRgba(lastRemovedArr, rgbaArr);
	lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
function parse(colorStr, rgbaArr) {
	if (!colorStr) return;
	rgbaArr = rgbaArr || [];
	var cached = colorCache.get(colorStr);
	if (cached) return copyRgba(rgbaArr, cached);
	colorStr = colorStr + "";
	var str = colorStr.replace(/ /g, "").toLowerCase();
	if (str in kCSSColorTable) {
		copyRgba(rgbaArr, kCSSColorTable[str]);
		putToCache(colorStr, rgbaArr);
		return rgbaArr;
	}
	var strLen = str.length;
	if (str.charAt(0) === "#") {
		if (strLen === 4 || strLen === 5) {
			var iv = parseInt(str.slice(1, 4), 16);
			if (!(iv >= 0 && iv <= 4095)) {
				setRgba(rgbaArr, 0, 0, 0, 1);
				return;
			}
			setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
			putToCache(colorStr, rgbaArr);
			return rgbaArr;
		} else if (strLen === 7 || strLen === 9) {
			var iv = parseInt(str.slice(1, 7), 16);
			if (!(iv >= 0 && iv <= 16777215)) {
				setRgba(rgbaArr, 0, 0, 0, 1);
				return;
			}
			setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
			putToCache(colorStr, rgbaArr);
			return rgbaArr;
		}
		return;
	}
	var op = str.indexOf("(");
	var ep = str.indexOf(")");
	if (op !== -1 && ep + 1 === strLen) {
		var fname = str.substr(0, op);
		var params = str.substr(op + 1, ep - (op + 1)).split(",");
		var alpha = 1;
		switch (fname) {
			case "rgba":
				if (params.length !== 4) return params.length === 3 ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1) : setRgba(rgbaArr, 0, 0, 0, 1);
				alpha = parseCssFloat(params.pop());
			case "rgb": if (params.length >= 3) {
				setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), params.length === 3 ? alpha : parseCssFloat(params[3]));
				putToCache(colorStr, rgbaArr);
				return rgbaArr;
			} else {
				setRgba(rgbaArr, 0, 0, 0, 1);
				return;
			}
			case "hsla":
				if (params.length !== 4) {
					setRgba(rgbaArr, 0, 0, 0, 1);
					return;
				}
				params[3] = parseCssFloat(params[3]);
				hsla2rgba(params, rgbaArr);
				putToCache(colorStr, rgbaArr);
				return rgbaArr;
			case "hsl":
				if (params.length !== 3) {
					setRgba(rgbaArr, 0, 0, 0, 1);
					return;
				}
				hsla2rgba(params, rgbaArr);
				putToCache(colorStr, rgbaArr);
				return rgbaArr;
			default: return;
		}
	}
	setRgba(rgbaArr, 0, 0, 0, 1);
}
function hsla2rgba(hsla, rgba) {
	var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
	var s = parseCssFloat(hsla[1]);
	var l = parseCssFloat(hsla[2]);
	var m2 = l <= .5 ? l * (s + 1) : l + s - l * s;
	var m1 = l * 2 - m2;
	rgba = rgba || [];
	setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
	if (hsla.length === 4) rgba[3] = hsla[3];
	return rgba;
}
function rgba2hsla(rgba) {
	if (!rgba) return;
	var R = rgba[0] / 255;
	var G = rgba[1] / 255;
	var B = rgba[2] / 255;
	var vMin = Math.min(R, G, B);
	var vMax = Math.max(R, G, B);
	var delta = vMax - vMin;
	var L = (vMax + vMin) / 2;
	var H;
	var S;
	if (delta === 0) {
		H = 0;
		S = 0;
	} else {
		if (L < .5) S = delta / (vMax + vMin);
		else S = delta / (2 - vMax - vMin);
		var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
		var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
		var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
		if (R === vMax) H = deltaB - deltaG;
		else if (G === vMax) H = 1 / 3 + deltaR - deltaB;
		else if (B === vMax) H = 2 / 3 + deltaG - deltaR;
		if (H < 0) H += 1;
		if (H > 1) H -= 1;
	}
	var hsla = [
		H * 360,
		S,
		L
	];
	if (rgba[3] != null) hsla.push(rgba[3]);
	return hsla;
}
function lift(color$2, level) {
	var colorArr = parse(color$2);
	if (colorArr) {
		for (var i$1 = 0; i$1 < 3; i$1++) {
			if (level < 0) colorArr[i$1] = colorArr[i$1] * (1 - level) | 0;
			else colorArr[i$1] = (255 - colorArr[i$1]) * level + colorArr[i$1] | 0;
			if (colorArr[i$1] > 255) colorArr[i$1] = 255;
			else if (colorArr[i$1] < 0) colorArr[i$1] = 0;
		}
		return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
	}
}
function toHex(color$2) {
	var colorArr = parse(color$2);
	if (colorArr) return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
}
function fastLerp(normalizedValue, colors, out$1) {
	if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) return;
	out$1 = out$1 || [];
	var value = normalizedValue * (colors.length - 1);
	var leftIndex = Math.floor(value);
	var rightIndex = Math.ceil(value);
	var leftColor = colors[leftIndex];
	var rightColor = colors[rightIndex];
	var dv = value - leftIndex;
	out$1[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
	out$1[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
	out$1[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
	out$1[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
	return out$1;
}
var fastMapToColor = fastLerp;
function lerp$1(normalizedValue, colors, fullOutput) {
	if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) return;
	var value = normalizedValue * (colors.length - 1);
	var leftIndex = Math.floor(value);
	var rightIndex = Math.ceil(value);
	var leftColor = parse(colors[leftIndex]);
	var rightColor = parse(colors[rightIndex]);
	var dv = value - leftIndex;
	var color$2 = stringify([
		clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
		clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
		clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
		clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
	], "rgba");
	return fullOutput ? {
		color: color$2,
		leftIndex,
		rightIndex,
		value
	} : color$2;
}
var mapToColor = lerp$1;
function modifyHSL(color$2, h, s, l) {
	var colorArr = parse(color$2);
	if (color$2) {
		colorArr = rgba2hsla(colorArr);
		h != null && (colorArr[0] = clampCssAngle(isFunction(h) ? h(colorArr[0]) : h));
		s != null && (colorArr[1] = parseCssFloat(isFunction(s) ? s(colorArr[1]) : s));
		l != null && (colorArr[2] = parseCssFloat(isFunction(l) ? l(colorArr[2]) : l));
		return stringify(hsla2rgba(colorArr), "rgba");
	}
}
function modifyAlpha(color$2, alpha) {
	var colorArr = parse(color$2);
	if (colorArr && alpha != null) {
		colorArr[3] = clampCssFloat(alpha);
		return stringify(colorArr, "rgba");
	}
}
function stringify(arrColor, type) {
	if (!arrColor || !arrColor.length) return;
	var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
	if (type === "rgba" || type === "hsva" || type === "hsla") colorStr += "," + arrColor[3];
	return type + "(" + colorStr + ")";
}
function lum(color$2, backgroundLum) {
	var arr = parse(color$2);
	return arr ? (.299 * arr[0] + .587 * arr[1] + .114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
}
function random() {
	return stringify([
		Math.round(Math.random() * 255),
		Math.round(Math.random() * 255),
		Math.round(Math.random() * 255)
	], "rgb");
}
var liftedColorCache = new LRU_default(100);
function liftColor(color$2) {
	if (isString(color$2)) {
		var liftedColor = liftedColorCache.get(color$2);
		if (!liftedColor) {
			liftedColor = lift(color$2, -.1);
			liftedColorCache.put(color$2, liftedColor);
		}
		return liftedColor;
	} else if (isGradientObject(color$2)) {
		var ret = extend({}, color$2);
		ret.colorStops = map(color$2.colorStops, function(stop$1) {
			return {
				offset: stop$1.offset,
				color: lift(stop$1.color, -.1)
			};
		});
		return ret;
	}
	return color$2;
}

//#endregion
//#region node_modules/zrender/lib/svg/helper.js
var mathRound$1 = Math.round;
function normalizeColor(color$2) {
	var opacity;
	if (!color$2 || color$2 === "transparent") color$2 = "none";
	else if (typeof color$2 === "string" && color$2.indexOf("rgba") > -1) {
		var arr = parse(color$2);
		if (arr) {
			color$2 = "rgb(" + arr[0] + "," + arr[1] + "," + arr[2] + ")";
			opacity = arr[3];
		}
	}
	return {
		color: color$2,
		opacity: opacity == null ? 1 : opacity
	};
}
var EPSILON$3 = 1e-4;
function isAroundZero(transform) {
	return transform < EPSILON$3 && transform > -EPSILON$3;
}
function round3(transform) {
	return mathRound$1(transform * 1e3) / 1e3;
}
function round4(transform) {
	return mathRound$1(transform * 1e4) / 1e4;
}
function getMatrixStr(m$1) {
	return "matrix(" + round3(m$1[0]) + "," + round3(m$1[1]) + "," + round3(m$1[2]) + "," + round3(m$1[3]) + "," + round4(m$1[4]) + "," + round4(m$1[5]) + ")";
}
var TEXT_ALIGN_TO_ANCHOR = {
	left: "start",
	right: "end",
	center: "middle",
	middle: "middle"
};
function adjustTextY(y, lineHeight, textBaseline) {
	if (textBaseline === "top") y += lineHeight / 2;
	else if (textBaseline === "bottom") y -= lineHeight / 2;
	return y;
}
function hasShadow(style) {
	return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY);
}
function getShadowKey(displayable) {
	var style = displayable.style;
	var globalScale = displayable.getGlobalScale();
	return [
		style.shadowColor,
		(style.shadowBlur || 0).toFixed(2),
		(style.shadowOffsetX || 0).toFixed(2),
		(style.shadowOffsetY || 0).toFixed(2),
		globalScale[0],
		globalScale[1]
	].join(",");
}
function isImagePattern(val) {
	return val && !!val.image;
}
function isSVGPattern(val) {
	return val && !!val.svgElement;
}
function isPattern(val) {
	return isImagePattern(val) || isSVGPattern(val);
}
function isLinearGradient(val) {
	return val.type === "linear";
}
function isRadialGradient(val) {
	return val.type === "radial";
}
function isGradient(val) {
	return val && (val.type === "linear" || val.type === "radial");
}
function getIdURL(id) {
	return "url(#" + id + ")";
}
function getPathPrecision(el) {
	var scale$3 = el.getGlobalScale();
	var size = Math.max(scale$3[0], scale$3[1]);
	return Math.max(Math.ceil(Math.log(size) / Math.log(10)), 1);
}
function getSRTTransformString(transform) {
	var x = transform.x || 0;
	var y = transform.y || 0;
	var rotation = (transform.rotation || 0) * RADIAN_TO_DEGREE;
	var scaleX = retrieve2(transform.scaleX, 1);
	var scaleY = retrieve2(transform.scaleY, 1);
	var skewX = transform.skewX || 0;
	var skewY = transform.skewY || 0;
	var res = [];
	if (x || y) res.push("translate(" + x + "px," + y + "px)");
	if (rotation) res.push("rotate(" + rotation + ")");
	if (scaleX !== 1 || scaleY !== 1) res.push("scale(" + scaleX + "," + scaleY + ")");
	if (skewX || skewY) res.push("skew(" + mathRound$1(skewX * RADIAN_TO_DEGREE) + "deg, " + mathRound$1(skewY * RADIAN_TO_DEGREE) + "deg)");
	return res.join(" ");
}
var encodeBase64 = (function() {
	if (env_default.hasGlobalWindow && isFunction(window.btoa)) return function(str) {
		return window.btoa(unescape(encodeURIComponent(str)));
	};
	if (typeof Buffer !== "undefined") return function(str) {
		return Buffer.from(str).toString("base64");
	};
	return function(str) {
		logError("Base64 isn't natively supported in the current environment.");
		return null;
	};
})();

//#endregion
//#region node_modules/zrender/lib/animation/Animator.js
var arraySlice = Array.prototype.slice;
function interpolateNumber$1(p0, p1, percent) {
	return (p1 - p0) * percent + p0;
}
function interpolate1DArray(out$1, p0, p1, percent) {
	var len$1 = p0.length;
	for (var i$1 = 0; i$1 < len$1; i$1++) out$1[i$1] = interpolateNumber$1(p0[i$1], p1[i$1], percent);
	return out$1;
}
function interpolate2DArray(out$1, p0, p1, percent) {
	var len$1 = p0.length;
	var len2 = len$1 && p0[0].length;
	for (var i$1 = 0; i$1 < len$1; i$1++) {
		if (!out$1[i$1]) out$1[i$1] = [];
		for (var j = 0; j < len2; j++) out$1[i$1][j] = interpolateNumber$1(p0[i$1][j], p1[i$1][j], percent);
	}
	return out$1;
}
function add1DArray(out$1, p0, p1, sign) {
	var len$1 = p0.length;
	for (var i$1 = 0; i$1 < len$1; i$1++) out$1[i$1] = p0[i$1] + p1[i$1] * sign;
	return out$1;
}
function add2DArray(out$1, p0, p1, sign) {
	var len$1 = p0.length;
	var len2 = len$1 && p0[0].length;
	for (var i$1 = 0; i$1 < len$1; i$1++) {
		if (!out$1[i$1]) out$1[i$1] = [];
		for (var j = 0; j < len2; j++) out$1[i$1][j] = p0[i$1][j] + p1[i$1][j] * sign;
	}
	return out$1;
}
function fillColorStops(val0, val1) {
	var len0 = val0.length;
	var len1 = val1.length;
	var shorterArr = len0 > len1 ? val1 : val0;
	var shorterLen = Math.min(len0, len1);
	var last = shorterArr[shorterLen - 1] || {
		color: [
			0,
			0,
			0,
			0
		],
		offset: 0
	};
	for (var i$1 = shorterLen; i$1 < Math.max(len0, len1); i$1++) shorterArr.push({
		offset: last.offset,
		color: last.color.slice()
	});
}
function fillArray(val0, val1, arrDim) {
	var arr0 = val0;
	var arr1 = val1;
	if (!arr0.push || !arr1.push) return;
	var arr0Len = arr0.length;
	var arr1Len = arr1.length;
	if (arr0Len !== arr1Len) if (arr0Len > arr1Len) arr0.length = arr1Len;
	else for (var i$1 = arr0Len; i$1 < arr1Len; i$1++) arr0.push(arrDim === 1 ? arr1[i$1] : arraySlice.call(arr1[i$1]));
	var len2 = arr0[0] && arr0[0].length;
	for (var i$1 = 0; i$1 < arr0.length; i$1++) if (arrDim === 1) {
		if (isNaN(arr0[i$1])) arr0[i$1] = arr1[i$1];
	} else for (var j = 0; j < len2; j++) if (isNaN(arr0[i$1][j])) arr0[i$1][j] = arr1[i$1][j];
}
function cloneValue(value) {
	if (isArrayLike(value)) {
		var len$1 = value.length;
		if (isArrayLike(value[0])) {
			var ret = [];
			for (var i$1 = 0; i$1 < len$1; i$1++) ret.push(arraySlice.call(value[i$1]));
			return ret;
		}
		return arraySlice.call(value);
	}
	return value;
}
function rgba2String(rgba) {
	rgba[0] = Math.floor(rgba[0]) || 0;
	rgba[1] = Math.floor(rgba[1]) || 0;
	rgba[2] = Math.floor(rgba[2]) || 0;
	rgba[3] = rgba[3] == null ? 1 : rgba[3];
	return "rgba(" + rgba.join(",") + ")";
}
function guessArrayDim(value) {
	return isArrayLike(value && value[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0;
var VALUE_TYPE_1D_ARRAY = 1;
var VALUE_TYPE_2D_ARRAY = 2;
var VALUE_TYPE_COLOR = 3;
var VALUE_TYPE_LINEAR_GRADIENT = 4;
var VALUE_TYPE_RADIAL_GRADIENT = 5;
var VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(valType) {
	return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(valType) {
	return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [
	0,
	0,
	0,
	0
];
var Track = function() {
	function Track$1(propName) {
		this.keyframes = [];
		this.discrete = false;
		this._invalid = false;
		this._needsSort = false;
		this._lastFr = 0;
		this._lastFrP = 0;
		this.propName = propName;
	}
	Track$1.prototype.isFinished = function() {
		return this._finished;
	};
	Track$1.prototype.setFinished = function() {
		this._finished = true;
		if (this._additiveTrack) this._additiveTrack.setFinished();
	};
	Track$1.prototype.needsAnimate = function() {
		return this.keyframes.length >= 1;
	};
	Track$1.prototype.getAdditiveTrack = function() {
		return this._additiveTrack;
	};
	Track$1.prototype.addKeyframe = function(time, rawValue, easing) {
		this._needsSort = true;
		var keyframes = this.keyframes;
		var len$1 = keyframes.length;
		var discrete = false;
		var valType = VALUE_TYPE_UNKOWN;
		var value = rawValue;
		if (isArrayLike(rawValue)) {
			var arrayDim = guessArrayDim(rawValue);
			valType = arrayDim;
			if (arrayDim === 1 && !isNumber(rawValue[0]) || arrayDim === 2 && !isNumber(rawValue[0][0])) discrete = true;
		} else if (isNumber(rawValue) && !eqNaN(rawValue)) valType = VALUE_TYPE_NUMBER;
		else if (isString(rawValue)) if (!isNaN(+rawValue)) valType = VALUE_TYPE_NUMBER;
		else {
			var colorArray = parse(rawValue);
			if (colorArray) {
				value = colorArray;
				valType = VALUE_TYPE_COLOR;
			}
		}
		else if (isGradientObject(rawValue)) {
			var parsedGradient = extend({}, value);
			parsedGradient.colorStops = map(rawValue.colorStops, function(colorStop) {
				return {
					offset: colorStop.offset,
					color: parse(colorStop.color)
				};
			});
			if (isLinearGradient(rawValue)) valType = VALUE_TYPE_LINEAR_GRADIENT;
			else if (isRadialGradient(rawValue)) valType = VALUE_TYPE_RADIAL_GRADIENT;
			value = parsedGradient;
		}
		if (len$1 === 0) this.valType = valType;
		else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) discrete = true;
		this.discrete = this.discrete || discrete;
		var kf = {
			time,
			value,
			rawValue,
			percent: 0
		};
		if (easing) {
			kf.easing = easing;
			kf.easingFunc = isFunction(easing) ? easing : easing_default[easing] || createCubicEasingFunc(easing);
		}
		keyframes.push(kf);
		return kf;
	};
	Track$1.prototype.prepare = function(maxTime, additiveTrack) {
		var kfs = this.keyframes;
		if (this._needsSort) kfs.sort(function(a, b) {
			return a.time - b.time;
		});
		var valType = this.valType;
		var kfsLen = kfs.length;
		var lastKf = kfs[kfsLen - 1];
		var isDiscrete = this.discrete;
		var isArr = isArrayValueType(valType);
		var isGradient$1 = isGradientValueType(valType);
		for (var i$1 = 0; i$1 < kfsLen; i$1++) {
			var kf = kfs[i$1];
			var value = kf.value;
			var lastValue = lastKf.value;
			kf.percent = kf.time / maxTime;
			if (!isDiscrete) {
				if (isArr && i$1 !== kfsLen - 1) fillArray(value, lastValue, valType);
				else if (isGradient$1) fillColorStops(value.colorStops, lastValue.colorStops);
			}
		}
		if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
			this._additiveTrack = additiveTrack;
			var startValue = kfs[0].value;
			for (var i$1 = 0; i$1 < kfsLen; i$1++) if (valType === VALUE_TYPE_NUMBER) kfs[i$1].additiveValue = kfs[i$1].value - startValue;
			else if (valType === VALUE_TYPE_COLOR) kfs[i$1].additiveValue = add1DArray([], kfs[i$1].value, startValue, -1);
			else if (isArrayValueType(valType)) kfs[i$1].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i$1].value, startValue, -1) : add2DArray([], kfs[i$1].value, startValue, -1);
		}
	};
	Track$1.prototype.step = function(target, percent) {
		if (this._finished) return;
		if (this._additiveTrack && this._additiveTrack._finished) this._additiveTrack = null;
		var isAdditive = this._additiveTrack != null;
		var valueKey = isAdditive ? "additiveValue" : "value";
		var valType = this.valType;
		var keyframes = this.keyframes;
		var kfsNum = keyframes.length;
		var propName = this.propName;
		var isValueColor = valType === VALUE_TYPE_COLOR;
		var frameIdx;
		var lastFrame = this._lastFr;
		var mathMin$12 = Math.min;
		var frame;
		var nextFrame;
		if (kfsNum === 1) frame = nextFrame = keyframes[0];
		else {
			if (percent < 0) frameIdx = 0;
			else if (percent < this._lastFrP) {
				for (frameIdx = mathMin$12(lastFrame + 1, kfsNum - 1); frameIdx >= 0; frameIdx--) if (keyframes[frameIdx].percent <= percent) break;
				frameIdx = mathMin$12(frameIdx, kfsNum - 2);
			} else {
				for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) if (keyframes[frameIdx].percent > percent) break;
				frameIdx = mathMin$12(frameIdx - 1, kfsNum - 2);
			}
			nextFrame = keyframes[frameIdx + 1];
			frame = keyframes[frameIdx];
		}
		if (!(frame && nextFrame)) return;
		this._lastFr = frameIdx;
		this._lastFrP = percent;
		var interval = nextFrame.percent - frame.percent;
		var w = interval === 0 ? 1 : mathMin$12((percent - frame.percent) / interval, 1);
		if (nextFrame.easingFunc) w = nextFrame.easingFunc(w);
		var targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
		if ((isArrayValueType(valType) || isValueColor) && !targetArr) targetArr = this._additiveValue = [];
		if (this.discrete) target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;
		else if (isArrayValueType(valType)) valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w) : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
		else if (isGradientValueType(valType)) {
			var val = frame[valueKey];
			var nextVal_1 = nextFrame[valueKey];
			var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;
			target[propName] = {
				type: isLinearGradient_1 ? "linear" : "radial",
				x: interpolateNumber$1(val.x, nextVal_1.x, w),
				y: interpolateNumber$1(val.y, nextVal_1.y, w),
				colorStops: map(val.colorStops, function(colorStop, idx) {
					var nextColorStop = nextVal_1.colorStops[idx];
					return {
						offset: interpolateNumber$1(colorStop.offset, nextColorStop.offset, w),
						color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))
					};
				}),
				global: nextVal_1.global
			};
			if (isLinearGradient_1) {
				target[propName].x2 = interpolateNumber$1(val.x2, nextVal_1.x2, w);
				target[propName].y2 = interpolateNumber$1(val.y2, nextVal_1.y2, w);
			} else target[propName].r = interpolateNumber$1(val.r, nextVal_1.r, w);
		} else if (isValueColor) {
			interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
			if (!isAdditive) target[propName] = rgba2String(targetArr);
		} else {
			var value = interpolateNumber$1(frame[valueKey], nextFrame[valueKey], w);
			if (isAdditive) this._additiveValue = value;
			else target[propName] = value;
		}
		if (isAdditive) this._addToTarget(target);
	};
	Track$1.prototype._addToTarget = function(target) {
		var valType = this.valType;
		var propName = this.propName;
		var additiveValue = this._additiveValue;
		if (valType === VALUE_TYPE_NUMBER) target[propName] = target[propName] + additiveValue;
		else if (valType === VALUE_TYPE_COLOR) {
			parse(target[propName], tmpRgba);
			add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
			target[propName] = rgba2String(tmpRgba);
		} else if (valType === VALUE_TYPE_1D_ARRAY) add1DArray(target[propName], target[propName], additiveValue, 1);
		else if (valType === VALUE_TYPE_2D_ARRAY) add2DArray(target[propName], target[propName], additiveValue, 1);
	};
	return Track$1;
}();
var Animator = function() {
	function Animator$1(target, loop, allowDiscreteAnimation, additiveTo) {
		this._tracks = {};
		this._trackKeys = [];
		this._maxTime = 0;
		this._started = 0;
		this._clip = null;
		this._target = target;
		this._loop = loop;
		if (loop && additiveTo) {
			logError("Can' use additive animation on looped animation.");
			return;
		}
		this._additiveAnimators = additiveTo;
		this._allowDiscrete = allowDiscreteAnimation;
	}
	Animator$1.prototype.getMaxTime = function() {
		return this._maxTime;
	};
	Animator$1.prototype.getDelay = function() {
		return this._delay;
	};
	Animator$1.prototype.getLoop = function() {
		return this._loop;
	};
	Animator$1.prototype.getTarget = function() {
		return this._target;
	};
	Animator$1.prototype.changeTarget = function(target) {
		this._target = target;
	};
	Animator$1.prototype.when = function(time, props, easing) {
		return this.whenWithKeys(time, props, keys(props), easing);
	};
	Animator$1.prototype.whenWithKeys = function(time, props, propNames, easing) {
		var tracks = this._tracks;
		for (var i$1 = 0; i$1 < propNames.length; i$1++) {
			var propName = propNames[i$1];
			var track = tracks[propName];
			if (!track) {
				track = tracks[propName] = new Track(propName);
				var initialValue = void 0;
				var additiveTrack = this._getAdditiveTrack(propName);
				if (additiveTrack) {
					var addtiveTrackKfs = additiveTrack.keyframes;
					var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
					initialValue = lastFinalKf && lastFinalKf.value;
					if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) initialValue = rgba2String(initialValue);
				} else initialValue = this._target[propName];
				if (initialValue == null) continue;
				if (time > 0) track.addKeyframe(0, cloneValue(initialValue), easing);
				this._trackKeys.push(propName);
			}
			track.addKeyframe(time, cloneValue(props[propName]), easing);
		}
		this._maxTime = Math.max(this._maxTime, time);
		return this;
	};
	Animator$1.prototype.pause = function() {
		this._clip.pause();
		this._paused = true;
	};
	Animator$1.prototype.resume = function() {
		this._clip.resume();
		this._paused = false;
	};
	Animator$1.prototype.isPaused = function() {
		return !!this._paused;
	};
	Animator$1.prototype.duration = function(duration) {
		this._maxTime = duration;
		this._force = true;
		return this;
	};
	Animator$1.prototype._doneCallback = function() {
		this._setTracksFinished();
		this._clip = null;
		var doneList = this._doneCbs;
		if (doneList) {
			var len$1 = doneList.length;
			for (var i$1 = 0; i$1 < len$1; i$1++) doneList[i$1].call(this);
		}
	};
	Animator$1.prototype._abortedCallback = function() {
		this._setTracksFinished();
		var animation = this.animation;
		var abortedList = this._abortedCbs;
		if (animation) animation.removeClip(this._clip);
		this._clip = null;
		if (abortedList) for (var i$1 = 0; i$1 < abortedList.length; i$1++) abortedList[i$1].call(this);
	};
	Animator$1.prototype._setTracksFinished = function() {
		var tracks = this._tracks;
		var tracksKeys = this._trackKeys;
		for (var i$1 = 0; i$1 < tracksKeys.length; i$1++) tracks[tracksKeys[i$1]].setFinished();
	};
	Animator$1.prototype._getAdditiveTrack = function(trackName) {
		var additiveTrack;
		var additiveAnimators = this._additiveAnimators;
		if (additiveAnimators) for (var i$1 = 0; i$1 < additiveAnimators.length; i$1++) {
			var track = additiveAnimators[i$1].getTrack(trackName);
			if (track) additiveTrack = track;
		}
		return additiveTrack;
	};
	Animator$1.prototype.start = function(easing) {
		if (this._started > 0) return;
		this._started = 1;
		var self$1 = this;
		var tracks = [];
		var maxTime = this._maxTime || 0;
		for (var i$1 = 0; i$1 < this._trackKeys.length; i$1++) {
			var propName = this._trackKeys[i$1];
			var track = this._tracks[propName];
			var additiveTrack = this._getAdditiveTrack(propName);
			var kfs = track.keyframes;
			var kfsNum = kfs.length;
			track.prepare(maxTime, additiveTrack);
			if (track.needsAnimate()) if (!this._allowDiscrete && track.discrete) {
				var lastKf = kfs[kfsNum - 1];
				if (lastKf) self$1._target[track.propName] = lastKf.rawValue;
				track.setFinished();
			} else tracks.push(track);
		}
		if (tracks.length || this._force) {
			var clip$1 = new Clip_default({
				life: maxTime,
				loop: this._loop,
				delay: this._delay || 0,
				onframe: function(percent) {
					self$1._started = 2;
					var additiveAnimators = self$1._additiveAnimators;
					if (additiveAnimators) {
						var stillHasAdditiveAnimator = false;
						for (var i$2 = 0; i$2 < additiveAnimators.length; i$2++) if (additiveAnimators[i$2]._clip) {
							stillHasAdditiveAnimator = true;
							break;
						}
						if (!stillHasAdditiveAnimator) self$1._additiveAnimators = null;
					}
					for (var i$2 = 0; i$2 < tracks.length; i$2++) tracks[i$2].step(self$1._target, percent);
					var onframeList = self$1._onframeCbs;
					if (onframeList) for (var i$2 = 0; i$2 < onframeList.length; i$2++) onframeList[i$2](self$1._target, percent);
				},
				ondestroy: function() {
					self$1._doneCallback();
				}
			});
			this._clip = clip$1;
			if (this.animation) this.animation.addClip(clip$1);
			if (easing) clip$1.setEasing(easing);
		} else this._doneCallback();
		return this;
	};
	Animator$1.prototype.stop = function(forwardToLast) {
		if (!this._clip) return;
		var clip$1 = this._clip;
		if (forwardToLast) clip$1.onframe(1);
		this._abortedCallback();
	};
	Animator$1.prototype.delay = function(time) {
		this._delay = time;
		return this;
	};
	Animator$1.prototype.during = function(cb) {
		if (cb) {
			if (!this._onframeCbs) this._onframeCbs = [];
			this._onframeCbs.push(cb);
		}
		return this;
	};
	Animator$1.prototype.done = function(cb) {
		if (cb) {
			if (!this._doneCbs) this._doneCbs = [];
			this._doneCbs.push(cb);
		}
		return this;
	};
	Animator$1.prototype.aborted = function(cb) {
		if (cb) {
			if (!this._abortedCbs) this._abortedCbs = [];
			this._abortedCbs.push(cb);
		}
		return this;
	};
	Animator$1.prototype.getClip = function() {
		return this._clip;
	};
	Animator$1.prototype.getTrack = function(propName) {
		return this._tracks[propName];
	};
	Animator$1.prototype.getTracks = function() {
		var _this = this;
		return map(this._trackKeys, function(key$1) {
			return _this._tracks[key$1];
		});
	};
	Animator$1.prototype.stopTracks = function(propNames, forwardToLast) {
		if (!propNames.length || !this._clip) return true;
		var tracks = this._tracks;
		var tracksKeys = this._trackKeys;
		for (var i$1 = 0; i$1 < propNames.length; i$1++) {
			var track = tracks[propNames[i$1]];
			if (track && !track.isFinished()) {
				if (forwardToLast) track.step(this._target, 1);
				else if (this._started === 1) track.step(this._target, 0);
				track.setFinished();
			}
		}
		var allAborted = true;
		for (var i$1 = 0; i$1 < tracksKeys.length; i$1++) if (!tracks[tracksKeys[i$1]].isFinished()) {
			allAborted = false;
			break;
		}
		if (allAborted) this._abortedCallback();
		return allAborted;
	};
	Animator$1.prototype.saveTo = function(target, trackKeys, firstOrLast) {
		if (!target) return;
		trackKeys = trackKeys || this._trackKeys;
		for (var i$1 = 0; i$1 < trackKeys.length; i$1++) {
			var propName = trackKeys[i$1];
			var track = this._tracks[propName];
			if (!track || track.isFinished()) continue;
			var kfs = track.keyframes;
			var kf = kfs[firstOrLast ? 0 : kfs.length - 1];
			if (kf) target[propName] = cloneValue(kf.rawValue);
		}
	};
	Animator$1.prototype.__changeFinalValue = function(finalProps, trackKeys) {
		trackKeys = trackKeys || keys(finalProps);
		for (var i$1 = 0; i$1 < trackKeys.length; i$1++) {
			var propName = trackKeys[i$1];
			var track = this._tracks[propName];
			if (!track) continue;
			var kfs = track.keyframes;
			if (kfs.length > 1) {
				var lastKf = kfs.pop();
				track.addKeyframe(lastKf.time, finalProps[propName]);
				track.prepare(this._maxTime, track.getAdditiveTrack());
			}
		}
	};
	return Animator$1;
}();
var Animator_default = Animator;

//#endregion
//#region node_modules/zrender/lib/animation/Animation.js
function getTime() {
	return (/* @__PURE__ */ new Date()).getTime();
}
var Animation = function(_super) {
	__extends$1(Animation$1, _super);
	function Animation$1(opts) {
		var _this = _super.call(this) || this;
		_this._running = false;
		_this._time = 0;
		_this._pausedTime = 0;
		_this._pauseStart = 0;
		_this._paused = false;
		opts = opts || {};
		_this.stage = opts.stage || {};
		return _this;
	}
	Animation$1.prototype.addClip = function(clip$1) {
		if (clip$1.animation) this.removeClip(clip$1);
		if (!this._head) this._head = this._tail = clip$1;
		else {
			this._tail.next = clip$1;
			clip$1.prev = this._tail;
			clip$1.next = null;
			this._tail = clip$1;
		}
		clip$1.animation = this;
	};
	Animation$1.prototype.addAnimator = function(animator) {
		animator.animation = this;
		var clip$1 = animator.getClip();
		if (clip$1) this.addClip(clip$1);
	};
	Animation$1.prototype.removeClip = function(clip$1) {
		if (!clip$1.animation) return;
		var prev = clip$1.prev;
		var next = clip$1.next;
		if (prev) prev.next = next;
		else this._head = next;
		if (next) next.prev = prev;
		else this._tail = prev;
		clip$1.next = clip$1.prev = clip$1.animation = null;
	};
	Animation$1.prototype.removeAnimator = function(animator) {
		var clip$1 = animator.getClip();
		if (clip$1) this.removeClip(clip$1);
		animator.animation = null;
	};
	Animation$1.prototype.update = function(notTriggerFrameAndStageUpdate) {
		var time = getTime() - this._pausedTime;
		var delta = time - this._time;
		var clip$1 = this._head;
		while (clip$1) {
			var nextClip = clip$1.next;
			if (clip$1.step(time, delta)) {
				clip$1.ondestroy();
				this.removeClip(clip$1);
				clip$1 = nextClip;
			} else clip$1 = nextClip;
		}
		this._time = time;
		if (!notTriggerFrameAndStageUpdate) {
			this.trigger("frame", delta);
			this.stage.update && this.stage.update();
		}
	};
	Animation$1.prototype._startLoop = function() {
		var self$1 = this;
		this._running = true;
		function step() {
			if (self$1._running) {
				requestAnimationFrame_default(step);
				!self$1._paused && self$1.update();
			}
		}
		requestAnimationFrame_default(step);
	};
	Animation$1.prototype.start = function() {
		if (this._running) return;
		this._time = getTime();
		this._pausedTime = 0;
		this._startLoop();
	};
	Animation$1.prototype.stop = function() {
		this._running = false;
	};
	Animation$1.prototype.pause = function() {
		if (!this._paused) {
			this._pauseStart = getTime();
			this._paused = true;
		}
	};
	Animation$1.prototype.resume = function() {
		if (this._paused) {
			this._pausedTime += getTime() - this._pauseStart;
			this._paused = false;
		}
	};
	Animation$1.prototype.clear = function() {
		var clip$1 = this._head;
		while (clip$1) {
			var nextClip = clip$1.next;
			clip$1.prev = clip$1.next = clip$1.animation = null;
			clip$1 = nextClip;
		}
		this._head = this._tail = null;
	};
	Animation$1.prototype.isFinished = function() {
		return this._head == null;
	};
	Animation$1.prototype.animate = function(target, options) {
		options = options || {};
		this.start();
		var animator = new Animator_default(target, options.loop);
		this.addAnimator(animator);
		return animator;
	};
	return Animation$1;
}(Eventful_default);
var Animation_default = Animation;

//#endregion
//#region node_modules/zrender/lib/dom/HandlerProxy.js
var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env_default.domSupported;
var localNativeListenerNames = (function() {
	var mouseHandlerNames = [
		"click",
		"dblclick",
		"mousewheel",
		"wheel",
		"mouseout",
		"mouseup",
		"mousedown",
		"mousemove",
		"contextmenu"
	];
	var touchHandlerNames = [
		"touchstart",
		"touchend",
		"touchmove"
	];
	var pointerEventNameMap = {
		pointerdown: 1,
		pointerup: 1,
		pointermove: 1,
		pointerout: 1
	};
	return {
		mouse: mouseHandlerNames,
		touch: touchHandlerNames,
		pointer: map(mouseHandlerNames, function(name) {
			var nm = name.replace("mouse", "pointer");
			return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
		})
	};
})();
var globalNativeListenerNames = {
	mouse: ["mousemove", "mouseup"],
	pointer: ["pointermove", "pointerup"]
};
var wheelEventSupported = false;
function isPointerFromTouch(event) {
	var pointerType = event.pointerType;
	return pointerType === "pen" || pointerType === "touch";
}
function setTouchTimer(scope) {
	scope.touching = true;
	if (scope.touchTimer != null) {
		clearTimeout(scope.touchTimer);
		scope.touchTimer = null;
	}
	scope.touchTimer = setTimeout(function() {
		scope.touching = false;
		scope.touchTimer = null;
	}, 700);
}
function markTouch(event) {
	event && (event.zrByTouch = true);
}
function normalizeGlobalEvent(instance, event) {
	return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
}
function isLocalEl(instance, el) {
	var elTmp = el;
	var isLocal = false;
	while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) elTmp = elTmp.parentNode;
	return isLocal;
}
var FakeGlobalEvent = function() {
	function FakeGlobalEvent$1(instance, event) {
		this.stopPropagation = noop;
		this.stopImmediatePropagation = noop;
		this.preventDefault = noop;
		this.type = event.type;
		this.target = this.currentTarget = instance.dom;
		this.pointerType = event.pointerType;
		this.clientX = event.clientX;
		this.clientY = event.clientY;
	}
	return FakeGlobalEvent$1;
}();
var localDOMHandlers = {
	mousedown: function(event) {
		event = normalizeEvent(this.dom, event);
		this.__mayPointerCapture = [event.zrX, event.zrY];
		this.trigger("mousedown", event);
	},
	mousemove: function(event) {
		event = normalizeEvent(this.dom, event);
		var downPoint = this.__mayPointerCapture;
		if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) this.__togglePointerCapture(true);
		this.trigger("mousemove", event);
	},
	mouseup: function(event) {
		event = normalizeEvent(this.dom, event);
		this.__togglePointerCapture(false);
		this.trigger("mouseup", event);
	},
	mouseout: function(event) {
		event = normalizeEvent(this.dom, event);
		var element = event.toElement || event.relatedTarget;
		if (!isLocalEl(this, element)) {
			if (this.__pointerCapturing) event.zrEventControl = "no_globalout";
			this.trigger("mouseout", event);
		}
	},
	wheel: function(event) {
		wheelEventSupported = true;
		event = normalizeEvent(this.dom, event);
		this.trigger("mousewheel", event);
	},
	mousewheel: function(event) {
		if (wheelEventSupported) return;
		event = normalizeEvent(this.dom, event);
		this.trigger("mousewheel", event);
	},
	touchstart: function(event) {
		event = normalizeEvent(this.dom, event);
		markTouch(event);
		this.__lastTouchMoment = /* @__PURE__ */ new Date();
		this.handler.processGesture(event, "start");
		localDOMHandlers.mousemove.call(this, event);
		localDOMHandlers.mousedown.call(this, event);
	},
	touchmove: function(event) {
		event = normalizeEvent(this.dom, event);
		markTouch(event);
		this.handler.processGesture(event, "change");
		localDOMHandlers.mousemove.call(this, event);
	},
	touchend: function(event) {
		event = normalizeEvent(this.dom, event);
		markTouch(event);
		this.handler.processGesture(event, "end");
		localDOMHandlers.mouseup.call(this, event);
		if (+/* @__PURE__ */ new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) localDOMHandlers.click.call(this, event);
	},
	pointerdown: function(event) {
		localDOMHandlers.mousedown.call(this, event);
	},
	pointermove: function(event) {
		if (!isPointerFromTouch(event)) localDOMHandlers.mousemove.call(this, event);
	},
	pointerup: function(event) {
		localDOMHandlers.mouseup.call(this, event);
	},
	pointerout: function(event) {
		if (!isPointerFromTouch(event)) localDOMHandlers.mouseout.call(this, event);
	}
};
each([
	"click",
	"dblclick",
	"contextmenu"
], function(name) {
	localDOMHandlers[name] = function(event) {
		event = normalizeEvent(this.dom, event);
		this.trigger(name, event);
	};
});
var globalDOMHandlers = {
	pointermove: function(event) {
		if (!isPointerFromTouch(event)) globalDOMHandlers.mousemove.call(this, event);
	},
	pointerup: function(event) {
		globalDOMHandlers.mouseup.call(this, event);
	},
	mousemove: function(event) {
		this.trigger("mousemove", event);
	},
	mouseup: function(event) {
		var pointerCaptureReleasing = this.__pointerCapturing;
		this.__togglePointerCapture(false);
		this.trigger("mouseup", event);
		if (pointerCaptureReleasing) {
			event.zrEventControl = "only_globalout";
			this.trigger("mouseout", event);
		}
	}
};
function mountLocalDOMEventListeners(instance, scope) {
	var domHandlers = scope.domHandlers;
	if (env_default.pointerEventsSupported) each(localNativeListenerNames.pointer, function(nativeEventName) {
		mountSingleDOMEventListener(scope, nativeEventName, function(event) {
			domHandlers[nativeEventName].call(instance, event);
		});
	});
	else {
		if (env_default.touchEventsSupported) each(localNativeListenerNames.touch, function(nativeEventName) {
			mountSingleDOMEventListener(scope, nativeEventName, function(event) {
				domHandlers[nativeEventName].call(instance, event);
				setTouchTimer(scope);
			});
		});
		each(localNativeListenerNames.mouse, function(nativeEventName) {
			mountSingleDOMEventListener(scope, nativeEventName, function(event) {
				event = getNativeEvent(event);
				if (!scope.touching) domHandlers[nativeEventName].call(instance, event);
			});
		});
	}
}
function mountGlobalDOMEventListeners(instance, scope) {
	if (env_default.pointerEventsSupported) each(globalNativeListenerNames.pointer, mount);
	else if (!env_default.touchEventsSupported) each(globalNativeListenerNames.mouse, mount);
	function mount(nativeEventName) {
		function nativeEventListener(event) {
			event = getNativeEvent(event);
			if (!isLocalEl(instance, event.target)) {
				event = normalizeGlobalEvent(instance, event);
				scope.domHandlers[nativeEventName].call(instance, event);
			}
		}
		mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
	}
}
function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
	scope.mounted[nativeEventName] = listener;
	scope.listenerOpts[nativeEventName] = opt;
	addEventListener(scope.domTarget, nativeEventName, listener, opt);
}
function unmountDOMEventListeners(scope) {
	var mounted = scope.mounted;
	for (var nativeEventName in mounted) if (mounted.hasOwnProperty(nativeEventName)) removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
	scope.mounted = {};
}
var DOMHandlerScope = function() {
	function DOMHandlerScope$1(domTarget, domHandlers) {
		this.mounted = {};
		this.listenerOpts = {};
		this.touching = false;
		this.domTarget = domTarget;
		this.domHandlers = domHandlers;
	}
	return DOMHandlerScope$1;
}();
var HandlerDomProxy = function(_super) {
	__extends$1(HandlerDomProxy$1, _super);
	function HandlerDomProxy$1(dom, painterRoot) {
		var _this = _super.call(this) || this;
		_this.__pointerCapturing = false;
		_this.dom = dom;
		_this.painterRoot = painterRoot;
		_this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
		if (globalEventSupported) _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
		mountLocalDOMEventListeners(_this, _this._localHandlerScope);
		return _this;
	}
	HandlerDomProxy$1.prototype.dispose = function() {
		unmountDOMEventListeners(this._localHandlerScope);
		if (globalEventSupported) unmountDOMEventListeners(this._globalHandlerScope);
	};
	HandlerDomProxy$1.prototype.setCursor = function(cursorStyle) {
		this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
	};
	HandlerDomProxy$1.prototype.__togglePointerCapture = function(isPointerCapturing) {
		this.__mayPointerCapture = null;
		if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
			this.__pointerCapturing = isPointerCapturing;
			var globalHandlerScope = this._globalHandlerScope;
			isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
		}
	};
	return HandlerDomProxy$1;
}(Eventful_default);
var HandlerProxy_default = HandlerDomProxy;

//#endregion
//#region node_modules/zrender/lib/config.js
var dpr = 1;
if (env_default.hasGlobalWindow) dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
var devicePixelRatio = dpr;
var DARK_MODE_THRESHOLD = .4;
var DARK_LABEL_COLOR = "#333";
var LIGHT_LABEL_COLOR = "#ccc";
var LIGHTER_LABEL_COLOR = "#eee";

//#endregion
//#region node_modules/zrender/lib/core/Transformable.js
var mIdentity = identity;
var EPSILON$2 = 5e-5;
function isNotAroundZero(val) {
	return val > EPSILON$2 || val < -EPSILON$2;
}
var scaleTmp = [];
var tmpTransform = [];
var originTransform = create$2();
var abs = Math.abs;
var Transformable = function() {
	function Transformable$1() {}
	Transformable$1.prototype.getLocalTransform = function(m$1) {
		return Transformable$1.getLocalTransform(this, m$1);
	};
	Transformable$1.prototype.setPosition = function(arr) {
		this.x = arr[0];
		this.y = arr[1];
	};
	Transformable$1.prototype.setScale = function(arr) {
		this.scaleX = arr[0];
		this.scaleY = arr[1];
	};
	Transformable$1.prototype.setSkew = function(arr) {
		this.skewX = arr[0];
		this.skewY = arr[1];
	};
	Transformable$1.prototype.setOrigin = function(arr) {
		this.originX = arr[0];
		this.originY = arr[1];
	};
	Transformable$1.prototype.needLocalTransform = function() {
		return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
	};
	Transformable$1.prototype.updateTransform = function() {
		var parentTransform = this.parent && this.parent.transform;
		var needLocalTransform = this.needLocalTransform();
		var m$1 = this.transform;
		if (!(needLocalTransform || parentTransform)) {
			if (m$1) {
				mIdentity(m$1);
				this.invTransform = null;
			}
			return;
		}
		m$1 = m$1 || create$2();
		if (needLocalTransform) this.getLocalTransform(m$1);
		else mIdentity(m$1);
		if (parentTransform) if (needLocalTransform) mul(m$1, parentTransform, m$1);
		else copy(m$1, parentTransform);
		this.transform = m$1;
		this._resolveGlobalScaleRatio(m$1);
	};
	Transformable$1.prototype._resolveGlobalScaleRatio = function(m$1) {
		var globalScaleRatio = this.globalScaleRatio;
		if (globalScaleRatio != null && globalScaleRatio !== 1) {
			this.getGlobalScale(scaleTmp);
			var relX = scaleTmp[0] < 0 ? -1 : 1;
			var relY = scaleTmp[1] < 0 ? -1 : 1;
			var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
			var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
			m$1[0] *= sx;
			m$1[1] *= sx;
			m$1[2] *= sy;
			m$1[3] *= sy;
		}
		this.invTransform = this.invTransform || create$2();
		invert(this.invTransform, m$1);
	};
	Transformable$1.prototype.getComputedTransform = function() {
		var transformNode = this;
		var ancestors = [];
		while (transformNode) {
			ancestors.push(transformNode);
			transformNode = transformNode.parent;
		}
		while (transformNode = ancestors.pop()) transformNode.updateTransform();
		return this.transform;
	};
	Transformable$1.prototype.setLocalTransform = function(m$1) {
		if (!m$1) return;
		var sx = m$1[0] * m$1[0] + m$1[1] * m$1[1];
		var sy = m$1[2] * m$1[2] + m$1[3] * m$1[3];
		var rotation = Math.atan2(m$1[1], m$1[0]);
		var shearX = Math.PI / 2 + rotation - Math.atan2(m$1[3], m$1[2]);
		sy = Math.sqrt(sy) * Math.cos(shearX);
		sx = Math.sqrt(sx);
		this.skewX = shearX;
		this.skewY = 0;
		this.rotation = -rotation;
		this.x = +m$1[4];
		this.y = +m$1[5];
		this.scaleX = sx;
		this.scaleY = sy;
		this.originX = 0;
		this.originY = 0;
	};
	Transformable$1.prototype.decomposeTransform = function() {
		if (!this.transform) return;
		var parent = this.parent;
		var m$1 = this.transform;
		if (parent && parent.transform) {
			parent.invTransform = parent.invTransform || create$2();
			mul(tmpTransform, parent.invTransform, m$1);
			m$1 = tmpTransform;
		}
		var ox = this.originX;
		var oy = this.originY;
		if (ox || oy) {
			originTransform[4] = ox;
			originTransform[5] = oy;
			mul(tmpTransform, m$1, originTransform);
			tmpTransform[4] -= ox;
			tmpTransform[5] -= oy;
			m$1 = tmpTransform;
		}
		this.setLocalTransform(m$1);
	};
	Transformable$1.prototype.getGlobalScale = function(out$1) {
		var m$1 = this.transform;
		out$1 = out$1 || [];
		if (!m$1) {
			out$1[0] = 1;
			out$1[1] = 1;
			return out$1;
		}
		out$1[0] = Math.sqrt(m$1[0] * m$1[0] + m$1[1] * m$1[1]);
		out$1[1] = Math.sqrt(m$1[2] * m$1[2] + m$1[3] * m$1[3]);
		if (m$1[0] < 0) out$1[0] = -out$1[0];
		if (m$1[3] < 0) out$1[1] = -out$1[1];
		return out$1;
	};
	Transformable$1.prototype.transformCoordToLocal = function(x, y) {
		var v2$1 = [x, y];
		var invTransform = this.invTransform;
		if (invTransform) applyTransform(v2$1, v2$1, invTransform);
		return v2$1;
	};
	Transformable$1.prototype.transformCoordToGlobal = function(x, y) {
		var v2$1 = [x, y];
		var transform = this.transform;
		if (transform) applyTransform(v2$1, v2$1, transform);
		return v2$1;
	};
	Transformable$1.prototype.getLineScale = function() {
		var m$1 = this.transform;
		return m$1 && abs(m$1[0] - 1) > 1e-10 && abs(m$1[3] - 1) > 1e-10 ? Math.sqrt(abs(m$1[0] * m$1[3] - m$1[2] * m$1[1])) : 1;
	};
	Transformable$1.prototype.copyTransform = function(source) {
		copyTransform(this, source);
	};
	Transformable$1.getLocalTransform = function(target, m$1) {
		m$1 = m$1 || [];
		var ox = target.originX || 0;
		var oy = target.originY || 0;
		var sx = target.scaleX;
		var sy = target.scaleY;
		var ax = target.anchorX;
		var ay = target.anchorY;
		var rotation = target.rotation || 0;
		var x = target.x;
		var y = target.y;
		var skewX = target.skewX ? Math.tan(target.skewX) : 0;
		var skewY = target.skewY ? Math.tan(-target.skewY) : 0;
		if (ox || oy || ax || ay) {
			var dx = ox + ax;
			var dy = oy + ay;
			m$1[4] = -dx * sx - skewX * dy * sy;
			m$1[5] = -dy * sy - skewY * dx * sx;
		} else m$1[4] = m$1[5] = 0;
		m$1[0] = sx;
		m$1[3] = sy;
		m$1[1] = skewY * sx;
		m$1[2] = skewX * sy;
		rotation && rotate(m$1, m$1, rotation);
		m$1[4] += ox + x;
		m$1[5] += oy + y;
		return m$1;
	};
	Transformable$1.initDefaultProps = (function() {
		var proto = Transformable$1.prototype;
		proto.scaleX = proto.scaleY = proto.globalScaleRatio = 1;
		proto.x = proto.y = proto.originX = proto.originY = proto.skewX = proto.skewY = proto.rotation = proto.anchorX = proto.anchorY = 0;
	})();
	return Transformable$1;
}();
var TRANSFORMABLE_PROPS = [
	"x",
	"y",
	"originX",
	"originY",
	"anchorX",
	"anchorY",
	"rotation",
	"scaleX",
	"scaleY",
	"skewX",
	"skewY"
];
function copyTransform(target, source) {
	for (var i$1 = 0; i$1 < TRANSFORMABLE_PROPS.length; i$1++) {
		var propName = TRANSFORMABLE_PROPS[i$1];
		target[propName] = source[propName];
	}
}
var Transformable_default = Transformable;

//#endregion
//#region node_modules/zrender/lib/contain/text.js
function ensureFontMeasureInfo(font) {
	if (!_fontMeasureInfoCache) _fontMeasureInfoCache = new LRU_default(100);
	font = font || DEFAULT_FONT;
	var measureInfo = _fontMeasureInfoCache.get(font);
	if (!measureInfo) {
		measureInfo = {
			font,
			strWidthCache: new LRU_default(500),
			asciiWidthMap: null,
			asciiWidthMapTried: false,
			stWideCharWidth: platformApi.measureText("", font).width,
			asciiCharWidth: platformApi.measureText("a", font).width
		};
		_fontMeasureInfoCache.put(font, measureInfo);
	}
	return measureInfo;
}
var _fontMeasureInfoCache;
function tryCreateASCIIWidthMap(font) {
	if (_getASCIIWidthMapLongCount >= GET_ASCII_WIDTH_LONG_COUNT_MAX) return;
	font = font || DEFAULT_FONT;
	var asciiWidthMap = [];
	var start$1 = +/* @__PURE__ */ new Date();
	for (var code = 0; code <= 127; code++) asciiWidthMap[code] = platformApi.measureText(String.fromCharCode(code), font).width;
	var cost = +/* @__PURE__ */ new Date() - start$1;
	if (cost > 16) _getASCIIWidthMapLongCount = GET_ASCII_WIDTH_LONG_COUNT_MAX;
	else if (cost > 2) _getASCIIWidthMapLongCount++;
	return asciiWidthMap;
}
var _getASCIIWidthMapLongCount = 0;
var GET_ASCII_WIDTH_LONG_COUNT_MAX = 5;
function measureCharWidth(fontMeasureInfo, charCode) {
	if (!fontMeasureInfo.asciiWidthMapTried) {
		fontMeasureInfo.asciiWidthMap = tryCreateASCIIWidthMap(fontMeasureInfo.font);
		fontMeasureInfo.asciiWidthMapTried = true;
	}
	return 0 <= charCode && charCode <= 127 ? fontMeasureInfo.asciiWidthMap != null ? fontMeasureInfo.asciiWidthMap[charCode] : fontMeasureInfo.asciiCharWidth : fontMeasureInfo.stWideCharWidth;
}
function measureWidth(fontMeasureInfo, text) {
	var strWidthCache = fontMeasureInfo.strWidthCache;
	var width = strWidthCache.get(text);
	if (width == null) {
		width = platformApi.measureText(text, fontMeasureInfo.font).width;
		strWidthCache.put(text, width);
	}
	return width;
}
function innerGetBoundingRect(text, font, textAlign, textBaseline) {
	var width = measureWidth(ensureFontMeasureInfo(font), text);
	var height = getLineHeight(font);
	return new BoundingRect_default(adjustTextX(0, width, textAlign), adjustTextY$1(0, height, textBaseline), width, height);
}
function getBoundingRect(text, font, textAlign, textBaseline) {
	var textLines = ((text || "") + "").split("\n");
	if (textLines.length === 1) return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
	else {
		var uniondRect = new BoundingRect_default(0, 0, 0, 0);
		for (var i$1 = 0; i$1 < textLines.length; i$1++) {
			var rect = innerGetBoundingRect(textLines[i$1], font, textAlign, textBaseline);
			i$1 === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
		}
		return uniondRect;
	}
}
function adjustTextX(x, width, textAlign, inverse) {
	if (textAlign === "right") !inverse ? x -= width : x += width;
	else if (textAlign === "center") !inverse ? x -= width / 2 : x += width / 2;
	return x;
}
function adjustTextY$1(y, height, verticalAlign, inverse) {
	if (verticalAlign === "middle") !inverse ? y -= height / 2 : y += height / 2;
	else if (verticalAlign === "bottom") !inverse ? y -= height : y += height;
	return y;
}
function getLineHeight(font) {
	return ensureFontMeasureInfo(font).stWideCharWidth;
}
function parsePercent(value, maxValue) {
	if (typeof value === "string") {
		if (value.lastIndexOf("%") >= 0) return parseFloat(value) / 100 * maxValue;
		return parseFloat(value);
	}
	return value;
}
function calculateTextPosition(out$1, opts, rect) {
	var textPosition = opts.position || "inside";
	var distance$1 = opts.distance != null ? opts.distance : 5;
	var height = rect.height;
	var width = rect.width;
	var halfHeight = height / 2;
	var x = rect.x;
	var y = rect.y;
	var textAlign = "left";
	var textVerticalAlign = "top";
	if (textPosition instanceof Array) {
		x += parsePercent(textPosition[0], rect.width);
		y += parsePercent(textPosition[1], rect.height);
		textAlign = null;
		textVerticalAlign = null;
	} else switch (textPosition) {
		case "left":
			x -= distance$1;
			y += halfHeight;
			textAlign = "right";
			textVerticalAlign = "middle";
			break;
		case "right":
			x += distance$1 + width;
			y += halfHeight;
			textVerticalAlign = "middle";
			break;
		case "top":
			x += width / 2;
			y -= distance$1;
			textAlign = "center";
			textVerticalAlign = "bottom";
			break;
		case "bottom":
			x += width / 2;
			y += height + distance$1;
			textAlign = "center";
			break;
		case "inside":
			x += width / 2;
			y += halfHeight;
			textAlign = "center";
			textVerticalAlign = "middle";
			break;
		case "insideLeft":
			x += distance$1;
			y += halfHeight;
			textVerticalAlign = "middle";
			break;
		case "insideRight":
			x += width - distance$1;
			y += halfHeight;
			textAlign = "right";
			textVerticalAlign = "middle";
			break;
		case "insideTop":
			x += width / 2;
			y += distance$1;
			textAlign = "center";
			break;
		case "insideBottom":
			x += width / 2;
			y += height - distance$1;
			textAlign = "center";
			textVerticalAlign = "bottom";
			break;
		case "insideTopLeft":
			x += distance$1;
			y += distance$1;
			break;
		case "insideTopRight":
			x += width - distance$1;
			y += distance$1;
			textAlign = "right";
			break;
		case "insideBottomLeft":
			x += distance$1;
			y += height - distance$1;
			textVerticalAlign = "bottom";
			break;
		case "insideBottomRight":
			x += width - distance$1;
			y += height - distance$1;
			textAlign = "right";
			textVerticalAlign = "bottom";
			break;
	}
	out$1 = out$1 || {};
	out$1.x = x;
	out$1.y = y;
	out$1.align = textAlign;
	out$1.verticalAlign = textVerticalAlign;
	return out$1;
}

//#endregion
//#region node_modules/zrender/lib/Element.js
var PRESERVED_NORMAL_STATE = "__zr_normal__";
var PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(["ignore"]);
var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(obj, key$1) {
	obj[key$1] = true;
	return obj;
}, { ignore: false });
var tmpTextPosCalcRes = {};
var tmpBoundingRect = new BoundingRect_default(0, 0, 0, 0);
var tmpInnerTextTrans = [];
var Element = function() {
	function Element$1(props) {
		this.id = guid();
		this.animators = [];
		this.currentStates = [];
		this.states = {};
		this._init(props);
	}
	Element$1.prototype._init = function(props) {
		this.attr(props);
	};
	Element$1.prototype.drift = function(dx, dy, e$1) {
		switch (this.draggable) {
			case "horizontal":
				dy = 0;
				break;
			case "vertical":
				dx = 0;
				break;
		}
		var m$1 = this.transform;
		if (!m$1) m$1 = this.transform = [
			1,
			0,
			0,
			1,
			0,
			0
		];
		m$1[4] += dx;
		m$1[5] += dy;
		this.decomposeTransform();
		this.markRedraw();
	};
	Element$1.prototype.beforeUpdate = function() {};
	Element$1.prototype.afterUpdate = function() {};
	Element$1.prototype.update = function() {
		this.updateTransform();
		if (this.__dirty) this.updateInnerText();
	};
	Element$1.prototype.updateInnerText = function(forceUpdate) {
		var textEl = this._textContent;
		if (textEl && (!textEl.ignore || forceUpdate)) {
			if (!this.textConfig) this.textConfig = {};
			var textConfig = this.textConfig;
			var isLocal = textConfig.local;
			var innerTransformable = textEl.innerTransformable;
			var textAlign = void 0;
			var textVerticalAlign = void 0;
			var textStyleChanged = false;
			innerTransformable.parent = isLocal ? this : null;
			var innerOrigin = false;
			innerTransformable.copyTransform(textEl);
			var hasPosition = textConfig.position != null;
			var autoOverflowArea = textConfig.autoOverflowArea;
			var layoutRect = void 0;
			if (autoOverflowArea || hasPosition) {
				layoutRect = tmpBoundingRect;
				if (textConfig.layoutRect) layoutRect.copy(textConfig.layoutRect);
				else layoutRect.copy(this.getBoundingRect());
				if (!isLocal) layoutRect.applyTransform(this.transform);
			}
			if (hasPosition) {
				if (this.calculateTextPosition) this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
				else calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
				innerTransformable.x = tmpTextPosCalcRes.x;
				innerTransformable.y = tmpTextPosCalcRes.y;
				textAlign = tmpTextPosCalcRes.align;
				textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
				var textOrigin = textConfig.origin;
				if (textOrigin && textConfig.rotation != null) {
					var relOriginX = void 0;
					var relOriginY = void 0;
					if (textOrigin === "center") {
						relOriginX = layoutRect.width * .5;
						relOriginY = layoutRect.height * .5;
					} else {
						relOriginX = parsePercent(textOrigin[0], layoutRect.width);
						relOriginY = parsePercent(textOrigin[1], layoutRect.height);
					}
					innerOrigin = true;
					innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
					innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
				}
			}
			if (textConfig.rotation != null) innerTransformable.rotation = textConfig.rotation;
			var textOffset = textConfig.offset;
			if (textOffset) {
				innerTransformable.x += textOffset[0];
				innerTransformable.y += textOffset[1];
				if (!innerOrigin) {
					innerTransformable.originX = -textOffset[0];
					innerTransformable.originY = -textOffset[1];
				}
			}
			var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
			if (autoOverflowArea) {
				var overflowRect = innerTextDefaultStyle.overflowRect = innerTextDefaultStyle.overflowRect || new BoundingRect_default(0, 0, 0, 0);
				innerTransformable.getLocalTransform(tmpInnerTextTrans);
				invert(tmpInnerTextTrans, tmpInnerTextTrans);
				BoundingRect_default.copy(overflowRect, layoutRect);
				overflowRect.applyTransform(tmpInnerTextTrans);
			} else innerTextDefaultStyle.overflowRect = null;
			var isInside = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
			var textFill = void 0;
			var textStroke = void 0;
			var autoStroke = void 0;
			if (isInside && this.canBeInsideText()) {
				textFill = textConfig.insideFill;
				textStroke = textConfig.insideStroke;
				if (textFill == null || textFill === "auto") textFill = this.getInsideTextFill();
				if (textStroke == null || textStroke === "auto") {
					textStroke = this.getInsideTextStroke(textFill);
					autoStroke = true;
				}
			} else {
				textFill = textConfig.outsideFill;
				textStroke = textConfig.outsideStroke;
				if (textFill == null || textFill === "auto") textFill = this.getOutsideFill();
				if (textStroke == null || textStroke === "auto") {
					textStroke = this.getOutsideStroke(textFill);
					autoStroke = true;
				}
			}
			textFill = textFill || "#000";
			if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
				textStyleChanged = true;
				innerTextDefaultStyle.fill = textFill;
				innerTextDefaultStyle.stroke = textStroke;
				innerTextDefaultStyle.autoStroke = autoStroke;
				innerTextDefaultStyle.align = textAlign;
				innerTextDefaultStyle.verticalAlign = textVerticalAlign;
				textEl.setDefaultTextStyle(innerTextDefaultStyle);
			}
			textEl.__dirty |= REDRAW_BIT;
			if (textStyleChanged) textEl.dirtyStyle(true);
		}
	};
	Element$1.prototype.canBeInsideText = function() {
		return true;
	};
	Element$1.prototype.getInsideTextFill = function() {
		return "#fff";
	};
	Element$1.prototype.getInsideTextStroke = function(textFill) {
		return "#000";
	};
	Element$1.prototype.getOutsideFill = function() {
		return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
	};
	Element$1.prototype.getOutsideStroke = function(textFill) {
		var backgroundColor$1 = this.__zr && this.__zr.getBackgroundColor();
		var colorArr = typeof backgroundColor$1 === "string" && parse(backgroundColor$1);
		if (!colorArr) colorArr = [
			255,
			255,
			255,
			1
		];
		var alpha = colorArr[3];
		var isDark = this.__zr.isDarkMode();
		for (var i$1 = 0; i$1 < 3; i$1++) colorArr[i$1] = colorArr[i$1] * alpha + (isDark ? 0 : 255) * (1 - alpha);
		colorArr[3] = 1;
		return stringify(colorArr, "rgba");
	};
	Element$1.prototype.traverse = function(cb, context) {};
	Element$1.prototype.attrKV = function(key$1, value) {
		if (key$1 === "textConfig") this.setTextConfig(value);
		else if (key$1 === "textContent") this.setTextContent(value);
		else if (key$1 === "clipPath") this.setClipPath(value);
		else if (key$1 === "extra") {
			this.extra = this.extra || {};
			extend(this.extra, value);
		} else this[key$1] = value;
	};
	Element$1.prototype.hide = function() {
		this.ignore = true;
		this.markRedraw();
	};
	Element$1.prototype.show = function() {
		this.ignore = false;
		this.markRedraw();
	};
	Element$1.prototype.attr = function(keyOrObj, value) {
		if (typeof keyOrObj === "string") this.attrKV(keyOrObj, value);
		else if (isObject(keyOrObj)) {
			var keysArr = keys(keyOrObj);
			for (var i$1 = 0; i$1 < keysArr.length; i$1++) {
				var key$1 = keysArr[i$1];
				this.attrKV(key$1, keyOrObj[key$1]);
			}
		}
		this.markRedraw();
		return this;
	};
	Element$1.prototype.saveCurrentToNormalState = function(toState) {
		this._innerSaveToNormal(toState);
		var normalState = this._normalState;
		for (var i$1 = 0; i$1 < this.animators.length; i$1++) {
			var animator = this.animators[i$1];
			var fromStateTransition = animator.__fromStateTransition;
			if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) continue;
			var targetName = animator.targetName;
			var target = targetName ? normalState[targetName] : normalState;
			animator.saveTo(target);
		}
	};
	Element$1.prototype._innerSaveToNormal = function(toState) {
		var normalState = this._normalState;
		if (!normalState) normalState = this._normalState = {};
		if (toState.textConfig && !normalState.textConfig) normalState.textConfig = this.textConfig;
		this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS$1);
	};
	Element$1.prototype._savePrimaryToNormal = function(toState, normalState, primaryKeys) {
		for (var i$1 = 0; i$1 < primaryKeys.length; i$1++) {
			var key$1 = primaryKeys[i$1];
			if (toState[key$1] != null && !(key$1 in normalState)) normalState[key$1] = this[key$1];
		}
	};
	Element$1.prototype.hasState = function() {
		return this.currentStates.length > 0;
	};
	Element$1.prototype.getState = function(name) {
		return this.states[name];
	};
	Element$1.prototype.ensureState = function(name) {
		var states = this.states;
		if (!states[name]) states[name] = {};
		return states[name];
	};
	Element$1.prototype.clearStates = function(noAnimation) {
		this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
	};
	Element$1.prototype.useState = function(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
		var toNormalState = stateName === PRESERVED_NORMAL_STATE;
		if (!this.hasState() && toNormalState) return;
		var currentStates = this.currentStates;
		var animationCfg = this.stateTransition;
		if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) return;
		var state;
		if (this.stateProxy && !toNormalState) state = this.stateProxy(stateName);
		if (!state) state = this.states && this.states[stateName];
		if (!state && !toNormalState) {
			logError("State " + stateName + " not exists.");
			return;
		}
		if (!toNormalState) this.saveCurrentToNormalState(state);
		var useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
		if (useHoverLayer) this._toggleHoverLayerFlag(true);
		this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
		var textContent = this._textContent;
		var textGuide = this._textGuide;
		if (textContent) textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
		if (textGuide) textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
		if (toNormalState) {
			this.currentStates = [];
			this._normalState = {};
		} else if (!keepCurrentStates) this.currentStates = [stateName];
		else this.currentStates.push(stateName);
		this._updateAnimationTargets();
		this.markRedraw();
		if (!useHoverLayer && this.__inHover) {
			this._toggleHoverLayerFlag(false);
			this.__dirty &= ~REDRAW_BIT;
		}
		return state;
	};
	Element$1.prototype.useStates = function(states, noAnimation, forceUseHoverLayer) {
		if (!states.length) this.clearStates();
		else {
			var stateObjects = [];
			var currentStates = this.currentStates;
			var len$1 = states.length;
			var notChange = len$1 === currentStates.length;
			if (notChange) {
				for (var i$1 = 0; i$1 < len$1; i$1++) if (states[i$1] !== currentStates[i$1]) {
					notChange = false;
					break;
				}
			}
			if (notChange) return;
			for (var i$1 = 0; i$1 < len$1; i$1++) {
				var stateName = states[i$1];
				var stateObj = void 0;
				if (this.stateProxy) stateObj = this.stateProxy(stateName, states);
				if (!stateObj) stateObj = this.states[stateName];
				if (stateObj) stateObjects.push(stateObj);
			}
			var lastStateObj = stateObjects[len$1 - 1];
			var useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
			if (useHoverLayer) this._toggleHoverLayerFlag(true);
			var mergedState = this._mergeStates(stateObjects);
			var animationCfg = this.stateTransition;
			this.saveCurrentToNormalState(mergedState);
			this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
			var textContent = this._textContent;
			var textGuide = this._textGuide;
			if (textContent) textContent.useStates(states, noAnimation, useHoverLayer);
			if (textGuide) textGuide.useStates(states, noAnimation, useHoverLayer);
			this._updateAnimationTargets();
			this.currentStates = states.slice();
			this.markRedraw();
			if (!useHoverLayer && this.__inHover) {
				this._toggleHoverLayerFlag(false);
				this.__dirty &= ~REDRAW_BIT;
			}
		}
	};
	Element$1.prototype.isSilent = function() {
		var el = this;
		while (el) {
			if (el.silent) return true;
			var hostEl = el.__hostTarget;
			el = hostEl ? el.ignoreHostSilent ? null : hostEl : el.parent;
		}
		return false;
	};
	Element$1.prototype._updateAnimationTargets = function() {
		for (var i$1 = 0; i$1 < this.animators.length; i$1++) {
			var animator = this.animators[i$1];
			if (animator.targetName) animator.changeTarget(this[animator.targetName]);
		}
	};
	Element$1.prototype.removeState = function(state) {
		var idx = indexOf(this.currentStates, state);
		if (idx >= 0) {
			var currentStates = this.currentStates.slice();
			currentStates.splice(idx, 1);
			this.useStates(currentStates);
		}
	};
	Element$1.prototype.replaceState = function(oldState, newState, forceAdd) {
		var currentStates = this.currentStates.slice();
		var idx = indexOf(currentStates, oldState);
		var newStateExists = indexOf(currentStates, newState) >= 0;
		if (idx >= 0) if (!newStateExists) currentStates[idx] = newState;
		else currentStates.splice(idx, 1);
		else if (forceAdd && !newStateExists) currentStates.push(newState);
		this.useStates(currentStates);
	};
	Element$1.prototype.toggleState = function(state, enable) {
		if (enable) this.useState(state, true);
		else this.removeState(state);
	};
	Element$1.prototype._mergeStates = function(states) {
		var mergedState = {};
		var mergedTextConfig;
		for (var i$1 = 0; i$1 < states.length; i$1++) {
			var state = states[i$1];
			extend(mergedState, state);
			if (state.textConfig) {
				mergedTextConfig = mergedTextConfig || {};
				extend(mergedTextConfig, state.textConfig);
			}
		}
		if (mergedTextConfig) mergedState.textConfig = mergedTextConfig;
		return mergedState;
	};
	Element$1.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
		var needsRestoreToNormal = !(state && keepCurrentStates);
		if (state && state.textConfig) {
			this.textConfig = extend({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
			extend(this.textConfig, state.textConfig);
		} else if (needsRestoreToNormal) {
			if (normalState.textConfig) this.textConfig = normalState.textConfig;
		}
		var transitionTarget = {};
		var hasTransition = false;
		for (var i$1 = 0; i$1 < PRIMARY_STATES_KEYS$1.length; i$1++) {
			var key$1 = PRIMARY_STATES_KEYS$1[i$1];
			var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key$1];
			if (state && state[key$1] != null) if (propNeedsTransition) {
				hasTransition = true;
				transitionTarget[key$1] = state[key$1];
			} else this[key$1] = state[key$1];
			else if (needsRestoreToNormal) {
				if (normalState[key$1] != null) if (propNeedsTransition) {
					hasTransition = true;
					transitionTarget[key$1] = normalState[key$1];
				} else this[key$1] = normalState[key$1];
			}
		}
		if (!transition) for (var i$1 = 0; i$1 < this.animators.length; i$1++) {
			var animator = this.animators[i$1];
			var targetName = animator.targetName;
			if (!animator.getLoop()) animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
		}
		if (hasTransition) this._transitionState(stateName, transitionTarget, animationCfg);
	};
	Element$1.prototype._attachComponent = function(componentEl) {
		if (componentEl.__zr && !componentEl.__hostTarget) throw new Error("Text element has been added to zrender.");
		if (componentEl === this) throw new Error("Recursive component attachment.");
		var zr = this.__zr;
		if (zr) componentEl.addSelfToZr(zr);
		componentEl.__zr = zr;
		componentEl.__hostTarget = this;
	};
	Element$1.prototype._detachComponent = function(componentEl) {
		if (componentEl.__zr) componentEl.removeSelfFromZr(componentEl.__zr);
		componentEl.__zr = null;
		componentEl.__hostTarget = null;
	};
	Element$1.prototype.getClipPath = function() {
		return this._clipPath;
	};
	Element$1.prototype.setClipPath = function(clipPath) {
		if (this._clipPath && this._clipPath !== clipPath) this.removeClipPath();
		this._attachComponent(clipPath);
		this._clipPath = clipPath;
		this.markRedraw();
	};
	Element$1.prototype.removeClipPath = function() {
		var clipPath = this._clipPath;
		if (clipPath) {
			this._detachComponent(clipPath);
			this._clipPath = null;
			this.markRedraw();
		}
	};
	Element$1.prototype.getTextContent = function() {
		return this._textContent;
	};
	Element$1.prototype.setTextContent = function(textEl) {
		var previousTextContent = this._textContent;
		if (previousTextContent === textEl) return;
		if (previousTextContent && previousTextContent !== textEl) this.removeTextContent();
		if (textEl.__zr && !textEl.__hostTarget) throw new Error("Text element has been added to zrender.");
		textEl.innerTransformable = new Transformable_default();
		this._attachComponent(textEl);
		this._textContent = textEl;
		this.markRedraw();
	};
	Element$1.prototype.setTextConfig = function(cfg) {
		if (!this.textConfig) this.textConfig = {};
		extend(this.textConfig, cfg);
		this.markRedraw();
	};
	Element$1.prototype.removeTextConfig = function() {
		this.textConfig = null;
		this.markRedraw();
	};
	Element$1.prototype.removeTextContent = function() {
		var textEl = this._textContent;
		if (textEl) {
			textEl.innerTransformable = null;
			this._detachComponent(textEl);
			this._textContent = null;
			this._innerTextDefaultStyle = null;
			this.markRedraw();
		}
	};
	Element$1.prototype.getTextGuideLine = function() {
		return this._textGuide;
	};
	Element$1.prototype.setTextGuideLine = function(guideLine) {
		if (this._textGuide && this._textGuide !== guideLine) this.removeTextGuideLine();
		this._attachComponent(guideLine);
		this._textGuide = guideLine;
		this.markRedraw();
	};
	Element$1.prototype.removeTextGuideLine = function() {
		var textGuide = this._textGuide;
		if (textGuide) {
			this._detachComponent(textGuide);
			this._textGuide = null;
			this.markRedraw();
		}
	};
	Element$1.prototype.markRedraw = function() {
		this.__dirty |= REDRAW_BIT;
		var zr = this.__zr;
		if (zr) if (this.__inHover) zr.refreshHover();
		else zr.refresh();
		if (this.__hostTarget) this.__hostTarget.markRedraw();
	};
	Element$1.prototype.dirty = function() {
		this.markRedraw();
	};
	Element$1.prototype._toggleHoverLayerFlag = function(inHover) {
		this.__inHover = inHover;
		var textContent = this._textContent;
		var textGuide = this._textGuide;
		if (textContent) textContent.__inHover = inHover;
		if (textGuide) textGuide.__inHover = inHover;
	};
	Element$1.prototype.addSelfToZr = function(zr) {
		if (this.__zr === zr) return;
		this.__zr = zr;
		var animators = this.animators;
		if (animators) for (var i$1 = 0; i$1 < animators.length; i$1++) zr.animation.addAnimator(animators[i$1]);
		if (this._clipPath) this._clipPath.addSelfToZr(zr);
		if (this._textContent) this._textContent.addSelfToZr(zr);
		if (this._textGuide) this._textGuide.addSelfToZr(zr);
	};
	Element$1.prototype.removeSelfFromZr = function(zr) {
		if (!this.__zr) return;
		this.__zr = null;
		var animators = this.animators;
		if (animators) for (var i$1 = 0; i$1 < animators.length; i$1++) zr.animation.removeAnimator(animators[i$1]);
		if (this._clipPath) this._clipPath.removeSelfFromZr(zr);
		if (this._textContent) this._textContent.removeSelfFromZr(zr);
		if (this._textGuide) this._textGuide.removeSelfFromZr(zr);
	};
	Element$1.prototype.animate = function(key$1, loop, allowDiscreteAnimation) {
		var target = key$1 ? this[key$1] : this;
		if (!target) {
			logError("Property \"" + key$1 + "\" is not existed in element " + this.id);
			return;
		}
		var animator = new Animator_default(target, loop, allowDiscreteAnimation);
		key$1 && (animator.targetName = key$1);
		this.addAnimator(animator, key$1);
		return animator;
	};
	Element$1.prototype.addAnimator = function(animator, key$1) {
		var zr = this.__zr;
		var el = this;
		animator.during(function() {
			el.updateDuringAnimation(key$1);
		}).done(function() {
			var animators = el.animators;
			var idx = indexOf(animators, animator);
			if (idx >= 0) animators.splice(idx, 1);
		});
		this.animators.push(animator);
		if (zr) zr.animation.addAnimator(animator);
		zr && zr.wakeUp();
	};
	Element$1.prototype.updateDuringAnimation = function(key$1) {
		this.markRedraw();
	};
	Element$1.prototype.stopAnimation = function(scope, forwardToLast) {
		var animators = this.animators;
		var len$1 = animators.length;
		var leftAnimators = [];
		for (var i$1 = 0; i$1 < len$1; i$1++) {
			var animator = animators[i$1];
			if (!scope || scope === animator.scope) animator.stop(forwardToLast);
			else leftAnimators.push(animator);
		}
		this.animators = leftAnimators;
		return this;
	};
	Element$1.prototype.animateTo = function(target, cfg, animationProps) {
		animateTo(this, target, cfg, animationProps);
	};
	Element$1.prototype.animateFrom = function(target, cfg, animationProps) {
		animateTo(this, target, cfg, animationProps, true);
	};
	Element$1.prototype._transitionState = function(stateName, target, cfg, animationProps) {
		var animators = animateTo(this, target, cfg, animationProps);
		for (var i$1 = 0; i$1 < animators.length; i$1++) animators[i$1].__fromStateTransition = stateName;
	};
	Element$1.prototype.getBoundingRect = function() {
		return null;
	};
	Element$1.prototype.getPaintRect = function() {
		return null;
	};
	Element$1.initDefaultProps = (function() {
		var elProto = Element$1.prototype;
		elProto.type = "element";
		elProto.name = "";
		elProto.ignore = elProto.silent = elProto.ignoreHostSilent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
		elProto.__dirty = REDRAW_BIT;
		var logs = {};
		function logDeprecatedError(key$1, xKey, yKey) {
			if (!logs[key$1 + xKey + yKey]) {
				console.warn("DEPRECATED: '" + key$1 + "' has been deprecated. use '" + xKey + "', '" + yKey + "' instead");
				logs[key$1 + xKey + yKey] = true;
			}
		}
		function createLegacyProperty(key$1, privateKey, xKey, yKey) {
			Object.defineProperty(elProto, key$1, {
				get: function() {
					logDeprecatedError(key$1, xKey, yKey);
					if (!this[privateKey]) {
						var pos = this[privateKey] = [];
						enhanceArray(this, pos);
					}
					return this[privateKey];
				},
				set: function(pos) {
					logDeprecatedError(key$1, xKey, yKey);
					this[xKey] = pos[0];
					this[yKey] = pos[1];
					this[privateKey] = pos;
					enhanceArray(this, pos);
				}
			});
			function enhanceArray(self$1, pos) {
				Object.defineProperty(pos, 0, {
					get: function() {
						return self$1[xKey];
					},
					set: function(val) {
						self$1[xKey] = val;
					}
				});
				Object.defineProperty(pos, 1, {
					get: function() {
						return self$1[yKey];
					},
					set: function(val) {
						self$1[yKey] = val;
					}
				});
			}
		}
		if (Object.defineProperty) {
			createLegacyProperty("position", "_legacyPos", "x", "y");
			createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
			createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
		}
	})();
	return Element$1;
}();
mixin(Element, Eventful_default);
mixin(Element, Transformable_default);
function animateTo(animatable, target, cfg, animationProps, reverse$1) {
	cfg = cfg || {};
	var animators = [];
	animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse$1);
	var finishCount = animators.length;
	var doneHappened = false;
	var cfgDone = cfg.done;
	var cfgAborted = cfg.aborted;
	var doneCb = function() {
		doneHappened = true;
		finishCount--;
		if (finishCount <= 0) doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
	};
	var abortedCb = function() {
		finishCount--;
		if (finishCount <= 0) doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
	};
	if (!finishCount) cfgDone && cfgDone();
	if (animators.length > 0 && cfg.during) animators[0].during(function(target$1, percent) {
		cfg.during(percent);
	});
	for (var i$1 = 0; i$1 < animators.length; i$1++) {
		var animator = animators[i$1];
		if (doneCb) animator.done(doneCb);
		if (abortedCb) animator.aborted(abortedCb);
		if (cfg.force) animator.duration(cfg.duration);
		animator.start(cfg.easing);
	}
	return animators;
}
function copyArrShallow(source, target, len$1) {
	for (var i$1 = 0; i$1 < len$1; i$1++) source[i$1] = target[i$1];
}
function is2DArray(value) {
	return isArrayLike(value[0]);
}
function copyValue(target, source, key$1) {
	if (isArrayLike(source[key$1])) {
		if (!isArrayLike(target[key$1])) target[key$1] = [];
		if (isTypedArray(source[key$1])) {
			var len$1 = source[key$1].length;
			if (target[key$1].length !== len$1) {
				target[key$1] = new source[key$1].constructor(len$1);
				copyArrShallow(target[key$1], source[key$1], len$1);
			}
		} else {
			var sourceArr = source[key$1];
			var targetArr = target[key$1];
			var len0 = sourceArr.length;
			if (is2DArray(sourceArr)) {
				var len1 = sourceArr[0].length;
				for (var i$1 = 0; i$1 < len0; i$1++) if (!targetArr[i$1]) targetArr[i$1] = Array.prototype.slice.call(sourceArr[i$1]);
				else copyArrShallow(targetArr[i$1], sourceArr[i$1], len1);
			} else copyArrShallow(targetArr, sourceArr, len0);
			targetArr.length = sourceArr.length;
		}
	} else target[key$1] = source[key$1];
}
function isValueSame(val1, val2) {
	return val1 === val2 || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);
}
function is1DArraySame(arr0, arr1) {
	var len$1 = arr0.length;
	if (len$1 !== arr1.length) return false;
	for (var i$1 = 0; i$1 < len$1; i$1++) if (arr0[i$1] !== arr1[i$1]) return false;
	return true;
}
function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse$1) {
	var targetKeys = keys(target);
	var duration = cfg.duration;
	var delay = cfg.delay;
	var additive = cfg.additive;
	var setToFinal = cfg.setToFinal;
	var animateAll = !isObject(animationProps);
	var existsAnimators = animatable.animators;
	var animationKeys = [];
	for (var k$1 = 0; k$1 < targetKeys.length; k$1++) {
		var innerKey = targetKeys[k$1];
		var targetVal = target[innerKey];
		if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) if (isObject(targetVal) && !isArrayLike(targetVal) && !isGradientObject(targetVal)) {
			if (topKey) {
				if (!reverse$1) {
					animateObj[innerKey] = targetVal;
					animatable.updateDuringAnimation(topKey);
				}
				continue;
			}
			animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse$1);
		} else animationKeys.push(innerKey);
		else if (!reverse$1) {
			animateObj[innerKey] = targetVal;
			animatable.updateDuringAnimation(topKey);
			animationKeys.push(innerKey);
		}
	}
	var keyLen = animationKeys.length;
	if (!additive && keyLen) for (var i$1 = 0; i$1 < existsAnimators.length; i$1++) {
		var animator = existsAnimators[i$1];
		if (animator.targetName === topKey) {
			if (animator.stopTracks(animationKeys)) {
				var idx = indexOf(existsAnimators, animator);
				existsAnimators.splice(idx, 1);
			}
		}
	}
	if (!cfg.force) {
		animationKeys = filter(animationKeys, function(key$1) {
			return !isValueSame(target[key$1], animateObj[key$1]);
		});
		keyLen = animationKeys.length;
	}
	if (keyLen > 0 || cfg.force && !animators.length) {
		var revertedSource = void 0;
		var reversedTarget = void 0;
		var sourceClone = void 0;
		if (reverse$1) {
			reversedTarget = {};
			if (setToFinal) revertedSource = {};
			for (var i$1 = 0; i$1 < keyLen; i$1++) {
				var innerKey = animationKeys[i$1];
				reversedTarget[innerKey] = animateObj[innerKey];
				if (setToFinal) revertedSource[innerKey] = target[innerKey];
				else animateObj[innerKey] = target[innerKey];
			}
		} else if (setToFinal) {
			sourceClone = {};
			for (var i$1 = 0; i$1 < keyLen; i$1++) {
				var innerKey = animationKeys[i$1];
				sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
				copyValue(animateObj, target, innerKey);
			}
		}
		var animator = new Animator_default(animateObj, false, false, additive ? filter(existsAnimators, function(animator$1) {
			return animator$1.targetName === topKey;
		}) : null);
		animator.targetName = topKey;
		if (cfg.scope) animator.scope = cfg.scope;
		if (setToFinal && revertedSource) animator.whenWithKeys(0, revertedSource, animationKeys);
		if (sourceClone) animator.whenWithKeys(0, sourceClone, animationKeys);
		animator.whenWithKeys(duration == null ? 500 : duration, reverse$1 ? reversedTarget : target, animationKeys).delay(delay || 0);
		animatable.addAnimator(animator, topKey);
		animators.push(animator);
	}
}
var Element_default = Element;

//#endregion
//#region node_modules/zrender/lib/graphic/Group.js
var Group$3 = function(_super) {
	__extends$1(Group$4, _super);
	function Group$4(opts) {
		var _this = _super.call(this) || this;
		_this.isGroup = true;
		_this._children = [];
		_this.attr(opts);
		return _this;
	}
	Group$4.prototype.childrenRef = function() {
		return this._children;
	};
	Group$4.prototype.children = function() {
		return this._children.slice();
	};
	Group$4.prototype.childAt = function(idx) {
		return this._children[idx];
	};
	Group$4.prototype.childOfName = function(name) {
		var children = this._children;
		for (var i$1 = 0; i$1 < children.length; i$1++) if (children[i$1].name === name) return children[i$1];
	};
	Group$4.prototype.childCount = function() {
		return this._children.length;
	};
	Group$4.prototype.add = function(child) {
		if (child) {
			if (child !== this && child.parent !== this) {
				this._children.push(child);
				this._doAdd(child);
			}
			if (child.__hostTarget) throw "This elemenet has been used as an attachment";
		}
		return this;
	};
	Group$4.prototype.addBefore = function(child, nextSibling$1) {
		if (child && child !== this && child.parent !== this && nextSibling$1 && nextSibling$1.parent === this) {
			var children = this._children;
			var idx = children.indexOf(nextSibling$1);
			if (idx >= 0) {
				children.splice(idx, 0, child);
				this._doAdd(child);
			}
		}
		return this;
	};
	Group$4.prototype.replace = function(oldChild, newChild) {
		var idx = indexOf(this._children, oldChild);
		if (idx >= 0) this.replaceAt(newChild, idx);
		return this;
	};
	Group$4.prototype.replaceAt = function(child, index) {
		var children = this._children;
		var old = children[index];
		if (child && child !== this && child.parent !== this && child !== old) {
			children[index] = child;
			old.parent = null;
			var zr = this.__zr;
			if (zr) old.removeSelfFromZr(zr);
			this._doAdd(child);
		}
		return this;
	};
	Group$4.prototype._doAdd = function(child) {
		if (child.parent) child.parent.remove(child);
		child.parent = this;
		var zr = this.__zr;
		if (zr && zr !== child.__zr) child.addSelfToZr(zr);
		zr && zr.refresh();
	};
	Group$4.prototype.remove = function(child) {
		var zr = this.__zr;
		var children = this._children;
		var idx = indexOf(children, child);
		if (idx < 0) return this;
		children.splice(idx, 1);
		child.parent = null;
		if (zr) child.removeSelfFromZr(zr);
		zr && zr.refresh();
		return this;
	};
	Group$4.prototype.removeAll = function() {
		var children = this._children;
		var zr = this.__zr;
		for (var i$1 = 0; i$1 < children.length; i$1++) {
			var child = children[i$1];
			if (zr) child.removeSelfFromZr(zr);
			child.parent = null;
		}
		children.length = 0;
		return this;
	};
	Group$4.prototype.eachChild = function(cb, context) {
		var children = this._children;
		for (var i$1 = 0; i$1 < children.length; i$1++) {
			var child = children[i$1];
			cb.call(context, child, i$1);
		}
		return this;
	};
	Group$4.prototype.traverse = function(cb, context) {
		for (var i$1 = 0; i$1 < this._children.length; i$1++) {
			var child = this._children[i$1];
			var stopped = cb.call(context, child);
			if (child.isGroup && !stopped) child.traverse(cb, context);
		}
		return this;
	};
	Group$4.prototype.addSelfToZr = function(zr) {
		_super.prototype.addSelfToZr.call(this, zr);
		for (var i$1 = 0; i$1 < this._children.length; i$1++) this._children[i$1].addSelfToZr(zr);
	};
	Group$4.prototype.removeSelfFromZr = function(zr) {
		_super.prototype.removeSelfFromZr.call(this, zr);
		for (var i$1 = 0; i$1 < this._children.length; i$1++) this._children[i$1].removeSelfFromZr(zr);
	};
	Group$4.prototype.getBoundingRect = function(includeChildren) {
		var tmpRect$2 = new BoundingRect_default(0, 0, 0, 0);
		var children = includeChildren || this._children;
		var tmpMat = [];
		var rect = null;
		for (var i$1 = 0; i$1 < children.length; i$1++) {
			var child = children[i$1];
			if (child.ignore || child.invisible) continue;
			var childRect = child.getBoundingRect();
			var transform = child.getLocalTransform(tmpMat);
			if (transform) {
				BoundingRect_default.applyTransform(tmpRect$2, childRect, transform);
				rect = rect || tmpRect$2.clone();
				rect.union(tmpRect$2);
			} else {
				rect = rect || childRect.clone();
				rect.union(childRect);
			}
		}
		return rect || tmpRect$2;
	};
	return Group$4;
}(Element_default);
Group$3.prototype.type = "group";
var Group_default = Group$3;

//#endregion
//#region node_modules/zrender/lib/zrender.js
var zrender_exports = /* @__PURE__ */ __export({
	dispose: () => dispose$1,
	disposeAll: () => disposeAll,
	getElementSSRData: () => getElementSSRData,
	getInstance: () => getInstance,
	init: () => init$2,
	registerPainter: () => registerPainter,
	registerSSRDataGetter: () => registerSSRDataGetter,
	version: () => version$1
});
var painterCtors = {};
var instances$1 = {};
function delInstance(id) {
	delete instances$1[id];
}
function isDarkMode(backgroundColor$1) {
	if (!backgroundColor$1) return false;
	if (typeof backgroundColor$1 === "string") return lum(backgroundColor$1, 1) < DARK_MODE_THRESHOLD;
	else if (backgroundColor$1.colorStops) {
		var colorStops = backgroundColor$1.colorStops;
		var totalLum = 0;
		var len$1 = colorStops.length;
		for (var i$1 = 0; i$1 < len$1; i$1++) totalLum += lum(colorStops[i$1].color, 1);
		totalLum /= len$1;
		return totalLum < DARK_MODE_THRESHOLD;
	}
	return false;
}
var ZRender = function() {
	function ZRender$1(id, dom, opts) {
		var _this = this;
		this._sleepAfterStill = 10;
		this._stillFrameAccum = 0;
		this._needsRefresh = true;
		this._needsRefreshHover = true;
		this._darkMode = false;
		opts = opts || {};
		this.dom = dom;
		this.id = id;
		var storage$1 = new Storage_default();
		var rendererType = opts.renderer || "canvas";
		if (!painterCtors[rendererType]) rendererType = keys(painterCtors)[0];
		if (!painterCtors[rendererType]) throw new Error("Renderer '" + rendererType + "' is not imported. Please import it first.");
		opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
		var painter = new painterCtors[rendererType](dom, storage$1, opts, id);
		var ssrMode = opts.ssr || painter.ssrOnly;
		this.storage = storage$1;
		this.painter = painter;
		var handlerProxy = !env_default.node && !env_default.worker && !ssrMode ? new HandlerProxy_default(painter.getViewportRoot(), painter.root) : null;
		var useCoarsePointer = opts.useCoarsePointer;
		var usePointerSize = useCoarsePointer == null || useCoarsePointer === "auto" ? env_default.touchEventsSupported : !!useCoarsePointer;
		var defaultPointerSize = 44;
		var pointerSize;
		if (usePointerSize) pointerSize = retrieve2(opts.pointerSize, defaultPointerSize);
		this.handler = new Handler_default(storage$1, painter, handlerProxy, painter.root, pointerSize);
		this.animation = new Animation_default({ stage: { update: ssrMode ? null : function() {
			return _this._flush(true);
		} } });
		if (!ssrMode) this.animation.start();
	}
	ZRender$1.prototype.add = function(el) {
		if (this._disposed || !el) return;
		this.storage.addRoot(el);
		el.addSelfToZr(this);
		this.refresh();
	};
	ZRender$1.prototype.remove = function(el) {
		if (this._disposed || !el) return;
		this.storage.delRoot(el);
		el.removeSelfFromZr(this);
		this.refresh();
	};
	ZRender$1.prototype.configLayer = function(zLevel, config) {
		if (this._disposed) return;
		if (this.painter.configLayer) this.painter.configLayer(zLevel, config);
		this.refresh();
	};
	ZRender$1.prototype.setBackgroundColor = function(backgroundColor$1) {
		if (this._disposed) return;
		if (this.painter.setBackgroundColor) this.painter.setBackgroundColor(backgroundColor$1);
		this.refresh();
		this._backgroundColor = backgroundColor$1;
		this._darkMode = isDarkMode(backgroundColor$1);
	};
	ZRender$1.prototype.getBackgroundColor = function() {
		return this._backgroundColor;
	};
	ZRender$1.prototype.setDarkMode = function(darkMode) {
		this._darkMode = darkMode;
	};
	ZRender$1.prototype.isDarkMode = function() {
		return this._darkMode;
	};
	ZRender$1.prototype.refreshImmediately = function(fromInside) {
		if (this._disposed) return;
		if (!fromInside) this.animation.update(true);
		this._needsRefresh = false;
		this.painter.refresh();
		this._needsRefresh = false;
	};
	ZRender$1.prototype.refresh = function() {
		if (this._disposed) return;
		this._needsRefresh = true;
		this.animation.start();
	};
	ZRender$1.prototype.flush = function() {
		if (this._disposed) return;
		this._flush(false);
	};
	ZRender$1.prototype._flush = function(fromInside) {
		var triggerRendered;
		var start$1 = getTime();
		if (this._needsRefresh) {
			triggerRendered = true;
			this.refreshImmediately(fromInside);
		}
		if (this._needsRefreshHover) {
			triggerRendered = true;
			this.refreshHoverImmediately();
		}
		var end$1 = getTime();
		if (triggerRendered) {
			this._stillFrameAccum = 0;
			this.trigger("rendered", { elapsedTime: end$1 - start$1 });
		} else if (this._sleepAfterStill > 0) {
			this._stillFrameAccum++;
			if (this._stillFrameAccum > this._sleepAfterStill) this.animation.stop();
		}
	};
	ZRender$1.prototype.setSleepAfterStill = function(stillFramesCount) {
		this._sleepAfterStill = stillFramesCount;
	};
	ZRender$1.prototype.wakeUp = function() {
		if (this._disposed) return;
		this.animation.start();
		this._stillFrameAccum = 0;
	};
	ZRender$1.prototype.refreshHover = function() {
		this._needsRefreshHover = true;
	};
	ZRender$1.prototype.refreshHoverImmediately = function() {
		if (this._disposed) return;
		this._needsRefreshHover = false;
		if (this.painter.refreshHover && this.painter.getType() === "canvas") this.painter.refreshHover();
	};
	ZRender$1.prototype.resize = function(opts) {
		if (this._disposed) return;
		opts = opts || {};
		this.painter.resize(opts.width, opts.height);
		this.handler.resize();
	};
	ZRender$1.prototype.clearAnimation = function() {
		if (this._disposed) return;
		this.animation.clear();
	};
	ZRender$1.prototype.getWidth = function() {
		if (this._disposed) return;
		return this.painter.getWidth();
	};
	ZRender$1.prototype.getHeight = function() {
		if (this._disposed) return;
		return this.painter.getHeight();
	};
	ZRender$1.prototype.setCursorStyle = function(cursorStyle) {
		if (this._disposed) return;
		this.handler.setCursorStyle(cursorStyle);
	};
	ZRender$1.prototype.findHover = function(x, y) {
		if (this._disposed) return;
		return this.handler.findHover(x, y);
	};
	ZRender$1.prototype.on = function(eventName, eventHandler, context) {
		if (!this._disposed) this.handler.on(eventName, eventHandler, context);
		return this;
	};
	ZRender$1.prototype.off = function(eventName, eventHandler) {
		if (this._disposed) return;
		this.handler.off(eventName, eventHandler);
	};
	ZRender$1.prototype.trigger = function(eventName, event) {
		if (this._disposed) return;
		this.handler.trigger(eventName, event);
	};
	ZRender$1.prototype.clear = function() {
		if (this._disposed) return;
		var roots$1 = this.storage.getRoots();
		for (var i$1 = 0; i$1 < roots$1.length; i$1++) if (roots$1[i$1] instanceof Group_default) roots$1[i$1].removeSelfFromZr(this);
		this.storage.delAllRoots();
		this.painter.clear();
	};
	ZRender$1.prototype.dispose = function() {
		if (this._disposed) return;
		this.animation.stop();
		this.clear();
		this.storage.dispose();
		this.painter.dispose();
		this.handler.dispose();
		this.animation = this.storage = this.painter = this.handler = null;
		this._disposed = true;
		delInstance(this.id);
	};
	return ZRender$1;
}();
function init$2(dom, opts) {
	var zr = new ZRender(guid(), dom, opts);
	instances$1[zr.id] = zr;
	return zr;
}
function dispose$1(zr) {
	zr.dispose();
}
function disposeAll() {
	for (var key$1 in instances$1) if (instances$1.hasOwnProperty(key$1)) instances$1[key$1].dispose();
	instances$1 = {};
}
function getInstance(id) {
	return instances$1[id];
}
function registerPainter(name, Ctor) {
	painterCtors[name] = Ctor;
}
var ssrDataGetter;
function getElementSSRData(el) {
	if (typeof ssrDataGetter === "function") return ssrDataGetter(el);
}
function registerSSRDataGetter(getter) {
	ssrDataGetter = getter;
}
var version$1 = "6.0.0";

//#endregion
//#region node_modules/echarts/lib/util/number.js
var RADIAN_EPSILON = 1e-4;
var ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(str) {
	return str.replace(/^\s+|\s+$/g, "");
}
var mathMin$1 = Math.min;
var mathMax$1 = Math.max;
var mathAbs$1 = Math.abs;
/**
* Linear mapping a value from domain to range
* @param  val
* @param  domain Domain extent domain[0] can be bigger than domain[1]
* @param  range  Range extent range[0] can be bigger than range[1]
* @param  clamp Default to be false
*/
function linearMap$2(val, domain, range, clamp$1) {
	var d0 = domain[0];
	var d1 = domain[1];
	var r0 = range[0];
	var r1 = range[1];
	var subDomain = d1 - d0;
	var subRange = r1 - r0;
	if (subDomain === 0) return subRange === 0 ? r0 : (r0 + r1) / 2;
	if (clamp$1) {
		if (subDomain > 0) {
			if (val <= d0) return r0;
			else if (val >= d1) return r1;
		} else if (val >= d0) return r0;
		else if (val <= d1) return r1;
	} else {
		if (val === d0) return r0;
		if (val === d1) return r1;
	}
	return (val - d0) / subDomain * subRange + r0;
}
/**
* Preserve the name `parsePercent` for backward compatibility,
* and it's effectively published as `echarts.number.parsePercent`.
*/
var parsePercent$1 = parsePositionOption;
/**
* @see {parsePositionSizeOption} and also accept a string preset.
* @see {PositionSizeOption}
*/
function parsePositionOption(option, percentBase, percentOffset) {
	switch (option) {
		case "center":
		case "middle":
			option = "50%";
			break;
		case "left":
		case "top":
			option = "0%";
			break;
		case "right":
		case "bottom":
			option = "100%";
			break;
	}
	return parsePositionSizeOption(option, percentBase, percentOffset);
}
/**
* Accept number, or numeric stirng (`'123'`), or percentage ('100%'), as x/y/width/height pixel number.
* If null/undefined or invalid, return NaN.
* (But allow JS type coercion (`+option`) due to backward compatibility)
* @see {PositionSizeOption}
*/
function parsePositionSizeOption(option, percentBase, percentOffset) {
	if (isString(option)) {
		if (_trim(option).match(/%$/)) return parseFloat(option) / 100 * percentBase + (percentOffset || 0);
		return parseFloat(option);
	}
	return option == null ? NaN : +option;
}
function round(x, precision, returnStr) {
	if (precision == null) precision = 10;
	precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
	x = (+x).toFixed(precision);
	return returnStr ? x : +x;
}
/**
* Inplacd asc sort arr.
* The input arr will be modified.
*/
function asc$1(arr) {
	arr.sort(function(a, b) {
		return a - b;
	});
	return arr;
}
/**
* Get precision.
*/
function getPrecision(val) {
	val = +val;
	if (isNaN(val)) return 0;
	if (val > 1e-14) {
		var e$1 = 1;
		for (var i$1 = 0; i$1 < 15; i$1++, e$1 *= 10) if (Math.round(val * e$1) / e$1 === val) return i$1;
	}
	return getPrecisionSafe(val);
}
/**
* Get precision with slow but safe method
*/
function getPrecisionSafe(val) {
	var str = val.toString().toLowerCase();
	var eIndex = str.indexOf("e");
	var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
	var significandPartLen = eIndex > 0 ? eIndex : str.length;
	var dotIndex = str.indexOf(".");
	var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
	return Math.max(0, decimalPartLen - exp);
}
/**
* Minimal dicernible data precisioin according to a single pixel.
*/
function getPixelPrecision(dataExtent, pixelExtent) {
	var log$1 = Math.log;
	var LN10 = Math.LN10;
	var dataQuantity = Math.floor(log$1(dataExtent[1] - dataExtent[0]) / LN10);
	var sizeQuantity = Math.round(log$1(mathAbs$1(pixelExtent[1] - pixelExtent[0])) / LN10);
	var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
	return !isFinite(precision) ? 20 : precision;
}
/**
* Get a data of given precision, assuring the sum of percentages
* in valueList is 1.
* The largest remainder method is used.
* https://en.wikipedia.org/wiki/Largest_remainder_method
*
* @param valueList a list of all data
* @param idx index of the data to be processed in valueList
* @param precision integer number showing digits of precision
* @return percent ranging from 0 to 100
*/
function getPercentWithPrecision(valueList, idx, precision) {
	if (!valueList[idx]) return 0;
	return getPercentSeats(valueList, precision)[idx] || 0;
}
/**
* Get a data of given precision, assuring the sum of percentages
* in valueList is 1.
* The largest remainder method is used.
* https://en.wikipedia.org/wiki/Largest_remainder_method
*
* @param valueList a list of all data
* @param precision integer number showing digits of precision
* @return {Array<number>}
*/
function getPercentSeats(valueList, precision) {
	var sum$1 = reduce(valueList, function(acc, val) {
		return acc + (isNaN(val) ? 0 : val);
	}, 0);
	if (sum$1 === 0) return [];
	var digits = Math.pow(10, precision);
	var votesPerQuota = map(valueList, function(val) {
		return (isNaN(val) ? 0 : val) / sum$1 * digits * 100;
	});
	var targetSeats = digits * 100;
	var seats = map(votesPerQuota, function(votes) {
		return Math.floor(votes);
	});
	var currentSum = reduce(seats, function(acc, val) {
		return acc + val;
	}, 0);
	var remainder = map(votesPerQuota, function(votes, idx) {
		return votes - seats[idx];
	});
	while (currentSum < targetSeats) {
		var max$2 = Number.NEGATIVE_INFINITY;
		var maxId = null;
		for (var i$1 = 0, len$1 = remainder.length; i$1 < len$1; ++i$1) if (remainder[i$1] > max$2) {
			max$2 = remainder[i$1];
			maxId = i$1;
		}
		++seats[maxId];
		remainder[maxId] = 0;
		++currentSum;
	}
	return map(seats, function(seat) {
		return seat / digits;
	});
}
/**
* Solve the floating point adding problem like 0.1 + 0.2 === 0.30000000000000004
* See <http://0.30000000000000004.com/>
*/
function addSafe(val0, val1) {
	var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
	var sum$1 = val0 + val1;
	return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum$1 : round(sum$1, maxPrecision);
}
var MAX_SAFE_INTEGER = 9007199254740991;
/**
* To 0 - 2 * PI, considering negative radian.
*/
function remRadian(radian) {
	var pi2 = Math.PI * 2;
	return (radian % pi2 + pi2) % pi2;
}
/**
* @param {type} radian
* @return {boolean}
*/
function isRadianAroundZero(val) {
	return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
/**
* @param value valid type: number | string | Date, otherwise return `new Date(NaN)`
*   These values can be accepted:
*   + An instance of Date, represent a time in its own time zone.
*   + Or string in a subset of ISO 8601, only including:
*     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
*     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
*     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
*     all of which will be treated as local time if time zone is not specified
*     (see <https://momentjs.com/>).
*   + Or other string format, including (all of which will be treated as local time):
*     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
*     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
*   + a timestamp, which represent a time in UTC.
* @return date Never be null/undefined. If invalid, return `new Date(NaN)`.
*/
function parseDate(value) {
	if (value instanceof Date) return value;
	else if (isString(value)) {
		var match = TIME_REG.exec(value);
		if (!match) return /* @__PURE__ */ new Date(NaN);
		if (!match[8]) return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
		else {
			var hour = +match[4] || 0;
			if (match[8].toUpperCase() !== "Z") hour -= +match[8].slice(0, 3);
			return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
		}
	} else if (value == null) return /* @__PURE__ */ new Date(NaN);
	return new Date(Math.round(value));
}
/**
* Quantity of a number. e.g. 0.1, 1, 10, 100
*
* @param val
* @return
*/
function quantity(val) {
	return Math.pow(10, quantityExponent(val));
}
/**
* Exponent of the quantity of a number
* e.g., 1234 equals to 1.234*10^3, so quantityExponent(1234) is 3
*
* @param val non-negative value
* @return
*/
function quantityExponent(val) {
	if (val === 0) return 0;
	var exp = Math.floor(Math.log(val) / Math.LN10);
	/**
	* exp is expected to be the rounded-down result of the base-10 log of val.
	* But due to the precision loss with Math.log(val), we need to restore it
	* using 10^exp to make sure we can get val back from exp. #11249
	*/
	if (val / Math.pow(10, exp) >= 10) exp++;
	return exp;
}
/**
* find a nice number approximately equal to x. Round the number if round = true,
* take ceiling if round = false. The primary observation is that the nicest
* numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
*
* See "Nice Numbers for Graph Labels" of Graphic Gems.
*
* @param  val Non-negative value.
* @param  round
* @return Niced number
*/
function nice(val, round$5) {
	var exponent = quantityExponent(val);
	var exp10 = Math.pow(10, exponent);
	var f = val / exp10;
	var nf;
	if (round$5) if (f < 1.5) nf = 1;
	else if (f < 2.5) nf = 2;
	else if (f < 4) nf = 3;
	else if (f < 7) nf = 5;
	else nf = 10;
	else if (f < 1) nf = 1;
	else if (f < 2) nf = 2;
	else if (f < 3) nf = 3;
	else if (f < 5) nf = 5;
	else nf = 10;
	val = nf * exp10;
	return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
/**
* This code was copied from "d3.js"
* <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/arrays/quantile.js>.
* See the license statement at the head of this file.
* @param ascArr
*/
function quantile(ascArr, p) {
	var H = (ascArr.length - 1) * p + 1;
	var h = Math.floor(H);
	var v = +ascArr[h - 1];
	var e$1 = H - h;
	return e$1 ? v + e$1 * (ascArr[h] - v) : v;
}
/**
* Order intervals asc, and split them when overlap.
* expect(numberUtil.reformIntervals([
*     {interval: [18, 62], close: [1, 1]},
*     {interval: [-Infinity, -70], close: [0, 0]},
*     {interval: [-70, -26], close: [1, 1]},
*     {interval: [-26, 18], close: [1, 1]},
*     {interval: [62, 150], close: [1, 1]},
*     {interval: [106, 150], close: [1, 1]},
*     {interval: [150, Infinity], close: [0, 0]}
* ])).toEqual([
*     {interval: [-Infinity, -70], close: [0, 0]},
*     {interval: [-70, -26], close: [1, 1]},
*     {interval: [-26, 18], close: [0, 1]},
*     {interval: [18, 62], close: [0, 1]},
*     {interval: [62, 150], close: [0, 1]},
*     {interval: [150, Infinity], close: [0, 0]}
* ]);
* @param list, where `close` mean open or close
*        of the interval, and Infinity can be used.
* @return The origin list, which has been reformed.
*/
function reformIntervals(list) {
	list.sort(function(a, b) {
		return littleThan$1(a, b, 0) ? -1 : 1;
	});
	var curr = -Infinity;
	var currClose = 1;
	for (var i$1 = 0; i$1 < list.length;) {
		var interval = list[i$1].interval;
		var close_1 = list[i$1].close;
		for (var lg = 0; lg < 2; lg++) {
			if (interval[lg] <= curr) {
				interval[lg] = curr;
				close_1[lg] = !lg ? 1 - currClose : 1;
			}
			curr = interval[lg];
			currClose = close_1[lg];
		}
		if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) list.splice(i$1, 1);
		else i$1++;
	}
	return list;
	function littleThan$1(a, b, lg$1) {
		return a.interval[lg$1] < b.interval[lg$1] || a.interval[lg$1] === b.interval[lg$1] && (a.close[lg$1] - b.close[lg$1] === (!lg$1 ? 1 : -1) || !lg$1 && littleThan$1(a, b, 1));
	}
}
/**
* [Numeric is defined as]:
*     `parseFloat(val) == val`
* For example:
* numeric:
*     typeof number except NaN, '-123', '123', '2e3', '-2e3', '011', 'Infinity', Infinity,
*     and they rounded by white-spaces or line-terminal like ' -123 \n ' (see es spec)
* not-numeric:
*     null, undefined, [], {}, true, false, 'NaN', NaN, '123ab',
*     empty string, string with only white-spaces or line-terminal (see es spec),
*     0x12, '0x12', '-0x12', 012, '012', '-012',
*     non-string, ...
*
* @test See full test cases in `test/ut/spec/util/number.js`.
* @return Must be a typeof number. If not numeric, return NaN.
*/
function numericToNumber(val) {
	var valFloat = parseFloat(val);
	return valFloat == val && (valFloat !== 0 || !isString(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
}
/**
* Definition of "numeric": see `numericToNumber`.
*/
function isNumeric(val) {
	return !isNaN(numericToNumber(val));
}
/**
* Use random base to prevent users hard code depending on
* this auto generated marker id.
* @return An positive integer.
*/
function getRandomIdBase() {
	return Math.round(Math.random() * 9);
}
/**
* Get the greatest common divisor.
*
* @param {number} a one number
* @param {number} b the other number
*/
function getGreatestCommonDividor(a, b) {
	if (b === 0) return a;
	return getGreatestCommonDividor(b, a % b);
}
/**
* Get the least common multiple.
*
* @param {number} a one number
* @param {number} b the other number
*/
function getLeastCommonMultiple(a, b) {
	if (a == null) return b;
	if (b == null) return a;
	return a * b / getGreatestCommonDividor(a, b);
}

//#endregion
//#region node_modules/echarts/lib/util/log.js
var ECHARTS_PREFIX = "[ECharts] ";
var storedLogs = {};
var hasConsole = typeof console !== "undefined" && console.warn && console.log;
function outputLog(type, str, onlyOnce) {
	if (hasConsole) {
		if (onlyOnce) {
			if (storedLogs[str]) return;
			storedLogs[str] = true;
		}
		console[type](ECHARTS_PREFIX + str);
	}
}
function log(str, onlyOnce) {
	outputLog("log", str, onlyOnce);
}
function warn(str, onlyOnce) {
	outputLog("warn", str, onlyOnce);
}
function error(str, onlyOnce) {
	outputLog("error", str, onlyOnce);
}
function deprecateLog(str) {
	outputLog("warn", "DEPRECATED: " + str, true);
}
function deprecateReplaceLog(oldOpt, newOpt, scope) {
	deprecateLog((scope ? "[" + scope + "]" : "") + (oldOpt + " is deprecated; use " + newOpt + " instead."));
}
/**
* If in __DEV__ environment, get console printable message for users hint.
* Parameters are separated by ' '.
* @usage
* makePrintable('This is an error on', someVar, someObj);
*
* @param hintInfo anything about the current execution context to hint users.
* @throws Error
*/
function makePrintable() {
	var hintInfo = [];
	for (var _i = 0; _i < arguments.length; _i++) hintInfo[_i] = arguments[_i];
	var msg = "";
	var makePrintableStringIfPossible_1 = function(val) {
		return val === void 0 ? "undefined" : val === Infinity ? "Infinity" : val === -Infinity ? "-Infinity" : eqNaN(val) ? "NaN" : val instanceof Date ? "Date(" + val.toISOString() + ")" : isFunction(val) ? "function () { ... }" : isRegExp(val) ? val + "" : null;
	};
	msg = map(hintInfo, function(arg) {
		if (isString(arg)) return arg;
		else {
			var printableStr = makePrintableStringIfPossible_1(arg);
			if (printableStr != null) return printableStr;
			else if (typeof JSON !== "undefined" && JSON.stringify) try {
				return JSON.stringify(arg, function(n, val) {
					var printableStr$1 = makePrintableStringIfPossible_1(val);
					return printableStr$1 == null ? val : printableStr$1;
				});
			} catch (err) {
				return "?";
			}
			else return "?";
		}
	}).join(" ");
	return msg;
}
/**
* @throws Error
*/
function throwError(msg) {
	throw new Error(msg);
}

//#endregion
//#region node_modules/echarts/lib/util/model.js
function interpolateNumber(p0, p1, percent) {
	return (p1 - p0) * percent + p0;
}
/**
* Make the name displayable. But we should
* make sure it is not duplicated with user
* specified name, so use '\0';
*/
var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
/**
* If value is not array, then translate it to array.
* @param  {*} value
* @return {Array} [value] or value
*/
function normalizeToArray(value) {
	return value instanceof Array ? value : value == null ? [] : [value];
}
/**
* Sync default option between normal and emphasis like `position` and `show`
* In case some one will write code like
*     label: {
*          show: false,
*          position: 'outside',
*          fontSize: 18
*     },
*     emphasis: {
*          label: { show: true }
*     }
*/
function defaultEmphasis(opt, key$1, subOpts) {
	if (opt) {
		opt[key$1] = opt[key$1] || {};
		opt.emphasis = opt.emphasis || {};
		opt.emphasis[key$1] = opt.emphasis[key$1] || {};
		for (var i$1 = 0, len$1 = subOpts.length; i$1 < len$1; i$1++) {
			var subOptName = subOpts[i$1];
			if (!opt.emphasis[key$1].hasOwnProperty(subOptName) && opt[key$1].hasOwnProperty(subOptName)) opt.emphasis[key$1][subOptName] = opt[key$1][subOptName];
		}
	}
}
var TEXT_STYLE_OPTIONS = [
	"fontStyle",
	"fontWeight",
	"fontSize",
	"fontFamily",
	"rich",
	"tag",
	"color",
	"textBorderColor",
	"textBorderWidth",
	"width",
	"height",
	"lineHeight",
	"align",
	"verticalAlign",
	"baseline",
	"shadowColor",
	"shadowBlur",
	"shadowOffsetX",
	"shadowOffsetY",
	"textShadowColor",
	"textShadowBlur",
	"textShadowOffsetX",
	"textShadowOffsetY",
	"backgroundColor",
	"borderColor",
	"borderWidth",
	"borderRadius",
	"padding"
];
/**
* The method does not ensure performance.
* data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
* This helper method retrieves value from data.
*/
function getDataItemValue(dataItem) {
	return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
/**
* data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
* This helper method determine if dataItem has extra option besides value
*/
function isDataItemOption(dataItem) {
	return isObject(dataItem) && !(dataItem instanceof Array);
}
/**
* Mapping to existings for merge.
*
* Mode "normalMege":
*     The mapping result (merge result) will keep the order of the existing
*     component, rather than the order of new option. Because we should ensure
*     some specified index reference (like xAxisIndex) keep work.
*     And in most cases, "merge option" is used to update partial option but not
*     be expected to change the order.
*
* Mode "replaceMege":
*     (1) Only the id mapped components will be merged.
*     (2) Other existing components (except internal components) will be removed.
*     (3) Other new options will be used to create new component.
*     (4) The index of the existing components will not be modified.
*     That means their might be "hole" after the removal.
*     The new components are created first at those available index.
*
* Mode "replaceAll":
*     This mode try to support that reproduce an echarts instance from another
*     echarts instance (via `getOption`) in some simple cases.
*     In this scenario, the `result` index are exactly the consistent with the `newCmptOptions`,
*     which ensures the component index referring (like `xAxisIndex: ?`) corrent. That is,
*     the "hole" in `newCmptOptions` will also be kept.
*     On the contrary, other modes try best to eliminate holes.
*     PENDING: This is an experimental mode yet.
*
* @return See the comment of <MappingResult>.
*/
function mappingToExists(existings, newCmptOptions, mode) {
	var isNormalMergeMode = mode === "normalMerge";
	var isReplaceMergeMode = mode === "replaceMerge";
	var isReplaceAllMode = mode === "replaceAll";
	existings = existings || [];
	newCmptOptions = (newCmptOptions || []).slice();
	var existingIdIdxMap = createHashMap();
	each(newCmptOptions, function(cmptOption, index) {
		if (!isObject(cmptOption)) {
			newCmptOptions[index] = null;
			return;
		}
		if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) warnInvalidateIdOrName(cmptOption.id);
		if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) warnInvalidateIdOrName(cmptOption.name);
	});
	var result = prepareResult(existings, existingIdIdxMap, mode);
	if (isNormalMergeMode || isReplaceMergeMode) mappingById(result, existings, existingIdIdxMap, newCmptOptions);
	if (isNormalMergeMode) mappingByName(result, newCmptOptions);
	if (isNormalMergeMode || isReplaceMergeMode) mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
	else if (isReplaceAllMode) mappingInReplaceAllMode(result, newCmptOptions);
	makeIdAndName(result);
	return result;
}
function prepareResult(existings, existingIdIdxMap, mode) {
	var result = [];
	if (mode === "replaceAll") return result;
	for (var index = 0; index < existings.length; index++) {
		var existing = existings[index];
		if (existing && existing.id != null) existingIdIdxMap.set(existing.id, index);
		result.push({
			existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
			newOption: null,
			keyInfo: null,
			brandNew: null
		});
	}
	return result;
}
function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
	each(newCmptOptions, function(cmptOption, index) {
		if (!cmptOption || cmptOption.id == null) return;
		var optionId = makeComparableKey(cmptOption.id);
		var existingIdx = existingIdIdxMap.get(optionId);
		if (existingIdx != null) {
			var resultItem = result[existingIdx];
			assert(!resultItem.newOption, "Duplicated option on id \"" + optionId + "\".");
			resultItem.newOption = cmptOption;
			resultItem.existing = existings[existingIdx];
			newCmptOptions[index] = null;
		}
	});
}
function mappingByName(result, newCmptOptions) {
	each(newCmptOptions, function(cmptOption, index) {
		if (!cmptOption || cmptOption.name == null) return;
		for (var i$1 = 0; i$1 < result.length; i$1++) {
			var existing = result[i$1].existing;
			if (!result[i$1].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
				result[i$1].newOption = cmptOption;
				newCmptOptions[index] = null;
				return;
			}
		}
	});
}
function mappingByIndex(result, newCmptOptions, brandNew) {
	each(newCmptOptions, function(cmptOption) {
		if (!cmptOption) return;
		var resultItem;
		var nextIdx = 0;
		while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))) nextIdx++;
		if (resultItem) {
			resultItem.newOption = cmptOption;
			resultItem.brandNew = brandNew;
		} else result.push({
			newOption: cmptOption,
			brandNew,
			existing: null,
			keyInfo: null
		});
		nextIdx++;
	});
}
function mappingInReplaceAllMode(result, newCmptOptions) {
	each(newCmptOptions, function(cmptOption) {
		result.push({
			newOption: cmptOption,
			brandNew: true,
			existing: null,
			keyInfo: null
		});
	});
}
/**
* Make id and name for mapping result (result of mappingToExists)
* into `keyInfo` field.
*/
function makeIdAndName(mapResult) {
	var idMap = createHashMap();
	each(mapResult, function(item) {
		var existing = item.existing;
		existing && idMap.set(existing.id, item);
	});
	each(mapResult, function(item) {
		var opt = item.newOption;
		assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
		opt && opt.id != null && idMap.set(opt.id, item);
		!item.keyInfo && (item.keyInfo = {});
	});
	each(mapResult, function(item, index) {
		var existing = item.existing;
		var opt = item.newOption;
		var keyInfo = item.keyInfo;
		if (!isObject(opt)) return;
		keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index;
		if (existing) keyInfo.id = makeComparableKey(existing.id);
		else if (opt.id != null) keyInfo.id = makeComparableKey(opt.id);
		else {
			var idNum = 0;
			do
				keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
			while (idMap.get(keyInfo.id));
		}
		idMap.set(keyInfo.id, item);
	});
}
function keyExistAndEqual(attr, obj1, obj2) {
	var key1 = convertOptionIdName(obj1[attr], null);
	var key2 = convertOptionIdName(obj2[attr], null);
	return key1 != null && key2 != null && key1 === key2;
}
/**
* @return return null if not exist.
*/
function makeComparableKey(val) {
	if (val == null) throw new Error();
	return convertOptionIdName(val, "");
}
function convertOptionIdName(idOrName, defaultValue) {
	if (idOrName == null) return defaultValue;
	return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
}
function warnInvalidateIdOrName(idOrName) {
	warn("`" + idOrName + "` is invalid id or name. Must be a string or number.");
}
function isValidIdOrName(idOrName) {
	return isStringSafe(idOrName) || isNumeric(idOrName);
}
function isNameSpecified(componentModel) {
	var name = componentModel.name;
	return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
/**
* @public
* @param {Object} cmptOption
* @return {boolean}
*/
function isComponentIdInternal(cmptOption) {
	return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function makeInternalComponentId(idSuffix) {
	return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;
}
function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
	each(mappingResult, function(item) {
		var newOption = item.newOption;
		if (isObject(newOption)) {
			item.keyInfo.mainType = mainType;
			item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
		}
	});
}
function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
	return newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
}
/**
* A helper for removing duplicate items between batchA and batchB,
* and in themselves, and categorize by series.
*
* @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
* @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
* @return result: [resultBatchA, resultBatchB]
*/
function compressBatches(batchA, batchB) {
	var mapA = {};
	var mapB = {};
	makeMap(batchA || [], mapA);
	makeMap(batchB || [], mapB, mapA);
	return [mapToArray(mapA), mapToArray(mapB)];
	function makeMap(sourceBatch, map$2, otherMap) {
		for (var i$1 = 0, len$1 = sourceBatch.length; i$1 < len$1; i$1++) {
			var seriesId = convertOptionIdName(sourceBatch[i$1].seriesId, null);
			if (seriesId == null) return;
			var dataIndices = normalizeToArray(sourceBatch[i$1].dataIndex);
			var otherDataIndices = otherMap && otherMap[seriesId];
			for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
				var dataIndex = dataIndices[j];
				if (otherDataIndices && otherDataIndices[dataIndex]) otherDataIndices[dataIndex] = null;
				else (map$2[seriesId] || (map$2[seriesId] = {}))[dataIndex] = 1;
			}
		}
	}
	function mapToArray(map$2, isData) {
		var result = [];
		for (var i$1 in map$2) if (map$2.hasOwnProperty(i$1) && map$2[i$1] != null) if (isData) result.push(+i$1);
		else {
			var dataIndices = mapToArray(map$2[i$1], true);
			dataIndices.length && result.push({
				seriesId: i$1,
				dataIndex: dataIndices
			});
		}
		return result;
	}
}
/**
* @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name
*                         each of which can be Array or primary type.
* @return dataIndex If not found, return undefined/null.
*/
function queryDataIndex(data, payload) {
	if (payload.dataIndexInside != null) return payload.dataIndexInside;
	else if (payload.dataIndex != null) return isArray(payload.dataIndex) ? map(payload.dataIndex, function(value) {
		return data.indexOfRawIndex(value);
	}) : data.indexOfRawIndex(payload.dataIndex);
	else if (payload.name != null) return isArray(payload.name) ? map(payload.name, function(value) {
		return data.indexOfName(value);
	}) : data.indexOfName(payload.name);
}
/**
* Enable property storage to any host object.
* Notice: Serialization is not supported.
*
* For example:
* let inner = zrUitl.makeInner();
*
* function some1(hostObj) {
*      inner(hostObj).someProperty = 1212;
*      ...
* }
* function some2() {
*      let fields = inner(this);
*      fields.someProperty1 = 1212;
*      fields.someProperty2 = 'xx';
*      ...
* }
*
* @return {Function}
*/
function makeInner() {
	var key$1 = "__ec_inner_" + innerUniqueIndex++;
	return function(hostObj) {
		return hostObj[key$1] || (hostObj[key$1] = {});
	};
}
var innerUniqueIndex = getRandomIdBase();
/**
* The same behavior as `component.getReferringComponents`.
*/
function parseFinder(ecModel, finderInput, opt) {
	var _a$1 = preParseFinder(finderInput, opt), mainTypeSpecified = _a$1.mainTypeSpecified, queryOptionMap = _a$1.queryOptionMap;
	var result = _a$1.others;
	var defaultMainType = opt ? opt.defaultMainType : null;
	if (!mainTypeSpecified && defaultMainType) queryOptionMap.set(defaultMainType, {});
	queryOptionMap.each(function(queryOption, mainType) {
		var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
			useDefault: defaultMainType === mainType,
			enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
			enableNone: opt && opt.enableNone != null ? opt.enableNone : true
		});
		result[mainType + "Models"] = queryResult.models;
		result[mainType + "Model"] = queryResult.models[0];
	});
	return result;
}
function preParseFinder(finderInput, opt) {
	var finder;
	if (isString(finderInput)) {
		var obj = {};
		obj[finderInput + "Index"] = 0;
		finder = obj;
	} else finder = finderInput;
	var queryOptionMap = createHashMap();
	var others = {};
	var mainTypeSpecified = false;
	each(finder, function(value, key$1) {
		if (key$1 === "dataIndex" || key$1 === "dataIndexInside") {
			others[key$1] = value;
			return;
		}
		var parsedKey = key$1.match(/^(\w+)(Index|Id|Name)$/) || [];
		var mainType = parsedKey[1];
		var queryType = (parsedKey[2] || "").toLowerCase();
		if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) return;
		mainTypeSpecified = mainTypeSpecified || !!mainType;
		var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
		queryOption[queryType] = value;
	});
	return {
		mainTypeSpecified,
		queryOptionMap,
		others
	};
}
var SINGLE_REFERRING = {
	useDefault: true,
	enableAll: false,
	enableNone: false
};
var MULTIPLE_REFERRING = {
	useDefault: false,
	enableAll: true,
	enableNone: true
};
function queryReferringComponents(ecModel, mainType, userOption, opt) {
	opt = opt || SINGLE_REFERRING;
	var indexOption = userOption.index;
	var idOption = userOption.id;
	var nameOption = userOption.name;
	var result = {
		models: null,
		specified: indexOption != null || idOption != null || nameOption != null
	};
	if (!result.specified) {
		var firstCmpt = void 0;
		result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
		return result;
	}
	if (indexOption === "none" || indexOption === false) if (opt.enableNone) {
		result.models = [];
		return result;
	} else {
		error("`\"none\"` or `false` is not a valid value on index option.");
		indexOption = -1;
	}
	if (indexOption === "all") if (opt.enableAll) indexOption = idOption = nameOption = null;
	else {
		error("`\"all\"` is not a valid value on index option.");
		indexOption = -1;
	}
	result.models = ecModel.queryComponents({
		mainType,
		index: indexOption,
		id: idOption,
		name: nameOption
	});
	return result;
}
function setAttribute(dom, key$1, value) {
	dom.setAttribute ? dom.setAttribute(key$1, value) : dom[key$1] = value;
}
function getAttribute(dom, key$1) {
	return dom.getAttribute ? dom.getAttribute(key$1) : dom[key$1];
}
function getTooltipRenderMode(renderModeOption) {
	if (renderModeOption === "auto") return env_default.domSupported ? "html" : "richText";
	else return renderModeOption || "html";
}
/**
* Group a list by key.
*/
function groupData(array, getKey$1) {
	var buckets = createHashMap();
	var keys$1 = [];
	each(array, function(item) {
		var key$1 = getKey$1(item);
		(buckets.get(key$1) || (keys$1.push(key$1), buckets.set(key$1, []))).push(item);
	});
	return {
		keys: keys$1,
		buckets
	};
}
/**
* Interpolate raw values of a series with percent
*
* @param data         data
* @param labelModel   label model of the text element
* @param sourceValue  start value. May be null/undefined when init.
* @param targetValue  end value
* @param percent      0~1 percentage; 0 uses start value while 1 uses end value
* @return             interpolated values
*                     If `sourceValue` and `targetValue` are `number`, return `number`.
*                     If `sourceValue` and `targetValue` are `string`, return `string`.
*                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.
*                     Other cases do not supported.
*/
function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
	var isAutoPrecision = precision == null || precision === "auto";
	if (targetValue == null) return targetValue;
	if (isNumber(targetValue)) {
		var value = interpolateNumber(sourceValue || 0, targetValue, percent);
		return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
	} else if (isString(targetValue)) return percent < 1 ? sourceValue : targetValue;
	else {
		var interpolated = [];
		var leftArr = sourceValue;
		var rightArr = targetValue;
		var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
		for (var i$1 = 0; i$1 < length_1; ++i$1) {
			var info = data.getDimensionInfo(i$1);
			if (info && info.type === "ordinal") interpolated[i$1] = (percent < 1 && leftArr ? leftArr : rightArr)[i$1];
			else {
				var leftVal = leftArr && leftArr[i$1] ? leftArr[i$1] : 0;
				var rightVal = rightArr[i$1];
				var value = interpolateNumber(leftVal, rightVal, percent);
				interpolated[i$1] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
			}
		}
		return interpolated;
	}
}
/**
* Use an iterator to avoid exposing the internal list or duplicating it
* for the outside traveller, and no extra heap allocation.
* @usage
*  for (const it = resetIterator(); it.next();) {
*      const item = it.item;
*      const key = it.key;
*      const itIdx = it.itIdx;
*      // ...
*  }
* @usage
*  const it = resetIterator();
*  while (it.next()) { ... }
* @usage
*  for (resetIterator(it); it.next();) { ... }
*/
var ListIterator = function() {
	function ListIterator$1() {}
	/**
	* The loop condition is `idx < end` if `step > 0`;
	* The loop condition is `idx >= end` if `step < 0`.
	*
	* @param end By default `list.length` if `step > 0`; `0` if `step < 0`.
	* @param step By default `1`.
	*/
	ListIterator$1.prototype.reset = function(list, start$1, end$1, step) {
		this._list = list;
		this._step = step = step || 1;
		this._idx = start$1;
		this._end = end$1 != null ? end$1 : step > 0 ? list.length : 0;
		this.item = null;
		this.key = NaN;
		return this;
	};
	ListIterator$1.prototype.next = function() {
		if (this._step > 0 ? this._idx < this._end : this._idx >= this._end) {
			this.item = this._list[this._idx];
			this.key = this._idx = this._idx + this._step;
			return true;
		}
		return false;
	};
	return ListIterator$1;
}();
function clearTmpModel(model) {
	model.option = model.parentModel = model.ecModel = null;
}

//#endregion
//#region node_modules/echarts/lib/util/clazz.js
var TYPE_DELIMITER = ".";
var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
/**
* Notice, parseClassType('') should returns {main: '', sub: ''}
* @public
*/
function parseClassType(componentType) {
	var ret = {
		main: "",
		sub: ""
	};
	if (componentType) {
		var typeArr = componentType.split(TYPE_DELIMITER);
		ret.main = typeArr[0] || "";
		ret.sub = typeArr[1] || "";
	}
	return ret;
}
/**
* @public
*/
function checkClassType(componentType) {
	assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), "componentType \"" + componentType + "\" illegal");
}
function isExtendedClass(clz) {
	return !!(clz && clz[IS_EXTENDED_CLASS]);
}
/**
* Implements `ExtendableConstructor` for `rootClz`.
*
* @usage
* ```ts
* class Xxx {}
* type XxxConstructor = typeof Xxx & ExtendableConstructor
* enableClassExtend(Xxx as XxxConstructor);
* ```
*/
function enableClassExtend(rootClz, mandatoryMethods) {
	rootClz.$constructor = rootClz;
	rootClz.extend = function(proto) {
		each(mandatoryMethods, function(method) {
			if (!proto[method]) console.warn("Method `" + method + "` should be implemented" + (proto.type ? " in " + proto.type : "") + ".");
		});
		var superClass = this;
		var ExtendedClass;
		if (isESClass(superClass)) ExtendedClass = function(_super) {
			__extends(class_1, _super);
			function class_1() {
				return _super.apply(this, arguments) || this;
			}
			return class_1;
		}(superClass);
		else {
			ExtendedClass = function() {
				(proto.$constructor || superClass).apply(this, arguments);
			};
			inherits(ExtendedClass, this);
		}
		extend(ExtendedClass.prototype, proto);
		ExtendedClass[IS_EXTENDED_CLASS] = true;
		ExtendedClass.extend = this.extend;
		ExtendedClass.superCall = superCall;
		ExtendedClass.superApply = superApply;
		ExtendedClass.superClass = superClass;
		return ExtendedClass;
	};
}
function isESClass(fn) {
	return isFunction(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
}
/**
* A work around to both support ts extend and this extend mechanism.
* on sub-class.
* @usage
* ```ts
* class Component { ... }
* classUtil.enableClassExtend(Component);
* classUtil.enableClassManagement(Component, {registerWhenExtend: true});
*
* class Series extends Component { ... }
* // Without calling `markExtend`, `registerWhenExtend` will not work.
* Component.markExtend(Series);
* ```
*/
function mountExtend(SubClz, SupperClz) {
	SubClz.extend = SupperClz.extend;
}
var classBase = Math.round(Math.random() * 10);
/**
* Implements `CheckableConstructor` for `target`.
* Can not use instanceof, consider different scope by
* cross domain or es module import in ec extensions.
* Mount a method "isInstance()" to Clz.
*
* @usage
* ```ts
* class Xxx {}
* type XxxConstructor = typeof Xxx & CheckableConstructor;
* enableClassCheck(Xxx as XxxConstructor)
* ```
*/
function enableClassCheck(target) {
	var classAttr = ["__\0is_clz", classBase++].join("_");
	target.prototype[classAttr] = true;
	assert(!target.isInstance, "The method \"is\" can not be defined.");
	target.isInstance = function(obj) {
		return !!(obj && obj[classAttr]);
	};
}
function superCall(context, methodName) {
	var args = [];
	for (var _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
	return this.superClass.prototype[methodName].apply(context, args);
}
function superApply(context, methodName, args) {
	return this.superClass.prototype[methodName].apply(context, args);
}
/**
* Implements `ClassManager` for `target`
*
* @usage
* ```ts
* class Xxx {}
* type XxxConstructor = typeof Xxx & ClassManager
* enableClassManagement(Xxx as XxxConstructor);
* ```
*/
function enableClassManagement(target) {
	/**
	* Component model classes
	* key: componentType,
	* value:
	*     componentClass, when componentType is 'a'
	*     or Object.<subKey, componentClass>, when componentType is 'a.b'
	*/
	var storage$1 = {};
	target.registerClass = function(clz) {
		var componentFullType = clz.type || clz.prototype.type;
		if (componentFullType) {
			checkClassType(componentFullType);
			clz.prototype.type = componentFullType;
			var componentTypeInfo = parseClassType(componentFullType);
			if (!componentTypeInfo.sub) {
				if (storage$1[componentTypeInfo.main]) console.warn(componentTypeInfo.main + " exists.");
				storage$1[componentTypeInfo.main] = clz;
			} else if (componentTypeInfo.sub !== IS_CONTAINER) {
				var container = makeContainer(componentTypeInfo);
				container[componentTypeInfo.sub] = clz;
			}
		}
		return clz;
	};
	target.getClass = function(mainType, subType, throwWhenNotFound) {
		var clz = storage$1[mainType];
		if (clz && clz[IS_CONTAINER]) clz = subType ? clz[subType] : null;
		if (throwWhenNotFound && !clz) throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
		return clz;
	};
	target.getClassesByMainType = function(componentType) {
		var componentTypeInfo = parseClassType(componentType);
		var result = [];
		var obj = storage$1[componentTypeInfo.main];
		if (obj && obj[IS_CONTAINER]) each(obj, function(o, type) {
			type !== IS_CONTAINER && result.push(o);
		});
		else result.push(obj);
		return result;
	};
	target.hasClass = function(componentType) {
		return !!storage$1[parseClassType(componentType).main];
	};
	/**
	* @return Like ['aa', 'bb'], but can not be ['aa.xx']
	*/
	target.getAllClassMainTypes = function() {
		var types = [];
		each(storage$1, function(obj, type) {
			types.push(type);
		});
		return types;
	};
	/**
	* If a main type is container and has sub types
	*/
	target.hasSubTypes = function(componentType) {
		var obj = storage$1[parseClassType(componentType).main];
		return obj && obj[IS_CONTAINER];
	};
	function makeContainer(componentTypeInfo) {
		var container = storage$1[componentTypeInfo.main];
		if (!container || !container[IS_CONTAINER]) {
			container = storage$1[componentTypeInfo.main] = {};
			container[IS_CONTAINER] = true;
		}
		return container;
	}
}

//#endregion
//#region node_modules/echarts/lib/model/mixin/makeStyleMapper.js
function makeStyleMapper(properties, ignoreParent) {
	for (var i$1 = 0; i$1 < properties.length; i$1++) if (!properties[i$1][1]) properties[i$1][1] = properties[i$1][0];
	ignoreParent = ignoreParent || false;
	return function(model, excludes, includes) {
		var style = {};
		for (var i$2 = 0; i$2 < properties.length; i$2++) {
			var propName = properties[i$2][1];
			if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) continue;
			var val = model.getShallow(propName, ignoreParent);
			if (val != null) style[properties[i$2][0]] = val;
		}
		return style;
	};
}

//#endregion
//#region node_modules/echarts/lib/model/mixin/areaStyle.js
var AREA_STYLE_KEY_MAP = [
	["fill", "color"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["opacity"],
	["shadowColor"]
];
var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
var AreaStyleMixin = function() {
	function AreaStyleMixin$1() {}
	AreaStyleMixin$1.prototype.getAreaStyle = function(excludes, includes) {
		return getAreaStyle(this, excludes, includes);
	};
	return AreaStyleMixin$1;
}();

//#endregion
//#region node_modules/zrender/lib/graphic/helper/image.js
var globalImageCache = new LRU_default(50);
function findExistImage(newImageOrSrc) {
	if (typeof newImageOrSrc === "string") {
		var cachedImgObj = globalImageCache.get(newImageOrSrc);
		return cachedImgObj && cachedImgObj.image;
	} else return newImageOrSrc;
}
function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
	if (!newImageOrSrc) return image;
	else if (typeof newImageOrSrc === "string") {
		if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) return image;
		var cachedImgObj = globalImageCache.get(newImageOrSrc);
		var pendingWrap = {
			hostEl,
			cb: onload,
			cbPayload
		};
		if (cachedImgObj) {
			image = cachedImgObj.image;
			!isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
		} else {
			image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
			image.__zrImageSrc = newImageOrSrc;
			globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
				image,
				pending: [pendingWrap]
			});
		}
		return image;
	} else return newImageOrSrc;
}
function imageOnLoad() {
	var cachedImgObj = this.__cachedImgObj;
	this.onload = this.onerror = this.__cachedImgObj = null;
	for (var i$1 = 0; i$1 < cachedImgObj.pending.length; i$1++) {
		var pendingWrap = cachedImgObj.pending[i$1];
		var cb = pendingWrap.cb;
		cb && cb(this, pendingWrap.cbPayload);
		pendingWrap.hostEl.dirty();
	}
	cachedImgObj.pending.length = 0;
}
function isImageReady(image) {
	return image && image.width && image.height;
}

//#endregion
//#region node_modules/zrender/lib/graphic/helper/parseText.js
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(text, containerWidth, font, ellipsis, options) {
	var out$1 = {};
	truncateText2(out$1, text, containerWidth, font, ellipsis, options);
	return out$1.text;
}
function truncateText2(out$1, text, containerWidth, font, ellipsis, options) {
	if (!containerWidth) {
		out$1.text = "";
		out$1.isTruncated = false;
		return;
	}
	var textLines = (text + "").split("\n");
	options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
	var isTruncated = false;
	var truncateOut = {};
	for (var i$1 = 0, len$1 = textLines.length; i$1 < len$1; i$1++) {
		truncateSingleLine(truncateOut, textLines[i$1], options);
		textLines[i$1] = truncateOut.textLine;
		isTruncated = isTruncated || truncateOut.isTruncated;
	}
	out$1.text = textLines.join("\n");
	out$1.isTruncated = isTruncated;
}
function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
	options = options || {};
	var preparedOpts = extend({}, options);
	ellipsis = retrieve2(ellipsis, "...");
	preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
	var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
	var fontMeasureInfo = preparedOpts.fontMeasureInfo = ensureFontMeasureInfo(font);
	var ascCharWidth = fontMeasureInfo.asciiCharWidth;
	preparedOpts.placeholder = retrieve2(options.placeholder, "");
	var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
	for (var i$1 = 0; i$1 < minChar && contentWidth >= ascCharWidth; i$1++) contentWidth -= ascCharWidth;
	var ellipsisWidth = measureWidth(fontMeasureInfo, ellipsis);
	if (ellipsisWidth > contentWidth) {
		ellipsis = "";
		ellipsisWidth = 0;
	}
	contentWidth = containerWidth - ellipsisWidth;
	preparedOpts.ellipsis = ellipsis;
	preparedOpts.ellipsisWidth = ellipsisWidth;
	preparedOpts.contentWidth = contentWidth;
	preparedOpts.containerWidth = containerWidth;
	return preparedOpts;
}
function truncateSingleLine(out$1, textLine, options) {
	var containerWidth = options.containerWidth;
	var contentWidth = options.contentWidth;
	var fontMeasureInfo = options.fontMeasureInfo;
	if (!containerWidth) {
		out$1.textLine = "";
		out$1.isTruncated = false;
		return;
	}
	var lineWidth = measureWidth(fontMeasureInfo, textLine);
	if (lineWidth <= containerWidth) {
		out$1.textLine = textLine;
		out$1.isTruncated = false;
		return;
	}
	for (var j = 0;; j++) {
		if (lineWidth <= contentWidth || j >= options.maxIterations) {
			textLine += options.ellipsis;
			break;
		}
		var subLength = j === 0 ? estimateLength(textLine, contentWidth, fontMeasureInfo) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
		textLine = textLine.substr(0, subLength);
		lineWidth = measureWidth(fontMeasureInfo, textLine);
	}
	if (textLine === "") textLine = options.placeholder;
	out$1.textLine = textLine;
	out$1.isTruncated = true;
}
function estimateLength(text, contentWidth, fontMeasureInfo) {
	var width = 0;
	var i$1 = 0;
	for (var len$1 = text.length; i$1 < len$1 && width < contentWidth; i$1++) width += measureCharWidth(fontMeasureInfo, text.charCodeAt(i$1));
	return i$1;
}
function parsePlainText(rawText, style, defaultOuterWidth, defaultOuterHeight) {
	var text = formatText(rawText);
	var overflow = style.overflow;
	var padding = style.padding;
	var paddingH = padding ? padding[1] + padding[3] : 0;
	var paddingV = padding ? padding[0] + padding[2] : 0;
	var font = style.font;
	var truncate = overflow === "truncate";
	var calculatedLineHeight = getLineHeight(font);
	var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
	var truncateLineOverflow = style.lineOverflow === "truncate";
	var isTruncated = false;
	var width = style.width;
	if (width == null && defaultOuterWidth != null) width = defaultOuterWidth - paddingH;
	var height = style.height;
	if (height == null && defaultOuterHeight != null) height = defaultOuterHeight - paddingV;
	var lines;
	if (width != null && (overflow === "break" || overflow === "breakAll")) lines = text ? wrapText(text, style.font, width, overflow === "breakAll", 0).lines : [];
	else lines = text ? text.split("\n") : [];
	var contentHeight = lines.length * lineHeight;
	if (height == null) height = contentHeight;
	if (contentHeight > height && truncateLineOverflow) {
		var lineCount = Math.floor(height / lineHeight);
		isTruncated = isTruncated || lines.length > lineCount;
		lines = lines.slice(0, lineCount);
		contentHeight = lines.length * lineHeight;
	}
	if (text && truncate && width != null) {
		var options = prepareTruncateOptions(width, font, style.ellipsis, {
			minChar: style.truncateMinChar,
			placeholder: style.placeholder
		});
		var singleOut = {};
		for (var i$1 = 0; i$1 < lines.length; i$1++) {
			truncateSingleLine(singleOut, lines[i$1], options);
			lines[i$1] = singleOut.textLine;
			isTruncated = isTruncated || singleOut.isTruncated;
		}
	}
	var outerHeight = height;
	var contentWidth = 0;
	var fontMeasureInfo = ensureFontMeasureInfo(font);
	for (var i$1 = 0; i$1 < lines.length; i$1++) contentWidth = Math.max(measureWidth(fontMeasureInfo, lines[i$1]), contentWidth);
	if (width == null) width = contentWidth;
	var outerWidth = width;
	outerHeight += paddingV;
	outerWidth += paddingH;
	return {
		lines,
		height,
		outerWidth,
		outerHeight,
		lineHeight,
		calculatedLineHeight,
		contentWidth,
		contentHeight,
		width,
		isTruncated
	};
}
var RichTextToken = function() {
	function RichTextToken$1() {}
	return RichTextToken$1;
}();
var RichTextLine = function() {
	function RichTextLine$1(tokens$1) {
		this.tokens = [];
		if (tokens$1) this.tokens = tokens$1;
	}
	return RichTextLine$1;
}();
var RichTextContentBlock = function() {
	function RichTextContentBlock$1() {
		this.width = 0;
		this.height = 0;
		this.contentWidth = 0;
		this.contentHeight = 0;
		this.outerWidth = 0;
		this.outerHeight = 0;
		this.lines = [];
		this.isTruncated = false;
	}
	return RichTextContentBlock$1;
}();
function parseRichText(rawText, style, defaultOuterWidth, defaultOuterHeight, topTextAlign) {
	var contentBlock = new RichTextContentBlock();
	var text = formatText(rawText);
	if (!text) return contentBlock;
	var stlPadding = style.padding;
	var stlPaddingH = stlPadding ? stlPadding[1] + stlPadding[3] : 0;
	var stlPaddingV = stlPadding ? stlPadding[0] + stlPadding[2] : 0;
	var topWidth = style.width;
	if (topWidth == null && defaultOuterWidth != null) topWidth = defaultOuterWidth - stlPaddingH;
	var topHeight = style.height;
	if (topHeight == null && defaultOuterHeight != null) topHeight = defaultOuterHeight - stlPaddingV;
	var overflow = style.overflow;
	var wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? {
		width: topWidth,
		accumWidth: 0,
		breakAll: overflow === "breakAll"
	} : null;
	var lastIndex = STYLE_REG.lastIndex = 0;
	var result;
	while ((result = STYLE_REG.exec(text)) != null) {
		var matchedIndex = result.index;
		if (matchedIndex > lastIndex) pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
		pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
		lastIndex = STYLE_REG.lastIndex;
	}
	if (lastIndex < text.length) pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
	var pendingList = [];
	var calculatedHeight = 0;
	var calculatedWidth = 0;
	var truncate = overflow === "truncate";
	var truncateLine = style.lineOverflow === "truncate";
	var tmpTruncateOut = {};
	function finishLine(line$1, lineWidth$1, lineHeight$1) {
		line$1.width = lineWidth$1;
		line$1.lineHeight = lineHeight$1;
		calculatedHeight += lineHeight$1;
		calculatedWidth = Math.max(calculatedWidth, lineWidth$1);
	}
	outer: for (var i$1 = 0; i$1 < contentBlock.lines.length; i$1++) {
		var line = contentBlock.lines[i$1];
		var lineHeight = 0;
		var lineWidth = 0;
		for (var j = 0; j < line.tokens.length; j++) {
			var token = line.tokens[j];
			var tokenStyle = token.styleName && style.rich[token.styleName] || {};
			var textPadding = token.textPadding = tokenStyle.padding;
			var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
			var font = token.font = tokenStyle.font || style.font;
			token.contentHeight = getLineHeight(font);
			var tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);
			token.innerHeight = tokenHeight;
			textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
			token.height = tokenHeight;
			token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
			token.align = tokenStyle && tokenStyle.align || topTextAlign;
			token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
			if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
				var originalLength = contentBlock.lines.length;
				if (j > 0) {
					line.tokens = line.tokens.slice(0, j);
					finishLine(line, lineWidth, lineHeight);
					contentBlock.lines = contentBlock.lines.slice(0, i$1 + 1);
				} else contentBlock.lines = contentBlock.lines.slice(0, i$1);
				contentBlock.isTruncated = contentBlock.isTruncated || contentBlock.lines.length < originalLength;
				break outer;
			}
			var styleTokenWidth = tokenStyle.width;
			var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
			if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
				token.percentWidth = styleTokenWidth;
				pendingList.push(token);
				token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);
			} else {
				if (tokenWidthNotSpecified) {
					var textBackgroundColor = tokenStyle.backgroundColor;
					var bgImg = textBackgroundColor && textBackgroundColor.image;
					if (bgImg) {
						bgImg = findExistImage(bgImg);
						if (isImageReady(bgImg)) token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
					}
				}
				var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;
				if (remainTruncWidth != null && remainTruncWidth < token.width) if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
					token.text = "";
					token.width = token.contentWidth = 0;
				} else {
					truncateText2(tmpTruncateOut, token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
					token.text = tmpTruncateOut.text;
					contentBlock.isTruncated = contentBlock.isTruncated || tmpTruncateOut.isTruncated;
					token.width = token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);
				}
				else token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);
			}
			token.width += paddingH;
			lineWidth += token.width;
			tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
		}
		finishLine(line, lineWidth, lineHeight);
	}
	contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
	contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
	contentBlock.contentHeight = calculatedHeight;
	contentBlock.contentWidth = calculatedWidth;
	contentBlock.outerWidth += stlPaddingH;
	contentBlock.outerHeight += stlPaddingV;
	for (var i$1 = 0; i$1 < pendingList.length; i$1++) {
		var token = pendingList[i$1];
		var percentWidth = token.percentWidth;
		token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
	}
	return contentBlock;
}
function pushTokens(block, str, style, wrapInfo, styleName) {
	var isEmptyStr = str === "";
	var tokenStyle = styleName && style.rich[styleName] || {};
	var lines = block.lines;
	var font = tokenStyle.font || style.font;
	var newLine = false;
	var strLines;
	var linesWidths;
	if (wrapInfo) {
		var tokenPadding = tokenStyle.padding;
		var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
		if (tokenStyle.width != null && tokenStyle.width !== "auto") {
			var outerWidth_1 = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
			if (lines.length > 0) {
				if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
					strLines = str.split("\n");
					newLine = true;
				}
			}
			wrapInfo.accumWidth = outerWidth_1;
		} else {
			var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
			wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
			linesWidths = res.linesWidths;
			strLines = res.lines;
		}
	}
	if (!strLines) strLines = str.split("\n");
	var fontMeasureInfo = ensureFontMeasureInfo(font);
	for (var i$1 = 0; i$1 < strLines.length; i$1++) {
		var text = strLines[i$1];
		var token = new RichTextToken();
		token.styleName = styleName;
		token.text = text;
		token.isLineHolder = !text && !isEmptyStr;
		if (typeof tokenStyle.width === "number") token.width = tokenStyle.width;
		else token.width = linesWidths ? linesWidths[i$1] : measureWidth(fontMeasureInfo, text);
		if (!i$1 && !newLine) {
			var tokens$1 = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
			var tokensLen = tokens$1.length;
			tokensLen === 1 && tokens$1[0].isLineHolder ? tokens$1[0] = token : (text || !tokensLen || isEmptyStr) && tokens$1.push(token);
		} else lines.push(new RichTextLine([token]));
	}
}
function isAlphabeticLetter(ch) {
	var code = ch.charCodeAt(0);
	return code >= 32 && code <= 591 || code >= 880 && code <= 4351 || code >= 4608 && code <= 5119 || code >= 7680 && code <= 8303;
}
var breakCharMap = reduce(",&?/;] ".split(""), function(obj, ch) {
	obj[ch] = true;
	return obj;
}, {});
function isWordBreakChar(ch) {
	if (isAlphabeticLetter(ch)) {
		if (breakCharMap[ch]) return true;
		return false;
	}
	return true;
}
function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
	var lines = [];
	var linesWidths = [];
	var line = "";
	var currentWord = "";
	var currentWordWidth = 0;
	var accumWidth = 0;
	var fontMeasureInfo = ensureFontMeasureInfo(font);
	for (var i$1 = 0; i$1 < text.length; i$1++) {
		var ch = text.charAt(i$1);
		if (ch === "\n") {
			if (currentWord) {
				line += currentWord;
				accumWidth += currentWordWidth;
			}
			lines.push(line);
			linesWidths.push(accumWidth);
			line = "";
			currentWord = "";
			currentWordWidth = 0;
			accumWidth = 0;
			continue;
		}
		var chWidth = measureCharWidth(fontMeasureInfo, ch.charCodeAt(0));
		var inWord = isBreakAll ? false : !isWordBreakChar(ch);
		if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
			if (!accumWidth) if (inWord) {
				lines.push(currentWord);
				linesWidths.push(currentWordWidth);
				currentWord = ch;
				currentWordWidth = chWidth;
			} else {
				lines.push(ch);
				linesWidths.push(chWidth);
			}
			else if (line || currentWord) if (inWord) {
				if (!line) {
					line = currentWord;
					currentWord = "";
					currentWordWidth = 0;
					accumWidth = currentWordWidth;
				}
				lines.push(line);
				linesWidths.push(accumWidth - currentWordWidth);
				currentWord += ch;
				currentWordWidth += chWidth;
				line = "";
				accumWidth = currentWordWidth;
			} else {
				if (currentWord) {
					line += currentWord;
					currentWord = "";
					currentWordWidth = 0;
				}
				lines.push(line);
				linesWidths.push(accumWidth);
				line = ch;
				accumWidth = chWidth;
			}
			continue;
		}
		accumWidth += chWidth;
		if (inWord) {
			currentWord += ch;
			currentWordWidth += chWidth;
		} else {
			if (currentWord) {
				line += currentWord;
				currentWord = "";
				currentWordWidth = 0;
			}
			line += ch;
		}
	}
	if (currentWord) line += currentWord;
	if (line) {
		lines.push(line);
		linesWidths.push(accumWidth);
	}
	if (lines.length === 1) accumWidth += lastAccumWidth;
	return {
		accumWidth,
		lines,
		linesWidths
	};
}
function calcInnerTextOverflowArea(out$1, overflowRect, baseX, baseY, textAlign, textVerticalAlign) {
	out$1.baseX = baseX;
	out$1.baseY = baseY;
	out$1.outerWidth = out$1.outerHeight = null;
	if (!overflowRect) return;
	var textWidth = overflowRect.width * 2;
	var textHeight = overflowRect.height * 2;
	BoundingRect_default.set(tmpCITCTextRect, adjustTextX(baseX, textWidth, textAlign), adjustTextY$1(baseY, textHeight, textVerticalAlign), textWidth, textHeight);
	BoundingRect_default.intersect(overflowRect, tmpCITCTextRect, null, tmpCITCIntersectRectOpt);
	var outIntersectRect = tmpCITCIntersectRectOpt.outIntersectRect;
	out$1.outerWidth = outIntersectRect.width;
	out$1.outerHeight = outIntersectRect.height;
	out$1.baseX = adjustTextX(outIntersectRect.x, outIntersectRect.width, textAlign, true);
	out$1.baseY = adjustTextY$1(outIntersectRect.y, outIntersectRect.height, textVerticalAlign, true);
}
var tmpCITCTextRect = new BoundingRect_default(0, 0, 0, 0);
var tmpCITCIntersectRectOpt = {
	outIntersectRect: {},
	clamp: true
};
function formatText(text) {
	return text != null ? text += "" : text = "";
}
function tSpanCreateBoundingRect(style) {
	var text = formatText(style.text);
	var font = style.font;
	return tSpanCreateBoundingRect2(style, measureWidth(ensureFontMeasureInfo(font), text), getLineHeight(font), null);
}
function tSpanCreateBoundingRect2(style, contentWidth, contentHeight, forceLineWidth) {
	var rect = new BoundingRect_default(adjustTextX(style.x || 0, contentWidth, style.textAlign), adjustTextY$1(style.y || 0, contentHeight, style.textBaseline), contentWidth, contentHeight);
	var lineWidth = forceLineWidth != null ? forceLineWidth : tSpanHasStroke(style) ? style.lineWidth : 0;
	if (lineWidth > 0) {
		rect.x -= lineWidth / 2;
		rect.y -= lineWidth / 2;
		rect.width += lineWidth;
		rect.height += lineWidth;
	}
	return rect;
}
function tSpanHasStroke(style) {
	var stroke = style.stroke;
	return stroke != null && stroke !== "none" && style.lineWidth > 0;
}

//#endregion
//#region node_modules/zrender/lib/graphic/Displayable.js
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
var DEFAULT_COMMON_STYLE = {
	shadowBlur: 0,
	shadowOffsetX: 0,
	shadowOffsetY: 0,
	shadowColor: "#000",
	opacity: 1,
	blend: "source-over"
};
var DEFAULT_COMMON_ANIMATION_PROPS = { style: {
	shadowBlur: true,
	shadowOffsetX: true,
	shadowOffsetY: true,
	shadowColor: true,
	opacity: true
} };
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
var PRIMARY_STATES_KEYS = [
	"z",
	"z2",
	"invisible"
];
var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
var Displayable = function(_super) {
	__extends$1(Displayable$1, _super);
	function Displayable$1(props) {
		return _super.call(this, props) || this;
	}
	Displayable$1.prototype._init = function(props) {
		var keysArr = keys(props);
		for (var i$1 = 0; i$1 < keysArr.length; i$1++) {
			var key$1 = keysArr[i$1];
			if (key$1 === "style") this.useStyle(props[key$1]);
			else _super.prototype.attrKV.call(this, key$1, props[key$1]);
		}
		if (!this.style) this.useStyle({});
	};
	Displayable$1.prototype.beforeBrush = function() {};
	Displayable$1.prototype.afterBrush = function() {};
	Displayable$1.prototype.innerBeforeBrush = function() {};
	Displayable$1.prototype.innerAfterBrush = function() {};
	Displayable$1.prototype.shouldBePainted = function(viewWidth, viewHeight, considerClipPath, considerAncestors) {
		var m$1 = this.transform;
		if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m$1 && !m$1[0] && !m$1[3]) return false;
		if (considerClipPath && this.__clipPaths && this.__clipPaths.length) {
			for (var i$1 = 0; i$1 < this.__clipPaths.length; ++i$1) if (this.__clipPaths[i$1].isZeroArea()) return false;
		}
		if (considerAncestors && this.parent) {
			var parent_1 = this.parent;
			while (parent_1) {
				if (parent_1.ignore) return false;
				parent_1 = parent_1.parent;
			}
		}
		return true;
	};
	Displayable$1.prototype.contain = function(x, y) {
		return this.rectContain(x, y);
	};
	Displayable$1.prototype.traverse = function(cb, context) {
		cb.call(context, this);
	};
	Displayable$1.prototype.rectContain = function(x, y) {
		var coord = this.transformCoordToLocal(x, y);
		return this.getBoundingRect().contain(coord[0], coord[1]);
	};
	Displayable$1.prototype.getPaintRect = function() {
		var rect = this._paintRect;
		if (!this._paintRect || this.__dirty) {
			var transform = this.transform;
			var elRect = this.getBoundingRect();
			var style = this.style;
			var shadowSize = style.shadowBlur || 0;
			var shadowOffsetX = style.shadowOffsetX || 0;
			var shadowOffsetY = style.shadowOffsetY || 0;
			rect = this._paintRect || (this._paintRect = new BoundingRect_default(0, 0, 0, 0));
			if (transform) BoundingRect_default.applyTransform(rect, elRect, transform);
			else rect.copy(elRect);
			if (shadowSize || shadowOffsetX || shadowOffsetY) {
				rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
				rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
				rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
				rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
			}
			var tolerance = this.dirtyRectTolerance;
			if (!rect.isZero()) {
				rect.x = Math.floor(rect.x - tolerance);
				rect.y = Math.floor(rect.y - tolerance);
				rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
				rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
			}
		}
		return rect;
	};
	Displayable$1.prototype.setPrevPaintRect = function(paintRect) {
		if (paintRect) {
			this._prevPaintRect = this._prevPaintRect || new BoundingRect_default(0, 0, 0, 0);
			this._prevPaintRect.copy(paintRect);
		} else this._prevPaintRect = null;
	};
	Displayable$1.prototype.getPrevPaintRect = function() {
		return this._prevPaintRect;
	};
	Displayable$1.prototype.animateStyle = function(loop) {
		return this.animate("style", loop);
	};
	Displayable$1.prototype.updateDuringAnimation = function(targetKey) {
		if (targetKey === "style") this.dirtyStyle();
		else this.markRedraw();
	};
	Displayable$1.prototype.attrKV = function(key$1, value) {
		if (key$1 !== "style") _super.prototype.attrKV.call(this, key$1, value);
		else if (!this.style) this.useStyle(value);
		else this.setStyle(value);
	};
	Displayable$1.prototype.setStyle = function(keyOrObj, value) {
		if (typeof keyOrObj === "string") this.style[keyOrObj] = value;
		else extend(this.style, keyOrObj);
		this.dirtyStyle();
		return this;
	};
	Displayable$1.prototype.dirtyStyle = function(notRedraw) {
		if (!notRedraw) this.markRedraw();
		this.__dirty |= STYLE_CHANGED_BIT;
		if (this._rect) this._rect = null;
	};
	Displayable$1.prototype.dirty = function() {
		this.dirtyStyle();
	};
	Displayable$1.prototype.styleChanged = function() {
		return !!(this.__dirty & STYLE_CHANGED_BIT);
	};
	Displayable$1.prototype.styleUpdated = function() {
		this.__dirty &= ~STYLE_CHANGED_BIT;
	};
	Displayable$1.prototype.createStyle = function(obj) {
		return createObject(DEFAULT_COMMON_STYLE, obj);
	};
	Displayable$1.prototype.useStyle = function(obj) {
		if (!obj[STYLE_MAGIC_KEY]) obj = this.createStyle(obj);
		if (this.__inHover) this.__hoverStyle = obj;
		else this.style = obj;
		this.dirtyStyle();
	};
	Displayable$1.prototype.isStyleObject = function(obj) {
		return obj[STYLE_MAGIC_KEY];
	};
	Displayable$1.prototype._innerSaveToNormal = function(toState) {
		_super.prototype._innerSaveToNormal.call(this, toState);
		var normalState = this._normalState;
		if (toState.style && !normalState.style) normalState.style = this._mergeStyle(this.createStyle(), this.style);
		this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
	};
	Displayable$1.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
		_super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
		var needsRestoreToNormal = !(state && keepCurrentStates);
		var targetStyle;
		if (state && state.style) if (transition) if (keepCurrentStates) targetStyle = state.style;
		else {
			targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
			this._mergeStyle(targetStyle, state.style);
		}
		else {
			targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
			this._mergeStyle(targetStyle, state.style);
		}
		else if (needsRestoreToNormal) targetStyle = normalState.style;
		if (targetStyle) if (transition) {
			var sourceStyle = this.style;
			this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
			if (needsRestoreToNormal) {
				var changedKeys = keys(sourceStyle);
				for (var i$1 = 0; i$1 < changedKeys.length; i$1++) {
					var key$1 = changedKeys[i$1];
					if (key$1 in targetStyle) {
						targetStyle[key$1] = targetStyle[key$1];
						this.style[key$1] = sourceStyle[key$1];
					}
				}
			}
			var targetKeys = keys(targetStyle);
			for (var i$1 = 0; i$1 < targetKeys.length; i$1++) {
				var key$1 = targetKeys[i$1];
				this.style[key$1] = this.style[key$1];
			}
			this._transitionState(stateName, { style: targetStyle }, animationCfg, this.getAnimationStyleProps());
		} else this.useStyle(targetStyle);
		var statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS;
		for (var i$1 = 0; i$1 < statesKeys.length; i$1++) {
			var key$1 = statesKeys[i$1];
			if (state && state[key$1] != null) this[key$1] = state[key$1];
			else if (needsRestoreToNormal) {
				if (normalState[key$1] != null) this[key$1] = normalState[key$1];
			}
		}
	};
	Displayable$1.prototype._mergeStates = function(states) {
		var mergedState = _super.prototype._mergeStates.call(this, states);
		var mergedStyle;
		for (var i$1 = 0; i$1 < states.length; i$1++) {
			var state = states[i$1];
			if (state.style) {
				mergedStyle = mergedStyle || {};
				this._mergeStyle(mergedStyle, state.style);
			}
		}
		if (mergedStyle) mergedState.style = mergedStyle;
		return mergedState;
	};
	Displayable$1.prototype._mergeStyle = function(targetStyle, sourceStyle) {
		extend(targetStyle, sourceStyle);
		return targetStyle;
	};
	Displayable$1.prototype.getAnimationStyleProps = function() {
		return DEFAULT_COMMON_ANIMATION_PROPS;
	};
	Displayable$1.initDefaultProps = (function() {
		var dispProto = Displayable$1.prototype;
		dispProto.type = "displayable";
		dispProto.invisible = false;
		dispProto.z = 0;
		dispProto.z2 = 0;
		dispProto.zlevel = 0;
		dispProto.culling = false;
		dispProto.cursor = "pointer";
		dispProto.rectHover = false;
		dispProto.incremental = false;
		dispProto._rect = null;
		dispProto.dirtyRectTolerance = 0;
		dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
	})();
	return Displayable$1;
}(Element_default);
var tmpRect = new BoundingRect_default(0, 0, 0, 0);
var viewRect = new BoundingRect_default(0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
	tmpRect.copy(el.getBoundingRect());
	if (el.transform) tmpRect.applyTransform(el.transform);
	viewRect.width = width;
	viewRect.height = height;
	return !tmpRect.intersect(viewRect);
}
var Displayable_default = Displayable;

//#endregion
//#region node_modules/zrender/lib/core/bbox.js
var mathMin$10 = Math.min;
var mathMax$10 = Math.max;
var mathSin$4 = Math.sin;
var mathCos$4 = Math.cos;
var PI2$8 = Math.PI * 2;
var start = create$1();
var end = create$1();
var extremity = create$1();
function fromPoints(points$3, min$2, max$2) {
	if (points$3.length === 0) return;
	var p = points$3[0];
	var left = p[0];
	var right = p[0];
	var top = p[1];
	var bottom = p[1];
	for (var i$1 = 1; i$1 < points$3.length; i$1++) {
		p = points$3[i$1];
		left = mathMin$10(left, p[0]);
		right = mathMax$10(right, p[0]);
		top = mathMin$10(top, p[1]);
		bottom = mathMax$10(bottom, p[1]);
	}
	min$2[0] = left;
	min$2[1] = top;
	max$2[0] = right;
	max$2[1] = bottom;
}
function fromLine(x0, y0, x1, y1, min$2, max$2) {
	min$2[0] = mathMin$10(x0, x1);
	min$2[1] = mathMin$10(y0, y1);
	max$2[0] = mathMax$10(x0, x1);
	max$2[1] = mathMax$10(y0, y1);
}
var xDim = [];
var yDim = [];
function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min$2, max$2) {
	var cubicExtrema$1 = cubicExtrema;
	var cubicAt$1 = cubicAt;
	var n = cubicExtrema$1(x0, x1, x2, x3, xDim);
	min$2[0] = Infinity;
	min$2[1] = Infinity;
	max$2[0] = -Infinity;
	max$2[1] = -Infinity;
	for (var i$1 = 0; i$1 < n; i$1++) {
		var x = cubicAt$1(x0, x1, x2, x3, xDim[i$1]);
		min$2[0] = mathMin$10(x, min$2[0]);
		max$2[0] = mathMax$10(x, max$2[0]);
	}
	n = cubicExtrema$1(y0, y1, y2, y3, yDim);
	for (var i$1 = 0; i$1 < n; i$1++) {
		var y = cubicAt$1(y0, y1, y2, y3, yDim[i$1]);
		min$2[1] = mathMin$10(y, min$2[1]);
		max$2[1] = mathMax$10(y, max$2[1]);
	}
	min$2[0] = mathMin$10(x0, min$2[0]);
	max$2[0] = mathMax$10(x0, max$2[0]);
	min$2[0] = mathMin$10(x3, min$2[0]);
	max$2[0] = mathMax$10(x3, max$2[0]);
	min$2[1] = mathMin$10(y0, min$2[1]);
	max$2[1] = mathMax$10(y0, max$2[1]);
	min$2[1] = mathMin$10(y3, min$2[1]);
	max$2[1] = mathMax$10(y3, max$2[1]);
}
function fromQuadratic(x0, y0, x1, y1, x2, y2, min$2, max$2) {
	var quadraticExtremum$1 = quadraticExtremum;
	var quadraticAt$2 = quadraticAt$1;
	var tx = mathMax$10(mathMin$10(quadraticExtremum$1(x0, x1, x2), 1), 0);
	var ty = mathMax$10(mathMin$10(quadraticExtremum$1(y0, y1, y2), 1), 0);
	var x = quadraticAt$2(x0, x1, x2, tx);
	var y = quadraticAt$2(y0, y1, y2, ty);
	min$2[0] = mathMin$10(x0, x2, x);
	min$2[1] = mathMin$10(y0, y2, y);
	max$2[0] = mathMax$10(x0, x2, x);
	max$2[1] = mathMax$10(y0, y2, y);
}
function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min$2, max$2) {
	var vec2Min = min;
	var vec2Max = max;
	var diff = Math.abs(startAngle - endAngle);
	if (diff % PI2$8 < 1e-4 && diff > 1e-4) {
		min$2[0] = x - rx;
		min$2[1] = y - ry;
		max$2[0] = x + rx;
		max$2[1] = y + ry;
		return;
	}
	start[0] = mathCos$4(startAngle) * rx + x;
	start[1] = mathSin$4(startAngle) * ry + y;
	end[0] = mathCos$4(endAngle) * rx + x;
	end[1] = mathSin$4(endAngle) * ry + y;
	vec2Min(min$2, start, end);
	vec2Max(max$2, start, end);
	startAngle = startAngle % PI2$8;
	if (startAngle < 0) startAngle = startAngle + PI2$8;
	endAngle = endAngle % PI2$8;
	if (endAngle < 0) endAngle = endAngle + PI2$8;
	if (startAngle > endAngle && !anticlockwise) endAngle += PI2$8;
	else if (startAngle < endAngle && anticlockwise) startAngle += PI2$8;
	if (anticlockwise) {
		var tmp = endAngle;
		endAngle = startAngle;
		startAngle = tmp;
	}
	for (var angle = 0; angle < endAngle; angle += Math.PI / 2) if (angle > startAngle) {
		extremity[0] = mathCos$4(angle) * rx + x;
		extremity[1] = mathSin$4(angle) * ry + y;
		vec2Min(min$2, extremity, min$2);
		vec2Max(max$2, extremity, max$2);
	}
}

//#endregion
//#region node_modules/zrender/lib/core/PathProxy.js
var CMD$4 = {
	M: 1,
	L: 2,
	C: 3,
	Q: 4,
	A: 5,
	Z: 6,
	R: 7
};
var tmpOutX = [];
var tmpOutY = [];
var min$1 = [];
var max$1 = [];
var min2 = [];
var max2 = [];
var mathMin$9 = Math.min;
var mathMax$9 = Math.max;
var mathCos$3 = Math.cos;
var mathSin$3 = Math.sin;
var mathAbs$4 = Math.abs;
var PI$8 = Math.PI;
var PI2$7 = PI$8 * 2;
var hasTypedArray = typeof Float32Array !== "undefined";
var tmpAngles = [];
function modPI2(radian) {
	return Math.round(radian / PI$8 * 1e8) / 1e8 % 2 * PI$8;
}
function normalizeArcAngles(angles, anticlockwise) {
	var newStartAngle = modPI2(angles[0]);
	if (newStartAngle < 0) newStartAngle += PI2$7;
	var delta = newStartAngle - angles[0];
	var newEndAngle = angles[1];
	newEndAngle += delta;
	if (!anticlockwise && newEndAngle - newStartAngle >= PI2$7) newEndAngle = newStartAngle + PI2$7;
	else if (anticlockwise && newStartAngle - newEndAngle >= PI2$7) newEndAngle = newStartAngle - PI2$7;
	else if (!anticlockwise && newStartAngle > newEndAngle) newEndAngle = newStartAngle + (PI2$7 - modPI2(newStartAngle - newEndAngle));
	else if (anticlockwise && newStartAngle < newEndAngle) newEndAngle = newStartAngle - (PI2$7 - modPI2(newEndAngle - newStartAngle));
	angles[0] = newStartAngle;
	angles[1] = newEndAngle;
}
var PathProxy = function() {
	function PathProxy$1(notSaveData) {
		this.dpr = 1;
		this._xi = 0;
		this._yi = 0;
		this._x0 = 0;
		this._y0 = 0;
		this._len = 0;
		if (notSaveData) this._saveData = false;
		if (this._saveData) this.data = [];
	}
	PathProxy$1.prototype.increaseVersion = function() {
		this._version++;
	};
	PathProxy$1.prototype.getVersion = function() {
		return this._version;
	};
	PathProxy$1.prototype.setScale = function(sx, sy, segmentIgnoreThreshold) {
		segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
		if (segmentIgnoreThreshold > 0) {
			this._ux = mathAbs$4(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
			this._uy = mathAbs$4(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
		}
	};
	PathProxy$1.prototype.setDPR = function(dpr$1) {
		this.dpr = dpr$1;
	};
	PathProxy$1.prototype.setContext = function(ctx) {
		this._ctx = ctx;
	};
	PathProxy$1.prototype.getContext = function() {
		return this._ctx;
	};
	PathProxy$1.prototype.beginPath = function() {
		this._ctx && this._ctx.beginPath();
		this.reset();
		return this;
	};
	PathProxy$1.prototype.reset = function() {
		if (this._saveData) this._len = 0;
		if (this._pathSegLen) {
			this._pathSegLen = null;
			this._pathLen = 0;
		}
		this._version++;
	};
	PathProxy$1.prototype.moveTo = function(x, y) {
		this._drawPendingPt();
		this.addData(CMD$4.M, x, y);
		this._ctx && this._ctx.moveTo(x, y);
		this._x0 = x;
		this._y0 = y;
		this._xi = x;
		this._yi = y;
		return this;
	};
	PathProxy$1.prototype.lineTo = function(x, y) {
		var dx = mathAbs$4(x - this._xi);
		var dy = mathAbs$4(y - this._yi);
		var exceedUnit = dx > this._ux || dy > this._uy;
		this.addData(CMD$4.L, x, y);
		if (this._ctx && exceedUnit) this._ctx.lineTo(x, y);
		if (exceedUnit) {
			this._xi = x;
			this._yi = y;
			this._pendingPtDist = 0;
		} else {
			var d2 = dx * dx + dy * dy;
			if (d2 > this._pendingPtDist) {
				this._pendingPtX = x;
				this._pendingPtY = y;
				this._pendingPtDist = d2;
			}
		}
		return this;
	};
	PathProxy$1.prototype.bezierCurveTo = function(x1, y1, x2, y2, x3, y3) {
		this._drawPendingPt();
		this.addData(CMD$4.C, x1, y1, x2, y2, x3, y3);
		if (this._ctx) this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
		this._xi = x3;
		this._yi = y3;
		return this;
	};
	PathProxy$1.prototype.quadraticCurveTo = function(x1, y1, x2, y2) {
		this._drawPendingPt();
		this.addData(CMD$4.Q, x1, y1, x2, y2);
		if (this._ctx) this._ctx.quadraticCurveTo(x1, y1, x2, y2);
		this._xi = x2;
		this._yi = y2;
		return this;
	};
	PathProxy$1.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
		this._drawPendingPt();
		tmpAngles[0] = startAngle;
		tmpAngles[1] = endAngle;
		normalizeArcAngles(tmpAngles, anticlockwise);
		startAngle = tmpAngles[0];
		endAngle = tmpAngles[1];
		var delta = endAngle - startAngle;
		this.addData(CMD$4.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);
		this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
		this._xi = mathCos$3(endAngle) * r + cx;
		this._yi = mathSin$3(endAngle) * r + cy;
		return this;
	};
	PathProxy$1.prototype.arcTo = function(x1, y1, x2, y2, radius) {
		this._drawPendingPt();
		if (this._ctx) this._ctx.arcTo(x1, y1, x2, y2, radius);
		return this;
	};
	PathProxy$1.prototype.rect = function(x, y, w, h) {
		this._drawPendingPt();
		this._ctx && this._ctx.rect(x, y, w, h);
		this.addData(CMD$4.R, x, y, w, h);
		return this;
	};
	PathProxy$1.prototype.closePath = function() {
		this._drawPendingPt();
		this.addData(CMD$4.Z);
		var ctx = this._ctx;
		var x0 = this._x0;
		var y0 = this._y0;
		if (ctx) ctx.closePath();
		this._xi = x0;
		this._yi = y0;
		return this;
	};
	PathProxy$1.prototype.fill = function(ctx) {
		ctx && ctx.fill();
		this.toStatic();
	};
	PathProxy$1.prototype.stroke = function(ctx) {
		ctx && ctx.stroke();
		this.toStatic();
	};
	PathProxy$1.prototype.len = function() {
		return this._len;
	};
	PathProxy$1.prototype.setData = function(data) {
		if (!this._saveData) return;
		var len$1 = data.length;
		if (!(this.data && this.data.length === len$1) && hasTypedArray) this.data = new Float32Array(len$1);
		for (var i$1 = 0; i$1 < len$1; i$1++) this.data[i$1] = data[i$1];
		this._len = len$1;
	};
	PathProxy$1.prototype.appendPath = function(path) {
		if (!this._saveData) return;
		if (!(path instanceof Array)) path = [path];
		var len$1 = path.length;
		var appendSize = 0;
		var offset = this._len;
		for (var i$1 = 0; i$1 < len$1; i$1++) appendSize += path[i$1].len();
		var oldData = this.data;
		if (hasTypedArray && (oldData instanceof Float32Array || !oldData)) {
			this.data = new Float32Array(offset + appendSize);
			if (offset > 0 && oldData) for (var k$1 = 0; k$1 < offset; k$1++) this.data[k$1] = oldData[k$1];
		}
		for (var i$1 = 0; i$1 < len$1; i$1++) {
			var appendPathData = path[i$1].data;
			for (var k$1 = 0; k$1 < appendPathData.length; k$1++) this.data[offset++] = appendPathData[k$1];
		}
		this._len = offset;
	};
	PathProxy$1.prototype.addData = function(cmd, a, b, c, d, e$1, f, g, h) {
		if (!this._saveData) return;
		var data = this.data;
		if (this._len + arguments.length > data.length) {
			this._expandData();
			data = this.data;
		}
		for (var i$1 = 0; i$1 < arguments.length; i$1++) data[this._len++] = arguments[i$1];
	};
	PathProxy$1.prototype._drawPendingPt = function() {
		if (this._pendingPtDist > 0) {
			this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
			this._pendingPtDist = 0;
		}
	};
	PathProxy$1.prototype._expandData = function() {
		if (!(this.data instanceof Array)) {
			var newData = [];
			for (var i$1 = 0; i$1 < this._len; i$1++) newData[i$1] = this.data[i$1];
			this.data = newData;
		}
	};
	PathProxy$1.prototype.toStatic = function() {
		if (!this._saveData) return;
		this._drawPendingPt();
		var data = this.data;
		if (data instanceof Array) {
			data.length = this._len;
			if (hasTypedArray && this._len > 11) this.data = new Float32Array(data);
		}
	};
	PathProxy$1.prototype.getBoundingRect = function() {
		min$1[0] = min$1[1] = min2[0] = min2[1] = Number.MAX_VALUE;
		max$1[0] = max$1[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
		var data = this.data;
		var xi = 0;
		var yi = 0;
		var x0 = 0;
		var y0 = 0;
		var i$1;
		for (i$1 = 0; i$1 < this._len;) {
			var cmd = data[i$1++];
			var isFirst = i$1 === 1;
			if (isFirst) {
				xi = data[i$1];
				yi = data[i$1 + 1];
				x0 = xi;
				y0 = yi;
			}
			switch (cmd) {
				case CMD$4.M:
					xi = x0 = data[i$1++];
					yi = y0 = data[i$1++];
					min2[0] = x0;
					min2[1] = y0;
					max2[0] = x0;
					max2[1] = y0;
					break;
				case CMD$4.L:
					fromLine(xi, yi, data[i$1], data[i$1 + 1], min2, max2);
					xi = data[i$1++];
					yi = data[i$1++];
					break;
				case CMD$4.C:
					fromCubic(xi, yi, data[i$1++], data[i$1++], data[i$1++], data[i$1++], data[i$1], data[i$1 + 1], min2, max2);
					xi = data[i$1++];
					yi = data[i$1++];
					break;
				case CMD$4.Q:
					fromQuadratic(xi, yi, data[i$1++], data[i$1++], data[i$1], data[i$1 + 1], min2, max2);
					xi = data[i$1++];
					yi = data[i$1++];
					break;
				case CMD$4.A:
					var cx = data[i$1++];
					var cy = data[i$1++];
					var rx = data[i$1++];
					var ry = data[i$1++];
					var startAngle = data[i$1++];
					var endAngle = data[i$1++] + startAngle;
					i$1 += 1;
					var anticlockwise = !data[i$1++];
					if (isFirst) {
						x0 = mathCos$3(startAngle) * rx + cx;
						y0 = mathSin$3(startAngle) * ry + cy;
					}
					fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
					xi = mathCos$3(endAngle) * rx + cx;
					yi = mathSin$3(endAngle) * ry + cy;
					break;
				case CMD$4.R:
					x0 = xi = data[i$1++];
					y0 = yi = data[i$1++];
					var width = data[i$1++];
					var height = data[i$1++];
					fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
					break;
				case CMD$4.Z:
					xi = x0;
					yi = y0;
					break;
			}
			min(min$1, min$1, min2);
			max(max$1, max$1, max2);
		}
		if (i$1 === 0) min$1[0] = min$1[1] = max$1[0] = max$1[1] = 0;
		return new BoundingRect_default(min$1[0], min$1[1], max$1[0] - min$1[0], max$1[1] - min$1[1]);
	};
	PathProxy$1.prototype._calculateLength = function() {
		var data = this.data;
		var len$1 = this._len;
		var ux = this._ux;
		var uy = this._uy;
		var xi = 0;
		var yi = 0;
		var x0 = 0;
		var y0 = 0;
		if (!this._pathSegLen) this._pathSegLen = [];
		var pathSegLen = this._pathSegLen;
		var pathTotalLen = 0;
		var segCount = 0;
		for (var i$1 = 0; i$1 < len$1;) {
			var cmd = data[i$1++];
			var isFirst = i$1 === 1;
			if (isFirst) {
				xi = data[i$1];
				yi = data[i$1 + 1];
				x0 = xi;
				y0 = yi;
			}
			var l = -1;
			switch (cmd) {
				case CMD$4.M:
					xi = x0 = data[i$1++];
					yi = y0 = data[i$1++];
					break;
				case CMD$4.L:
					var x2 = data[i$1++];
					var y2 = data[i$1++];
					var dx = x2 - xi;
					var dy = y2 - yi;
					if (mathAbs$4(dx) > ux || mathAbs$4(dy) > uy || i$1 === len$1 - 1) {
						l = Math.sqrt(dx * dx + dy * dy);
						xi = x2;
						yi = y2;
					}
					break;
				case CMD$4.C:
					var x1 = data[i$1++];
					var y1 = data[i$1++];
					var x2 = data[i$1++];
					var y2 = data[i$1++];
					var x3 = data[i$1++];
					var y3 = data[i$1++];
					l = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);
					xi = x3;
					yi = y3;
					break;
				case CMD$4.Q:
					var x1 = data[i$1++];
					var y1 = data[i$1++];
					var x2 = data[i$1++];
					var y2 = data[i$1++];
					l = quadraticLength(xi, yi, x1, y1, x2, y2, 10);
					xi = x2;
					yi = y2;
					break;
				case CMD$4.A:
					var cx = data[i$1++];
					var cy = data[i$1++];
					var rx = data[i$1++];
					var ry = data[i$1++];
					var startAngle = data[i$1++];
					var delta = data[i$1++];
					var endAngle = delta + startAngle;
					i$1 += 1;
					if (isFirst) {
						x0 = mathCos$3(startAngle) * rx + cx;
						y0 = mathSin$3(startAngle) * ry + cy;
					}
					l = mathMax$9(rx, ry) * mathMin$9(PI2$7, Math.abs(delta));
					xi = mathCos$3(endAngle) * rx + cx;
					yi = mathSin$3(endAngle) * ry + cy;
					break;
				case CMD$4.R:
					x0 = xi = data[i$1++];
					y0 = yi = data[i$1++];
					var width = data[i$1++];
					var height = data[i$1++];
					l = width * 2 + height * 2;
					break;
				case CMD$4.Z:
					var dx = x0 - xi;
					var dy = y0 - yi;
					l = Math.sqrt(dx * dx + dy * dy);
					xi = x0;
					yi = y0;
					break;
			}
			if (l >= 0) {
				pathSegLen[segCount++] = l;
				pathTotalLen += l;
			}
		}
		this._pathLen = pathTotalLen;
		return pathTotalLen;
	};
	PathProxy$1.prototype.rebuildPath = function(ctx, percent) {
		var d = this.data;
		var ux = this._ux;
		var uy = this._uy;
		var len$1 = this._len;
		var x0;
		var y0;
		var xi;
		var yi;
		var x;
		var y;
		var drawPart = percent < 1;
		var pathSegLen;
		var pathTotalLen;
		var accumLength = 0;
		var segCount = 0;
		var displayedLength;
		var pendingPtDist = 0;
		var pendingPtX;
		var pendingPtY;
		if (drawPart) {
			if (!this._pathSegLen) this._calculateLength();
			pathSegLen = this._pathSegLen;
			pathTotalLen = this._pathLen;
			displayedLength = percent * pathTotalLen;
			if (!displayedLength) return;
		}
		lo: for (var i$1 = 0; i$1 < len$1;) {
			var cmd = d[i$1++];
			var isFirst = i$1 === 1;
			if (isFirst) {
				xi = d[i$1];
				yi = d[i$1 + 1];
				x0 = xi;
				y0 = yi;
			}
			if (cmd !== CMD$4.L && pendingPtDist > 0) {
				ctx.lineTo(pendingPtX, pendingPtY);
				pendingPtDist = 0;
			}
			switch (cmd) {
				case CMD$4.M:
					x0 = xi = d[i$1++];
					y0 = yi = d[i$1++];
					ctx.moveTo(xi, yi);
					break;
				case CMD$4.L:
					x = d[i$1++];
					y = d[i$1++];
					var dx = mathAbs$4(x - xi);
					var dy = mathAbs$4(y - yi);
					if (dx > ux || dy > uy) {
						if (drawPart) {
							var l = pathSegLen[segCount++];
							if (accumLength + l > displayedLength) {
								var t = (displayedLength - accumLength) / l;
								ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);
								break lo;
							}
							accumLength += l;
						}
						ctx.lineTo(x, y);
						xi = x;
						yi = y;
						pendingPtDist = 0;
					} else {
						var d2 = dx * dx + dy * dy;
						if (d2 > pendingPtDist) {
							pendingPtX = x;
							pendingPtY = y;
							pendingPtDist = d2;
						}
					}
					break;
				case CMD$4.C:
					var x1 = d[i$1++];
					var y1 = d[i$1++];
					var x2 = d[i$1++];
					var y2 = d[i$1++];
					var x3 = d[i$1++];
					var y3 = d[i$1++];
					if (drawPart) {
						var l = pathSegLen[segCount++];
						if (accumLength + l > displayedLength) {
							var t = (displayedLength - accumLength) / l;
							cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);
							cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);
							ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
							break lo;
						}
						accumLength += l;
					}
					ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
					xi = x3;
					yi = y3;
					break;
				case CMD$4.Q:
					var x1 = d[i$1++];
					var y1 = d[i$1++];
					var x2 = d[i$1++];
					var y2 = d[i$1++];
					if (drawPart) {
						var l = pathSegLen[segCount++];
						if (accumLength + l > displayedLength) {
							var t = (displayedLength - accumLength) / l;
							quadraticSubdivide(xi, x1, x2, t, tmpOutX);
							quadraticSubdivide(yi, y1, y2, t, tmpOutY);
							ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
							break lo;
						}
						accumLength += l;
					}
					ctx.quadraticCurveTo(x1, y1, x2, y2);
					xi = x2;
					yi = y2;
					break;
				case CMD$4.A:
					var cx = d[i$1++];
					var cy = d[i$1++];
					var rx = d[i$1++];
					var ry = d[i$1++];
					var startAngle = d[i$1++];
					var delta = d[i$1++];
					var psi = d[i$1++];
					var anticlockwise = !d[i$1++];
					var r = rx > ry ? rx : ry;
					var isEllipse = mathAbs$4(rx - ry) > .001;
					var endAngle = startAngle + delta;
					var breakBuild = false;
					if (drawPart) {
						var l = pathSegLen[segCount++];
						if (accumLength + l > displayedLength) {
							endAngle = startAngle + delta * (displayedLength - accumLength) / l;
							breakBuild = true;
						}
						accumLength += l;
					}
					if (isEllipse && ctx.ellipse) ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
					else ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
					if (breakBuild) break lo;
					if (isFirst) {
						x0 = mathCos$3(startAngle) * rx + cx;
						y0 = mathSin$3(startAngle) * ry + cy;
					}
					xi = mathCos$3(endAngle) * rx + cx;
					yi = mathSin$3(endAngle) * ry + cy;
					break;
				case CMD$4.R:
					x0 = xi = d[i$1];
					y0 = yi = d[i$1 + 1];
					x = d[i$1++];
					y = d[i$1++];
					var width = d[i$1++];
					var height = d[i$1++];
					if (drawPart) {
						var l = pathSegLen[segCount++];
						if (accumLength + l > displayedLength) {
							var d_1 = displayedLength - accumLength;
							ctx.moveTo(x, y);
							ctx.lineTo(x + mathMin$9(d_1, width), y);
							d_1 -= width;
							if (d_1 > 0) ctx.lineTo(x + width, y + mathMin$9(d_1, height));
							d_1 -= height;
							if (d_1 > 0) ctx.lineTo(x + mathMax$9(width - d_1, 0), y + height);
							d_1 -= width;
							if (d_1 > 0) ctx.lineTo(x, y + mathMax$9(height - d_1, 0));
							break lo;
						}
						accumLength += l;
					}
					ctx.rect(x, y, width, height);
					break;
				case CMD$4.Z:
					if (drawPart) {
						var l = pathSegLen[segCount++];
						if (accumLength + l > displayedLength) {
							var t = (displayedLength - accumLength) / l;
							ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);
							break lo;
						}
						accumLength += l;
					}
					ctx.closePath();
					xi = x0;
					yi = y0;
			}
		}
	};
	PathProxy$1.prototype.clone = function() {
		var newProxy = new PathProxy$1();
		var data = this.data;
		newProxy.data = data.slice ? data.slice() : Array.prototype.slice.call(data);
		newProxy._len = this._len;
		return newProxy;
	};
	PathProxy$1.prototype.canSave = function() {
		return !!this._saveData;
	};
	PathProxy$1.CMD = CMD$4;
	PathProxy$1.initDefaultProps = (function() {
		var proto = PathProxy$1.prototype;
		proto._saveData = true;
		proto._ux = 0;
		proto._uy = 0;
		proto._pendingPtDist = 0;
		proto._version = 0;
	})();
	return PathProxy$1;
}();
var PathProxy_default = PathProxy;

//#endregion
//#region node_modules/zrender/lib/contain/line.js
function containStroke$4(x0, y0, x1, y1, lineWidth, x, y) {
	if (lineWidth === 0) return false;
	var _l = lineWidth;
	var _a$1 = 0;
	var _b$1 = x0;
	if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) return false;
	if (x0 !== x1) {
		_a$1 = (y0 - y1) / (x0 - x1);
		_b$1 = (x0 * y1 - x1 * y0) / (x0 - x1);
	} else return Math.abs(x - x0) <= _l / 2;
	var tmp = _a$1 * x - y + _b$1;
	return tmp * tmp / (_a$1 * _a$1 + 1) <= _l / 2 * _l / 2;
}

//#endregion
//#region node_modules/zrender/lib/contain/cubic.js
function containStroke$3(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	if (lineWidth === 0) return false;
	var _l = lineWidth;
	if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) return false;
	return cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null) <= _l / 2;
}

//#endregion
//#region node_modules/zrender/lib/contain/quadratic.js
function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	if (lineWidth === 0) return false;
	var _l = lineWidth;
	if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) return false;
	return quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null) <= _l / 2;
}

//#endregion
//#region node_modules/zrender/lib/contain/util.js
var PI2$6 = Math.PI * 2;
function normalizeRadian(angle) {
	angle %= PI2$6;
	if (angle < 0) angle += PI2$6;
	return angle;
}

//#endregion
//#region node_modules/zrender/lib/contain/arc.js
var PI2$5 = Math.PI * 2;
function containStroke$1(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
	if (lineWidth === 0) return false;
	var _l = lineWidth;
	x -= cx;
	y -= cy;
	var d = Math.sqrt(x * x + y * y);
	if (d - _l > r || d + _l < r) return false;
	if (Math.abs(startAngle - endAngle) % PI2$5 < 1e-4) return true;
	if (anticlockwise) {
		var tmp = startAngle;
		startAngle = normalizeRadian(endAngle);
		endAngle = normalizeRadian(tmp);
	} else {
		startAngle = normalizeRadian(startAngle);
		endAngle = normalizeRadian(endAngle);
	}
	if (startAngle > endAngle) endAngle += PI2$5;
	var angle = Math.atan2(y, x);
	if (angle < 0) angle += PI2$5;
	return angle >= startAngle && angle <= endAngle || angle + PI2$5 >= startAngle && angle + PI2$5 <= endAngle;
}

//#endregion
//#region node_modules/zrender/lib/contain/windingLine.js
function windingLine(x0, y0, x1, y1, x, y) {
	if (y > y0 && y > y1 || y < y0 && y < y1) return 0;
	if (y1 === y0) return 0;
	var t = (y - y0) / (y1 - y0);
	var dir$1 = y1 < y0 ? 1 : -1;
	if (t === 1 || t === 0) dir$1 = y1 < y0 ? .5 : -.5;
	var x_ = t * (x1 - x0) + x0;
	return x_ === x ? Infinity : x_ > x ? dir$1 : 0;
}

//#endregion
//#region node_modules/zrender/lib/contain/path.js
var CMD$3 = PathProxy_default.CMD;
var PI2$4 = Math.PI * 2;
var EPSILON$1 = 1e-4;
function isAroundEqual$1(a, b) {
	return Math.abs(a - b) < EPSILON$1;
}
var roots = [
	-1,
	-1,
	-1
];
var extrema = [-1, -1];
function swapExtrema() {
	var tmp = extrema[0];
	extrema[0] = extrema[1];
	extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) return 0;
	var nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
	if (nRoots === 0) return 0;
	else {
		var w = 0;
		var nExtrema = -1;
		var y0_ = void 0;
		var y1_ = void 0;
		for (var i$1 = 0; i$1 < nRoots; i$1++) {
			var t = roots[i$1];
			var unit = t === 0 || t === 1 ? .5 : 1;
			if (cubicAt(x0, x1, x2, x3, t) < x) continue;
			if (nExtrema < 0) {
				nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
				if (extrema[1] < extrema[0] && nExtrema > 1) swapExtrema();
				y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
				if (nExtrema > 1) y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
			}
			if (nExtrema === 2) if (t < extrema[0]) w += y0_ < y0 ? unit : -unit;
			else if (t < extrema[1]) w += y1_ < y0_ ? unit : -unit;
			else w += y3 < y1_ ? unit : -unit;
			else if (t < extrema[0]) w += y0_ < y0 ? unit : -unit;
			else w += y3 < y0_ ? unit : -unit;
		}
		return w;
	}
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) return 0;
	var nRoots = quadraticRootAt(y0, y1, y2, y, roots);
	if (nRoots === 0) return 0;
	else {
		var t = quadraticExtremum(y0, y1, y2);
		if (t >= 0 && t <= 1) {
			var w = 0;
			var y_ = quadraticAt$1(y0, y1, y2, t);
			for (var i$1 = 0; i$1 < nRoots; i$1++) {
				var unit = roots[i$1] === 0 || roots[i$1] === 1 ? .5 : 1;
				var x_ = quadraticAt$1(x0, x1, x2, roots[i$1]);
				if (x_ < x) continue;
				if (roots[i$1] < t) w += y_ < y0 ? unit : -unit;
				else w += y2 < y_ ? unit : -unit;
			}
			return w;
		} else {
			var unit = roots[0] === 0 || roots[0] === 1 ? .5 : 1;
			var x_ = quadraticAt$1(x0, x1, x2, roots[0]);
			if (x_ < x) return 0;
			return y2 < y0 ? unit : -unit;
		}
	}
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
	y -= cy;
	if (y > r || y < -r) return 0;
	var tmp = Math.sqrt(r * r - y * y);
	roots[0] = -tmp;
	roots[1] = tmp;
	var dTheta = Math.abs(startAngle - endAngle);
	if (dTheta < 1e-4) return 0;
	if (dTheta >= PI2$4 - 1e-4) {
		startAngle = 0;
		endAngle = PI2$4;
		var dir$1 = anticlockwise ? 1 : -1;
		if (x >= roots[0] + cx && x <= roots[1] + cx) return dir$1;
		else return 0;
	}
	if (startAngle > endAngle) {
		var tmp_1 = startAngle;
		startAngle = endAngle;
		endAngle = tmp_1;
	}
	if (startAngle < 0) {
		startAngle += PI2$4;
		endAngle += PI2$4;
	}
	var w = 0;
	for (var i$1 = 0; i$1 < 2; i$1++) {
		var x_ = roots[i$1];
		if (x_ + cx > x) {
			var angle = Math.atan2(y, x_);
			var dir$1 = anticlockwise ? 1 : -1;
			if (angle < 0) angle = PI2$4 + angle;
			if (angle >= startAngle && angle <= endAngle || angle + PI2$4 >= startAngle && angle + PI2$4 <= endAngle) {
				if (angle > Math.PI / 2 && angle < Math.PI * 1.5) dir$1 = -dir$1;
				w += dir$1;
			}
		}
	}
	return w;
}
function containPath(path, lineWidth, isStroke, x, y) {
	var data = path.data;
	var len$1 = path.len();
	var w = 0;
	var xi = 0;
	var yi = 0;
	var x0 = 0;
	var y0 = 0;
	var x1;
	var y1;
	for (var i$1 = 0; i$1 < len$1;) {
		var cmd = data[i$1++];
		var isFirst = i$1 === 1;
		if (cmd === CMD$3.M && i$1 > 1) {
			if (!isStroke) w += windingLine(xi, yi, x0, y0, x, y);
		}
		if (isFirst) {
			xi = data[i$1];
			yi = data[i$1 + 1];
			x0 = xi;
			y0 = yi;
		}
		switch (cmd) {
			case CMD$3.M:
				x0 = data[i$1++];
				y0 = data[i$1++];
				xi = x0;
				yi = y0;
				break;
			case CMD$3.L:
				if (isStroke) {
					if (containStroke$4(xi, yi, data[i$1], data[i$1 + 1], lineWidth, x, y)) return true;
				} else w += windingLine(xi, yi, data[i$1], data[i$1 + 1], x, y) || 0;
				xi = data[i$1++];
				yi = data[i$1++];
				break;
			case CMD$3.C:
				if (isStroke) {
					if (containStroke$3(xi, yi, data[i$1++], data[i$1++], data[i$1++], data[i$1++], data[i$1], data[i$1 + 1], lineWidth, x, y)) return true;
				} else w += windingCubic(xi, yi, data[i$1++], data[i$1++], data[i$1++], data[i$1++], data[i$1], data[i$1 + 1], x, y) || 0;
				xi = data[i$1++];
				yi = data[i$1++];
				break;
			case CMD$3.Q:
				if (isStroke) {
					if (containStroke$2(xi, yi, data[i$1++], data[i$1++], data[i$1], data[i$1 + 1], lineWidth, x, y)) return true;
				} else w += windingQuadratic(xi, yi, data[i$1++], data[i$1++], data[i$1], data[i$1 + 1], x, y) || 0;
				xi = data[i$1++];
				yi = data[i$1++];
				break;
			case CMD$3.A:
				var cx = data[i$1++];
				var cy = data[i$1++];
				var rx = data[i$1++];
				var ry = data[i$1++];
				var theta = data[i$1++];
				var dTheta = data[i$1++];
				i$1 += 1;
				var anticlockwise = !!(1 - data[i$1++]);
				x1 = Math.cos(theta) * rx + cx;
				y1 = Math.sin(theta) * ry + cy;
				if (!isFirst) w += windingLine(xi, yi, x1, y1, x, y);
				else {
					x0 = x1;
					y0 = y1;
				}
				var _x = (x - cx) * ry / rx + cx;
				if (isStroke) {
					if (containStroke$1(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) return true;
				} else w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
				xi = Math.cos(theta + dTheta) * rx + cx;
				yi = Math.sin(theta + dTheta) * ry + cy;
				break;
			case CMD$3.R:
				x0 = xi = data[i$1++];
				y0 = yi = data[i$1++];
				var width = data[i$1++];
				var height = data[i$1++];
				x1 = x0 + width;
				y1 = y0 + height;
				if (isStroke) {
					if (containStroke$4(x0, y0, x1, y0, lineWidth, x, y) || containStroke$4(x1, y0, x1, y1, lineWidth, x, y) || containStroke$4(x1, y1, x0, y1, lineWidth, x, y) || containStroke$4(x0, y1, x0, y0, lineWidth, x, y)) return true;
				} else {
					w += windingLine(x1, y0, x1, y1, x, y);
					w += windingLine(x0, y1, x0, y0, x, y);
				}
				break;
			case CMD$3.Z:
				if (isStroke) {
					if (containStroke$4(xi, yi, x0, y0, lineWidth, x, y)) return true;
				} else w += windingLine(xi, yi, x0, y0, x, y);
				xi = x0;
				yi = y0;
				break;
		}
	}
	if (!isStroke && !isAroundEqual$1(yi, y0)) w += windingLine(xi, yi, x0, y0, x, y) || 0;
	return w !== 0;
}
function contain$2(pathProxy, x, y) {
	return containPath(pathProxy, 0, false, x, y);
}
function containStroke(pathProxy, lineWidth, x, y) {
	return containPath(pathProxy, lineWidth, true, x, y);
}

//#endregion
//#region node_modules/zrender/lib/graphic/Path.js
var DEFAULT_PATH_STYLE = defaults({
	fill: "#000",
	stroke: null,
	strokePercent: 1,
	fillOpacity: 1,
	strokeOpacity: 1,
	lineDashOffset: 0,
	lineWidth: 1,
	lineCap: "butt",
	miterLimit: 10,
	strokeNoScale: false,
	strokeFirst: false
}, DEFAULT_COMMON_STYLE);
var DEFAULT_PATH_ANIMATION_PROPS = { style: defaults({
	fill: true,
	stroke: true,
	strokePercent: true,
	fillOpacity: true,
	strokeOpacity: true,
	lineDashOffset: true,
	lineWidth: true,
	miterLimit: true
}, DEFAULT_COMMON_ANIMATION_PROPS.style) };
var pathCopyParams = TRANSFORMABLE_PROPS.concat([
	"invisible",
	"culling",
	"z",
	"z2",
	"zlevel",
	"parent"
]);
var Path = function(_super) {
	__extends$1(Path$1, _super);
	function Path$1(opts) {
		return _super.call(this, opts) || this;
	}
	Path$1.prototype.update = function() {
		var _this = this;
		_super.prototype.update.call(this);
		var style = this.style;
		if (style.decal) {
			var decalEl = this._decalEl = this._decalEl || new Path$1();
			if (decalEl.buildPath === Path$1.prototype.buildPath) decalEl.buildPath = function(ctx) {
				_this.buildPath(ctx, _this.shape);
			};
			decalEl.silent = true;
			var decalElStyle = decalEl.style;
			for (var key$1 in style) if (decalElStyle[key$1] !== style[key$1]) decalElStyle[key$1] = style[key$1];
			decalElStyle.fill = style.fill ? style.decal : null;
			decalElStyle.decal = null;
			decalElStyle.shadowColor = null;
			style.strokeFirst && (decalElStyle.stroke = null);
			for (var i$1 = 0; i$1 < pathCopyParams.length; ++i$1) decalEl[pathCopyParams[i$1]] = this[pathCopyParams[i$1]];
			decalEl.__dirty |= REDRAW_BIT;
		} else if (this._decalEl) this._decalEl = null;
	};
	Path$1.prototype.getDecalElement = function() {
		return this._decalEl;
	};
	Path$1.prototype._init = function(props) {
		var keysArr = keys(props);
		this.shape = this.getDefaultShape();
		var defaultStyle = this.getDefaultStyle();
		if (defaultStyle) this.useStyle(defaultStyle);
		for (var i$1 = 0; i$1 < keysArr.length; i$1++) {
			var key$1 = keysArr[i$1];
			var value = props[key$1];
			if (key$1 === "style") if (!this.style) this.useStyle(value);
			else extend(this.style, value);
			else if (key$1 === "shape") extend(this.shape, value);
			else _super.prototype.attrKV.call(this, key$1, value);
		}
		if (!this.style) this.useStyle({});
	};
	Path$1.prototype.getDefaultStyle = function() {
		return null;
	};
	Path$1.prototype.getDefaultShape = function() {
		return {};
	};
	Path$1.prototype.canBeInsideText = function() {
		return this.hasFill();
	};
	Path$1.prototype.getInsideTextFill = function() {
		var pathFill = this.style.fill;
		if (pathFill !== "none") {
			if (isString(pathFill)) {
				var fillLum = lum(pathFill, 0);
				if (fillLum > .5) return DARK_LABEL_COLOR;
				else if (fillLum > .2) return LIGHTER_LABEL_COLOR;
				return LIGHT_LABEL_COLOR;
			} else if (pathFill) return LIGHT_LABEL_COLOR;
		}
		return DARK_LABEL_COLOR;
	};
	Path$1.prototype.getInsideTextStroke = function(textFill) {
		var pathFill = this.style.fill;
		if (isString(pathFill)) {
			var zr = this.__zr;
			if (!!(zr && zr.isDarkMode()) === lum(textFill, 0) < DARK_MODE_THRESHOLD) return pathFill;
		}
	};
	Path$1.prototype.buildPath = function(ctx, shapeCfg, inBatch) {};
	Path$1.prototype.pathUpdated = function() {
		this.__dirty &= ~SHAPE_CHANGED_BIT;
	};
	Path$1.prototype.getUpdatedPathProxy = function(inBatch) {
		!this.path && this.createPathProxy();
		this.path.beginPath();
		this.buildPath(this.path, this.shape, inBatch);
		return this.path;
	};
	Path$1.prototype.createPathProxy = function() {
		this.path = new PathProxy_default(false);
	};
	Path$1.prototype.hasStroke = function() {
		var style = this.style;
		var stroke = style.stroke;
		return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
	};
	Path$1.prototype.hasFill = function() {
		var fill = this.style.fill;
		return fill != null && fill !== "none";
	};
	Path$1.prototype.getBoundingRect = function() {
		var rect = this._rect;
		var style = this.style;
		var needsUpdateRect = !rect;
		if (needsUpdateRect) {
			var firstInvoke = false;
			if (!this.path) {
				firstInvoke = true;
				this.createPathProxy();
			}
			var path = this.path;
			if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
				path.beginPath();
				this.buildPath(path, this.shape, false);
				this.pathUpdated();
			}
			rect = path.getBoundingRect();
		}
		this._rect = rect;
		if (this.hasStroke() && this.path && this.path.len() > 0) {
			var rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
			if (this.__dirty || needsUpdateRect) {
				rectStroke.copy(rect);
				var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
				var w = style.lineWidth;
				if (!this.hasFill()) {
					var strokeContainThreshold = this.strokeContainThreshold;
					w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold);
				}
				if (lineScale > 1e-10) {
					rectStroke.width += w / lineScale;
					rectStroke.height += w / lineScale;
					rectStroke.x -= w / lineScale / 2;
					rectStroke.y -= w / lineScale / 2;
				}
			}
			return rectStroke;
		}
		return rect;
	};
	Path$1.prototype.contain = function(x, y) {
		var localPos = this.transformCoordToLocal(x, y);
		var rect = this.getBoundingRect();
		var style = this.style;
		x = localPos[0];
		y = localPos[1];
		if (rect.contain(x, y)) {
			var pathProxy = this.path;
			if (this.hasStroke()) {
				var lineWidth = style.lineWidth;
				var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
				if (lineScale > 1e-10) {
					if (!this.hasFill()) lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
					if (containStroke(pathProxy, lineWidth / lineScale, x, y)) return true;
				}
			}
			if (this.hasFill()) return contain$2(pathProxy, x, y);
		}
		return false;
	};
	Path$1.prototype.dirtyShape = function() {
		this.__dirty |= SHAPE_CHANGED_BIT;
		if (this._rect) this._rect = null;
		if (this._decalEl) this._decalEl.dirtyShape();
		this.markRedraw();
	};
	Path$1.prototype.dirty = function() {
		this.dirtyStyle();
		this.dirtyShape();
	};
	Path$1.prototype.animateShape = function(loop) {
		return this.animate("shape", loop);
	};
	Path$1.prototype.updateDuringAnimation = function(targetKey) {
		if (targetKey === "style") this.dirtyStyle();
		else if (targetKey === "shape") this.dirtyShape();
		else this.markRedraw();
	};
	Path$1.prototype.attrKV = function(key$1, value) {
		if (key$1 === "shape") this.setShape(value);
		else _super.prototype.attrKV.call(this, key$1, value);
	};
	Path$1.prototype.setShape = function(keyOrObj, value) {
		var shape = this.shape;
		if (!shape) shape = this.shape = {};
		if (typeof keyOrObj === "string") shape[keyOrObj] = value;
		else extend(shape, keyOrObj);
		this.dirtyShape();
		return this;
	};
	Path$1.prototype.shapeChanged = function() {
		return !!(this.__dirty & SHAPE_CHANGED_BIT);
	};
	Path$1.prototype.createStyle = function(obj) {
		return createObject(DEFAULT_PATH_STYLE, obj);
	};
	Path$1.prototype._innerSaveToNormal = function(toState) {
		_super.prototype._innerSaveToNormal.call(this, toState);
		var normalState = this._normalState;
		if (toState.shape && !normalState.shape) normalState.shape = extend({}, this.shape);
	};
	Path$1.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
		_super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
		var needsRestoreToNormal = !(state && keepCurrentStates);
		var targetShape;
		if (state && state.shape) if (transition) if (keepCurrentStates) targetShape = state.shape;
		else {
			targetShape = extend({}, normalState.shape);
			extend(targetShape, state.shape);
		}
		else {
			targetShape = extend({}, keepCurrentStates ? this.shape : normalState.shape);
			extend(targetShape, state.shape);
		}
		else if (needsRestoreToNormal) targetShape = normalState.shape;
		if (targetShape) if (transition) {
			this.shape = extend({}, this.shape);
			var targetShapePrimaryProps = {};
			var shapeKeys = keys(targetShape);
			for (var i$1 = 0; i$1 < shapeKeys.length; i$1++) {
				var key$1 = shapeKeys[i$1];
				if (typeof targetShape[key$1] === "object") this.shape[key$1] = targetShape[key$1];
				else targetShapePrimaryProps[key$1] = targetShape[key$1];
			}
			this._transitionState(stateName, { shape: targetShapePrimaryProps }, animationCfg);
		} else {
			this.shape = targetShape;
			this.dirtyShape();
		}
	};
	Path$1.prototype._mergeStates = function(states) {
		var mergedState = _super.prototype._mergeStates.call(this, states);
		var mergedShape;
		for (var i$1 = 0; i$1 < states.length; i$1++) {
			var state = states[i$1];
			if (state.shape) {
				mergedShape = mergedShape || {};
				this._mergeStyle(mergedShape, state.shape);
			}
		}
		if (mergedShape) mergedState.shape = mergedShape;
		return mergedState;
	};
	Path$1.prototype.getAnimationStyleProps = function() {
		return DEFAULT_PATH_ANIMATION_PROPS;
	};
	Path$1.prototype.isZeroArea = function() {
		return false;
	};
	Path$1.extend = function(defaultProps) {
		var Sub = function(_super$1) {
			__extends$1(Sub$1, _super$1);
			function Sub$1(opts) {
				var _this = _super$1.call(this, opts) || this;
				defaultProps.init && defaultProps.init.call(_this, opts);
				return _this;
			}
			Sub$1.prototype.getDefaultStyle = function() {
				return clone(defaultProps.style);
			};
			Sub$1.prototype.getDefaultShape = function() {
				return clone(defaultProps.shape);
			};
			return Sub$1;
		}(Path$1);
		for (var key$1 in defaultProps) if (typeof defaultProps[key$1] === "function") Sub.prototype[key$1] = defaultProps[key$1];
		return Sub;
	};
	Path$1.initDefaultProps = (function() {
		var pathProto = Path$1.prototype;
		pathProto.type = "path";
		pathProto.strokeContainThreshold = 5;
		pathProto.segmentIgnoreThreshold = 0;
		pathProto.subPixelOptimize = false;
		pathProto.autoBatch = false;
		pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
	})();
	return Path$1;
}(Displayable_default);
var Path_default = Path;

//#endregion
//#region node_modules/zrender/lib/graphic/TSpan.js
var DEFAULT_TSPAN_STYLE = defaults({
	strokeFirst: true,
	font: DEFAULT_FONT,
	x: 0,
	y: 0,
	textAlign: "left",
	textBaseline: "top",
	miterLimit: 2
}, DEFAULT_PATH_STYLE);
var TSpan = function(_super) {
	__extends$1(TSpan$1, _super);
	function TSpan$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	TSpan$1.prototype.hasStroke = function() {
		return tSpanHasStroke(this.style);
	};
	TSpan$1.prototype.hasFill = function() {
		var fill = this.style.fill;
		return fill != null && fill !== "none";
	};
	TSpan$1.prototype.createStyle = function(obj) {
		return createObject(DEFAULT_TSPAN_STYLE, obj);
	};
	TSpan$1.prototype.setBoundingRect = function(rect) {
		this._rect = rect;
	};
	TSpan$1.prototype.getBoundingRect = function() {
		if (!this._rect) this._rect = tSpanCreateBoundingRect(this.style);
		return this._rect;
	};
	TSpan$1.initDefaultProps = (function() {
		var tspanProto = TSpan$1.prototype;
		tspanProto.dirtyRectTolerance = 10;
	})();
	return TSpan$1;
}(Displayable_default);
TSpan.prototype.type = "tspan";
var TSpan_default = TSpan;

//#endregion
//#region node_modules/zrender/lib/graphic/Image.js
var DEFAULT_IMAGE_STYLE = defaults({
	x: 0,
	y: 0
}, DEFAULT_COMMON_STYLE);
var DEFAULT_IMAGE_ANIMATION_PROPS = { style: defaults({
	x: true,
	y: true,
	width: true,
	height: true,
	sx: true,
	sy: true,
	sWidth: true,
	sHeight: true
}, DEFAULT_COMMON_ANIMATION_PROPS.style) };
function isImageLike$1(source) {
	return !!(source && typeof source !== "string" && source.width && source.height);
}
var ZRImage = function(_super) {
	__extends$1(ZRImage$1, _super);
	function ZRImage$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	ZRImage$1.prototype.createStyle = function(obj) {
		return createObject(DEFAULT_IMAGE_STYLE, obj);
	};
	ZRImage$1.prototype._getSize = function(dim) {
		var style = this.style;
		var size = style[dim];
		if (size != null) return size;
		var imageSource = isImageLike$1(style.image) ? style.image : this.__image;
		if (!imageSource) return 0;
		var otherDim = dim === "width" ? "height" : "width";
		var otherDimSize = style[otherDim];
		if (otherDimSize == null) return imageSource[dim];
		else return imageSource[dim] / imageSource[otherDim] * otherDimSize;
	};
	ZRImage$1.prototype.getWidth = function() {
		return this._getSize("width");
	};
	ZRImage$1.prototype.getHeight = function() {
		return this._getSize("height");
	};
	ZRImage$1.prototype.getAnimationStyleProps = function() {
		return DEFAULT_IMAGE_ANIMATION_PROPS;
	};
	ZRImage$1.prototype.getBoundingRect = function() {
		var style = this.style;
		if (!this._rect) this._rect = new BoundingRect_default(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
		return this._rect;
	};
	return ZRImage$1;
}(Displayable_default);
ZRImage.prototype.type = "image";
var Image_default = ZRImage;

//#endregion
//#region node_modules/zrender/lib/graphic/helper/roundRect.js
function buildPath$2(ctx, shape) {
	var x = shape.x;
	var y = shape.y;
	var width = shape.width;
	var height = shape.height;
	var r = shape.r;
	var r1;
	var r2;
	var r3;
	var r4;
	if (width < 0) {
		x = x + width;
		width = -width;
	}
	if (height < 0) {
		y = y + height;
		height = -height;
	}
	if (typeof r === "number") r1 = r2 = r3 = r4 = r;
	else if (r instanceof Array) if (r.length === 1) r1 = r2 = r3 = r4 = r[0];
	else if (r.length === 2) {
		r1 = r3 = r[0];
		r2 = r4 = r[1];
	} else if (r.length === 3) {
		r1 = r[0];
		r2 = r4 = r[1];
		r3 = r[2];
	} else {
		r1 = r[0];
		r2 = r[1];
		r3 = r[2];
		r4 = r[3];
	}
	else r1 = r2 = r3 = r4 = 0;
	var total;
	if (r1 + r2 > width) {
		total = r1 + r2;
		r1 *= width / total;
		r2 *= width / total;
	}
	if (r3 + r4 > width) {
		total = r3 + r4;
		r3 *= width / total;
		r4 *= width / total;
	}
	if (r2 + r3 > height) {
		total = r2 + r3;
		r2 *= height / total;
		r3 *= height / total;
	}
	if (r1 + r4 > height) {
		total = r1 + r4;
		r1 *= height / total;
		r4 *= height / total;
	}
	ctx.moveTo(x + r1, y);
	ctx.lineTo(x + width - r2, y);
	r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
	ctx.lineTo(x + width, y + height - r3);
	r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
	ctx.lineTo(x + r4, y + height);
	r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
	ctx.lineTo(x, y + r1);
	r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
}

//#endregion
//#region node_modules/zrender/lib/graphic/helper/subPixelOptimize.js
var round$4 = Math.round;
function subPixelOptimizeLine(outputShape, inputShape, style) {
	if (!inputShape) return;
	var x1 = inputShape.x1;
	var x2 = inputShape.x2;
	var y1 = inputShape.y1;
	var y2 = inputShape.y2;
	outputShape.x1 = x1;
	outputShape.x2 = x2;
	outputShape.y1 = y1;
	outputShape.y2 = y2;
	var lineWidth = style && style.lineWidth;
	if (!lineWidth) return outputShape;
	if (round$4(x1 * 2) === round$4(x2 * 2)) outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
	if (round$4(y1 * 2) === round$4(y2 * 2)) outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
	return outputShape;
}
function subPixelOptimizeRect$1(outputShape, inputShape, style) {
	if (!inputShape) return;
	var originX = inputShape.x;
	var originY = inputShape.y;
	var originWidth = inputShape.width;
	var originHeight = inputShape.height;
	outputShape.x = originX;
	outputShape.y = originY;
	outputShape.width = originWidth;
	outputShape.height = originHeight;
	var lineWidth = style && style.lineWidth;
	if (!lineWidth) return outputShape;
	outputShape.x = subPixelOptimize(originX, lineWidth, true);
	outputShape.y = subPixelOptimize(originY, lineWidth, true);
	outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
	outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
	return outputShape;
}
function subPixelOptimize(position$1, lineWidth, positiveOrNegative) {
	if (!lineWidth) return position$1;
	var doubledPosition = round$4(position$1 * 2);
	return (doubledPosition + round$4(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Rect.js
var RectShape = function() {
	function RectShape$1() {
		this.x = 0;
		this.y = 0;
		this.width = 0;
		this.height = 0;
	}
	return RectShape$1;
}();
var subPixelOptimizeOutputShape$1 = {};
var Rect$2 = function(_super) {
	__extends$1(Rect$3, _super);
	function Rect$3(opts) {
		return _super.call(this, opts) || this;
	}
	Rect$3.prototype.getDefaultShape = function() {
		return new RectShape();
	};
	Rect$3.prototype.buildPath = function(ctx, shape) {
		var x;
		var y;
		var width;
		var height;
		if (this.subPixelOptimize) {
			var optimizedShape = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, shape, this.style);
			x = optimizedShape.x;
			y = optimizedShape.y;
			width = optimizedShape.width;
			height = optimizedShape.height;
			optimizedShape.r = shape.r;
			shape = optimizedShape;
		} else {
			x = shape.x;
			y = shape.y;
			width = shape.width;
			height = shape.height;
		}
		if (!shape.r) ctx.rect(x, y, width, height);
		else buildPath$2(ctx, shape);
	};
	Rect$3.prototype.isZeroArea = function() {
		return !this.shape.width || !this.shape.height;
	};
	return Rect$3;
}(Path_default);
Rect$2.prototype.type = "rect";
var Rect_default = Rect$2;

//#endregion
//#region node_modules/zrender/lib/graphic/Text.js
var DEFAULT_RICH_TEXT_COLOR = { fill: "#000" };
var DEFAULT_STROKE_LINE_WIDTH = 2;
var tmpCITOverflowAreaOut = {};
var DEFAULT_TEXT_ANIMATION_PROPS = { style: defaults({
	fill: true,
	stroke: true,
	fillOpacity: true,
	strokeOpacity: true,
	lineWidth: true,
	fontSize: true,
	lineHeight: true,
	width: true,
	height: true,
	textShadowColor: true,
	textShadowBlur: true,
	textShadowOffsetX: true,
	textShadowOffsetY: true,
	backgroundColor: true,
	padding: true,
	borderColor: true,
	borderWidth: true,
	borderRadius: true
}, DEFAULT_COMMON_ANIMATION_PROPS.style) };
var ZRText = function(_super) {
	__extends$1(ZRText$1, _super);
	function ZRText$1(opts) {
		var _this = _super.call(this) || this;
		_this.type = "text";
		_this._children = [];
		_this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
		_this.attr(opts);
		return _this;
	}
	ZRText$1.prototype.childrenRef = function() {
		return this._children;
	};
	ZRText$1.prototype.update = function() {
		_super.prototype.update.call(this);
		if (this.styleChanged()) this._updateSubTexts();
		for (var i$1 = 0; i$1 < this._children.length; i$1++) {
			var child = this._children[i$1];
			child.zlevel = this.zlevel;
			child.z = this.z;
			child.z2 = this.z2;
			child.culling = this.culling;
			child.cursor = this.cursor;
			child.invisible = this.invisible;
		}
	};
	ZRText$1.prototype.updateTransform = function() {
		var innerTransformable = this.innerTransformable;
		if (innerTransformable) {
			innerTransformable.updateTransform();
			if (innerTransformable.transform) this.transform = innerTransformable.transform;
		} else _super.prototype.updateTransform.call(this);
	};
	ZRText$1.prototype.getLocalTransform = function(m$1) {
		var innerTransformable = this.innerTransformable;
		return innerTransformable ? innerTransformable.getLocalTransform(m$1) : _super.prototype.getLocalTransform.call(this, m$1);
	};
	ZRText$1.prototype.getComputedTransform = function() {
		if (this.__hostTarget) {
			this.__hostTarget.getComputedTransform();
			this.__hostTarget.updateInnerText(true);
		}
		return _super.prototype.getComputedTransform.call(this);
	};
	ZRText$1.prototype._updateSubTexts = function() {
		this._childCursor = 0;
		normalizeTextStyle(this.style);
		this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
		this._children.length = this._childCursor;
		this.styleUpdated();
	};
	ZRText$1.prototype.addSelfToZr = function(zr) {
		_super.prototype.addSelfToZr.call(this, zr);
		for (var i$1 = 0; i$1 < this._children.length; i$1++) this._children[i$1].__zr = zr;
	};
	ZRText$1.prototype.removeSelfFromZr = function(zr) {
		_super.prototype.removeSelfFromZr.call(this, zr);
		for (var i$1 = 0; i$1 < this._children.length; i$1++) this._children[i$1].__zr = null;
	};
	ZRText$1.prototype.getBoundingRect = function() {
		if (this.styleChanged()) this._updateSubTexts();
		if (!this._rect) {
			var tmpRect$2 = new BoundingRect_default(0, 0, 0, 0);
			var children = this._children;
			var tmpMat = [];
			var rect = null;
			for (var i$1 = 0; i$1 < children.length; i$1++) {
				var child = children[i$1];
				var childRect = child.getBoundingRect();
				var transform = child.getLocalTransform(tmpMat);
				if (transform) {
					tmpRect$2.copy(childRect);
					tmpRect$2.applyTransform(transform);
					rect = rect || tmpRect$2.clone();
					rect.union(tmpRect$2);
				} else {
					rect = rect || childRect.clone();
					rect.union(childRect);
				}
			}
			this._rect = rect || tmpRect$2;
		}
		return this._rect;
	};
	ZRText$1.prototype.setDefaultTextStyle = function(defaultTextStyle) {
		this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
	};
	ZRText$1.prototype.setTextContent = function(textContent) {
		throw new Error("Can't attach text on another text");
	};
	ZRText$1.prototype._mergeStyle = function(targetStyle, sourceStyle) {
		if (!sourceStyle) return targetStyle;
		var sourceRich = sourceStyle.rich;
		var targetRich = targetStyle.rich || sourceRich && {};
		extend(targetStyle, sourceStyle);
		if (sourceRich && targetRich) {
			this._mergeRich(targetRich, sourceRich);
			targetStyle.rich = targetRich;
		} else if (targetRich) targetStyle.rich = targetRich;
		return targetStyle;
	};
	ZRText$1.prototype._mergeRich = function(targetRich, sourceRich) {
		var richNames = keys(sourceRich);
		for (var i$1 = 0; i$1 < richNames.length; i$1++) {
			var richName = richNames[i$1];
			targetRich[richName] = targetRich[richName] || {};
			extend(targetRich[richName], sourceRich[richName]);
		}
	};
	ZRText$1.prototype.getAnimationStyleProps = function() {
		return DEFAULT_TEXT_ANIMATION_PROPS;
	};
	ZRText$1.prototype._getOrCreateChild = function(Ctor) {
		var child = this._children[this._childCursor];
		if (!child || !(child instanceof Ctor)) child = new Ctor();
		this._children[this._childCursor++] = child;
		child.__zr = this.__zr;
		child.parent = this;
		return child;
	};
	ZRText$1.prototype._updatePlainTexts = function() {
		var style = this.style;
		var textFont = style.font || DEFAULT_FONT;
		var textPadding = style.padding;
		var defaultStyle = this._defaultStyle;
		var baseX = style.x || 0;
		var baseY = style.y || 0;
		var textAlign = style.align || defaultStyle.align || "left";
		var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
		calcInnerTextOverflowArea(tmpCITOverflowAreaOut, defaultStyle.overflowRect, baseX, baseY, textAlign, verticalAlign);
		baseX = tmpCITOverflowAreaOut.baseX;
		baseY = tmpCITOverflowAreaOut.baseY;
		var contentBlock = parsePlainText(getStyleText(style), style, tmpCITOverflowAreaOut.outerWidth, tmpCITOverflowAreaOut.outerHeight);
		var needDrawBg = needDrawBackground(style);
		var bgColorDrawn = !!style.backgroundColor;
		var outerHeight = contentBlock.outerHeight;
		var outerWidth = contentBlock.outerWidth;
		var textLines = contentBlock.lines;
		var lineHeight = contentBlock.lineHeight;
		this.isTruncated = !!contentBlock.isTruncated;
		var textX = baseX;
		var textY = adjustTextY$1(baseY, contentBlock.contentHeight, verticalAlign);
		if (needDrawBg || textPadding) {
			var boxX = adjustTextX(baseX, outerWidth, textAlign);
			var boxY = adjustTextY$1(baseY, outerHeight, verticalAlign);
			needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
		}
		textY += lineHeight / 2;
		if (textPadding) {
			textX = getTextXForPadding(baseX, textAlign, textPadding);
			if (verticalAlign === "top") textY += textPadding[0];
			else if (verticalAlign === "bottom") textY -= textPadding[2];
		}
		var defaultLineWidth = 0;
		var usingDefaultStroke = false;
		var useDefaultFill = false;
		var textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
		var textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, usingDefaultStroke = true, defaultStyle.stroke) : null);
		var hasShadow$1 = style.textShadowBlur > 0;
		for (var i$1 = 0; i$1 < textLines.length; i$1++) {
			var el = this._getOrCreateChild(TSpan_default);
			var subElStyle = el.createStyle();
			el.useStyle(subElStyle);
			subElStyle.text = textLines[i$1];
			subElStyle.x = textX;
			subElStyle.y = textY;
			if (textAlign) subElStyle.textAlign = textAlign;
			subElStyle.textBaseline = "middle";
			subElStyle.opacity = style.opacity;
			subElStyle.strokeFirst = true;
			if (hasShadow$1) {
				subElStyle.shadowBlur = style.textShadowBlur || 0;
				subElStyle.shadowColor = style.textShadowColor || "transparent";
				subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
				subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
			}
			subElStyle.stroke = textStroke;
			subElStyle.fill = textFill;
			if (textStroke) {
				subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
				subElStyle.lineDash = style.lineDash;
				subElStyle.lineDashOffset = style.lineDashOffset || 0;
			}
			subElStyle.font = textFont;
			setSeparateFont(subElStyle, style);
			textY += lineHeight;
			el.setBoundingRect(tSpanCreateBoundingRect2(subElStyle, contentBlock.contentWidth, contentBlock.calculatedLineHeight, usingDefaultStroke ? 0 : null));
		}
	};
	ZRText$1.prototype._updateRichTexts = function() {
		var style = this.style;
		var defaultStyle = this._defaultStyle;
		var textAlign = style.align || defaultStyle.align;
		var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
		var baseX = style.x || 0;
		var baseY = style.y || 0;
		calcInnerTextOverflowArea(tmpCITOverflowAreaOut, defaultStyle.overflowRect, baseX, baseY, textAlign, verticalAlign);
		baseX = tmpCITOverflowAreaOut.baseX;
		baseY = tmpCITOverflowAreaOut.baseY;
		var contentBlock = parseRichText(getStyleText(style), style, tmpCITOverflowAreaOut.outerWidth, tmpCITOverflowAreaOut.outerHeight, textAlign);
		var contentWidth = contentBlock.width;
		var outerWidth = contentBlock.outerWidth;
		var outerHeight = contentBlock.outerHeight;
		var textPadding = style.padding;
		this.isTruncated = !!contentBlock.isTruncated;
		var boxX = adjustTextX(baseX, outerWidth, textAlign);
		var boxY = adjustTextY$1(baseY, outerHeight, verticalAlign);
		var xLeft = boxX;
		var lineTop = boxY;
		if (textPadding) {
			xLeft += textPadding[3];
			lineTop += textPadding[0];
		}
		var xRight = xLeft + contentWidth;
		if (needDrawBackground(style)) this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
		var bgColorDrawn = !!style.backgroundColor;
		for (var i$1 = 0; i$1 < contentBlock.lines.length; i$1++) {
			var line = contentBlock.lines[i$1];
			var tokens$1 = line.tokens;
			var tokenCount = tokens$1.length;
			var lineHeight = line.lineHeight;
			var remainedWidth = line.width;
			var leftIndex = 0;
			var lineXLeft = xLeft;
			var lineXRight = xRight;
			var rightIndex = tokenCount - 1;
			var token = void 0;
			while (leftIndex < tokenCount && (token = tokens$1[leftIndex], !token.align || token.align === "left")) {
				this._placeToken(token, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
				remainedWidth -= token.width;
				lineXLeft += token.width;
				leftIndex++;
			}
			while (rightIndex >= 0 && (token = tokens$1[rightIndex], token.align === "right")) {
				this._placeToken(token, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
				remainedWidth -= token.width;
				lineXRight -= token.width;
				rightIndex--;
			}
			lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
			while (leftIndex <= rightIndex) {
				token = tokens$1[leftIndex];
				this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center", bgColorDrawn);
				lineXLeft += token.width;
				leftIndex++;
			}
			lineTop += lineHeight;
		}
	};
	ZRText$1.prototype._placeToken = function(token, style, lineHeight, lineTop, x, textAlign, parentBgColorDrawn) {
		var tokenStyle = style.rich[token.styleName] || {};
		tokenStyle.text = token.text;
		var verticalAlign = token.verticalAlign;
		var y = lineTop + lineHeight / 2;
		if (verticalAlign === "top") y = lineTop + token.height / 2;
		else if (verticalAlign === "bottom") y = lineTop + lineHeight - token.height / 2;
		!token.isLineHolder && needDrawBackground(tokenStyle) && this._renderBackground(tokenStyle, style, textAlign === "right" ? x - token.width : textAlign === "center" ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
		var bgColorDrawn = !!tokenStyle.backgroundColor;
		var textPadding = token.textPadding;
		if (textPadding) {
			x = getTextXForPadding(x, textAlign, textPadding);
			y -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
		}
		var el = this._getOrCreateChild(TSpan_default);
		var subElStyle = el.createStyle();
		el.useStyle(subElStyle);
		var defaultStyle = this._defaultStyle;
		var useDefaultFill = false;
		var defaultLineWidth = 0;
		var usingDefaultStroke = false;
		var textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : "fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
		var textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : "stroke" in style ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, usingDefaultStroke = true, defaultStyle.stroke) : null);
		var hasShadow$1 = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
		subElStyle.text = token.text;
		subElStyle.x = x;
		subElStyle.y = y;
		if (hasShadow$1) {
			subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
			subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
			subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
			subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
		}
		subElStyle.textAlign = textAlign;
		subElStyle.textBaseline = "middle";
		subElStyle.font = token.font || DEFAULT_FONT;
		subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
		setSeparateFont(subElStyle, tokenStyle);
		if (textStroke) {
			subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
			subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
			subElStyle.lineDashOffset = style.lineDashOffset || 0;
			subElStyle.stroke = textStroke;
		}
		if (textFill) subElStyle.fill = textFill;
		el.setBoundingRect(tSpanCreateBoundingRect2(subElStyle, token.contentWidth, token.contentHeight, usingDefaultStroke ? 0 : null));
	};
	ZRText$1.prototype._renderBackground = function(style, topStyle, x, y, width, height) {
		var textBackgroundColor = style.backgroundColor;
		var textBorderWidth = style.borderWidth;
		var textBorderColor = style.borderColor;
		var isImageBg = textBackgroundColor && textBackgroundColor.image;
		var isPlainOrGradientBg = textBackgroundColor && !isImageBg;
		var textBorderRadius = style.borderRadius;
		var self$1 = this;
		var rectEl;
		var imgEl;
		if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
			rectEl = this._getOrCreateChild(Rect_default);
			rectEl.useStyle(rectEl.createStyle());
			rectEl.style.fill = null;
			var rectShape = rectEl.shape;
			rectShape.x = x;
			rectShape.y = y;
			rectShape.width = width;
			rectShape.height = height;
			rectShape.r = textBorderRadius;
			rectEl.dirtyShape();
		}
		if (isPlainOrGradientBg) {
			var rectStyle = rectEl.style;
			rectStyle.fill = textBackgroundColor || null;
			rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
		} else if (isImageBg) {
			imgEl = this._getOrCreateChild(Image_default);
			imgEl.onload = function() {
				self$1.dirtyStyle();
			};
			var imgStyle = imgEl.style;
			imgStyle.image = textBackgroundColor.image;
			imgStyle.x = x;
			imgStyle.y = y;
			imgStyle.width = width;
			imgStyle.height = height;
		}
		if (textBorderWidth && textBorderColor) {
			var rectStyle = rectEl.style;
			rectStyle.lineWidth = textBorderWidth;
			rectStyle.stroke = textBorderColor;
			rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
			rectStyle.lineDash = style.borderDash;
			rectStyle.lineDashOffset = style.borderDashOffset || 0;
			rectEl.strokeContainThreshold = 0;
			if (rectEl.hasFill() && rectEl.hasStroke()) {
				rectStyle.strokeFirst = true;
				rectStyle.lineWidth *= 2;
			}
		}
		var commonStyle = (rectEl || imgEl).style;
		commonStyle.shadowBlur = style.shadowBlur || 0;
		commonStyle.shadowColor = style.shadowColor || "transparent";
		commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
		commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
		commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
	};
	ZRText$1.makeFont = function(style) {
		var font = "";
		if (hasSeparateFont(style)) font = [
			style.fontStyle,
			style.fontWeight,
			parseFontSize(style.fontSize),
			style.fontFamily || "sans-serif"
		].join(" ");
		return font && trim(font) || style.textFont || style.font;
	};
	return ZRText$1;
}(Displayable_default);
var VALID_TEXT_ALIGN = {
	left: true,
	right: 1,
	center: 1
};
var VALID_TEXT_VERTICAL_ALIGN = {
	top: 1,
	bottom: 1,
	middle: 1
};
var FONT_PARTS = [
	"fontStyle",
	"fontWeight",
	"fontSize",
	"fontFamily"
];
function parseFontSize(fontSize) {
	if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) return fontSize;
	else if (!isNaN(+fontSize)) return fontSize + "px";
	else return DEFAULT_FONT_SIZE + "px";
}
function setSeparateFont(targetStyle, sourceStyle) {
	for (var i$1 = 0; i$1 < FONT_PARTS.length; i$1++) {
		var fontProp = FONT_PARTS[i$1];
		var val = sourceStyle[fontProp];
		if (val != null) targetStyle[fontProp] = val;
	}
}
function hasSeparateFont(style) {
	return style.fontSize != null || style.fontFamily || style.fontWeight;
}
function normalizeTextStyle(style) {
	normalizeStyle(style);
	each(style.rich, normalizeStyle);
	return style;
}
function normalizeStyle(style) {
	if (style) {
		style.font = ZRText.makeFont(style);
		var textAlign = style.align;
		textAlign === "middle" && (textAlign = "center");
		style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
		var verticalAlign = style.verticalAlign;
		verticalAlign === "center" && (verticalAlign = "middle");
		style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
		if (style.padding) style.padding = normalizeCssArray$1(style.padding);
	}
}
function getStroke(stroke, lineWidth) {
	return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
}
function getFill(fill) {
	return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
}
function getTextXForPadding(x, textAlign, textPadding) {
	return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}
function getStyleText(style) {
	var text = style.text;
	text != null && (text += "");
	return text;
}
function needDrawBackground(style) {
	return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
}
var Text_default = ZRText;

//#endregion
//#region node_modules/echarts/lib/util/innerStore.js
var getECData = makeInner();
var setCommonECData = function(seriesIndex, dataType, dataIdx, el) {
	if (el) {
		var ecData = getECData(el);
		ecData.dataIndex = dataIdx;
		ecData.dataType = dataType;
		ecData.seriesIndex = seriesIndex;
		ecData.ssrType = "chart";
		if (el.type === "group") el.traverse(function(child) {
			var childECData = getECData(child);
			childECData.seriesIndex = seriesIndex;
			childECData.dataIndex = dataIdx;
			childECData.dataType = dataType;
			childECData.ssrType = "chart";
		});
	}
};

//#endregion
//#region node_modules/echarts/lib/util/states.js
var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var getSavedStates = makeInner();
var getComponentStates = makeInner();
var HOVER_STATE_NORMAL = 0;
var HOVER_STATE_BLUR = 1;
var HOVER_STATE_EMPHASIS = 2;
var SPECIAL_STATES = [
	"emphasis",
	"blur",
	"select"
];
var DISPLAY_STATES = [
	"normal",
	"emphasis",
	"blur",
	"select"
];
var Z2_EMPHASIS_LIFT = 10;
var Z2_SELECT_LIFT = 9;
var HIGHLIGHT_ACTION_TYPE = "highlight";
var DOWNPLAY_ACTION_TYPE = "downplay";
var SELECT_ACTION_TYPE = "select";
var UNSELECT_ACTION_TYPE = "unselect";
var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
var SELECT_CHANGED_EVENT_TYPE = "selectchanged";
function hasFillOrStroke(fillOrStroke) {
	return fillOrStroke != null && fillOrStroke !== "none";
}
function doChangeHoverState(el, stateName, hoverStateEnum) {
	if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) el.onHoverStateChange(stateName);
	el.hoverState = hoverStateEnum;
}
function singleEnterEmphasis(el) {
	doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(el) {
	if (el.hoverState === HOVER_STATE_EMPHASIS) doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
}
function singleEnterBlur(el) {
	doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(el) {
	if (el.hoverState === HOVER_STATE_BLUR) doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
}
function singleEnterSelect(el) {
	el.selected = true;
}
function singleLeaveSelect(el) {
	el.selected = false;
}
function updateElementState(el, updater, commonParam) {
	updater(el, commonParam);
}
function traverseUpdateState(el, updater, commonParam) {
	updateElementState(el, updater, commonParam);
	el.isGroup && el.traverse(function(child) {
		updateElementState(child, updater, commonParam);
	});
}
function setStatesFlag(el, stateName) {
	switch (stateName) {
		case "emphasis":
			el.hoverState = HOVER_STATE_EMPHASIS;
			break;
		case "normal":
			el.hoverState = HOVER_STATE_NORMAL;
			break;
		case "blur":
			el.hoverState = HOVER_STATE_BLUR;
			break;
		case "select": el.selected = true;
	}
}
function getFromStateStyle(el, props, toStateName, defaultValue) {
	var style = el.style;
	var fromState = {};
	for (var i$1 = 0; i$1 < props.length; i$1++) {
		var propName = props[i$1];
		var val = style[propName];
		fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
	}
	for (var i$1 = 0; i$1 < el.animators.length; i$1++) {
		var animator = el.animators[i$1];
		if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") animator.saveTo(fromState, props);
	}
	return fromState;
}
function createEmphasisDefaultState(el, stateName, targetStates, state) {
	var hasSelect = targetStates && indexOf(targetStates, "select") >= 0;
	var cloned = false;
	if (el instanceof Path_default) {
		var store = getSavedStates(el);
		var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
		var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
		if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
			state = state || {};
			var emphasisStyle = state.style || {};
			if (emphasisStyle.fill === "inherit") {
				cloned = true;
				state = extend({}, state);
				emphasisStyle = extend({}, emphasisStyle);
				emphasisStyle.fill = fromFill;
			} else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
				cloned = true;
				state = extend({}, state);
				emphasisStyle = extend({}, emphasisStyle);
				emphasisStyle.fill = liftColor(fromFill);
			} else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
				if (!cloned) {
					state = extend({}, state);
					emphasisStyle = extend({}, emphasisStyle);
				}
				emphasisStyle.stroke = liftColor(fromStroke);
			}
			state.style = emphasisStyle;
		}
	}
	if (state) {
		if (state.z2 == null) {
			if (!cloned) state = extend({}, state);
			var z2EmphasisLift = el.z2EmphasisLift;
			state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
		}
	}
	return state;
}
function createSelectDefaultState(el, stateName, state) {
	if (state) {
		if (state.z2 == null) {
			state = extend({}, state);
			var z2SelectLift = el.z2SelectLift;
			state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
		}
	}
	return state;
}
function createBlurDefaultState(el, stateName, state) {
	var hasBlur = indexOf(el.currentStates, stateName) >= 0;
	var currentOpacity = el.style.opacity;
	var fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, { opacity: 1 }) : null;
	state = state || {};
	var blurStyle = state.style || {};
	if (blurStyle.opacity == null) {
		state = extend({}, state);
		blurStyle = extend({ opacity: hasBlur ? currentOpacity : fromState.opacity * .1 }, blurStyle);
		state.style = blurStyle;
	}
	return state;
}
function elementStateProxy(stateName, targetStates) {
	var state = this.states[stateName];
	if (this.style) {
		if (stateName === "emphasis") return createEmphasisDefaultState(this, stateName, targetStates, state);
		else if (stateName === "blur") return createBlurDefaultState(this, stateName, state);
		else if (stateName === "select") return createSelectDefaultState(this, stateName, state);
	}
	return state;
}
/**
* Set hover style (namely "emphasis style") of element.
* @param el Should not be `zrender/graphic/Group`.
* @param focus 'self' | 'selfInSeries' | 'series'
*/
function setDefaultStateProxy(el) {
	el.stateProxy = elementStateProxy;
	var textContent = el.getTextContent();
	var textGuide = el.getTextGuideLine();
	if (textContent) textContent.stateProxy = elementStateProxy;
	if (textGuide) textGuide.stateProxy = elementStateProxy;
}
function enterEmphasisWhenMouseOver(el, e$1) {
	!shouldSilent(el, e$1) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(el, e$1) {
	!shouldSilent(el, e$1) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterEmphasis(el, highlightDigit) {
	el.__highByOuter |= 1 << (highlightDigit || 0);
	traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasis(el, highlightDigit) {
	!(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterBlur(el) {
	traverseUpdateState(el, singleEnterBlur);
}
function leaveBlur(el) {
	traverseUpdateState(el, singleLeaveBlur);
}
function enterSelect(el) {
	traverseUpdateState(el, singleEnterSelect);
}
function leaveSelect(el) {
	traverseUpdateState(el, singleLeaveSelect);
}
function shouldSilent(el, e$1) {
	return el.__highDownSilentOnTouch && e$1.zrByTouch;
}
function allLeaveBlur(api) {
	var model = api.getModel();
	var leaveBlurredSeries = [];
	var allComponentViews = [];
	model.eachComponent(function(componentType, componentModel) {
		var componentStates = getComponentStates(componentModel);
		var isSeries$1 = componentType === "series";
		var view = isSeries$1 ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
		!isSeries$1 && allComponentViews.push(view);
		if (componentStates.isBlured) {
			view.group.traverse(function(child) {
				singleLeaveBlur(child);
			});
			isSeries$1 && leaveBlurredSeries.push(componentModel);
		}
		componentStates.isBlured = false;
	});
	each(allComponentViews, function(view) {
		if (view && view.toggleBlurSeries) view.toggleBlurSeries(leaveBlurredSeries, false, model);
	});
}
function blurSeries(targetSeriesIndex, focus, blurScope, api) {
	var ecModel = api.getModel();
	blurScope = blurScope || "coordinateSystem";
	function leaveBlurOfIndices(data, dataIndices) {
		for (var i$1 = 0; i$1 < dataIndices.length; i$1++) {
			var itemEl = data.getItemGraphicEl(dataIndices[i$1]);
			itemEl && leaveBlur(itemEl);
		}
	}
	if (targetSeriesIndex == null) return;
	if (!focus || focus === "none") return;
	var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
	var targetCoordSys = targetSeriesModel.coordinateSystem;
	if (targetCoordSys && targetCoordSys.master) targetCoordSys = targetCoordSys.master;
	var blurredSeries = [];
	ecModel.eachSeries(function(seriesModel) {
		var sameSeries = targetSeriesModel === seriesModel;
		var coordSys = seriesModel.coordinateSystem;
		if (coordSys && coordSys.master) coordSys = coordSys.master;
		if (!(blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !(coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries) || focus === "series" && sameSeries)) {
			api.getViewOfSeriesModel(seriesModel).group.traverse(function(child) {
				if (child.__highByOuter && sameSeries && focus === "self") return;
				singleEnterBlur(child);
			});
			if (isArrayLike(focus)) leaveBlurOfIndices(seriesModel.getData(), focus);
			else if (isObject(focus)) {
				var dataTypes = keys(focus);
				for (var d = 0; d < dataTypes.length; d++) leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);
			}
			blurredSeries.push(seriesModel);
			getComponentStates(seriesModel).isBlured = true;
		}
	});
	ecModel.eachComponent(function(componentType, componentModel) {
		if (componentType === "series") return;
		var view = api.getViewOfComponentModel(componentModel);
		if (view && view.toggleBlurSeries) view.toggleBlurSeries(blurredSeries, true, ecModel);
	});
}
function blurComponent(componentMainType, componentIndex, api) {
	if (componentMainType == null || componentIndex == null) return;
	var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
	if (!componentModel) return;
	getComponentStates(componentModel).isBlured = true;
	var view = api.getViewOfComponentModel(componentModel);
	if (!view || !view.focusBlurEnabled) return;
	view.group.traverse(function(child) {
		singleEnterBlur(child);
	});
}
function blurSeriesFromHighlightPayload(seriesModel, payload, api) {
	var seriesIndex = seriesModel.seriesIndex;
	var data = seriesModel.getData(payload.dataType);
	if (!data) {
		error("Unknown dataType " + payload.dataType);
		return;
	}
	var dataIndex = queryDataIndex(data, payload);
	dataIndex = (isArray(dataIndex) ? dataIndex[0] : dataIndex) || 0;
	var el = data.getItemGraphicEl(dataIndex);
	if (!el) {
		var count$1 = data.count();
		var current = 0;
		while (!el && current < count$1) el = data.getItemGraphicEl(current++);
	}
	if (el) {
		var ecData = getECData(el);
		blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);
	} else {
		var focus_1 = seriesModel.get(["emphasis", "focus"]);
		var blurScope = seriesModel.get(["emphasis", "blurScope"]);
		if (focus_1 != null) blurSeries(seriesIndex, focus_1, blurScope, api);
	}
}
function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api) {
	var ret = {
		focusSelf: false,
		dispatchers: null
	};
	if (componentMainType == null || componentMainType === "series" || componentIndex == null || name == null) return ret;
	var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
	if (!componentModel) return ret;
	var view = api.getViewOfComponentModel(componentModel);
	if (!view || !view.findHighDownDispatchers) return ret;
	var dispatchers = view.findHighDownDispatchers(name);
	var focusSelf;
	for (var i$1 = 0; i$1 < dispatchers.length; i$1++) {
		if (!isHighDownDispatcher(dispatchers[i$1])) error("param should be highDownDispatcher");
		if (getECData(dispatchers[i$1]).focus === "self") {
			focusSelf = true;
			break;
		}
	}
	return {
		focusSelf,
		dispatchers
	};
}
function handleGlobalMouseOverForHighDown(dispatcher, e$1, api) {
	if (!isHighDownDispatcher(dispatcher)) error("param should be highDownDispatcher");
	var ecData = getECData(dispatcher);
	var _a$1 = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api), dispatchers = _a$1.dispatchers, focusSelf = _a$1.focusSelf;
	if (dispatchers) {
		if (focusSelf) blurComponent(ecData.componentMainType, ecData.componentIndex, api);
		each(dispatchers, function(dispatcher$1) {
			return enterEmphasisWhenMouseOver(dispatcher$1, e$1);
		});
	} else {
		blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);
		if (ecData.focus === "self") blurComponent(ecData.componentMainType, ecData.componentIndex, api);
		enterEmphasisWhenMouseOver(dispatcher, e$1);
	}
}
function handleGlobalMouseOutForHighDown(dispatcher, e$1, api) {
	if (!isHighDownDispatcher(dispatcher)) error("param should be highDownDispatcher");
	allLeaveBlur(api);
	var ecData = getECData(dispatcher);
	var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;
	if (dispatchers) each(dispatchers, function(dispatcher$1) {
		return leaveEmphasisWhenMouseOut(dispatcher$1, e$1);
	});
	else leaveEmphasisWhenMouseOut(dispatcher, e$1);
}
function toggleSelectionFromPayload(seriesModel, payload, api) {
	if (!isSelectChangePayload(payload)) return;
	var dataType = payload.dataType;
	var dataIndex = queryDataIndex(seriesModel.getData(dataType), payload);
	if (!isArray(dataIndex)) dataIndex = [dataIndex];
	seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
}
function updateSeriesElementSelection(seriesModel) {
	each(seriesModel.getAllData(), function(_a$1) {
		var data = _a$1.data, type = _a$1.type;
		data.eachItemGraphicEl(function(el, idx) {
			seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
		});
	});
}
function getAllSelectedIndices(ecModel) {
	var ret = [];
	ecModel.eachSeries(function(seriesModel) {
		each(seriesModel.getAllData(), function(_a$1) {
			_a$1.data;
			var type = _a$1.type;
			var dataIndices = seriesModel.getSelectedDataIndices();
			if (dataIndices.length > 0) {
				var item = {
					dataIndex: dataIndices,
					seriesIndex: seriesModel.seriesIndex
				};
				if (type != null) item.dataType = type;
				ret.push(item);
			}
		});
	});
	return ret;
}
/**
* Enable the function that mouseover will trigger the emphasis state.
*
* NOTE:
* This function should be used on the element with dataIndex, seriesIndex.
*
*/
function enableHoverEmphasis(el, focus, blurScope) {
	setAsHighDownDispatcher(el, true);
	traverseUpdateState(el, setDefaultStateProxy);
	enableHoverFocus(el, focus, blurScope);
}
function disableHoverEmphasis(el) {
	setAsHighDownDispatcher(el, false);
}
function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
	isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
}
function enableHoverFocus(el, focus, blurScope) {
	var ecData = getECData(el);
	if (focus != null) {
		ecData.focus = focus;
		ecData.blurScope = blurScope;
	} else if (ecData.focus) ecData.focus = null;
}
var OTHER_STATES = [
	"emphasis",
	"blur",
	"select"
];
var defaultStyleGetterMap = {
	itemStyle: "getItemStyle",
	lineStyle: "getLineStyle",
	areaStyle: "getAreaStyle"
};
/**
* Set emphasis/blur/selected states of element.
*/
function setStatesStylesFromModel(el, itemModel, styleType, getter) {
	styleType = styleType || "itemStyle";
	for (var i$1 = 0; i$1 < OTHER_STATES.length; i$1++) {
		var stateName = OTHER_STATES[i$1];
		var model = itemModel.getModel([stateName, styleType]);
		var state = el.ensureState(stateName);
		state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
	}
}
/**
*
* Set element as highlight / downplay dispatcher.
* It will be checked when element received mouseover event or from highlight action.
* It's in change of all highlight/downplay behavior of it's children.
*
* @param el
* @param el.highDownSilentOnTouch
*        In touch device, mouseover event will be trigger on touchstart event
*        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
*        conveniently use hoverStyle when tap on touch screen without additional
*        code for compatibility.
*        But if the chart/component has select feature, which usually also use
*        hoverStyle, there might be conflict between 'select-highlight' and
*        'hover-highlight' especially when roam is enabled (see geo for example).
*        In this case, `highDownSilentOnTouch` should be used to disable
*        hover-highlight on touch device.
* @param asDispatcher If `false`, do not set as "highDownDispatcher".
*/
function setAsHighDownDispatcher(el, asDispatcher) {
	var disable = asDispatcher === false;
	var extendedEl = el;
	if (el.highDownSilentOnTouch) extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
	if (!disable || extendedEl.__highDownDispatcher) {
		extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
		extendedEl.__highDownDispatcher = !disable;
	}
}
function isHighDownDispatcher(el) {
	return !!(el && el.__highDownDispatcher);
}
/**
* Enable component highlight/downplay features:
* + hover link (within the same name)
* + focus blur in component
*/
function enableComponentHighDownFeatures(el, componentModel, componentHighDownName) {
	var ecData = getECData(el);
	ecData.componentMainType = componentModel.mainType;
	ecData.componentIndex = componentModel.componentIndex;
	ecData.componentHighDownName = componentHighDownName;
}
/**
* Support highlight/downplay record on each elements.
* For the case: hover highlight/downplay (legend, visualMap, ...) and
* user triggered highlight/downplay should not conflict.
* Only all of the highlightDigit cleared, return to normal.
* @param {string} highlightKey
* @return {number} highlightDigit
*/
function getHighlightDigit(highlightKey) {
	var highlightDigit = _highlightKeyMap[highlightKey];
	if (highlightDigit == null && _highlightNextDigit <= 32) highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
	return highlightDigit;
}
function isSelectChangePayload(payload) {
	var payloadType = payload.type;
	return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(payload) {
	var payloadType = payload.type;
	return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(el) {
	var store = getSavedStates(el);
	store.normalFill = el.style.fill;
	store.normalStroke = el.style.stroke;
	var selectState = el.states.select || {};
	store.selectFill = selectState.style && selectState.style.fill || null;
	store.selectStroke = selectState.style && selectState.style.stroke || null;
}

//#endregion
//#region node_modules/zrender/lib/tool/transformPath.js
var CMD$2 = PathProxy_default.CMD;
var points$2 = [
	[],
	[],
	[]
];
var mathSqrt$2 = Math.sqrt;
var mathAtan2 = Math.atan2;
function transformPath(path, m$1) {
	if (!m$1) return;
	var data = path.data;
	var len$1 = path.len();
	var cmd;
	var nPoint;
	var i$1;
	var j;
	var k$1;
	var p;
	var M = CMD$2.M;
	var C = CMD$2.C;
	var L = CMD$2.L;
	var R = CMD$2.R;
	var A = CMD$2.A;
	var Q = CMD$2.Q;
	for (i$1 = 0, j = 0; i$1 < len$1;) {
		cmd = data[i$1++];
		j = i$1;
		nPoint = 0;
		switch (cmd) {
			case M:
				nPoint = 1;
				break;
			case L:
				nPoint = 1;
				break;
			case C:
				nPoint = 3;
				break;
			case Q:
				nPoint = 2;
				break;
			case A:
				var x = m$1[4];
				var y = m$1[5];
				var sx = mathSqrt$2(m$1[0] * m$1[0] + m$1[1] * m$1[1]);
				var sy = mathSqrt$2(m$1[2] * m$1[2] + m$1[3] * m$1[3]);
				var angle = mathAtan2(-m$1[1] / sy, m$1[0] / sx);
				data[i$1] *= sx;
				data[i$1++] += x;
				data[i$1] *= sy;
				data[i$1++] += y;
				data[i$1++] *= sx;
				data[i$1++] *= sy;
				data[i$1++] += angle;
				data[i$1++] += angle;
				i$1 += 2;
				j = i$1;
				break;
			case R:
				p[0] = data[i$1++];
				p[1] = data[i$1++];
				applyTransform(p, p, m$1);
				data[j++] = p[0];
				data[j++] = p[1];
				p[0] += data[i$1++];
				p[1] += data[i$1++];
				applyTransform(p, p, m$1);
				data[j++] = p[0];
				data[j++] = p[1];
		}
		for (k$1 = 0; k$1 < nPoint; k$1++) {
			var p_1 = points$2[k$1];
			p_1[0] = data[i$1++];
			p_1[1] = data[i$1++];
			applyTransform(p_1, p_1, m$1);
			data[j++] = p_1[0];
			data[j++] = p_1[1];
		}
	}
	path.increaseVersion();
}

//#endregion
//#region node_modules/zrender/lib/tool/path.js
var mathSqrt$1 = Math.sqrt;
var mathSin$2 = Math.sin;
var mathCos$2 = Math.cos;
var PI$7 = Math.PI;
function vMag(v) {
	return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
	return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
}
function vAngle(u, v) {
	return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	var psi = psiDeg * (PI$7 / 180);
	var xp = mathCos$2(psi) * (x1 - x2) / 2 + mathSin$2(psi) * (y1 - y2) / 2;
	var yp = -1 * mathSin$2(psi) * (x1 - x2) / 2 + mathCos$2(psi) * (y1 - y2) / 2;
	var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
	if (lambda > 1) {
		rx *= mathSqrt$1(lambda);
		ry *= mathSqrt$1(lambda);
	}
	var f = (fa === fs ? -1 : 1) * mathSqrt$1((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
	var cxp = f * rx * yp / ry;
	var cyp = f * -ry * xp / rx;
	var cx = (x1 + x2) / 2 + mathCos$2(psi) * cxp - mathSin$2(psi) * cyp;
	var cy = (y1 + y2) / 2 + mathSin$2(psi) * cxp + mathCos$2(psi) * cyp;
	var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	var dTheta = vAngle(u, v);
	if (vRatio(u, v) <= -1) dTheta = PI$7;
	if (vRatio(u, v) >= 1) dTheta = 0;
	if (dTheta < 0) {
		var n = Math.round(dTheta / PI$7 * 1e6) / 1e6;
		dTheta = PI$7 * 2 + n % 2 * PI$7;
	}
	path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi;
var numberReg$1 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data) {
	var path = new PathProxy_default();
	if (!data) return path;
	var cpx = 0;
	var cpy = 0;
	var subpathX = cpx;
	var subpathY = cpy;
	var prevCmd;
	var CMD$5 = PathProxy_default.CMD;
	var cmdList = data.match(commandReg);
	if (!cmdList) return path;
	for (var l = 0; l < cmdList.length; l++) {
		var cmdText = cmdList[l];
		var cmdStr = cmdText.charAt(0);
		var cmd = void 0;
		var p = cmdText.match(numberReg$1) || [];
		var pLen = p.length;
		for (var i$1 = 0; i$1 < pLen; i$1++) p[i$1] = parseFloat(p[i$1]);
		var off = 0;
		while (off < pLen) {
			var ctlPtx = void 0;
			var ctlPty = void 0;
			var rx = void 0;
			var ry = void 0;
			var psi = void 0;
			var fa = void 0;
			var fs = void 0;
			var x1 = cpx;
			var y1 = cpy;
			var len$1 = void 0;
			var pathData = void 0;
			switch (cmdStr) {
				case "l":
					cpx += p[off++];
					cpy += p[off++];
					cmd = CMD$5.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "L":
					cpx = p[off++];
					cpy = p[off++];
					cmd = CMD$5.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "m":
					cpx += p[off++];
					cpy += p[off++];
					cmd = CMD$5.M;
					path.addData(cmd, cpx, cpy);
					subpathX = cpx;
					subpathY = cpy;
					cmdStr = "l";
					break;
				case "M":
					cpx = p[off++];
					cpy = p[off++];
					cmd = CMD$5.M;
					path.addData(cmd, cpx, cpy);
					subpathX = cpx;
					subpathY = cpy;
					cmdStr = "L";
					break;
				case "h":
					cpx += p[off++];
					cmd = CMD$5.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "H":
					cpx = p[off++];
					cmd = CMD$5.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "v":
					cpy += p[off++];
					cmd = CMD$5.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "V":
					cpy = p[off++];
					cmd = CMD$5.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "C":
					cmd = CMD$5.C;
					path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
					cpx = p[off - 2];
					cpy = p[off - 1];
					break;
				case "c":
					cmd = CMD$5.C;
					path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
					cpx += p[off - 2];
					cpy += p[off - 1];
					break;
				case "S":
					ctlPtx = cpx;
					ctlPty = cpy;
					len$1 = path.len();
					pathData = path.data;
					if (prevCmd === CMD$5.C) {
						ctlPtx += cpx - pathData[len$1 - 4];
						ctlPty += cpy - pathData[len$1 - 3];
					}
					cmd = CMD$5.C;
					x1 = p[off++];
					y1 = p[off++];
					cpx = p[off++];
					cpy = p[off++];
					path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
					break;
				case "s":
					ctlPtx = cpx;
					ctlPty = cpy;
					len$1 = path.len();
					pathData = path.data;
					if (prevCmd === CMD$5.C) {
						ctlPtx += cpx - pathData[len$1 - 4];
						ctlPty += cpy - pathData[len$1 - 3];
					}
					cmd = CMD$5.C;
					x1 = cpx + p[off++];
					y1 = cpy + p[off++];
					cpx += p[off++];
					cpy += p[off++];
					path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
					break;
				case "Q":
					x1 = p[off++];
					y1 = p[off++];
					cpx = p[off++];
					cpy = p[off++];
					cmd = CMD$5.Q;
					path.addData(cmd, x1, y1, cpx, cpy);
					break;
				case "q":
					x1 = p[off++] + cpx;
					y1 = p[off++] + cpy;
					cpx += p[off++];
					cpy += p[off++];
					cmd = CMD$5.Q;
					path.addData(cmd, x1, y1, cpx, cpy);
					break;
				case "T":
					ctlPtx = cpx;
					ctlPty = cpy;
					len$1 = path.len();
					pathData = path.data;
					if (prevCmd === CMD$5.Q) {
						ctlPtx += cpx - pathData[len$1 - 4];
						ctlPty += cpy - pathData[len$1 - 3];
					}
					cpx = p[off++];
					cpy = p[off++];
					cmd = CMD$5.Q;
					path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
					break;
				case "t":
					ctlPtx = cpx;
					ctlPty = cpy;
					len$1 = path.len();
					pathData = path.data;
					if (prevCmd === CMD$5.Q) {
						ctlPtx += cpx - pathData[len$1 - 4];
						ctlPty += cpy - pathData[len$1 - 3];
					}
					cpx += p[off++];
					cpy += p[off++];
					cmd = CMD$5.Q;
					path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
					break;
				case "A":
					rx = p[off++];
					ry = p[off++];
					psi = p[off++];
					fa = p[off++];
					fs = p[off++];
					x1 = cpx, y1 = cpy;
					cpx = p[off++];
					cpy = p[off++];
					cmd = CMD$5.A;
					processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
					break;
				case "a":
					rx = p[off++];
					ry = p[off++];
					psi = p[off++];
					fa = p[off++];
					fs = p[off++];
					x1 = cpx, y1 = cpy;
					cpx += p[off++];
					cpy += p[off++];
					cmd = CMD$5.A;
					processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
					break;
			}
		}
		if (cmdStr === "z" || cmdStr === "Z") {
			cmd = CMD$5.Z;
			path.addData(cmd);
			cpx = subpathX;
			cpy = subpathY;
		}
		prevCmd = cmd;
	}
	path.toStatic();
	return path;
}
var SVGPath = function(_super) {
	__extends$1(SVGPath$1, _super);
	function SVGPath$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	SVGPath$1.prototype.applyTransform = function(m$1) {};
	return SVGPath$1;
}(Path_default);
function isPathProxy(path) {
	return path.setData != null;
}
function createPathOptions(str, opts) {
	var pathProxy = createPathProxyFromString(str);
	var innerOpts = extend({}, opts);
	innerOpts.buildPath = function(path) {
		var beProxy = isPathProxy(path);
		if (beProxy && path.canSave()) {
			path.appendPath(pathProxy);
			var ctx = path.getContext();
			if (ctx) path.rebuildPath(ctx, 1);
		} else {
			var ctx = beProxy ? path.getContext() : path;
			if (ctx) pathProxy.rebuildPath(ctx, 1);
		}
	};
	innerOpts.applyTransform = function(m$1) {
		transformPath(pathProxy, m$1);
		this.dirtyShape();
	};
	return innerOpts;
}
function createFromString(str, opts) {
	return new SVGPath(createPathOptions(str, opts));
}
function extendFromString(str, defaultOpts) {
	var innerOpts = createPathOptions(str, defaultOpts);
	return function(_super) {
		__extends$1(Sub, _super);
		function Sub(opts) {
			var _this = _super.call(this, opts) || this;
			_this.applyTransform = innerOpts.applyTransform;
			_this.buildPath = innerOpts.buildPath;
			return _this;
		}
		return Sub;
	}(SVGPath);
}
function mergePath$1(pathEls, opts) {
	var pathList = [];
	var len$1 = pathEls.length;
	for (var i$1 = 0; i$1 < len$1; i$1++) {
		var pathEl = pathEls[i$1];
		pathList.push(pathEl.getUpdatedPathProxy(true));
	}
	var pathBundle = new Path_default(opts);
	pathBundle.createPathProxy();
	pathBundle.buildPath = function(path) {
		if (isPathProxy(path)) {
			path.appendPath(pathList);
			var ctx = path.getContext();
			if (ctx) path.rebuildPath(ctx, 1);
		}
	};
	return pathBundle;
}
function clonePath(sourcePath, opts) {
	opts = opts || {};
	var path = new Path_default();
	if (sourcePath.shape) path.setShape(sourcePath.shape);
	path.setStyle(sourcePath.style);
	if (opts.bakeTransform) transformPath(path.path, sourcePath.getComputedTransform());
	else if (opts.toLocal) path.setLocalTransform(sourcePath.getComputedTransform());
	else path.copyTransform(sourcePath);
	path.buildPath = sourcePath.buildPath;
	path.applyTransform = path.applyTransform;
	path.z = sourcePath.z;
	path.z2 = sourcePath.z2;
	path.zlevel = sourcePath.zlevel;
	return path;
}

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Circle.js
var CircleShape = function() {
	function CircleShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.r = 0;
	}
	return CircleShape$1;
}();
var Circle = function(_super) {
	__extends$1(Circle$1, _super);
	function Circle$1(opts) {
		return _super.call(this, opts) || this;
	}
	Circle$1.prototype.getDefaultShape = function() {
		return new CircleShape();
	};
	Circle$1.prototype.buildPath = function(ctx, shape) {
		ctx.moveTo(shape.cx + shape.r, shape.cy);
		ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
	};
	return Circle$1;
}(Path_default);
Circle.prototype.type = "circle";
var Circle_default = Circle;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Ellipse.js
var EllipseShape = function() {
	function EllipseShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.rx = 0;
		this.ry = 0;
	}
	return EllipseShape$1;
}();
var Ellipse = function(_super) {
	__extends$1(Ellipse$1, _super);
	function Ellipse$1(opts) {
		return _super.call(this, opts) || this;
	}
	Ellipse$1.prototype.getDefaultShape = function() {
		return new EllipseShape();
	};
	Ellipse$1.prototype.buildPath = function(ctx, shape) {
		var k$1 = .5522848;
		var x = shape.cx;
		var y = shape.cy;
		var a = shape.rx;
		var b = shape.ry;
		var ox = a * k$1;
		var oy = b * k$1;
		ctx.moveTo(x - a, y);
		ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
		ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
		ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
		ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
		ctx.closePath();
	};
	return Ellipse$1;
}(Path_default);
Ellipse.prototype.type = "ellipse";
var Ellipse_default = Ellipse;

//#endregion
//#region node_modules/zrender/lib/graphic/helper/roundSector.js
var PI$6 = Math.PI;
var PI2$3 = PI$6 * 2;
var mathSin$1 = Math.sin;
var mathCos$1 = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathAbs$3 = Math.abs;
var mathSqrt = Math.sqrt;
var mathMax$8 = Math.max;
var mathMin$8 = Math.min;
var e = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
	var dx10 = x1 - x0;
	var dy10 = y1 - y0;
	var dx32 = x3 - x2;
	var dy32 = y3 - y2;
	var t = dy32 * dx10 - dx32 * dy10;
	if (t * t < e) return;
	t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
	return [x0 + t * dx10, y0 + t * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
	var x01 = x0 - x1;
	var y01 = y0 - y1;
	var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
	var ox = lo * y01;
	var oy = -lo * x01;
	var x11 = x0 + ox;
	var y11 = y0 + oy;
	var x10 = x1 + ox;
	var y10 = y1 + oy;
	var x00 = (x11 + x10) / 2;
	var y00 = (y11 + y10) / 2;
	var dx = x10 - x11;
	var dy = y10 - y11;
	var d2 = dx * dx + dy * dy;
	var r = radius - cr;
	var s = x11 * y10 - x10 * y11;
	var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax$8(0, r * r * d2 - s * s));
	var cx0 = (s * dy - dx * d) / d2;
	var cy0 = (-s * dx - dy * d) / d2;
	var cx1 = (s * dy + dx * d) / d2;
	var cy1 = (-s * dx + dy * d) / d2;
	var dx0 = cx0 - x00;
	var dy0 = cy0 - y00;
	var dx1 = cx1 - x00;
	var dy1 = cy1 - y00;
	if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
		cx0 = cx1;
		cy0 = cy1;
	}
	return {
		cx: cx0,
		cy: cy0,
		x0: -ox,
		y0: -oy,
		x1: cx0 * (radius / r - 1),
		y1: cy0 * (radius / r - 1)
	};
}
function normalizeCornerRadius(cr) {
	var arr;
	if (isArray(cr)) {
		var len$1 = cr.length;
		if (!len$1) return cr;
		if (len$1 === 1) arr = [
			cr[0],
			cr[0],
			0,
			0
		];
		else if (len$1 === 2) arr = [
			cr[0],
			cr[0],
			cr[1],
			cr[1]
		];
		else if (len$1 === 3) arr = cr.concat(cr[2]);
		else arr = cr;
	} else arr = [
		cr,
		cr,
		cr,
		cr
	];
	return arr;
}
function buildPath$1(ctx, shape) {
	var _a$1;
	var radius = mathMax$8(shape.r, 0);
	var innerRadius = mathMax$8(shape.r0 || 0, 0);
	var hasRadius = radius > 0;
	if (!hasRadius && !(innerRadius > 0)) return;
	if (!hasRadius) {
		radius = innerRadius;
		innerRadius = 0;
	}
	if (innerRadius > radius) {
		var tmp = radius;
		radius = innerRadius;
		innerRadius = tmp;
	}
	var startAngle = shape.startAngle, endAngle = shape.endAngle;
	if (isNaN(startAngle) || isNaN(endAngle)) return;
	var cx = shape.cx, cy = shape.cy;
	var clockwise = !!shape.clockwise;
	var arc = mathAbs$3(endAngle - startAngle);
	var mod = arc > PI2$3 && arc % PI2$3;
	mod > e && (arc = mod);
	if (!(radius > e)) ctx.moveTo(cx, cy);
	else if (arc > PI2$3 - e) {
		ctx.moveTo(cx + radius * mathCos$1(startAngle), cy + radius * mathSin$1(startAngle));
		ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
		if (innerRadius > e) {
			ctx.moveTo(cx + innerRadius * mathCos$1(endAngle), cy + innerRadius * mathSin$1(endAngle));
			ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
		}
	} else {
		var icrStart = void 0;
		var icrEnd = void 0;
		var ocrStart = void 0;
		var ocrEnd = void 0;
		var ocrs = void 0;
		var ocre = void 0;
		var icrs = void 0;
		var icre = void 0;
		var ocrMax = void 0;
		var icrMax = void 0;
		var limitedOcrMax = void 0;
		var limitedIcrMax = void 0;
		var xre = void 0;
		var yre = void 0;
		var xirs = void 0;
		var yirs = void 0;
		var xrs = radius * mathCos$1(startAngle);
		var yrs = radius * mathSin$1(startAngle);
		var xire = innerRadius * mathCos$1(endAngle);
		var yire = innerRadius * mathSin$1(endAngle);
		var hasArc = arc > e;
		if (hasArc) {
			var cornerRadius = shape.cornerRadius;
			if (cornerRadius) _a$1 = normalizeCornerRadius(cornerRadius), icrStart = _a$1[0], icrEnd = _a$1[1], ocrStart = _a$1[2], ocrEnd = _a$1[3];
			var halfRd = mathAbs$3(radius - innerRadius) / 2;
			ocrs = mathMin$8(halfRd, ocrStart);
			ocre = mathMin$8(halfRd, ocrEnd);
			icrs = mathMin$8(halfRd, icrStart);
			icre = mathMin$8(halfRd, icrEnd);
			limitedOcrMax = ocrMax = mathMax$8(ocrs, ocre);
			limitedIcrMax = icrMax = mathMax$8(icrs, icre);
			if (ocrMax > e || icrMax > e) {
				xre = radius * mathCos$1(endAngle);
				yre = radius * mathSin$1(endAngle);
				xirs = innerRadius * mathCos$1(startAngle);
				yirs = innerRadius * mathSin$1(startAngle);
				if (arc < PI$6) {
					var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
					if (it_1) {
						var x0 = xrs - it_1[0];
						var y0 = yrs - it_1[1];
						var x1 = xre - it_1[0];
						var y1 = yre - it_1[1];
						var a = 1 / mathSin$1(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
						var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
						limitedOcrMax = mathMin$8(ocrMax, (radius - b) / (a + 1));
						limitedIcrMax = mathMin$8(icrMax, (innerRadius - b) / (a - 1));
					}
				}
			}
		}
		if (!hasArc) ctx.moveTo(cx + xrs, cy + yrs);
		else if (limitedOcrMax > e) {
			var crStart = mathMin$8(ocrStart, limitedOcrMax);
			var crEnd = mathMin$8(ocrEnd, limitedOcrMax);
			var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
			var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
			ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
			if (limitedOcrMax < ocrMax && crStart === crEnd) ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
			else {
				crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
				ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
				crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
			}
		} else {
			ctx.moveTo(cx + xrs, cy + yrs);
			ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
		}
		if (!(innerRadius > e) || !hasArc) ctx.lineTo(cx + xire, cy + yire);
		else if (limitedIcrMax > e) {
			var crStart = mathMin$8(icrStart, limitedIcrMax);
			var crEnd = mathMin$8(icrEnd, limitedIcrMax);
			var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
			var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
			ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
			if (limitedIcrMax < icrMax && crStart === crEnd) ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
			else {
				crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
				ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
				crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
			}
		} else {
			ctx.lineTo(cx + xire, cy + yire);
			ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
		}
	}
	ctx.closePath();
}

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Sector.js
var SectorShape = function() {
	function SectorShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.r0 = 0;
		this.r = 0;
		this.startAngle = 0;
		this.endAngle = Math.PI * 2;
		this.clockwise = true;
		this.cornerRadius = 0;
	}
	return SectorShape$1;
}();
var Sector = function(_super) {
	__extends$1(Sector$1, _super);
	function Sector$1(opts) {
		return _super.call(this, opts) || this;
	}
	Sector$1.prototype.getDefaultShape = function() {
		return new SectorShape();
	};
	Sector$1.prototype.buildPath = function(ctx, shape) {
		buildPath$1(ctx, shape);
	};
	Sector$1.prototype.isZeroArea = function() {
		return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
	};
	return Sector$1;
}(Path_default);
Sector.prototype.type = "sector";
var Sector_default = Sector;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Ring.js
var RingShape = function() {
	function RingShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.r = 0;
		this.r0 = 0;
	}
	return RingShape$1;
}();
var Ring = function(_super) {
	__extends$1(Ring$1, _super);
	function Ring$1(opts) {
		return _super.call(this, opts) || this;
	}
	Ring$1.prototype.getDefaultShape = function() {
		return new RingShape();
	};
	Ring$1.prototype.buildPath = function(ctx, shape) {
		var x = shape.cx;
		var y = shape.cy;
		var PI2$9 = Math.PI * 2;
		ctx.moveTo(x + shape.r, y);
		ctx.arc(x, y, shape.r, 0, PI2$9, false);
		ctx.moveTo(x + shape.r0, y);
		ctx.arc(x, y, shape.r0, 0, PI2$9, true);
	};
	return Ring$1;
}(Path_default);
Ring.prototype.type = "ring";
var Ring_default = Ring;

//#endregion
//#region node_modules/zrender/lib/graphic/helper/smoothBezier.js
function smoothBezier(points$3, smooth, isLoop, constraint) {
	var cps = [];
	var v = [];
	var v1$1 = [];
	var v2$1 = [];
	var prevPoint;
	var nextPoint;
	var min$2;
	var max$2;
	if (constraint) {
		min$2 = [Infinity, Infinity];
		max$2 = [-Infinity, -Infinity];
		for (var i$1 = 0, len$1 = points$3.length; i$1 < len$1; i$1++) {
			min(min$2, min$2, points$3[i$1]);
			max(max$2, max$2, points$3[i$1]);
		}
		min(min$2, min$2, constraint[0]);
		max(max$2, max$2, constraint[1]);
	}
	for (var i$1 = 0, len$1 = points$3.length; i$1 < len$1; i$1++) {
		var point = points$3[i$1];
		if (isLoop) {
			prevPoint = points$3[i$1 ? i$1 - 1 : len$1 - 1];
			nextPoint = points$3[(i$1 + 1) % len$1];
		} else if (i$1 === 0 || i$1 === len$1 - 1) {
			cps.push(clone$3(points$3[i$1]));
			continue;
		} else {
			prevPoint = points$3[i$1 - 1];
			nextPoint = points$3[i$1 + 1];
		}
		sub(v, nextPoint, prevPoint);
		scale$1(v, v, smooth);
		var d0 = distance(point, prevPoint);
		var d1 = distance(point, nextPoint);
		var sum$1 = d0 + d1;
		if (sum$1 !== 0) {
			d0 /= sum$1;
			d1 /= sum$1;
		}
		scale$1(v1$1, v, -d0);
		scale$1(v2$1, v, d1);
		var cp0 = add([], point, v1$1);
		var cp1 = add([], point, v2$1);
		if (constraint) {
			max(cp0, cp0, min$2);
			min(cp0, cp0, max$2);
			max(cp1, cp1, min$2);
			min(cp1, cp1, max$2);
		}
		cps.push(cp0);
		cps.push(cp1);
	}
	if (isLoop) cps.push(cps.shift());
	return cps;
}

//#endregion
//#region node_modules/zrender/lib/graphic/helper/poly.js
function buildPath(ctx, shape, closePath) {
	var smooth = shape.smooth;
	var points$3 = shape.points;
	if (points$3 && points$3.length >= 2) {
		if (smooth) {
			var controlPoints = smoothBezier(points$3, smooth, closePath, shape.smoothConstraint);
			ctx.moveTo(points$3[0][0], points$3[0][1]);
			var len$1 = points$3.length;
			for (var i$1 = 0; i$1 < (closePath ? len$1 : len$1 - 1); i$1++) {
				var cp1 = controlPoints[i$1 * 2];
				var cp2 = controlPoints[i$1 * 2 + 1];
				var p = points$3[(i$1 + 1) % len$1];
				ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
			}
		} else {
			ctx.moveTo(points$3[0][0], points$3[0][1]);
			for (var i$1 = 1, l = points$3.length; i$1 < l; i$1++) ctx.lineTo(points$3[i$1][0], points$3[i$1][1]);
		}
		closePath && ctx.closePath();
	}
}

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Polygon.js
var PolygonShape = function() {
	function PolygonShape$1() {
		this.points = null;
		this.smooth = 0;
		this.smoothConstraint = null;
	}
	return PolygonShape$1;
}();
var Polygon = function(_super) {
	__extends$1(Polygon$1, _super);
	function Polygon$1(opts) {
		return _super.call(this, opts) || this;
	}
	Polygon$1.prototype.getDefaultShape = function() {
		return new PolygonShape();
	};
	Polygon$1.prototype.buildPath = function(ctx, shape) {
		buildPath(ctx, shape, true);
	};
	return Polygon$1;
}(Path_default);
Polygon.prototype.type = "polygon";
var Polygon_default = Polygon;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Polyline.js
var PolylineShape = function() {
	function PolylineShape$1() {
		this.points = null;
		this.percent = 1;
		this.smooth = 0;
		this.smoothConstraint = null;
	}
	return PolylineShape$1;
}();
var Polyline$1 = function(_super) {
	__extends$1(Polyline$2, _super);
	function Polyline$2(opts) {
		return _super.call(this, opts) || this;
	}
	Polyline$2.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	};
	Polyline$2.prototype.getDefaultShape = function() {
		return new PolylineShape();
	};
	Polyline$2.prototype.buildPath = function(ctx, shape) {
		buildPath(ctx, shape, false);
	};
	return Polyline$2;
}(Path_default);
Polyline$1.prototype.type = "polyline";
var Polyline_default = Polyline$1;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Line.js
var subPixelOptimizeOutputShape = {};
var LineShape = function() {
	function LineShape$1() {
		this.x1 = 0;
		this.y1 = 0;
		this.x2 = 0;
		this.y2 = 0;
		this.percent = 1;
	}
	return LineShape$1;
}();
var Line$1 = function(_super) {
	__extends$1(Line$2, _super);
	function Line$2(opts) {
		return _super.call(this, opts) || this;
	}
	Line$2.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	};
	Line$2.prototype.getDefaultShape = function() {
		return new LineShape();
	};
	Line$2.prototype.buildPath = function(ctx, shape) {
		var x1;
		var y1;
		var x2;
		var y2;
		if (this.subPixelOptimize) {
			var optimizedShape = subPixelOptimizeLine(subPixelOptimizeOutputShape, shape, this.style);
			x1 = optimizedShape.x1;
			y1 = optimizedShape.y1;
			x2 = optimizedShape.x2;
			y2 = optimizedShape.y2;
		} else {
			x1 = shape.x1;
			y1 = shape.y1;
			x2 = shape.x2;
			y2 = shape.y2;
		}
		var percent = shape.percent;
		if (percent === 0) return;
		ctx.moveTo(x1, y1);
		if (percent < 1) {
			x2 = x1 * (1 - percent) + x2 * percent;
			y2 = y1 * (1 - percent) + y2 * percent;
		}
		ctx.lineTo(x2, y2);
	};
	Line$2.prototype.pointAt = function(p) {
		var shape = this.shape;
		return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
	};
	return Line$2;
}(Path_default);
Line$1.prototype.type = "line";
var Line_default = Line$1;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/BezierCurve.js
var out = [];
var BezierCurveShape = function() {
	function BezierCurveShape$1() {
		this.x1 = 0;
		this.y1 = 0;
		this.x2 = 0;
		this.y2 = 0;
		this.cpx1 = 0;
		this.cpy1 = 0;
		this.percent = 1;
	}
	return BezierCurveShape$1;
}();
function someVectorAt(shape, t, isTangent) {
	var cpx2 = shape.cpx2;
	var cpy2 = shape.cpy2;
	if (cpx2 != null || cpy2 != null) return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
	else return [(isTangent ? quadraticDerivativeAt : quadraticAt$1)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt$1)(shape.y1, shape.cpy1, shape.y2, t)];
}
var BezierCurve = function(_super) {
	__extends$1(BezierCurve$1, _super);
	function BezierCurve$1(opts) {
		return _super.call(this, opts) || this;
	}
	BezierCurve$1.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	};
	BezierCurve$1.prototype.getDefaultShape = function() {
		return new BezierCurveShape();
	};
	BezierCurve$1.prototype.buildPath = function(ctx, shape) {
		var x1 = shape.x1;
		var y1 = shape.y1;
		var x2 = shape.x2;
		var y2 = shape.y2;
		var cpx1 = shape.cpx1;
		var cpy1 = shape.cpy1;
		var cpx2 = shape.cpx2;
		var cpy2 = shape.cpy2;
		var percent = shape.percent;
		if (percent === 0) return;
		ctx.moveTo(x1, y1);
		if (cpx2 == null || cpy2 == null) {
			if (percent < 1) {
				quadraticSubdivide(x1, cpx1, x2, percent, out);
				cpx1 = out[1];
				x2 = out[2];
				quadraticSubdivide(y1, cpy1, y2, percent, out);
				cpy1 = out[1];
				y2 = out[2];
			}
			ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
		} else {
			if (percent < 1) {
				cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
				cpx1 = out[1];
				cpx2 = out[2];
				x2 = out[3];
				cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
				cpy1 = out[1];
				cpy2 = out[2];
				y2 = out[3];
			}
			ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
		}
	};
	BezierCurve$1.prototype.pointAt = function(t) {
		return someVectorAt(this.shape, t, false);
	};
	BezierCurve$1.prototype.tangentAt = function(t) {
		var p = someVectorAt(this.shape, t, true);
		return normalize$3(p, p);
	};
	return BezierCurve$1;
}(Path_default);
BezierCurve.prototype.type = "bezier-curve";
var BezierCurve_default = BezierCurve;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Arc.js
var ArcShape = function() {
	function ArcShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.r = 0;
		this.startAngle = 0;
		this.endAngle = Math.PI * 2;
		this.clockwise = true;
	}
	return ArcShape$1;
}();
var Arc = function(_super) {
	__extends$1(Arc$1, _super);
	function Arc$1(opts) {
		return _super.call(this, opts) || this;
	}
	Arc$1.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	};
	Arc$1.prototype.getDefaultShape = function() {
		return new ArcShape();
	};
	Arc$1.prototype.buildPath = function(ctx, shape) {
		var x = shape.cx;
		var y = shape.cy;
		var r = Math.max(shape.r, 0);
		var startAngle = shape.startAngle;
		var endAngle = shape.endAngle;
		var clockwise = shape.clockwise;
		var unitX = Math.cos(startAngle);
		var unitY = Math.sin(startAngle);
		ctx.moveTo(unitX * r + x, unitY * r + y);
		ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	};
	return Arc$1;
}(Path_default);
Arc.prototype.type = "arc";
var Arc_default = Arc;

//#endregion
//#region node_modules/zrender/lib/graphic/CompoundPath.js
var CompoundPath = function(_super) {
	__extends$1(CompoundPath$1, _super);
	function CompoundPath$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "compound";
		return _this;
	}
	CompoundPath$1.prototype._updatePathDirty = function() {
		var paths = this.shape.paths;
		var dirtyPath = this.shapeChanged();
		for (var i$1 = 0; i$1 < paths.length; i$1++) dirtyPath = dirtyPath || paths[i$1].shapeChanged();
		if (dirtyPath) this.dirtyShape();
	};
	CompoundPath$1.prototype.beforeBrush = function() {
		this._updatePathDirty();
		var paths = this.shape.paths || [];
		var scale$3 = this.getGlobalScale();
		for (var i$1 = 0; i$1 < paths.length; i$1++) {
			if (!paths[i$1].path) paths[i$1].createPathProxy();
			paths[i$1].path.setScale(scale$3[0], scale$3[1], paths[i$1].segmentIgnoreThreshold);
		}
	};
	CompoundPath$1.prototype.buildPath = function(ctx, shape) {
		var paths = shape.paths || [];
		for (var i$1 = 0; i$1 < paths.length; i$1++) paths[i$1].buildPath(ctx, paths[i$1].shape, true);
	};
	CompoundPath$1.prototype.afterBrush = function() {
		var paths = this.shape.paths || [];
		for (var i$1 = 0; i$1 < paths.length; i$1++) paths[i$1].pathUpdated();
	};
	CompoundPath$1.prototype.getBoundingRect = function() {
		this._updatePathDirty.call(this);
		return Path_default.prototype.getBoundingRect.call(this);
	};
	return CompoundPath$1;
}(Path_default);
var CompoundPath_default = CompoundPath;

//#endregion
//#region node_modules/zrender/lib/graphic/Gradient.js
var Gradient = function() {
	function Gradient$1(colorStops) {
		this.colorStops = colorStops || [];
	}
	Gradient$1.prototype.addColorStop = function(offset, color$2) {
		this.colorStops.push({
			offset,
			color: color$2
		});
	};
	return Gradient$1;
}();
var Gradient_default = Gradient;

//#endregion
//#region node_modules/zrender/lib/graphic/LinearGradient.js
var LinearGradient = function(_super) {
	__extends$1(LinearGradient$1, _super);
	function LinearGradient$1(x, y, x2, y2, colorStops, globalCoord) {
		var _this = _super.call(this, colorStops) || this;
		_this.x = x == null ? 0 : x;
		_this.y = y == null ? 0 : y;
		_this.x2 = x2 == null ? 1 : x2;
		_this.y2 = y2 == null ? 0 : y2;
		_this.type = "linear";
		_this.global = globalCoord || false;
		return _this;
	}
	return LinearGradient$1;
}(Gradient_default);
var LinearGradient_default = LinearGradient;

//#endregion
//#region node_modules/zrender/lib/graphic/RadialGradient.js
var RadialGradient = function(_super) {
	__extends$1(RadialGradient$1, _super);
	function RadialGradient$1(x, y, r, colorStops, globalCoord) {
		var _this = _super.call(this, colorStops) || this;
		_this.x = x == null ? .5 : x;
		_this.y = y == null ? .5 : y;
		_this.r = r == null ? .5 : r;
		_this.type = "radial";
		_this.global = globalCoord || false;
		return _this;
	}
	return RadialGradient$1;
}(Gradient_default);
var RadialGradient_default = RadialGradient;

//#endregion
//#region node_modules/zrender/lib/core/OrientedBoundingRect.js
var mathMin$7 = Math.min;
var mathMax$7 = Math.max;
var mathAbs$2 = Math.abs;
var _extent = [0, 0];
var _extent2 = [0, 0];
var _intersectCtx = createIntersectContext();
var _minTv = _intersectCtx.minTv;
var _maxTv = _intersectCtx.maxTv;
var OrientedBoundingRect = function() {
	function OrientedBoundingRect$1(rect, transform) {
		this._corners = [];
		this._axes = [];
		this._origin = [0, 0];
		for (var i$1 = 0; i$1 < 4; i$1++) this._corners[i$1] = new Point_default();
		for (var i$1 = 0; i$1 < 2; i$1++) this._axes[i$1] = new Point_default();
		if (rect) this.fromBoundingRect(rect, transform);
	}
	OrientedBoundingRect$1.prototype.fromBoundingRect = function(rect, transform) {
		var corners = this._corners;
		var axes = this._axes;
		var x = rect.x;
		var y = rect.y;
		var x2 = x + rect.width;
		var y2 = y + rect.height;
		corners[0].set(x, y);
		corners[1].set(x2, y);
		corners[2].set(x2, y2);
		corners[3].set(x, y2);
		if (transform) for (var i$1 = 0; i$1 < 4; i$1++) corners[i$1].transform(transform);
		Point_default.sub(axes[0], corners[1], corners[0]);
		Point_default.sub(axes[1], corners[3], corners[0]);
		axes[0].normalize();
		axes[1].normalize();
		for (var i$1 = 0; i$1 < 2; i$1++) this._origin[i$1] = axes[i$1].dot(corners[0]);
	};
	OrientedBoundingRect$1.prototype.intersect = function(other, mtv, opt) {
		var overlapped = true;
		var noMtv = !mtv;
		if (mtv) Point_default.set(mtv, 0, 0);
		_intersectCtx.reset(opt, !noMtv);
		if (!this._intersectCheckOneSide(this, other, noMtv, 1)) {
			overlapped = false;
			if (noMtv) return overlapped;
		}
		if (!this._intersectCheckOneSide(other, this, noMtv, -1)) {
			overlapped = false;
			if (noMtv) return overlapped;
		}
		if (!noMtv && !_intersectCtx.negativeSize) Point_default.copy(mtv, overlapped ? _intersectCtx.useDir ? _intersectCtx.dirMinTv : _minTv : _maxTv);
		return overlapped;
	};
	OrientedBoundingRect$1.prototype._intersectCheckOneSide = function(self$1, other, noMtv, inverse) {
		var overlapped = true;
		for (var i$1 = 0; i$1 < 2; i$1++) {
			var axis = self$1._axes[i$1];
			self$1._getProjMinMaxOnAxis(i$1, self$1._corners, _extent);
			self$1._getProjMinMaxOnAxis(i$1, other._corners, _extent2);
			if (_intersectCtx.negativeSize || _extent[1] < _extent2[0] || _extent[0] > _extent2[1]) {
				overlapped = false;
				if (_intersectCtx.negativeSize || noMtv) return overlapped;
				var dist0 = mathAbs$2(_extent2[0] - _extent[1]);
				var dist1 = mathAbs$2(_extent[0] - _extent2[1]);
				if (mathMin$7(dist0, dist1) > _maxTv.len()) if (dist0 < dist1) Point_default.scale(_maxTv, axis, -dist0 * inverse);
				else Point_default.scale(_maxTv, axis, dist1 * inverse);
			} else if (!noMtv) {
				var dist0 = mathAbs$2(_extent2[0] - _extent[1]);
				var dist1 = mathAbs$2(_extent[0] - _extent2[1]);
				if (_intersectCtx.useDir || mathMin$7(dist0, dist1) < _minTv.len()) {
					if (dist0 < dist1 || !_intersectCtx.bidirectional) {
						Point_default.scale(_minTv, axis, dist0 * inverse);
						if (_intersectCtx.useDir) _intersectCtx.calcDirMTV();
					}
					if (dist0 >= dist1 || !_intersectCtx.bidirectional) {
						Point_default.scale(_minTv, axis, -dist1 * inverse);
						if (_intersectCtx.useDir) _intersectCtx.calcDirMTV();
					}
				}
			}
		}
		return overlapped;
	};
	OrientedBoundingRect$1.prototype._getProjMinMaxOnAxis = function(dim, corners, out$1) {
		var axis = this._axes[dim];
		var origin = this._origin;
		var proj = corners[0].dot(axis) + origin[dim];
		var min$2 = proj;
		var max$2 = proj;
		for (var i$1 = 1; i$1 < corners.length; i$1++) {
			var proj_1 = corners[i$1].dot(axis) + origin[dim];
			min$2 = mathMin$7(proj_1, min$2);
			max$2 = mathMax$7(proj_1, max$2);
		}
		out$1[0] = min$2 + _intersectCtx.touchThreshold;
		out$1[1] = max$2 - _intersectCtx.touchThreshold;
		_intersectCtx.negativeSize = out$1[1] < out$1[0];
	};
	return OrientedBoundingRect$1;
}();
var OrientedBoundingRect_default = OrientedBoundingRect;

//#endregion
//#region node_modules/zrender/lib/graphic/IncrementalDisplayable.js
var m = [];
var IncrementalDisplayable = function(_super) {
	__extends$1(IncrementalDisplayable$1, _super);
	function IncrementalDisplayable$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.notClear = true;
		_this.incremental = true;
		_this._displayables = [];
		_this._temporaryDisplayables = [];
		_this._cursor = 0;
		return _this;
	}
	IncrementalDisplayable$1.prototype.traverse = function(cb, context) {
		cb.call(context, this);
	};
	IncrementalDisplayable$1.prototype.useStyle = function() {
		this.style = {};
	};
	IncrementalDisplayable$1.prototype.getCursor = function() {
		return this._cursor;
	};
	IncrementalDisplayable$1.prototype.innerAfterBrush = function() {
		this._cursor = this._displayables.length;
	};
	IncrementalDisplayable$1.prototype.clearDisplaybles = function() {
		this._displayables = [];
		this._temporaryDisplayables = [];
		this._cursor = 0;
		this.markRedraw();
		this.notClear = false;
	};
	IncrementalDisplayable$1.prototype.clearTemporalDisplayables = function() {
		this._temporaryDisplayables = [];
	};
	IncrementalDisplayable$1.prototype.addDisplayable = function(displayable, notPersistent) {
		if (notPersistent) this._temporaryDisplayables.push(displayable);
		else this._displayables.push(displayable);
		this.markRedraw();
	};
	IncrementalDisplayable$1.prototype.addDisplayables = function(displayables, notPersistent) {
		notPersistent = notPersistent || false;
		for (var i$1 = 0; i$1 < displayables.length; i$1++) this.addDisplayable(displayables[i$1], notPersistent);
	};
	IncrementalDisplayable$1.prototype.getDisplayables = function() {
		return this._displayables;
	};
	IncrementalDisplayable$1.prototype.getTemporalDisplayables = function() {
		return this._temporaryDisplayables;
	};
	IncrementalDisplayable$1.prototype.eachPendingDisplayable = function(cb) {
		for (var i$1 = this._cursor; i$1 < this._displayables.length; i$1++) cb && cb(this._displayables[i$1]);
		for (var i$1 = 0; i$1 < this._temporaryDisplayables.length; i$1++) cb && cb(this._temporaryDisplayables[i$1]);
	};
	IncrementalDisplayable$1.prototype.update = function() {
		this.updateTransform();
		for (var i$1 = this._cursor; i$1 < this._displayables.length; i$1++) {
			var displayable = this._displayables[i$1];
			displayable.parent = this;
			displayable.update();
			displayable.parent = null;
		}
		for (var i$1 = 0; i$1 < this._temporaryDisplayables.length; i$1++) {
			var displayable = this._temporaryDisplayables[i$1];
			displayable.parent = this;
			displayable.update();
			displayable.parent = null;
		}
	};
	IncrementalDisplayable$1.prototype.getBoundingRect = function() {
		if (!this._rect) {
			var rect = new BoundingRect_default(Infinity, Infinity, -Infinity, -Infinity);
			for (var i$1 = 0; i$1 < this._displayables.length; i$1++) {
				var displayable = this._displayables[i$1];
				var childRect = displayable.getBoundingRect().clone();
				if (displayable.needLocalTransform()) childRect.applyTransform(displayable.getLocalTransform(m));
				rect.union(childRect);
			}
			this._rect = rect;
		}
		return this._rect;
	};
	IncrementalDisplayable$1.prototype.contain = function(x, y) {
		var localPos = this.transformCoordToLocal(x, y);
		if (this.getBoundingRect().contain(localPos[0], localPos[1])) {
			for (var i$1 = 0; i$1 < this._displayables.length; i$1++) if (this._displayables[i$1].contain(x, y)) return true;
		}
		return false;
	};
	return IncrementalDisplayable$1;
}(Displayable_default);
var IncrementalDisplayable_default = IncrementalDisplayable;

//#endregion
//#region node_modules/echarts/lib/animation/basicTransition.js
var transitionStore = makeInner();
/**
* Return null if animation is disabled.
*/
function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
	var animationPayload;
	if (animatableModel && animatableModel.ecModel) {
		var updatePayload = animatableModel.ecModel.getUpdatePayload();
		animationPayload = updatePayload && updatePayload.animation;
	}
	var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
	var isUpdate = animationType === "update";
	if (animationEnabled) {
		var duration = void 0;
		var easing = void 0;
		var delay = void 0;
		if (extraOpts) {
			duration = retrieve2(extraOpts.duration, 200);
			easing = retrieve2(extraOpts.easing, "cubicOut");
			delay = 0;
		} else {
			duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
			easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
			delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
		}
		if (animationPayload) {
			animationPayload.duration != null && (duration = animationPayload.duration);
			animationPayload.easing != null && (easing = animationPayload.easing);
			animationPayload.delay != null && (delay = animationPayload.delay);
		}
		if (isFunction(delay)) delay = delay(dataIndex, extraDelayParams);
		if (isFunction(duration)) duration = duration(dataIndex);
		return {
			duration: duration || 0,
			delay,
			easing
		};
	} else return null;
}
function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
	var isFrom = false;
	var removeOpt;
	if (isFunction(dataIndex)) {
		during = cb;
		cb = dataIndex;
		dataIndex = null;
	} else if (isObject(dataIndex)) {
		cb = dataIndex.cb;
		during = dataIndex.during;
		isFrom = dataIndex.isFrom;
		removeOpt = dataIndex.removeOpt;
		dataIndex = dataIndex.dataIndex;
	}
	var isRemove = animationType === "leave";
	if (!isRemove) el.stopAnimation("leave");
	var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
	if (animationConfig && animationConfig.duration > 0) {
		var duration = animationConfig.duration;
		var animationDelay = animationConfig.delay;
		var animationEasing = animationConfig.easing;
		var animateConfig = {
			duration,
			delay: animationDelay || 0,
			easing: animationEasing,
			done: cb,
			force: !!cb || !!during,
			setToFinal: !isRemove,
			scope: animationType,
			during
		};
		isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
	} else {
		el.stopAnimation();
		!isFrom && el.attr(props);
		during && during(1);
		cb && cb();
	}
}
/**
* Update graphic element properties with or without animation according to the
* configuration in series.
*
* Caution: this method will stop previous animation.
* So do not use this method to one element twice before
* animation starts, unless you know what you are doing.
* @example
*     graphic.updateProps(el, {
*         position: [100, 100]
*     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
*     // Or
*     graphic.updateProps(el, {
*         position: [100, 100]
*     }, seriesModel, function () { console.log('Animation done!'); });
*/
function updateProps(el, props, animatableModel, dataIndex, cb, during) {
	animateOrSetProps("update", el, props, animatableModel, dataIndex, cb, during);
}
/**
* Init graphic element properties with or without animation according to the
* configuration in series.
*
* Caution: this method will stop previous animation.
* So do not use this method to one element twice before
* animation starts, unless you know what you are doing.
*/
function initProps(el, props, animatableModel, dataIndex, cb, during) {
	animateOrSetProps("enter", el, props, animatableModel, dataIndex, cb, during);
}
/**
* If element is removed.
* It can determine if element is having remove animation.
*/
function isElementRemoved(el) {
	if (!el.__zr) return true;
	for (var i$1 = 0; i$1 < el.animators.length; i$1++) if (el.animators[i$1].scope === "leave") return true;
	return false;
}
/**
* Remove graphic element
*/
function removeElement(el, props, animatableModel, dataIndex, cb, during) {
	if (isElementRemoved(el)) return;
	animateOrSetProps("leave", el, props, animatableModel, dataIndex, cb, during);
}
function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
	el.removeTextContent();
	el.removeTextGuideLine();
	removeElement(el, { style: { opacity: 0 } }, animatableModel, dataIndex, done);
}
function removeElementWithFadeOut(el, animatableModel, dataIndex) {
	function doRemove() {
		el.parent && el.parent.remove(el);
	}
	if (!el.isGroup) fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
	else el.traverse(function(disp) {
		if (!disp.isGroup) fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
	});
}
/**
* Save old style for style transition in universalTransition module.
* It's used when element will be reused in each render.
* For chart like map, heatmap, which will always create new element.
* We don't need to save this because universalTransition can get old style from the old element
*/
function saveOldStyle(el) {
	transitionStore(el).oldStyle = el.style;
}
function getOldStyle(el) {
	return transitionStore(el).oldStyle;
}

//#endregion
//#region node_modules/echarts/lib/util/graphic.js
var graphic_exports$1 = /* @__PURE__ */ __export({
	Arc: () => Arc_default,
	BezierCurve: () => BezierCurve_default,
	BoundingRect: () => BoundingRect_default,
	Circle: () => Circle_default,
	CompoundPath: () => CompoundPath_default,
	Ellipse: () => Ellipse_default,
	Group: () => Group_default,
	Image: () => Image_default,
	IncrementalDisplayable: () => IncrementalDisplayable_default,
	Line: () => Line_default,
	LinearGradient: () => LinearGradient_default,
	OrientedBoundingRect: () => OrientedBoundingRect_default,
	Path: () => Path_default,
	Point: () => Point_default,
	Polygon: () => Polygon_default,
	Polyline: () => Polyline_default,
	RadialGradient: () => RadialGradient_default,
	Rect: () => Rect_default,
	Ring: () => Ring_default,
	Sector: () => Sector_default,
	Text: () => Text_default,
	WH: () => WH,
	XY: () => XY,
	applyTransform: () => applyTransform$1,
	calcZ2Range: () => calcZ2Range,
	clipPointsByRect: () => clipPointsByRect,
	clipRectByRect: () => clipRectByRect,
	createIcon: () => createIcon,
	ensureCopyRect: () => ensureCopyRect,
	ensureCopyTransform: () => ensureCopyTransform,
	expandOrShrinkRect: () => expandOrShrinkRect,
	extendPath: () => extendPath,
	extendShape: () => extendShape,
	getShapeClass: () => getShapeClass,
	getTransform: () => getTransform$1,
	groupTransition: () => groupTransition,
	initProps: () => initProps,
	isBoundingRectAxisAligned: () => isBoundingRectAxisAligned,
	isElementRemoved: () => isElementRemoved,
	lineLineIntersect: () => lineLineIntersect$1,
	linePolygonIntersect: () => linePolygonIntersect,
	makeImage: () => makeImage,
	makePath: () => makePath,
	mergePath: () => mergePath,
	registerShape: () => registerShape,
	removeElement: () => removeElement,
	removeElementWithFadeOut: () => removeElementWithFadeOut,
	resizePath: () => resizePath,
	retrieveZInfo: () => retrieveZInfo,
	setTooltipConfig: () => setTooltipConfig,
	subPixelOptimize: () => subPixelOptimize$1,
	subPixelOptimizeLine: () => subPixelOptimizeLine$1,
	subPixelOptimizeRect: () => subPixelOptimizeRect,
	transformDirection: () => transformDirection,
	traverseElements: () => traverseElements,
	traverseUpdateZ: () => traverseUpdateZ,
	updateProps: () => updateProps
});
var _customShapeMap = {};
var XY = ["x", "y"];
var WH = ["width", "height"];
/**
* Extend shape with parameters
*/
function extendShape(opts) {
	return Path_default.extend(opts);
}
var extendPathFromString = extendFromString;
/**
* Extend path
*/
function extendPath(pathData, opts) {
	return extendPathFromString(pathData, opts);
}
/**
* Register a user defined shape.
* The shape class can be fetched by `getShapeClass`
* This method will overwrite the registered shapes, including
* the registered built-in shapes, if using the same `name`.
* The shape can be used in `custom series` and
* `graphic component` by declaring `{type: name}`.
*
* @param name
* @param ShapeClass Can be generated by `extendShape`.
*/
function registerShape(name, ShapeClass) {
	_customShapeMap[name] = ShapeClass;
}
/**
* Find shape class registered by `registerShape`. Usually used in
* fetching user defined shape.
*
* [Caution]:
* (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared
* to use user registered shapes.
* Because the built-in shape (see `getBuiltInShape`) will be registered by
* `registerShape` by default. That enables users to get both built-in
* shapes as well as the shapes belonging to themsleves. But users can overwrite
* the built-in shapes by using names like 'circle', 'rect' via calling
* `registerShape`. So the echarts inner featrues should not fetch shapes from here
* in case that it is overwritten by users, except that some features, like
* `custom series`, `graphic component`, do it deliberately.
*
* (2) In the features like `custom series`, `graphic component`, the user input
* `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic
* elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names
* are reserved names, that is, if some user registers a shape named `'image'`,
* the shape will not be used. If we intending to add some more reserved names
* in feature, that might bring break changes (disable some existing user shape
* names). But that case probably rarely happens. So we don't make more mechanism
* to resolve this issue here.
*
* @param name
* @return The shape class. If not found, return nothing.
*/
function getShapeClass(name) {
	if (_customShapeMap.hasOwnProperty(name)) return _customShapeMap[name];
}
/**
* Create a path element from path data string
* @param pathData
* @param opts
* @param rect
* @param layout 'center' or 'cover' default to be cover
*/
function makePath(pathData, opts, rect, layout$3) {
	var path = createFromString(pathData, opts);
	if (rect) {
		if (layout$3 === "center") rect = centerGraphic(rect, path.getBoundingRect());
		resizePath(path, rect);
	}
	return path;
}
/**
* Create a image element from image url
* @param imageUrl image url
* @param opts options
* @param rect constrain rect
* @param layout 'center' or 'cover'. Default to be 'cover'
*/
function makeImage(imageUrl, rect, layout$3) {
	var zrImg = new Image_default({
		style: {
			image: imageUrl,
			x: rect.x,
			y: rect.y,
			width: rect.width,
			height: rect.height
		},
		onload: function(img) {
			if (layout$3 === "center") {
				var boundingRect = {
					width: img.width,
					height: img.height
				};
				zrImg.setStyle(centerGraphic(rect, boundingRect));
			}
		}
	});
	return zrImg;
}
/**
* Get position of centered element in bounding box.
*
* @param  rect         element local bounding box
* @param  boundingRect constraint bounding box
* @return element position containing x, y, width, and height
*/
function centerGraphic(rect, boundingRect) {
	var aspect = boundingRect.width / boundingRect.height;
	var width = rect.height * aspect;
	var height;
	if (width <= rect.width) height = rect.height;
	else {
		width = rect.width;
		height = width / aspect;
	}
	var cx = rect.x + rect.width / 2;
	var cy = rect.y + rect.height / 2;
	return {
		x: cx - width / 2,
		y: cy - height / 2,
		width,
		height
	};
}
var mergePath = mergePath$1;
/**
* Resize a path to fit the rect
* @param path
* @param rect
*/
function resizePath(path, rect) {
	if (!path.applyTransform) return;
	var m$1 = path.getBoundingRect().calculateTransform(rect);
	path.applyTransform(m$1);
}
/**
* Sub pixel optimize line for canvas
*/
function subPixelOptimizeLine$1(shape, lineWidth) {
	subPixelOptimizeLine(shape, shape, { lineWidth });
	return shape;
}
/**
* Sub pixel optimize rect for canvas
*/
function subPixelOptimizeRect(shape, style) {
	subPixelOptimizeRect$1(shape, shape, style);
	return shape;
}
/**
* Sub pixel optimize for canvas
*
* @param position Coordinate, such as x, y
* @param lineWidth Should be nonnegative integer.
* @param positiveOrNegative Default false (negative).
* @return Optimized position.
*/
var subPixelOptimize$1 = subPixelOptimize;
/**
* Get transform matrix of target (param target),
* in coordinate of its ancestor (param ancestor)
*
* @param target
* @param [ancestor]
*/
function getTransform$1(target, ancestor) {
	var mat = identity([]);
	while (target && target !== ancestor) {
		mul(mat, target.getLocalTransform(), mat);
		target = target.parent;
	}
	return mat;
}
/**
* Apply transform to an vertex.
* @param target [x, y]
* @param transform Can be:
*      + Transform matrix: like [1, 0, 0, 1, 0, 0]
*      + {position, rotation, scale}, the same as `zrender/Transformable`.
* @param invert Whether use invert matrix.
* @return [x, y]
*/
function applyTransform$1(target, transform, invert$1) {
	if (transform && !isArrayLike(transform)) transform = Transformable_default.getLocalTransform(transform);
	if (invert$1) transform = invert([], transform);
	return applyTransform([], target, transform);
}
/**
* @param direction 'left' 'right' 'top' 'bottom'
* @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]
* @param invert Whether use invert matrix.
* @return Transformed direction. 'left' 'right' 'top' 'bottom'
*/
function transformDirection(direction, transform, invert$1) {
	var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : mathAbs$1(2 * transform[4] / transform[0]);
	var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : mathAbs$1(2 * transform[4] / transform[2]);
	var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
	vertex = applyTransform$1(vertex, transform, invert$1);
	return mathAbs$1(vertex[0]) > mathAbs$1(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
}
function isNotGroup(el) {
	return !el.isGroup;
}
function isPath$1(el) {
	return el.shape != null;
}
/**
* Apply group transition animation from g1 to g2.
* If no animatableModel, no animation.
*/
function groupTransition(g1, g2, animatableModel) {
	if (!g1 || !g2) return;
	function getElMap(g) {
		var elMap = {};
		g.traverse(function(el) {
			if (isNotGroup(el) && el.anid) elMap[el.anid] = el;
		});
		return elMap;
	}
	function getAnimatableProps(el) {
		var obj = {
			x: el.x,
			y: el.y,
			rotation: el.rotation
		};
		if (isPath$1(el)) obj.shape = clone(el.shape);
		return obj;
	}
	var elMap1 = getElMap(g1);
	g2.traverse(function(el) {
		if (isNotGroup(el) && el.anid) {
			var oldEl = elMap1[el.anid];
			if (oldEl) {
				var newProp = getAnimatableProps(el);
				el.attr(getAnimatableProps(oldEl));
				updateProps(el, newProp, animatableModel, getECData(el).dataIndex);
			}
		}
	});
}
function clipPointsByRect(points$3, rect) {
	return map(points$3, function(point) {
		var x = point[0];
		x = mathMax$1(x, rect.x);
		x = mathMin$1(x, rect.x + rect.width);
		var y = point[1];
		y = mathMax$1(y, rect.y);
		y = mathMin$1(y, rect.y + rect.height);
		return [x, y];
	});
}
/**
* Return a new clipped rect. If rect size are negative, return undefined.
*/
function clipRectByRect(targetRect, rect) {
	var x = mathMax$1(targetRect.x, rect.x);
	var x2 = mathMin$1(targetRect.x + targetRect.width, rect.x + rect.width);
	var y = mathMax$1(targetRect.y, rect.y);
	var y2 = mathMin$1(targetRect.y + targetRect.height, rect.y + rect.height);
	if (x2 >= x && y2 >= y) return {
		x,
		y,
		width: x2 - x,
		height: y2 - y
	};
}
function createIcon(iconStr, opt, rect) {
	var innerOpts = extend({ rectHover: true }, opt);
	var style = innerOpts.style = { strokeNoScale: true };
	rect = rect || {
		x: -1,
		y: -1,
		width: 2,
		height: 2
	};
	if (iconStr) return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new Image_default(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
}
/**
* Return `true` if the given line (line `a`) and the given polygon
* are intersect.
* Note that we do not count colinear as intersect here because no
* requirement for that. We could do that if required in future.
*/
function linePolygonIntersect(a1x, a1y, a2x, a2y, points$3) {
	for (var i$1 = 0, p2 = points$3[points$3.length - 1]; i$1 < points$3.length; i$1++) {
		var p = points$3[i$1];
		if (lineLineIntersect$1(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) return true;
		p2 = p;
	}
}
/**
* Return `true` if the given two lines (line `a` and line `b`)
* are intersect.
* Note that we do not count colinear as intersect here because no
* requirement for that. We could do that if required in future.
*/
function lineLineIntersect$1(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
	var mx = a2x - a1x;
	var my = a2y - a1y;
	var nx = b2x - b1x;
	var ny = b2y - b1y;
	var nmCrossProduct = crossProduct2d$1(nx, ny, mx, my);
	if (nearZero(nmCrossProduct)) return false;
	var b1a1x = a1x - b1x;
	var b1a1y = a1y - b1y;
	var q = crossProduct2d$1(b1a1x, b1a1y, mx, my) / nmCrossProduct;
	if (q < 0 || q > 1) return false;
	var p = crossProduct2d$1(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
	if (p < 0 || p > 1) return false;
	return true;
}
/**
* Cross product of 2-dimension vector.
*/
function crossProduct2d$1(x1, y1, x2, y2) {
	return x1 * y2 - x2 * y1;
}
function nearZero(val) {
	return val <= 1e-6 && val >= -1e-6;
}
/**
* NOTE:
*  A negative-width/height rect (due to negative margins) is not supported;
*  it will be clampped to zero width/height.
*  Although negative-width/height rects can be defined reasonably following the
*  similar sense in CSS, but they are rarely used, hard to understand and complicated.
*
* @param rect Assume its width/height >= 0 if existing.
*  x/y/width/height is allowed to be NaN,
*  for the case that only x/width or y/height is intended to be computed.
* @param delta
*  If be `number[]`, should be `[top, right, bottom, left]`,
*      which can be used in padding or margin case.
*      @see `normalizeCssArray` in `util/format.ts`
*  If be `number`, it means [delta, delta, delta, delta],
*      which can be used in lineWidth (borderWith) case,
*      [NOTICE]: commonly pass lineWidth / 2, following the convention that border is
*      half inside half outside of the rect.
* @param shrinkOrExpand
*  `true` - shrink if `delta[i]` is positive, commmonly used in `padding` case.
*  `false` - expand if `delta[i]` is positive, commmonly used in `margin` case. (default)
* @param noNegative
*  `true` - negative `delta[i]` will be clampped to 0.
*  `false` - No clamp to `delta`. (default).
* @return The input `rect`.
*/
function expandOrShrinkRect(rect, delta, shrinkOrExpand, noNegative, minSize) {
	if (delta == null) return rect;
	else if (isNumber(delta)) _tmpExpandRectDelta[0] = _tmpExpandRectDelta[1] = _tmpExpandRectDelta[2] = _tmpExpandRectDelta[3] = delta;
	else {
		assert(delta.length === 4);
		_tmpExpandRectDelta[0] = delta[0];
		_tmpExpandRectDelta[1] = delta[1];
		_tmpExpandRectDelta[2] = delta[2];
		_tmpExpandRectDelta[3] = delta[3];
	}
	if (noNegative) {
		_tmpExpandRectDelta[0] = mathMax$1(0, _tmpExpandRectDelta[0]);
		_tmpExpandRectDelta[1] = mathMax$1(0, _tmpExpandRectDelta[1]);
		_tmpExpandRectDelta[2] = mathMax$1(0, _tmpExpandRectDelta[2]);
		_tmpExpandRectDelta[3] = mathMax$1(0, _tmpExpandRectDelta[3]);
	}
	if (shrinkOrExpand) {
		_tmpExpandRectDelta[0] = -_tmpExpandRectDelta[0];
		_tmpExpandRectDelta[1] = -_tmpExpandRectDelta[1];
		_tmpExpandRectDelta[2] = -_tmpExpandRectDelta[2];
		_tmpExpandRectDelta[3] = -_tmpExpandRectDelta[3];
	}
	expandRectOnOneDimension(rect, _tmpExpandRectDelta, "x", "width", 3, 1, minSize && minSize[0] || 0);
	expandRectOnOneDimension(rect, _tmpExpandRectDelta, "y", "height", 0, 2, minSize && minSize[1] || 0);
	return rect;
}
var _tmpExpandRectDelta = [
	0,
	0,
	0,
	0
];
function expandRectOnOneDimension(rect, delta, xy, wh, ltIdx, rbIdx, minSize) {
	var deltaSum = delta[rbIdx] + delta[ltIdx];
	var oldSize = rect[wh];
	rect[wh] += deltaSum;
	minSize = mathMax$1(0, mathMin$1(minSize, oldSize));
	if (rect[wh] < minSize) {
		rect[wh] = minSize;
		rect[xy] += delta[ltIdx] >= 0 ? -delta[ltIdx] : delta[rbIdx] >= 0 ? oldSize + delta[rbIdx] : mathAbs$1(deltaSum) > 1e-8 ? (oldSize - minSize) * delta[ltIdx] / deltaSum : 0;
	} else rect[xy] -= delta[ltIdx];
}
function setTooltipConfig(opt) {
	var itemTooltipOption = opt.itemTooltipOption;
	var componentModel = opt.componentModel;
	var itemName = opt.itemName;
	var itemTooltipOptionObj = isString(itemTooltipOption) ? { formatter: itemTooltipOption } : itemTooltipOption;
	var mainType = componentModel.mainType;
	var componentIndex = componentModel.componentIndex;
	var formatterParams = {
		componentType: mainType,
		name: itemName,
		$vars: ["name"]
	};
	formatterParams[mainType + "Index"] = componentIndex;
	var formatterParamsExtra = opt.formatterParamsExtra;
	if (formatterParamsExtra) each(keys(formatterParamsExtra), function(key$1) {
		if (!hasOwn(formatterParams, key$1)) {
			formatterParams[key$1] = formatterParamsExtra[key$1];
			formatterParams.$vars.push(key$1);
		}
	});
	var ecData = getECData(opt.el);
	ecData.componentMainType = mainType;
	ecData.componentIndex = componentIndex;
	ecData.tooltipConfig = {
		name: itemName,
		option: defaults({
			content: itemName,
			encodeHTMLContent: true,
			formatterParams
		}, itemTooltipOptionObj)
	};
}
function traverseElement(el, cb) {
	var stopped;
	if (el.isGroup) stopped = cb(el);
	if (!stopped) el.traverse(cb);
}
function traverseElements(els, cb) {
	if (els) if (isArray(els)) for (var i$1 = 0; i$1 < els.length; i$1++) traverseElement(els[i$1], cb);
	else traverseElement(els, cb);
}
/**
* After a boundingRect applying a `transform`, whether to be still parallel screen X and Y.
*/
function isBoundingRectAxisAligned(transform) {
	return !transform || mathAbs$1(transform[1]) < AXIS_ALIGN_EPSILON && mathAbs$1(transform[2]) < AXIS_ALIGN_EPSILON || mathAbs$1(transform[0]) < AXIS_ALIGN_EPSILON && mathAbs$1(transform[3]) < AXIS_ALIGN_EPSILON;
}
var AXIS_ALIGN_EPSILON = 1e-5;
/**
* Create or copy to the existing bounding rect to avoid modifying `source`.
*
* @usage
*  out.rect = ensureCopyRect(out.rect, sourceRect);
*/
function ensureCopyRect(target, source) {
	return target ? BoundingRect_default.copy(target, source) : source.clone();
}
/**
* Create or copy to the existing transform to avoid modifying `source`.
*
* [CAUTION]: transform is `NullUndefined` if no transform, following convention of zrender,
*  and enable to bypass some unnecessary calculation, since in most cases there is no transform.
*
* @usage
*  out.transform = ensureCopyTransform(out.transform, sourceTransform);
*/
function ensureCopyTransform(target, source) {
	return source ? copy(target || create$2(), source) : void 0;
}
function retrieveZInfo(model) {
	return {
		z: model.get("z") || 0,
		zlevel: model.get("zlevel") || 0
	};
}
/**
* Assume all of the elements has the same `z` and `zlevel`.
*/
function calcZ2Range(el) {
	var max$2 = -Infinity;
	var min$2 = Infinity;
	traverseElement(el, function(el$1) {
		visitEl(el$1);
		visitEl(el$1.getTextContent());
		visitEl(el$1.getTextGuideLine());
	});
	function visitEl(el$1) {
		if (!el$1 || el$1.isGroup) return;
		var currentStates = el$1.currentStates;
		if (currentStates.length) for (var idx = 0; idx < currentStates.length; idx++) calcZ2(el$1.states[currentStates[idx]]);
		calcZ2(el$1);
	}
	function calcZ2(entity) {
		if (entity) {
			var z2 = entity.z2;
			if (z2 > max$2) max$2 = z2;
			if (z2 < min$2) min$2 = z2;
		}
	}
	if (min$2 > max$2) min$2 = max$2 = 0;
	return {
		min: min$2,
		max: max$2
	};
}
function traverseUpdateZ(el, z, zlevel) {
	doUpdateZ(el, z, zlevel, -Infinity);
}
function doUpdateZ(el, z, zlevel, maxZ2) {
	if (el.ignoreModelZ) return maxZ2;
	var label = el.getTextContent();
	var labelLine = el.getTextGuideLine();
	if (el.isGroup) {
		var children = el.childrenRef();
		for (var i$1 = 0; i$1 < children.length; i$1++) maxZ2 = mathMax$1(doUpdateZ(children[i$1], z, zlevel, maxZ2), maxZ2);
	} else {
		el.z = z;
		el.zlevel = zlevel;
		maxZ2 = mathMax$1(el.z2 || 0, maxZ2);
	}
	if (label) {
		label.z = z;
		label.zlevel = zlevel;
		isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
	}
	if (labelLine) {
		var textGuideLineConfig = el.textGuideLineConfig;
		labelLine.z = z;
		labelLine.zlevel = zlevel;
		isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
	}
	return maxZ2;
}
registerShape("circle", Circle_default);
registerShape("ellipse", Ellipse_default);
registerShape("sector", Sector_default);
registerShape("ring", Ring_default);
registerShape("polygon", Polygon_default);
registerShape("polyline", Polyline_default);
registerShape("rect", Rect_default);
registerShape("line", Line_default);
registerShape("bezierCurve", BezierCurve_default);
registerShape("arc", Arc_default);

//#endregion
//#region node_modules/echarts/lib/label/labelStyle.js
var EMPTY_OBJ = {};
function setLabelText(label, labelTexts) {
	for (var i$1 = 0; i$1 < SPECIAL_STATES.length; i$1++) {
		var stateName = SPECIAL_STATES[i$1];
		var text = labelTexts[stateName];
		var state = label.ensureState(stateName);
		state.style = state.style || {};
		state.style.text = text;
	}
	var oldStates = label.currentStates.slice();
	label.clearStates(true);
	label.setStyle({ text: labelTexts.normal });
	label.useStates(oldStates, true);
}
function getLabelText(opt, stateModels, interpolatedValue) {
	var labelFetcher = opt.labelFetcher;
	var labelDataIndex = opt.labelDataIndex;
	var labelDimIndex = opt.labelDimIndex;
	var normalModel = stateModels.normal;
	var baseText;
	if (labelFetcher) baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? { interpolatedValue } : null);
	if (baseText == null) baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
	var statesText = { normal: baseText };
	for (var i$1 = 0; i$1 < SPECIAL_STATES.length; i$1++) {
		var stateName = SPECIAL_STATES[i$1];
		var stateModel = stateModels[stateName];
		statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
	}
	return statesText;
}
function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
	opt = opt || EMPTY_OBJ;
	var isSetOnText = targetEl instanceof Text_default;
	var needsCreateText = false;
	for (var i$1 = 0; i$1 < DISPLAY_STATES.length; i$1++) {
		var stateModel = labelStatesModels[DISPLAY_STATES[i$1]];
		if (stateModel && stateModel.getShallow("show")) {
			needsCreateText = true;
			break;
		}
	}
	var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
	if (needsCreateText) {
		if (!isSetOnText) {
			if (!textContent) {
				textContent = new Text_default();
				targetEl.setTextContent(textContent);
			}
			if (targetEl.stateProxy) textContent.stateProxy = targetEl.stateProxy;
		}
		var labelStatesTexts = getLabelText(opt, labelStatesModels);
		var normalModel = labelStatesModels.normal;
		var showNormal = !!normalModel.getShallow("show");
		var normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
		normalStyle.text = labelStatesTexts.normal;
		if (!isSetOnText) targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
		for (var i$1 = 0; i$1 < SPECIAL_STATES.length; i$1++) {
			var stateName = SPECIAL_STATES[i$1];
			var stateModel = labelStatesModels[stateName];
			if (stateModel) {
				var stateObj = textContent.ensureState(stateName);
				var stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
				if (stateShow !== showNormal) stateObj.ignore = !stateShow;
				stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
				stateObj.style.text = labelStatesTexts[stateName];
				if (!isSetOnText) {
					var targetElEmphasisState = targetEl.ensureState(stateName);
					targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
				}
			}
		}
		textContent.silent = !!normalModel.getShallow("silent");
		if (textContent.style.x != null) normalStyle.x = textContent.style.x;
		if (textContent.style.y != null) normalStyle.y = textContent.style.y;
		textContent.ignore = !showNormal;
		textContent.useStyle(normalStyle);
		textContent.dirty();
		if (opt.enableTextSetter) labelInner(textContent).setLabelText = function(interpolatedValue) {
			var labelStatesTexts$1 = getLabelText(opt, labelStatesModels, interpolatedValue);
			setLabelText(textContent, labelStatesTexts$1);
		};
	} else if (textContent) textContent.ignore = true;
	targetEl.dirty();
}
function getLabelStatesModels(itemModel, labelName) {
	labelName = labelName || "label";
	var statesModels = { normal: itemModel.getModel(labelName) };
	for (var i$1 = 0; i$1 < SPECIAL_STATES.length; i$1++) {
		var stateName = SPECIAL_STATES[i$1];
		statesModels[stateName] = itemModel.getModel([stateName, labelName]);
	}
	return statesModels;
}
/**
* Set basic textStyle properties.
*/
function createTextStyle(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
	var textStyle = {};
	setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
	specifiedTextStyle && extend(textStyle, specifiedTextStyle);
	return textStyle;
}
function createTextConfig(textStyleModel, opt, isNotNormal) {
	opt = opt || {};
	var textConfig = {};
	var labelPosition;
	var labelRotate = textStyleModel.getShallow("rotate");
	var labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
	var labelOffset = textStyleModel.getShallow("offset");
	labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
	labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
	if (labelPosition != null) textConfig.position = labelPosition;
	if (labelOffset != null) textConfig.offset = labelOffset;
	if (labelRotate != null) {
		labelRotate *= Math.PI / 180;
		textConfig.rotation = labelRotate;
	}
	if (labelDistance != null) textConfig.distance = labelDistance;
	textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
	if (opt.autoOverflowArea != null) textConfig.autoOverflowArea = opt.autoOverflowArea;
	if (opt.layoutRect != null) textConfig.layoutRect = opt.layoutRect;
	return textConfig;
}
/**
* The uniform entry of set text style, that is, retrieve style definitions
* from `model` and set to `textStyle` object.
*
* Never in merge mode, but in overwrite mode, that is, all of the text style
* properties will be set. (Consider the states of normal and emphasis and
* default value can be adopted, merge would make the logic too complicated
* to manage.)
*/
function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
	opt = opt || EMPTY_OBJ;
	var ecModel = textStyleModel.ecModel;
	var globalTextStyle = ecModel && ecModel.option.textStyle;
	var richItemNames = getRichItemNames(textStyleModel);
	var richResult;
	if (richItemNames) {
		richResult = {};
		var richInheritPlainLabelOptionName = "richInheritPlainLabel";
		var richInheritPlainLabel = retrieve2(textStyleModel.get(richInheritPlainLabelOptionName), ecModel ? ecModel.get(richInheritPlainLabelOptionName) : void 0);
		for (var name_1 in richItemNames) if (richItemNames.hasOwnProperty(name_1)) {
			var richTextStyle = textStyleModel.getModel(["rich", name_1]);
			setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, textStyleModel, richInheritPlainLabel, opt, isNotNormal, isAttached, false, true);
		}
	}
	if (richResult) textStyle.rich = richResult;
	var overflow = textStyleModel.get("overflow");
	if (overflow) textStyle.overflow = overflow;
	var lineOverflow = textStyleModel.get("lineOverflow");
	if (lineOverflow) textStyle.lineOverflow = lineOverflow;
	var labelTextStyle = textStyle;
	var minMargin = textStyleModel.get("minMargin");
	if (minMargin != null) {
		minMargin = !isNumber(minMargin) ? 0 : minMargin / 2;
		labelTextStyle.margin = [
			minMargin,
			minMargin,
			minMargin,
			minMargin
		];
		labelTextStyle.__marginType = LabelMarginType.minMargin;
	} else {
		var textMargin = textStyleModel.get("textMargin");
		if (textMargin != null) {
			labelTextStyle.margin = normalizeCssArray$1(textMargin);
			labelTextStyle.__marginType = LabelMarginType.textMargin;
		}
	}
	setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, null, null, opt, isNotNormal, isAttached, true, false);
}
function getRichItemNames(textStyleModel) {
	var richItemNameMap;
	while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
		var rich = (textStyleModel.option || EMPTY_OBJ).rich;
		if (rich) {
			richItemNameMap = richItemNameMap || {};
			var richKeys = keys(rich);
			for (var i$1 = 0; i$1 < richKeys.length; i$1++) {
				var richKey = richKeys[i$1];
				richItemNameMap[richKey] = 1;
			}
		}
		textStyleModel = textStyleModel.parentModel;
	}
	return richItemNameMap;
}
var TEXT_PROPS_WITH_GLOBAL = [
	"fontStyle",
	"fontWeight",
	"fontSize",
	"fontFamily",
	"textShadowColor",
	"textShadowBlur",
	"textShadowOffsetX",
	"textShadowOffsetY"
];
var TEXT_PROPS_SELF = [
	"align",
	"lineHeight",
	"width",
	"height",
	"tag",
	"verticalAlign",
	"ellipsis"
];
var TEXT_PROPS_BOX = [
	"padding",
	"borderWidth",
	"borderRadius",
	"borderDashOffset",
	"backgroundColor",
	"borderColor",
	"shadowColor",
	"shadowBlur",
	"shadowOffsetX",
	"shadowOffsetY"
];
function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, plainTextModel, richInheritPlainLabel, opt, isNotNormal, isAttached, isBlock, inRich) {
	globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
	var inheritColor = opt && opt.inheritColor;
	var fillColor = textStyleModel.getShallow("color");
	var strokeColor = textStyleModel.getShallow("textBorderColor");
	var opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
	if (fillColor === "inherit" || fillColor === "auto") {
		if (fillColor === "auto") deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
		if (inheritColor) fillColor = inheritColor;
		else fillColor = null;
	}
	if (strokeColor === "inherit" || strokeColor === "auto") {
		if (strokeColor === "auto") deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
		if (inheritColor) strokeColor = inheritColor;
		else strokeColor = null;
	}
	if (!isAttached) {
		fillColor = fillColor || globalTextStyle.color;
		strokeColor = strokeColor || globalTextStyle.textBorderColor;
	}
	if (fillColor != null) textStyle.fill = fillColor;
	if (strokeColor != null) textStyle.stroke = strokeColor;
	var textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
	if (textBorderWidth != null) textStyle.lineWidth = textBorderWidth;
	var textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
	if (textBorderType != null) textStyle.lineDash = textBorderType;
	var textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
	if (textBorderDashOffset != null) textStyle.lineDashOffset = textBorderDashOffset;
	if (!isNotNormal && opacity == null && !inRich) opacity = opt && opt.defaultOpacity;
	if (opacity != null) textStyle.opacity = opacity;
	if (!isNotNormal && !isAttached) {
		if (textStyle.fill == null && opt.inheritColor) textStyle.fill = opt.inheritColor;
	}
	for (var i$1 = 0; i$1 < TEXT_PROPS_WITH_GLOBAL.length; i$1++) {
		var key$1 = TEXT_PROPS_WITH_GLOBAL[i$1];
		var val = richInheritPlainLabel !== false && plainTextModel ? retrieve3(textStyleModel.getShallow(key$1), plainTextModel.getShallow(key$1), globalTextStyle[key$1]) : retrieve2(textStyleModel.getShallow(key$1), globalTextStyle[key$1]);
		if (val != null) textStyle[key$1] = val;
	}
	for (var i$1 = 0; i$1 < TEXT_PROPS_SELF.length; i$1++) {
		var key$1 = TEXT_PROPS_SELF[i$1];
		var val = textStyleModel.getShallow(key$1);
		if (val != null) textStyle[key$1] = val;
	}
	if (textStyle.verticalAlign == null) {
		var baseline = textStyleModel.getShallow("baseline");
		if (baseline != null) textStyle.verticalAlign = baseline;
	}
	if (!isBlock || !opt.disableBox) {
		for (var i$1 = 0; i$1 < TEXT_PROPS_BOX.length; i$1++) {
			var key$1 = TEXT_PROPS_BOX[i$1];
			var val = textStyleModel.getShallow(key$1);
			if (val != null) textStyle[key$1] = val;
		}
		var borderType = textStyleModel.getShallow("borderType");
		if (borderType != null) textStyle.borderDash = borderType;
		if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
			if (textStyle.backgroundColor === "auto") deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'");
			textStyle.backgroundColor = inheritColor;
		}
		if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
			if (textStyle.borderColor === "auto") deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'");
			textStyle.borderColor = inheritColor;
		}
	}
}
function getFont(opt, ecModel) {
	var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
	return trim([
		opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
		opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
		(opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
		opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
	].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
	if (!label) return;
	var obj = labelInner(label);
	obj.prevValue = obj.value;
	obj.value = value;
	var normalLabelModel = labelStatesModels.normal;
	obj.valueAnimation = normalLabelModel.get("valueAnimation");
	if (obj.valueAnimation) {
		obj.precision = normalLabelModel.get("precision");
		obj.defaultInterpolatedText = getDefaultText;
		obj.statesModels = labelStatesModels;
	}
}
function animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {
	var labelInnerStore = labelInner(textEl);
	if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) return;
	var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
	var currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);
	var targetValue = labelInnerStore.value;
	function during(percent) {
		var interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent);
		labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;
		setLabelText(textEl, getLabelText({
			labelDataIndex: dataIndex,
			labelFetcher,
			defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ""
		}, labelInnerStore.statesModels, interpolated));
	}
	textEl.percent = 0;
	(labelInnerStore.prevValue == null ? initProps : updateProps)(textEl, { percent: 1 }, animatableModel, dataIndex, null, during);
}
/**
* PENDING: Temporary impl. unify them?
* @see {LabelCommonOption['textMargin']}
* @see {LabelCommonOption['minMargin']}
*/
var LabelMarginType = {
	minMargin: 1,
	textMargin: 2
};

//#endregion
//#region node_modules/echarts/lib/model/mixin/textStyle.js
var PATH_COLOR = ["textStyle", "color"];
var textStyleParams = [
	"fontStyle",
	"fontWeight",
	"fontSize",
	"fontFamily",
	"padding",
	"lineHeight",
	"rich",
	"width",
	"height",
	"overflow"
];
var tmpText = new Text_default();
var TextStyleMixin = function() {
	function TextStyleMixin$1() {}
	/**
	* Get color property or get color from option.textStyle.color
	*/
	TextStyleMixin$1.prototype.getTextColor = function(isEmphasis) {
		var ecModel = this.ecModel;
		return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
	};
	/**
	* Create font string from fontStyle, fontWeight, fontSize, fontFamily
	* @return {string}
	*/
	TextStyleMixin$1.prototype.getFont = function() {
		return getFont({
			fontStyle: this.getShallow("fontStyle"),
			fontWeight: this.getShallow("fontWeight"),
			fontSize: this.getShallow("fontSize"),
			fontFamily: this.getShallow("fontFamily")
		}, this.ecModel);
	};
	TextStyleMixin$1.prototype.getTextRect = function(text) {
		var style = {
			text,
			verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
		};
		for (var i$1 = 0; i$1 < textStyleParams.length; i$1++) style[textStyleParams[i$1]] = this.getShallow(textStyleParams[i$1]);
		tmpText.useStyle(style);
		tmpText.update();
		return tmpText.getBoundingRect();
	};
	return TextStyleMixin$1;
}();
var textStyle_default = TextStyleMixin;

//#endregion
//#region node_modules/echarts/lib/model/mixin/lineStyle.js
var LINE_STYLE_KEY_MAP = [
	["lineWidth", "width"],
	["stroke", "color"],
	["opacity"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["shadowColor"],
	["lineDash", "type"],
	["lineDashOffset", "dashOffset"],
	["lineCap", "cap"],
	["lineJoin", "join"],
	["miterLimit"]
];
var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
var LineStyleMixin = function() {
	function LineStyleMixin$1() {}
	LineStyleMixin$1.prototype.getLineStyle = function(excludes) {
		return getLineStyle(this, excludes);
	};
	return LineStyleMixin$1;
}();

//#endregion
//#region node_modules/echarts/lib/model/mixin/itemStyle.js
var ITEM_STYLE_KEY_MAP = [
	["fill", "color"],
	["stroke", "borderColor"],
	["lineWidth", "borderWidth"],
	["opacity"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["shadowColor"],
	["lineDash", "borderType"],
	["lineDashOffset", "borderDashOffset"],
	["lineCap", "borderCap"],
	["lineJoin", "borderJoin"],
	["miterLimit", "borderMiterLimit"]
];
var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
var ItemStyleMixin = function() {
	function ItemStyleMixin$1() {}
	ItemStyleMixin$1.prototype.getItemStyle = function(excludes, includes) {
		return getItemStyle(this, excludes, includes);
	};
	return ItemStyleMixin$1;
}();

//#endregion
//#region node_modules/echarts/lib/model/Model.js
var Model = function() {
	function Model$1(option, parentModel, ecModel) {
		this.parentModel = parentModel;
		this.ecModel = ecModel;
		this.option = option;
	}
	Model$1.prototype.init = function(option, parentModel, ecModel) {
		var rest = [];
		for (var _i = 3; _i < arguments.length; _i++) rest[_i - 3] = arguments[_i];
	};
	/**
	* Merge the input option to me.
	*/
	Model$1.prototype.mergeOption = function(option, ecModel) {
		merge(this.option, option, true);
	};
	Model$1.prototype.get = function(path, ignoreParent) {
		if (path == null) return this.option;
		return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
	};
	Model$1.prototype.getShallow = function(key$1, ignoreParent) {
		var option = this.option;
		var val = option == null ? option : option[key$1];
		if (val == null && !ignoreParent) {
			var parentModel = this.parentModel;
			if (parentModel) val = parentModel.getShallow(key$1);
		}
		return val;
	};
	Model$1.prototype.getModel = function(path, parentModel) {
		var hasPath = path != null;
		var pathFinal = hasPath ? this.parsePath(path) : null;
		var obj = hasPath ? this._doGet(pathFinal) : this.option;
		parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
		return new Model$1(obj, parentModel, this.ecModel);
	};
	/**
	* If model has option
	*/
	Model$1.prototype.isEmpty = function() {
		return this.option == null;
	};
	Model$1.prototype.restoreData = function() {};
	Model$1.prototype.clone = function() {
		var Ctor = this.constructor;
		return new Ctor(clone(this.option));
	};
	Model$1.prototype.parsePath = function(path) {
		if (typeof path === "string") return path.split(".");
		return path;
	};
	Model$1.prototype.resolveParentPath = function(path) {
		return path;
	};
	Model$1.prototype.isAnimationEnabled = function() {
		if (!env_default.node && this.option) {
			if (this.option.animation != null) return !!this.option.animation;
			else if (this.parentModel) return this.parentModel.isAnimationEnabled();
		}
	};
	Model$1.prototype._doGet = function(pathArr, parentModel) {
		var obj = this.option;
		if (!pathArr) return obj;
		for (var i$1 = 0; i$1 < pathArr.length; i$1++) {
			if (!pathArr[i$1]) continue;
			obj = obj && typeof obj === "object" ? obj[pathArr[i$1]] : null;
			if (obj == null) break;
		}
		if (obj == null && parentModel) obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
		return obj;
	};
	return Model$1;
}();
enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, LineStyleMixin);
mixin(Model, ItemStyleMixin);
mixin(Model, AreaStyleMixin);
mixin(Model, textStyle_default);
var Model_default = Model;

//#endregion
//#region node_modules/echarts/lib/util/component.js
var base = Math.round(Math.random() * 10);
/**
* @public
* @param {string} type
* @return {string}
*/
function getUID(type) {
	return [type || "", base++].join("_");
}
/**
* Implements `SubTypeDefaulterManager` for `target`.
*/
function enableSubTypeDefaulter(target) {
	var subTypeDefaulters = {};
	target.registerSubTypeDefaulter = function(componentType, defaulter) {
		var componentTypeInfo = parseClassType(componentType);
		subTypeDefaulters[componentTypeInfo.main] = defaulter;
	};
	target.determineSubType = function(componentType, option) {
		var type = option.type;
		if (!type) {
			var componentTypeMain = parseClassType(componentType).main;
			if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) type = subTypeDefaulters[componentTypeMain](option);
		}
		return type;
	};
}
/**
* Implements `TopologicalTravelable<any>` for `entity`.
*
* Topological travel on Activity Network (Activity On Vertices).
* Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
* If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
* If there is circular dependencey, Error will be thrown.
*/
function enableTopologicalTravel(entity, dependencyGetter) {
	/**
	* @param targetNameList Target Component type list.
	*                       Can be ['aa', 'bb', 'aa.xx']
	* @param fullNameList By which we can build dependency graph.
	* @param callback Params: componentType, dependencies.
	* @param context Scope of callback.
	*/
	entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
		if (!targetNameList.length) return;
		var result = makeDepndencyGraph(fullNameList);
		var graph = result.graph;
		var noEntryList = result.noEntryList;
		var targetNameSet = {};
		each(targetNameList, function(name) {
			targetNameSet[name] = true;
		});
		while (noEntryList.length) {
			var currComponentType = noEntryList.pop();
			var currVertex = graph[currComponentType];
			var isInTargetNameSet = !!targetNameSet[currComponentType];
			if (isInTargetNameSet) {
				callback.call(context, currComponentType, currVertex.originalDeps.slice());
				delete targetNameSet[currComponentType];
			}
			each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
		}
		each(targetNameSet, function() {
			var errMsg = "";
			errMsg = makePrintable("Circular dependency may exists: ", targetNameSet, targetNameList, fullNameList);
			throw new Error(errMsg);
		});
		function removeEdge(succComponentType) {
			graph[succComponentType].entryCount--;
			if (graph[succComponentType].entryCount === 0) noEntryList.push(succComponentType);
		}
		function removeEdgeAndAdd(succComponentType) {
			targetNameSet[succComponentType] = true;
			removeEdge(succComponentType);
		}
	};
	function makeDepndencyGraph(fullNameList) {
		var graph = {};
		var noEntryList = [];
		each(fullNameList, function(name) {
			var thisItem = createDependencyGraphItem(graph, name);
			var availableDeps = getAvailableDependencies(thisItem.originalDeps = dependencyGetter(name), fullNameList);
			thisItem.entryCount = availableDeps.length;
			if (thisItem.entryCount === 0) noEntryList.push(name);
			each(availableDeps, function(dependentName) {
				if (indexOf(thisItem.predecessor, dependentName) < 0) thisItem.predecessor.push(dependentName);
				var thatItem = createDependencyGraphItem(graph, dependentName);
				if (indexOf(thatItem.successor, dependentName) < 0) thatItem.successor.push(name);
			});
		});
		return {
			graph,
			noEntryList
		};
	}
	function createDependencyGraphItem(graph, name) {
		if (!graph[name]) graph[name] = {
			predecessor: [],
			successor: []
		};
		return graph[name];
	}
	function getAvailableDependencies(originalDeps, fullNameList) {
		var availableDeps = [];
		each(originalDeps, function(dep) {
			indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
		});
		return availableDeps;
	}
}
function inheritDefaultOption(superOption, subOption) {
	return merge(merge({}, superOption, true), subOption, true);
}

//#endregion
//#region node_modules/echarts/lib/i18n/langEN.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Language: English.
*/
var langEN_default = {
	time: {
		month: [
			"January",
			"February",
			"March",
			"April",
			"May",
			"June",
			"July",
			"August",
			"September",
			"October",
			"November",
			"December"
		],
		monthAbbr: [
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec"
		],
		dayOfWeek: [
			"Sunday",
			"Monday",
			"Tuesday",
			"Wednesday",
			"Thursday",
			"Friday",
			"Saturday"
		],
		dayOfWeekAbbr: [
			"Sun",
			"Mon",
			"Tue",
			"Wed",
			"Thu",
			"Fri",
			"Sat"
		]
	},
	legend: { selector: {
		all: "All",
		inverse: "Inv"
	} },
	toolbox: {
		brush: { title: {
			rect: "Box Select",
			polygon: "Lasso Select",
			lineX: "Horizontally Select",
			lineY: "Vertically Select",
			keep: "Keep Selections",
			clear: "Clear Selections"
		} },
		dataView: {
			title: "Data View",
			lang: [
				"Data View",
				"Close",
				"Refresh"
			]
		},
		dataZoom: { title: {
			zoom: "Zoom",
			back: "Zoom Reset"
		} },
		magicType: { title: {
			line: "Switch to Line Chart",
			bar: "Switch to Bar Chart",
			stack: "Stack",
			tiled: "Tile"
		} },
		restore: { title: "Restore" },
		saveAsImage: {
			title: "Save as Image",
			lang: ["Right Click to Save Image"]
		}
	},
	series: { typeNames: {
		pie: "Pie chart",
		bar: "Bar chart",
		line: "Line chart",
		scatter: "Scatter plot",
		effectScatter: "Ripple scatter plot",
		radar: "Radar chart",
		tree: "Tree",
		treemap: "Treemap",
		boxplot: "Boxplot",
		candlestick: "Candlestick",
		k: "K line chart",
		heatmap: "Heat map",
		map: "Map",
		parallel: "Parallel coordinate map",
		lines: "Line graph",
		graph: "Relationship graph",
		sankey: "Sankey diagram",
		funnel: "Funnel chart",
		gauge: "Gauge",
		pictorialBar: "Pictorial bar",
		themeRiver: "Theme River Map",
		sunburst: "Sunburst",
		custom: "Custom chart",
		chart: "Chart"
	} },
	aria: {
		general: {
			withTitle: "This is a chart about \"{title}\"",
			withoutTitle: "This is a chart"
		},
		series: {
			single: {
				prefix: "",
				withName: " with type {seriesType} named {seriesName}.",
				withoutName: " with type {seriesType}."
			},
			multiple: {
				prefix: ". It consists of {seriesCount} series count.",
				withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
				withoutName: " The {seriesId} series is a {seriesType}.",
				separator: {
					middle: "",
					end: ""
				}
			}
		},
		data: {
			allData: "The data is as follows: ",
			partialData: "The first {displayCnt} items are: ",
			withName: "the data for {name} is {value}",
			withoutName: "{value}",
			separator: {
				middle: ", ",
				end: ". "
			}
		}
	}
};

//#endregion
//#region node_modules/echarts/lib/i18n/langZH.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var langZH_default = {
	time: {
		month: [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		monthAbbr: [
			"1",
			"2",
			"3",
			"4",
			"5",
			"6",
			"7",
			"8",
			"9",
			"10",
			"11",
			"12"
		],
		dayOfWeek: [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		dayOfWeekAbbr: [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		]
	},
	legend: { selector: {
		all: "",
		inverse: ""
	} },
	toolbox: {
		brush: { title: {
			rect: "",
			polygon: "",
			lineX: "",
			lineY: "",
			keep: "",
			clear: ""
		} },
		dataView: {
			title: "",
			lang: [
				"",
				"",
				""
			]
		},
		dataZoom: { title: {
			zoom: "",
			back: ""
		} },
		magicType: { title: {
			line: "",
			bar: "",
			stack: "",
			tiled: ""
		} },
		restore: { title: "" },
		saveAsImage: {
			title: "",
			lang: [""]
		}
	},
	series: { typeNames: {
		pie: "",
		bar: "",
		line: "",
		scatter: "",
		effectScatter: "",
		radar: "",
		tree: "",
		treemap: "",
		boxplot: "",
		candlestick: "K",
		k: "K",
		heatmap: "",
		map: "",
		parallel: "",
		lines: "",
		graph: "",
		sankey: "",
		funnel: "",
		gauge: "",
		pictorialBar: "",
		themeRiver: "",
		sunburst: "",
		custom: "",
		chart: ""
	} },
	aria: {
		general: {
			withTitle: "{title}",
			withoutTitle: ""
		},
		series: {
			single: {
				prefix: "",
				withName: "{seriesType}{seriesName}",
				withoutName: "{seriesType}"
			},
			multiple: {
				prefix: "{seriesCount}",
				withName: "{seriesId}{seriesName}{seriesType}",
				withoutName: "{seriesId}{seriesType}",
				separator: {
					middle: "",
					end: ""
				}
			}
		},
		data: {
			allData: "",
			partialData: "{displayCnt}",
			withName: "{name}{value}",
			withoutName: "{value}",
			separator: {
				middle: "",
				end: ""
			}
		}
	}
};

//#endregion
//#region node_modules/echarts/lib/core/locale.js
var LOCALE_ZH = "ZH";
var LOCALE_EN = "EN";
var DEFAULT_LOCALE = LOCALE_EN;
var localeStorage = {};
var localeModels = {};
var SYSTEM_LANG = !env_default.domSupported ? DEFAULT_LOCALE : function() {
	return (document.documentElement.lang || navigator.language || navigator.browserLanguage || DEFAULT_LOCALE).toUpperCase().indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}();
function registerLocale(locale, localeObj) {
	locale = locale.toUpperCase();
	localeModels[locale] = new Model_default(localeObj);
	localeStorage[locale] = localeObj;
}
function createLocaleObject(locale) {
	if (isString(locale)) {
		var localeObj = localeStorage[locale.toUpperCase()] || {};
		if (locale === LOCALE_ZH || locale === LOCALE_EN) return clone(localeObj);
		else return merge(clone(localeObj), clone(localeStorage[DEFAULT_LOCALE]), false);
	} else return merge(clone(locale), clone(localeStorage[DEFAULT_LOCALE]), false);
}
function getLocaleModel(lang) {
	return localeModels[lang];
}
function getDefaultLocaleModel() {
	return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN_default);
registerLocale(LOCALE_ZH, langZH_default);

//#endregion
//#region node_modules/echarts/lib/scale/break.js
var _impl$1 = null;
function registerScaleBreakHelperImpl(impl) {
	if (!_impl$1) _impl$1 = impl;
}
function getScaleBreakHelper() {
	return _impl$1;
}

//#endregion
//#region node_modules/echarts/lib/util/time.js
var ONE_SECOND = 1e3;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;
var ONE_YEAR = ONE_DAY * 365;
var primaryTimeUnitFormatterMatchers = {
	year: /({yyyy}|{yy})/,
	month: /({MMMM}|{MMM}|{MM}|{M})/,
	day: /({dd}|{d})/,
	hour: /({HH}|{H}|{hh}|{h})/,
	minute: /({mm}|{m})/,
	second: /({ss}|{s})/,
	millisecond: /({SSS}|{S})/
};
var defaultFormatterSeed = {
	year: "{yyyy}",
	month: "{MMM}",
	day: "{d}",
	hour: "{HH}:{mm}",
	minute: "{HH}:{mm}",
	second: "{HH}:{mm}:{ss}",
	millisecond: "{HH}:{mm}:{ss} {SSS}"
};
var defaultFullFormatter = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}";
var fullDayFormatter = "{yyyy}-{MM}-{dd}";
var fullLeveledFormatter = {
	year: "{yyyy}",
	month: "{yyyy}-{MM}",
	day: fullDayFormatter,
	hour: fullDayFormatter + " " + defaultFormatterSeed.hour,
	minute: fullDayFormatter + " " + defaultFormatterSeed.minute,
	second: fullDayFormatter + " " + defaultFormatterSeed.second,
	millisecond: defaultFullFormatter
};
var primaryTimeUnits = [
	"year",
	"month",
	"day",
	"hour",
	"minute",
	"second",
	"millisecond"
];
var timeUnits = [
	"year",
	"half-year",
	"quarter",
	"month",
	"week",
	"half-week",
	"day",
	"half-day",
	"quarter-day",
	"hour",
	"minute",
	"second",
	"millisecond"
];
function parseTimeAxisLabelFormatter(formatter) {
	return !isString(formatter) && !isFunction(formatter) ? parseTimeAxisLabelFormatterDictionary(formatter) : formatter;
}
/**
* The final generated dictionary is like:
*  generated_dict = {
*      year: {
*          year: ['{yyyy}', ...<higher_levels_if_any>]
*      },
*      month: {
*          year: ['{yyyy} {MMM}', ...<higher_levels_if_any>],
*          month: ['{MMM}', ...<higher_levels_if_any>]
*      },
*      day: {
*          year: ['{yyyy} {MMM} {d}', ...<higher_levels_if_any>],
*          month: ['{MMM} {d}', ...<higher_levels_if_any>],
*          day: ['{d}', ...<higher_levels_if_any>]
*      },
*      ...
*  }
*
* In echarts option, users can specify the entire dictionary or typically just:
*  {formatter: {
*      year: '{yyyy}', // Or an array of leveled templates: `['{yyyy}', '{bold1|{yyyy}}', ...]`,
*                      // corresponding to `[level0, level1, level2, ...]`.
*      month: '{MMM}',
*      day: '{d}',
*      hour: '{HH}:{mm}',
*      second: '{HH}:{mm}',
*      ...
*  }}
*  If any time unit is not specified in echarts option, the default template is used,
*  such as `['{yyyy}', {primary|{yyyy}']`.
*
* The `tick.level` is only used to read string from each array, meaning the style type.
*
* Let `lowerUnit = getUnitFromValue(tick.value)`.
* The non-break axis ticks only use `generated_dict[lowerUnit][lowerUnit][level]`.
* The break axis ticks may use `generated_dict[lowerUnit][upperUnit][level]`, because:
*  Consider the case: the non-break ticks are `16th, 23th, Feb, 7th, ...`, where `Feb` is in the break
*  range and pruned by breaks, and the break ends might be in lower time unit than day. e.g., break start
*  is `Jan 25th 18:00`(in unit `hour`) and break end is `Feb 6th 18:30` (in unit `minute`). Thus the break
*  label prefers `Jan 25th 18:00` and `Feb 6th 18:30` rather than only `18:00` and `18:30`, otherwise it
*  causes misleading.
*  In this case, the tick of the break start and end will both be:
*      `{level: 1, lowerTimeUnit: 'minute', upperTimeUnit: 'month'}`
*  And get the final template by `generated_dict[lowerTimeUnit][upperTimeUnit][level]`.
*  Note that the time unit can not be calculated directly by a single tick value, since the two breaks have
*  to be at the same time unit to avoid awkward appearance. i.e., `Jan 25th 18:00` is in the time unit "hour"
*  but we need it to be "minute", following `Feb 6th 18:30`.
*/
function parseTimeAxisLabelFormatterDictionary(dictOption) {
	dictOption = dictOption || {};
	var dict = {};
	var canAddHighlight = true;
	each(primaryTimeUnits, function(lowestUnit) {
		canAddHighlight && (canAddHighlight = dictOption[lowestUnit] == null);
	});
	each(primaryTimeUnits, function(lowestUnit, lowestUnitIdx) {
		var upperDictOption = dictOption[lowestUnit];
		dict[lowestUnit] = {};
		var lowerTpl = null;
		for (var upperUnitIdx = lowestUnitIdx; upperUnitIdx >= 0; upperUnitIdx--) {
			var upperUnit = primaryTimeUnits[upperUnitIdx];
			var upperDictItemOption = isObject(upperDictOption) && !isArray(upperDictOption) ? upperDictOption[upperUnit] : upperDictOption;
			var tplArr = void 0;
			if (isArray(upperDictItemOption)) {
				tplArr = upperDictItemOption.slice();
				lowerTpl = tplArr[0] || "";
			} else if (isString(upperDictItemOption)) {
				lowerTpl = upperDictItemOption;
				tplArr = [lowerTpl];
			} else {
				if (lowerTpl == null) lowerTpl = defaultFormatterSeed[lowestUnit];
				else if (!primaryTimeUnitFormatterMatchers[upperUnit].test(lowerTpl)) lowerTpl = dict[upperUnit][upperUnit][0] + " " + lowerTpl;
				tplArr = [lowerTpl];
				if (canAddHighlight) tplArr[1] = "{primary|" + lowerTpl + "}";
			}
			dict[lowestUnit][upperUnit] = tplArr;
		}
	});
	return dict;
}
function pad(str, len$1) {
	str += "";
	return "0000".substr(0, len$1 - str.length) + str;
}
function getPrimaryTimeUnit(timeUnit) {
	switch (timeUnit) {
		case "half-year":
		case "quarter": return "month";
		case "week":
		case "half-week": return "day";
		case "half-day":
		case "quarter-day": return "hour";
		default: return timeUnit;
	}
}
function isPrimaryTimeUnit(timeUnit) {
	return timeUnit === getPrimaryTimeUnit(timeUnit);
}
function getDefaultFormatPrecisionOfInterval(timeUnit) {
	switch (timeUnit) {
		case "year":
		case "month": return "day";
		case "millisecond": return "millisecond";
		default: return "second";
	}
}
function format(time, template, isUTC, lang) {
	var date = parseDate(time);
	var y = date[fullYearGetterName(isUTC)]();
	var M = date[monthGetterName(isUTC)]() + 1;
	var q = Math.floor((M - 1) / 3) + 1;
	var d = date[dateGetterName(isUTC)]();
	var e$1 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
	var H = date[hoursGetterName(isUTC)]();
	var h = (H - 1) % 12 + 1;
	var m$1 = date[minutesGetterName(isUTC)]();
	var s = date[secondsGetterName(isUTC)]();
	var S = date[millisecondsGetterName(isUTC)]();
	var a = H >= 12 ? "pm" : "am";
	var A = a.toUpperCase();
	var timeModel = (lang instanceof Model_default ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel()).getModel("time");
	var month = timeModel.get("month");
	var monthAbbr = timeModel.get("monthAbbr");
	var dayOfWeek = timeModel.get("dayOfWeek");
	var dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
	return (template || "").replace(/{a}/g, a + "").replace(/{A}/g, A + "").replace(/{yyyy}/g, y + "").replace(/{yy}/g, pad(y % 100 + "", 2)).replace(/{Q}/g, q + "").replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + "").replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + "").replace(/{eeee}/g, dayOfWeek[e$1]).replace(/{ee}/g, dayOfWeekAbbr[e$1]).replace(/{e}/g, e$1 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, pad(m$1, 2)).replace(/{m}/g, m$1 + "").replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + "").replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + "");
}
function leveledFormat(tick, idx, formatter, lang, isUTC) {
	var template = null;
	if (isString(formatter)) template = formatter;
	else if (isFunction(formatter)) {
		var extra = {
			time: tick.time,
			level: tick.time.level
		};
		var scaleBreakHelper = getScaleBreakHelper();
		if (scaleBreakHelper) scaleBreakHelper.makeAxisLabelFormatterParamBreak(extra, tick["break"]);
		template = formatter(tick.value, idx, extra);
	} else {
		var tickTime = tick.time;
		if (tickTime) {
			var leveledTplArr = formatter[tickTime.lowerTimeUnit][tickTime.upperTimeUnit];
			template = leveledTplArr[Math.min(tickTime.level, leveledTplArr.length - 1)] || "";
		} else {
			var unit = getUnitFromValue(tick.value, isUTC);
			template = formatter[unit][unit][0];
		}
	}
	return format(new Date(tick.value), template, isUTC, lang);
}
function getUnitFromValue(value, isUTC) {
	var date = parseDate(value);
	var M = date[monthGetterName(isUTC)]() + 1;
	var d = date[dateGetterName(isUTC)]();
	var h = date[hoursGetterName(isUTC)]();
	var m$1 = date[minutesGetterName(isUTC)]();
	var s = date[secondsGetterName(isUTC)]();
	var isSecond = date[millisecondsGetterName(isUTC)]() === 0;
	var isMinute = isSecond && s === 0;
	var isHour = isMinute && m$1 === 0;
	var isDay = isHour && h === 0;
	var isMonth = isDay && d === 1;
	if (isMonth && M === 1) return "year";
	else if (isMonth) return "month";
	else if (isDay) return "day";
	else if (isHour) return "hour";
	else if (isMinute) return "minute";
	else if (isSecond) return "second";
	else return "millisecond";
}
/**
* e.g.,
* If timeUnit is 'year', return the Jan 1st 00:00:00 000 of that year.
* If timeUnit is 'day', return the 00:00:00 000 of that day.
*
* @return The input date.
*/
function roundTime(date, timeUnit, isUTC) {
	switch (timeUnit) {
		case "year": date[monthSetterName(isUTC)](0);
		case "month": date[dateSetterName(isUTC)](1);
		case "day": date[hoursSetterName(isUTC)](0);
		case "hour": date[minutesSetterName(isUTC)](0);
		case "minute": date[secondsSetterName(isUTC)](0);
		case "second": date[millisecondsSetterName(isUTC)](0);
	}
	return date;
}
function fullYearGetterName(isUTC) {
	return isUTC ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(isUTC) {
	return isUTC ? "getUTCMonth" : "getMonth";
}
function dateGetterName(isUTC) {
	return isUTC ? "getUTCDate" : "getDate";
}
function hoursGetterName(isUTC) {
	return isUTC ? "getUTCHours" : "getHours";
}
function minutesGetterName(isUTC) {
	return isUTC ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(isUTC) {
	return isUTC ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(isUTC) {
	return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(isUTC) {
	return isUTC ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(isUTC) {
	return isUTC ? "setUTCMonth" : "setMonth";
}
function dateSetterName(isUTC) {
	return isUTC ? "setUTCDate" : "setDate";
}
function hoursSetterName(isUTC) {
	return isUTC ? "setUTCHours" : "setHours";
}
function minutesSetterName(isUTC) {
	return isUTC ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(isUTC) {
	return isUTC ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(isUTC) {
	return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
}

//#endregion
//#region node_modules/echarts/lib/legacy/getTextRect.js
function getTextRect(text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
	return new Text_default({ style: {
		text,
		font,
		align,
		verticalAlign,
		padding,
		rich,
		overflow: truncate ? "truncate" : null,
		lineHeight
	} }).getBoundingRect();
}

//#endregion
//#region node_modules/echarts/lib/util/format.js
/**
* Add a comma each three digit.
*/
function addCommas(x) {
	if (!isNumeric(x)) return isString(x) ? x : "-";
	var parts = (x + "").split(".");
	return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts.length > 1 ? "." + parts[1] : "");
}
function toCamelCase(str, upperCaseFirst) {
	str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
		return group1.toUpperCase();
	});
	if (upperCaseFirst && str) str = str.charAt(0).toUpperCase() + str.slice(1);
	return str;
}
var normalizeCssArray = normalizeCssArray$1;
/**
* Make value user readable for tooltip and label.
* "User readable":
*     Try to not print programmer-specific text like NaN, Infinity, null, undefined.
*     Avoid to display an empty string, which users can not recognize there is
*     a value and it might look like a bug.
*/
function makeValueReadable(value, valueType, useUTC) {
	var USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
	function stringToUserReadable(str) {
		return str && trim(str) ? str : "-";
	}
	function isNumberUserReadable(num) {
		return !!(num != null && !isNaN(num) && isFinite(num));
	}
	var isTypeTime = valueType === "time";
	var isValueDate = value instanceof Date;
	if (isTypeTime || isValueDate) {
		var date = isTypeTime ? parseDate(value) : value;
		if (!isNaN(+date)) return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
		else if (isValueDate) return "-";
	}
	if (valueType === "ordinal") return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
	var numericResult = numericToNumber(value);
	return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
}
var TPL_VAR_ALIAS = [
	"a",
	"b",
	"c",
	"d",
	"e",
	"f",
	"g"
];
var wrapVar = function(varName, seriesIdx) {
	return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
};
/**
* Template formatter
* @param {Array.<Object>|Object} paramsList
*/
function formatTpl(tpl, paramsList, encode) {
	if (!isArray(paramsList)) paramsList = [paramsList];
	var seriesLen = paramsList.length;
	if (!seriesLen) return "";
	var $vars = paramsList[0].$vars || [];
	for (var i$1 = 0; i$1 < $vars.length; i$1++) {
		var alias = TPL_VAR_ALIAS[i$1];
		tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
	}
	for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) for (var k$1 = 0; k$1 < $vars.length; k$1++) {
		var val = paramsList[seriesIdx][$vars[k$1]];
		tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k$1], seriesIdx), encode ? encodeHTML(val) : val);
	}
	return tpl;
}
/**
* simple Template formatter
*/
function formatTplSimple(tpl, param, encode) {
	each(param, function(value, key$1) {
		tpl = tpl.replace("{" + key$1 + "}", encode ? encodeHTML(value) : value);
	});
	return tpl;
}
function getTooltipMarker(inOpt, extraCssText) {
	var opt = isString(inOpt) ? {
		color: inOpt,
		extraCssText
	} : inOpt || {};
	var color$2 = opt.color;
	var type = opt.type;
	extraCssText = opt.extraCssText;
	var renderMode = opt.renderMode || "html";
	if (!color$2) return "";
	if (renderMode === "html") return type === "subItem" ? "<span style=\"display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:" + encodeHTML(color$2) + ";" + (extraCssText || "") + "\"></span>" : "<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:" + encodeHTML(color$2) + ";" + (extraCssText || "") + "\"></span>";
	else return {
		renderMode,
		content: "{" + (opt.markerId || "markerX") + "|}  ",
		style: type === "subItem" ? {
			width: 4,
			height: 4,
			borderRadius: 2,
			backgroundColor: color$2
		} : {
			width: 10,
			height: 10,
			borderRadius: 5,
			backgroundColor: color$2
		}
	};
}
/**
* @deprecated Use `time/format` instead.
* ISO Date format
* @param {string} tpl
* @param {number} value
* @param {boolean} [isUTC=false] Default in local time.
*           see `module:echarts/scale/Time`
*           and `module:echarts/util/number#parseDate`.
* @inner
*/
function formatTime(tpl, value, isUTC) {
	deprecateReplaceLog("echarts.format.formatTime", "echarts.time.format");
	if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") tpl = "MM-dd\nyyyy";
	var date = parseDate(value);
	var getUTC = isUTC ? "getUTC" : "get";
	var y = date[getUTC + "FullYear"]();
	var M = date[getUTC + "Month"]() + 1;
	var d = date[getUTC + "Date"]();
	var h = date[getUTC + "Hours"]();
	var m$1 = date[getUTC + "Minutes"]();
	var s = date[getUTC + "Seconds"]();
	var S = date[getUTC + "Milliseconds"]();
	tpl = tpl.replace("MM", pad(M, 2)).replace("M", M).replace("yyyy", y).replace("yy", pad(y % 100 + "", 2)).replace("dd", pad(d, 2)).replace("d", d).replace("hh", pad(h, 2)).replace("h", h).replace("mm", pad(m$1, 2)).replace("m", m$1).replace("ss", pad(s, 2)).replace("s", s).replace("SSS", pad(S, 3));
	return tpl;
}
/**
* Capital first
* @param {string} str
* @return {string}
*/
function capitalFirst(str) {
	return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}
/**
* @return Never be null/undefined.
*/
function convertToColorString(color$2, defaultColor) {
	defaultColor = defaultColor || "transparent";
	return isString(color$2) ? color$2 : isObject(color$2) ? color$2.colorStops && (color$2.colorStops[0] || {}).color || defaultColor : defaultColor;
}
/**
* open new tab
* @param link url
* @param target blank or self
*/
function windowOpen(link, target) {
	if (target === "_blank" || target === "blank") {
		var blank = window.open();
		blank.opener = null;
		blank.location.href = link;
	} else window.open(link, target);
}

//#endregion
//#region node_modules/echarts/lib/core/CoordinateSystem.js
/**
* FIXME:
* `nonSeriesBoxCoordSysCreators` and `_nonSeriesBoxMasterList` are hardcoded implementations.
* Regarding "coord sys layout based on another coord sys", currently we only exprimentally support one level
* dpendency, such as, "grid(cartesian)s can be laid out based on matrix/calendar coord sys."
* But a comprehensive implementation may need to support:
*  - Recursive dependencies. e.g., a matrix coord sys lays out based on another matrix coord sys.
*    That requires in the implementation `create` and `update` of coord sys are called by a dependency graph.
*    (@see enableTopologicalTravel in `util/component.ts`)
*/
var nonSeriesBoxCoordSysCreators = {};
var normalCoordSysCreators = {};
var CoordinateSystemManager = function() {
	function CoordinateSystemManager$1() {
		this._normalMasterList = [];
		this._nonSeriesBoxMasterList = [];
	}
	/**
	* Typically,
	*  - in `create`, a coord sys lays out based on a given rect;
	*  - in `update`, update the pixel and data extent of there axes (if any) based on processed `series.data`.
	* After that, a coord sys can serve (typically by `dataToPoint`/`dataToLayout`/`pointToData`).
	* If the coordinate system do not lay out based on `series.data`, `update` is not needed.
	*/
	CoordinateSystemManager$1.prototype.create = function(ecModel, api) {
		this._nonSeriesBoxMasterList = dealCreate(nonSeriesBoxCoordSysCreators, true);
		this._normalMasterList = dealCreate(normalCoordSysCreators, false);
		function dealCreate(creatorMap, canBeNonSeriesBox) {
			var coordinateSystems = [];
			each(creatorMap, function(creator, type) {
				var list = creator.create(ecModel, api);
				coordinateSystems = coordinateSystems.concat(list || []);
				if (canBeNonSeriesBox) each(list, function(master) {
					return assert(!master.update);
				});
			});
			return coordinateSystems;
		}
	};
	/**
	* @see CoordinateSystem['create']
	*/
	CoordinateSystemManager$1.prototype.update = function(ecModel, api) {
		each(this._normalMasterList, function(coordSys) {
			coordSys.update && coordSys.update(ecModel, api);
		});
	};
	CoordinateSystemManager$1.prototype.getCoordinateSystems = function() {
		return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
	};
	CoordinateSystemManager$1.register = function(type, creator) {
		if (type === "matrix" || type === "calendar") {
			nonSeriesBoxCoordSysCreators[type] = creator;
			return;
		}
		normalCoordSysCreators[type] = creator;
	};
	CoordinateSystemManager$1.get = function(type) {
		return normalCoordSysCreators[type] || nonSeriesBoxCoordSysCreators[type];
	};
	return CoordinateSystemManager$1;
}();
function canBeNonSeriesBoxCoordSys(coordSysType) {
	return !!nonSeriesBoxCoordSysCreators[coordSysType];
}
var BoxCoordinateSystemCoordFrom = {
	coord: 1,
	coord2: 2
};
/**
* @see_also `createBoxLayoutReference`
* @see_also `injectCoordSysByOption`
*/
function registerLayOutOnCoordSysUsage(opt) {
	assert(!coordSysUseMap.get(opt.fullType));
	coordSysUseMap.set(opt.fullType, { getCoord2: void 0 }).getCoord2 = opt.getCoord2;
}
var coordSysUseMap = createHashMap();
/**
* @return Be an object, but never be NullUndefined.
*/
function getCoordForBoxCoordSys(model) {
	var coord = model.getShallow("coord", true);
	var from = BoxCoordinateSystemCoordFrom.coord;
	if (coord == null) {
		var store = coordSysUseMap.get(model.type);
		if (store && store.getCoord2) {
			from = BoxCoordinateSystemCoordFrom.coord2;
			coord = store.getCoord2(model);
		}
	}
	return {
		coord,
		from
	};
}
/**
* - "dataCoordSys": each data item is laid out based on a coord sys.
* - "boxCoordSys": the overall bounding rect or anchor point is calculated based on a coord sys.
*   e.g.,
*      grid rect (cartesian rect) is calculate based on matrix/calendar coord sys;
*      pie center is calculated based on calendar/cartesian;
*
* The default value (if not declared in option `coordinateSystemUsage`):
*  For series, use `dataCoordSys`, since this is the most case and backward compatible.
*  For non-series components, use `boxCoordSys`, since `dataCoordSys` is not applicable.
*/
var CoordinateSystemUsageKind = {
	none: 0,
	dataCoordSys: 1,
	boxCoordSys: 2
};
function decideCoordSysUsageKind(model, printError) {
	var coordSysType = model.getShallow("coordinateSystem");
	var coordSysUsageOption = model.getShallow("coordinateSystemUsage", true);
	var isDeclaredExplicitly = coordSysUsageOption != null;
	var kind = CoordinateSystemUsageKind.none;
	if (coordSysType) {
		var isSeries$1 = model.mainType === "series";
		if (coordSysUsageOption == null) coordSysUsageOption = isSeries$1 ? "data" : "box";
		if (coordSysUsageOption === "data") {
			kind = CoordinateSystemUsageKind.dataCoordSys;
			if (!isSeries$1) {
				if (isDeclaredExplicitly && printError) error("coordinateSystemUsage \"data\" is not supported in non-series components.");
				kind = CoordinateSystemUsageKind.none;
			}
		} else if (coordSysUsageOption === "box") {
			kind = CoordinateSystemUsageKind.boxCoordSys;
			if (!isSeries$1 && !canBeNonSeriesBoxCoordSys(coordSysType)) {
				if (isDeclaredExplicitly && printError) error("coordinateSystem \"" + coordSysType + "\" cannot be used" + (" as coordinateSystemUsage \"box\" for \"" + model.type + "\" yet."));
				kind = CoordinateSystemUsageKind.none;
			}
		}
	}
	return {
		coordSysType,
		kind
	};
}
/**
* These cases are considered:
*  (A) Most series can use only "dataCoordSys", but "boxCoordSys" is not applicable:
*    - e.g., series.heatmap, series.line, series.bar, series.scatter, ...
*  (B) Some series and most components can use only "boxCoordSys", but "dataCoordSys" is not applicable:
*    - e.g., series.pie, series.funnel, ...
*    - e.g., grid, polar, geo, title, ...
*  (C) Several series can use both "boxCoordSys" and "dataCoordSys", even at the same time:
*    - e.g., series.graph, series.map
*      - If graph or map series use a "boxCoordSys", it creates a internal "dataCoordSys" to lay out its data.
*      - Graph series can use matrix coord sys as either the "dataCoordSys" (each item layout on one cell)
*        or "boxCoordSys" (the entire series are layout within one cell).
*    - To achieve this effect,
*      `series.coordinateSystemUsage: 'box'` needs to be specified explicitly.
*
* Check these echarts option settings:
*  - If `series: {type: 'bar'}`:
*      dataCoordSys: "cartesian2d", boxCoordSys: "none".
*      (since `coordinateSystem: 'cartesian2d'` is the default option in bar.)
*  - If `grid: {coordinateSystem: 'matrix'}`
*      dataCoordSys: "none", boxCoordSys: "matrix".
*  - If `series: {type: 'pie', coordinateSystem: 'matrix'}`:
*      dataCoordSys: "none", boxCoordSys: "matrix".
*      (since `coordinateSystemUsage: 'box'` is the default option in pie.)
*  - If `series: {type: 'graph', coordinateSystem: 'matrix'}`:
*      dataCoordSys: "matrix", boxCoordSys: "none"
*  - If `series: {type: 'graph', coordinateSystem: 'matrix', coordinateSystemUsage: 'box'}`:
*      dataCoordSys: "an internal view", boxCoordSys: "the internal view is laid out on a matrix"
*  - If `series: {type: 'map'}`:
*      dataCoordSys: "a internal geo", boxCoordSys: "none"
*  - If `series: {type: 'map', coordinateSystem: 'geo', geoIndex: 0}`:
*      dataCoordSys: "a geo", boxCoordSys: "none"
*  - If `series: {type: 'map', coordinateSystem: 'matrix'}`:
*      not_applicable
*  - If `series: {type: 'map', coordinateSystem: 'matrix', coordinateSystemUsage: 'box'}`:
*      dataCoordSys: "an internal geo", boxCoordSys: "the internal geo is laid out on a matrix"
*
* @usage
* For case (A) & (B),
*  call `injectCoordSysByOption({coordSysType: 'aaa', ...})` once for each series/components.
* For case (C),
*  call `injectCoordSysByOption({coordSysType: 'aaa', ...})` once for each series/components,
*  and then call `injectCoordSysByOption({coordSysType: 'bbb', ..., isDefaultDataCoordSys: true})`
*  once for each series/components.
*
* @return Whether injected.
*/
function injectCoordSysByOption(opt) {
	var targetModel = opt.targetModel, coordSysType = opt.coordSysType, coordSysProvider = opt.coordSysProvider, isDefaultDataCoordSys = opt.isDefaultDataCoordSys, allowNotFound = opt.allowNotFound;
	assert(!!coordSysType);
	var _a$1 = decideCoordSysUsageKind(targetModel, true), kind = _a$1.kind, declaredType = _a$1.coordSysType;
	if (isDefaultDataCoordSys && kind !== CoordinateSystemUsageKind.dataCoordSys) {
		kind = CoordinateSystemUsageKind.dataCoordSys;
		declaredType = coordSysType;
	}
	if (kind === CoordinateSystemUsageKind.none || declaredType !== coordSysType) return false;
	var coordSys = coordSysProvider(coordSysType, targetModel);
	if (!coordSys) {
		if (!allowNotFound) error(coordSysType + " cannot be found for" + (" " + targetModel.type + " (index: " + targetModel.componentIndex + ")."));
		return false;
	}
	if (kind === CoordinateSystemUsageKind.dataCoordSys) {
		assert(targetModel.mainType === "series");
		targetModel.coordinateSystem = coordSys;
	} else targetModel.boxCoordinateSystem = coordSys;
	return true;
}
var simpleCoordSysInjectionProvider = function(coordSysType, injectTargetModel) {
	var coordSysModel = injectTargetModel.getReferringComponents(coordSysType, SINGLE_REFERRING).models[0];
	return coordSysModel && coordSysModel.coordinateSystem;
};
var CoordinateSystem_default = CoordinateSystemManager;

//#endregion
//#region node_modules/echarts/lib/util/layout.js
var each$15 = each;
/**
* @public
*/
var LOCATION_PARAMS = [
	"left",
	"right",
	"top",
	"bottom",
	"width",
	"height"
];
/**
* @public
*/
var HV_NAMES = [[
	"width",
	"left",
	"right"
], [
	"height",
	"top",
	"bottom"
]];
function boxLayout(orient, group, gap, maxWidth, maxHeight) {
	var x = 0;
	var y = 0;
	if (maxWidth == null) maxWidth = Infinity;
	if (maxHeight == null) maxHeight = Infinity;
	var currentLineMaxSize = 0;
	group.eachChild(function(child, idx) {
		var rect = child.getBoundingRect();
		var nextChild = group.childAt(idx + 1);
		var nextChildRect = nextChild && nextChild.getBoundingRect();
		var nextX;
		var nextY;
		if (orient === "horizontal") {
			var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
			nextX = x + moveX;
			if (nextX > maxWidth || child.newline) {
				x = 0;
				nextX = moveX;
				y += currentLineMaxSize + gap;
				currentLineMaxSize = rect.height;
			} else currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
		} else {
			var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
			nextY = y + moveY;
			if (nextY > maxHeight || child.newline) {
				x += currentLineMaxSize + gap;
				y = 0;
				nextY = moveY;
				currentLineMaxSize = rect.width;
			} else currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
		}
		if (child.newline) return;
		child.x = x;
		child.y = y;
		child.markRedraw();
		orient === "horizontal" ? x = nextX + gap : y = nextY + gap;
	});
}
/**
* VBox or HBox layouting
* @param {string} orient
* @param {module:zrender/graphic/Group} group
* @param {number} gap
* @param {number} [width=Infinity]
* @param {number} [height=Infinity]
*/
var box = boxLayout;
/**
* VBox layouting
* @param {module:zrender/graphic/Group} group
* @param {number} gap
* @param {number} [width=Infinity]
* @param {number} [height=Infinity]
*/
var vbox = curry(boxLayout, "vertical");
/**
* HBox layouting
* @param {module:zrender/graphic/Group} group
* @param {number} gap
* @param {number} [width=Infinity]
* @param {number} [height=Infinity]
*/
var hbox = curry(boxLayout, "horizontal");
function getBoxLayoutParams(boxLayoutModel, ignoreParent) {
	return {
		left: boxLayoutModel.getShallow("left", ignoreParent),
		top: boxLayoutModel.getShallow("top", ignoreParent),
		right: boxLayoutModel.getShallow("right", ignoreParent),
		bottom: boxLayoutModel.getShallow("bottom", ignoreParent),
		width: boxLayoutModel.getShallow("width", ignoreParent),
		height: boxLayoutModel.getShallow("height", ignoreParent)
	};
}
function getViewRectAndCenterForCircleLayout(seriesModel, api) {
	var layoutRef = createBoxLayoutReference(seriesModel, api, { enableLayoutOnlyByCenter: true });
	var boxLayoutParams = seriesModel.getBoxLayoutParams();
	var viewRect$1;
	var center$2;
	if (layoutRef.type === BoxLayoutReferenceType.point) {
		center$2 = layoutRef.refPoint;
		viewRect$1 = getLayoutRect(boxLayoutParams, {
			width: api.getWidth(),
			height: api.getHeight()
		});
	} else {
		var centerOption = seriesModel.get("center");
		var centerOptionArr = isArray(centerOption) ? centerOption : [centerOption, centerOption];
		viewRect$1 = getLayoutRect(boxLayoutParams, layoutRef.refContainer);
		center$2 = layoutRef.boxCoordFrom === BoxCoordinateSystemCoordFrom.coord2 ? layoutRef.refPoint : [parsePercent$1(centerOptionArr[0], viewRect$1.width) + viewRect$1.x, parsePercent$1(centerOptionArr[1], viewRect$1.height) + viewRect$1.y];
	}
	return {
		viewRect: viewRect$1,
		center: center$2
	};
}
function getCircleLayout(seriesModel, api) {
	var _a$1 = getViewRectAndCenterForCircleLayout(seriesModel, api), viewRect$1 = _a$1.viewRect, center$2 = _a$1.center;
	var radius = seriesModel.get("radius");
	if (!isArray(radius)) radius = [0, radius];
	var width = parsePercent$1(viewRect$1.width, api.getWidth());
	var height = parsePercent$1(viewRect$1.height, api.getHeight());
	var size = Math.min(width, height);
	var r0 = parsePercent$1(radius[0], size / 2);
	var r = parsePercent$1(radius[1], size / 2);
	return {
		cx: center$2[0],
		cy: center$2[1],
		r0,
		r,
		viewRect: viewRect$1
	};
}
/**
* Parse position info.
*/
function getLayoutRect(positionInfo, containerRect, margin) {
	margin = normalizeCssArray(margin || 0);
	var containerWidth = containerRect.width;
	var containerHeight = containerRect.height;
	var left = parsePercent$1(positionInfo.left, containerWidth);
	var top = parsePercent$1(positionInfo.top, containerHeight);
	var right = parsePercent$1(positionInfo.right, containerWidth);
	var bottom = parsePercent$1(positionInfo.bottom, containerHeight);
	var width = parsePercent$1(positionInfo.width, containerWidth);
	var height = parsePercent$1(positionInfo.height, containerHeight);
	var verticalMargin = margin[2] + margin[0];
	var horizontalMargin = margin[1] + margin[3];
	var aspect = positionInfo.aspect;
	if (isNaN(width)) width = containerWidth - right - horizontalMargin - left;
	if (isNaN(height)) height = containerHeight - bottom - verticalMargin - top;
	if (aspect != null) {
		if (isNaN(width) && isNaN(height)) if (aspect > containerWidth / containerHeight) width = containerWidth * .8;
		else height = containerHeight * .8;
		if (isNaN(width)) width = aspect * height;
		if (isNaN(height)) height = width / aspect;
	}
	if (isNaN(left)) left = containerWidth - right - width - horizontalMargin;
	if (isNaN(top)) top = containerHeight - bottom - height - verticalMargin;
	switch (positionInfo.left || positionInfo.right) {
		case "center":
			left = containerWidth / 2 - width / 2 - margin[3];
			break;
		case "right":
			left = containerWidth - width - horizontalMargin;
			break;
	}
	switch (positionInfo.top || positionInfo.bottom) {
		case "middle":
		case "center":
			top = containerHeight / 2 - height / 2 - margin[0];
			break;
		case "bottom":
			top = containerHeight - height - verticalMargin;
			break;
	}
	left = left || 0;
	top = top || 0;
	if (isNaN(width)) width = containerWidth - horizontalMargin - left - (right || 0);
	if (isNaN(height)) height = containerHeight - verticalMargin - top - (bottom || 0);
	var rect = new BoundingRect_default((containerRect.x || 0) + left + margin[3], (containerRect.y || 0) + top + margin[0], width, height);
	rect.margin = margin;
	return rect;
}
/**
* PENDING:
*  when preserveAspect: 'cover' and aspect is near Infinity
*  or when preserveAspect: 'contain' and aspect is near 0,
*  the result width or height is near Inifity. It's logically correct,
*  Therefore currently we do not handle it, until bad cases arise.
*/
function applyPreserveAspect(component, layoutRect, aspect) {
	var preserveAspect = component.getShallow("preserveAspect", true);
	if (!preserveAspect) return layoutRect;
	var actualAspect = layoutRect.width / layoutRect.height;
	if (Math.abs(Math.atan(aspect) - Math.atan(actualAspect)) < 1e-9) return layoutRect;
	var preserveAspectAlign = component.getShallow("preserveAspectAlign", true);
	var preserveAspectVerticalAlign = component.getShallow("preserveAspectVerticalAlign", true);
	var layoutOptInner = {
		width: layoutRect.width,
		height: layoutRect.height
	};
	var isCover = preserveAspect === "cover";
	if (actualAspect > aspect && !isCover || actualAspect < aspect && isCover) {
		layoutOptInner.width = layoutRect.height * aspect;
		preserveAspectAlign === "left" ? layoutOptInner.left = 0 : preserveAspectAlign === "right" ? layoutOptInner.right = 0 : layoutOptInner.left = "center";
	} else {
		layoutOptInner.height = layoutRect.width / aspect;
		preserveAspectVerticalAlign === "top" ? layoutOptInner.top = 0 : preserveAspectVerticalAlign === "bottom" ? layoutOptInner.bottom = 0 : layoutOptInner.top = "middle";
	}
	return getLayoutRect(layoutOptInner, layoutRect);
}
var BoxLayoutReferenceType = {
	rect: 1,
	point: 2
};
/**
* Uniformly calculate layout reference (rect or center) based on either:
*  - viewport:
*      - Get `refContainer` as `{x: 0, y: 0, width: api.getWidth(), height: api.getHeight()}`
*  - coordinate system, which can serve in several ways:
*      - Use `dataToPoint` to get the `refPoint`, such as, in cartesian2d coord sys.
*      - Use `dataToLayout` to get the `refContainer`, such as, in matrix coord sys.
*/
function createBoxLayoutReference(model, api, opt) {
	var refContainer;
	var refPoint;
	var layoutRefType;
	var boxCoordSys = model.boxCoordinateSystem;
	var boxCoordFrom;
	if (boxCoordSys) {
		var _a$1 = getCoordForBoxCoordSys(model), coord = _a$1.coord, from = _a$1.from;
		if (boxCoordSys.dataToLayout) {
			layoutRefType = BoxLayoutReferenceType.rect;
			boxCoordFrom = from;
			var result = boxCoordSys.dataToLayout(coord);
			refContainer = result.contentRect || result.rect;
		} else if (opt && opt.enableLayoutOnlyByCenter && boxCoordSys.dataToPoint) {
			layoutRefType = BoxLayoutReferenceType.point;
			boxCoordFrom = from;
			refPoint = boxCoordSys.dataToPoint(coord);
		} else error(model.type + "[" + model.componentIndex + "]" + (" layout based on " + boxCoordSys.type + " is not supported."));
	}
	if (layoutRefType == null) layoutRefType = BoxLayoutReferenceType.rect;
	if (layoutRefType === BoxLayoutReferenceType.rect) {
		if (!refContainer) refContainer = {
			x: 0,
			y: 0,
			width: api.getWidth(),
			height: api.getHeight()
		};
		refPoint = [refContainer.x + refContainer.width / 2, refContainer.y + refContainer.height / 2];
	}
	return {
		type: layoutRefType,
		refContainer,
		refPoint,
		boxCoordFrom
	};
}
/**
* Position a zr element in viewport
*  Group position is specified by either
*  {left, top}, {right, bottom}
*  If all properties exists, right and bottom will be igonred.
*
* Logic:
*     1. Scale (against origin point in parent coord)
*     2. Rotate (against origin point in parent coord)
*     3. Translate (with el.position by this method)
* So this method only fixes the last step 'Translate', which does not affect
* scaling and rotating.
*
* If be called repeatedly with the same input el, the same result will be gotten.
*
* Return true if the layout happened.
*
* @param el Should have `getBoundingRect` method.
* @param positionInfo
* @param positionInfo.left
* @param positionInfo.top
* @param positionInfo.right
* @param positionInfo.bottom
* @param positionInfo.width Only for opt.boundingModel: 'raw'
* @param positionInfo.height Only for opt.boundingModel: 'raw'
* @param containerRect
* @param margin
* @param opt
* @param opt.hv Only horizontal or only vertical. Default to be [1, 1]
* @param opt.boundingMode
*        Specify how to calculate boundingRect when locating.
*        'all': Position the boundingRect that is transformed and uioned
*               both itself and its descendants.
*               This mode simplies confine the elements in the bounding
*               of their container (e.g., using 'right: 0').
*        'raw': Position the boundingRect that is not transformed and only itself.
*               This mode is useful when you want a element can overflow its
*               container. (Consider a rotated circle needs to be located in a corner.)
*               In this mode positionInfo.width/height can only be number.
*/
function positionElement(el, positionInfo, containerRect, margin, opt, out$1) {
	var h = !opt || !opt.hv || opt.hv[0];
	var v = !opt || !opt.hv || opt.hv[1];
	var boundingMode = opt && opt.boundingMode || "all";
	out$1 = out$1 || el;
	out$1.x = el.x;
	out$1.y = el.y;
	if (!h && !v) return false;
	var rect;
	if (boundingMode === "raw") rect = el.type === "group" ? new BoundingRect_default(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
	else {
		rect = el.getBoundingRect();
		if (el.needLocalTransform()) {
			var transform = el.getLocalTransform();
			rect = rect.clone();
			rect.applyTransform(transform);
		}
	}
	var layoutRect = getLayoutRect(defaults({
		width: rect.width,
		height: rect.height
	}, positionInfo), containerRect, margin);
	var dx = h ? layoutRect.x - rect.x : 0;
	var dy = v ? layoutRect.y - rect.y : 0;
	if (boundingMode === "raw") {
		out$1.x = dx;
		out$1.y = dy;
	} else {
		out$1.x += dx;
		out$1.y += dy;
	}
	if (out$1 === el) el.markRedraw();
	return true;
}
/**
* @param option Contains some of the properties in HV_NAMES.
* @param hvIdx 0: horizontal; 1: vertical.
*/
function sizeCalculable(option, hvIdx) {
	return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
function fetchLayoutMode(ins) {
	var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
	return isObject(layoutMode) ? layoutMode : layoutMode ? { type: layoutMode } : null;
}
/**
* Consider Case:
* When default option has {left: 0, width: 100}, and we set {right: 0}
* through setOption or media query, using normal zrUtil.merge will cause
* {right: 0} does not take effect.
*
* @example
* ComponentModel.extend({
*     init: function () {
*         ...
*         let inputPositionParams = layout.getLayoutParams(option);
*         this.mergeOption(inputPositionParams);
*     },
*     mergeOption: function (newOption) {
*         newOption && zrUtil.merge(thisOption, newOption, true);
*         layout.mergeLayoutParam(thisOption, newOption);
*     }
* });
*
* @param targetOption
* @param newOption
* @param opt
*/
function mergeLayoutParam(targetOption, newOption, opt) {
	var ignoreSize = opt && opt.ignoreSize;
	!isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
	var hResult = merge$1(HV_NAMES[0], 0);
	var vResult = merge$1(HV_NAMES[1], 1);
	copy$2(HV_NAMES[0], targetOption, hResult);
	copy$2(HV_NAMES[1], targetOption, vResult);
	function merge$1(names, hvIdx) {
		var newParams = {};
		var newValueCount = 0;
		var merged = {};
		var mergedValueCount = 0;
		var enoughParamNumber = 2;
		each$15(names, function(name) {
			merged[name] = targetOption[name];
		});
		each$15(names, function(name) {
			hasOwn(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
			hasValue(newParams, name) && newValueCount++;
			hasValue(merged, name) && mergedValueCount++;
		});
		if (ignoreSize[hvIdx]) {
			if (hasValue(newOption, names[1])) merged[names[2]] = null;
			else if (hasValue(newOption, names[2])) merged[names[1]] = null;
			return merged;
		}
		if (mergedValueCount === enoughParamNumber || !newValueCount) return merged;
		else if (newValueCount >= enoughParamNumber) return newParams;
		else {
			for (var i$1 = 0; i$1 < names.length; i$1++) {
				var name_1 = names[i$1];
				if (!hasOwn(newParams, name_1) && hasOwn(targetOption, name_1)) {
					newParams[name_1] = targetOption[name_1];
					break;
				}
			}
			return newParams;
		}
	}
	function hasValue(obj, name) {
		return obj[name] != null && obj[name] !== "auto";
	}
	function copy$2(names, target, source) {
		each$15(names, function(name) {
			target[name] = source[name];
		});
	}
}
/**
* Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
*/
function getLayoutParams(source) {
	return copyLayoutParams({}, source);
}
/**
* Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
* @param {Object} source
* @return {Object} Result contains those props.
*/
function copyLayoutParams(target, source) {
	source && target && each$15(LOCATION_PARAMS, function(name) {
		hasOwn(source, name) && (target[name] = source[name]);
	});
	return target;
}

//#endregion
//#region node_modules/echarts/lib/model/Component.js
var inner$23 = makeInner();
var ComponentModel = function(_super) {
	__extends(ComponentModel$1, _super);
	function ComponentModel$1(option, parentModel, ecModel) {
		var _this = _super.call(this, option, parentModel, ecModel) || this;
		_this.uid = getUID("ec_cpt_model");
		return _this;
	}
	ComponentModel$1.prototype.init = function(option, parentModel, ecModel) {
		this.mergeDefaultAndTheme(option, ecModel);
	};
	ComponentModel$1.prototype.mergeDefaultAndTheme = function(option, ecModel) {
		var layoutMode = fetchLayoutMode(this);
		var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
		var themeModel = ecModel.getTheme();
		merge(option, themeModel.get(this.mainType));
		merge(option, this.getDefaultOption());
		if (layoutMode) mergeLayoutParam(option, inputPositionParams, layoutMode);
	};
	ComponentModel$1.prototype.mergeOption = function(option, ecModel) {
		merge(this.option, option, true);
		var layoutMode = fetchLayoutMode(this);
		if (layoutMode) mergeLayoutParam(this.option, option, layoutMode);
	};
	/**
	* Called immediately after `init` or `mergeOption` of this instance called.
	*/
	ComponentModel$1.prototype.optionUpdated = function(newCptOption, isInit) {};
	/**
	* [How to declare defaultOption]:
	*
	* (A) If using class declaration in typescript (since echarts 5):
	* ```ts
	* import {ComponentOption} from '../model/option.js';
	* export interface XxxOption extends ComponentOption {
	*     aaa: number
	* }
	* export class XxxModel extends Component {
	*     static type = 'xxx';
	*     static defaultOption: XxxOption = {
	*         aaa: 123
	*     }
	* }
	* Component.registerClass(XxxModel);
	* ```
	* ```ts
	* import {inheritDefaultOption} from '../util/component.js';
	* import {XxxModel, XxxOption} from './XxxModel.js';
	* export interface XxxSubOption extends XxxOption {
	*     bbb: number
	* }
	* class XxxSubModel extends XxxModel {
	*     static defaultOption: XxxSubOption = inheritDefaultOption(XxxModel.defaultOption, {
	*         bbb: 456
	*     })
	*     fn() {
	*         let opt = this.getDefaultOption();
	*         // opt is {aaa: 123, bbb: 456}
	*     }
	* }
	* ```
	*
	* (B) If using class extend (previous approach in echarts 3 & 4):
	* ```js
	* let XxxComponent = Component.extend({
	*     defaultOption: {
	*         xx: 123
	*     }
	* })
	* ```
	* ```js
	* let XxxSubComponent = XxxComponent.extend({
	*     defaultOption: {
	*         yy: 456
	*     },
	*     fn: function () {
	*         let opt = this.getDefaultOption();
	*         // opt is {xx: 123, yy: 456}
	*     }
	* })
	* ```
	*/
	ComponentModel$1.prototype.getDefaultOption = function() {
		var ctor = this.constructor;
		if (!isExtendedClass(ctor)) return ctor.defaultOption;
		var fields = inner$23(this);
		if (!fields.defaultOption) {
			var optList = [];
			var clz = ctor;
			while (clz) {
				var opt = clz.prototype.defaultOption;
				opt && optList.push(opt);
				clz = clz.superClass;
			}
			var defaultOption$2 = {};
			for (var i$1 = optList.length - 1; i$1 >= 0; i$1--) defaultOption$2 = merge(defaultOption$2, optList[i$1], true);
			fields.defaultOption = defaultOption$2;
		}
		return fields.defaultOption;
	};
	/**
	* Notice: always force to input param `useDefault` in case that forget to consider it.
	* The same behavior as `modelUtil.parseFinder`.
	*
	* @param useDefault In many cases like series refer axis and axis refer grid,
	*        If axis index / axis id not specified, use the first target as default.
	*        In other cases like dataZoom refer axis, if not specified, measn no refer.
	*/
	ComponentModel$1.prototype.getReferringComponents = function(mainType, opt) {
		var indexKey = mainType + "Index";
		var idKey = mainType + "Id";
		return queryReferringComponents(this.ecModel, mainType, {
			index: this.get(indexKey, true),
			id: this.get(idKey, true)
		}, opt);
	};
	ComponentModel$1.prototype.getBoxLayoutParams = function() {
		return getBoxLayoutParams(this, false);
	};
	/**
	* Get key for zlevel.
	* If developers don't configure zlevel. We will assign zlevel to series based on the key.
	* For example, lines with trail effect and progressive series will in an individual zlevel.
	*/
	ComponentModel$1.prototype.getZLevelKey = function() {
		return "";
	};
	ComponentModel$1.prototype.setZLevel = function(zlevel) {
		this.option.zlevel = zlevel;
	};
	ComponentModel$1.protoInitialize = function() {
		var proto = ComponentModel$1.prototype;
		proto.type = "component";
		proto.id = "";
		proto.name = "";
		proto.mainType = "";
		proto.subType = "";
		proto.componentIndex = 0;
	}();
	return ComponentModel$1;
}(Model_default);
mountExtend(ComponentModel, Model_default);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(componentType) {
	var deps = [];
	each(ComponentModel.getClassesByMainType(componentType), function(clz) {
		deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
	});
	deps = map(deps, function(type) {
		return parseClassType(type).main;
	});
	if (componentType !== "dataset" && indexOf(deps, "dataset") <= 0) deps.unshift("dataset");
	return deps;
}
var Component_default = ComponentModel;

//#endregion
//#region node_modules/echarts/lib/visual/tokens.js
var tokens = {
	color: {},
	darkColor: {},
	size: {}
};
var color$1 = tokens.color = {
	theme: [
		"#5070dd",
		"#b6d634",
		"#505372",
		"#ff994d",
		"#0ca8df",
		"#ffd10a",
		"#fb628b",
		"#785db0",
		"#3fbe95"
	],
	neutral00: "#fff",
	neutral05: "#f4f7fd",
	neutral10: "#e8ebf0",
	neutral15: "#dbdee4",
	neutral20: "#cfd2d7",
	neutral25: "#c3c5cb",
	neutral30: "#b7b9be",
	neutral35: "#aaacb2",
	neutral40: "#9ea0a5",
	neutral45: "#929399",
	neutral50: "#86878c",
	neutral55: "#797b7f",
	neutral60: "#6d6e73",
	neutral65: "#616266",
	neutral70: "#54555a",
	neutral75: "#48494d",
	neutral80: "#3c3c41",
	neutral85: "#303034",
	neutral90: "#232328",
	neutral95: "#17171b",
	neutral99: "#000",
	accent05: "#eff1f9",
	accent10: "#e0e4f2",
	accent15: "#d0d6ec",
	accent20: "#c0c9e6",
	accent25: "#b1bbdf",
	accent30: "#a1aed9",
	accent35: "#91a0d3",
	accent40: "#8292cc",
	accent45: "#7285c6",
	accent50: "#6578ba",
	accent55: "#5c6da9",
	accent60: "#536298",
	accent65: "#4a5787",
	accent70: "#404c76",
	accent75: "#374165",
	accent80: "#2e3654",
	accent85: "#252b43",
	accent90: "#1b2032",
	accent95: "#121521",
	transparent: "rgba(0,0,0,0)",
	highlight: "rgba(255,231,130,0.8)"
};
extend(color$1, {
	primary: color$1.neutral80,
	secondary: color$1.neutral70,
	tertiary: color$1.neutral60,
	quaternary: color$1.neutral50,
	disabled: color$1.neutral20,
	border: color$1.neutral30,
	borderTint: color$1.neutral20,
	borderShade: color$1.neutral40,
	background: color$1.neutral05,
	backgroundTint: "rgba(234,237,245,0.5)",
	backgroundTransparent: "rgba(255,255,255,0)",
	backgroundShade: color$1.neutral10,
	shadow: "rgba(0,0,0,0.2)",
	shadowTint: "rgba(129,130,136,0.2)",
	axisLine: color$1.neutral70,
	axisLineTint: color$1.neutral40,
	axisTick: color$1.neutral70,
	axisTickMinor: color$1.neutral60,
	axisLabel: color$1.neutral70,
	axisSplitLine: color$1.neutral15,
	axisMinorSplitLine: color$1.neutral05
});
for (var key in color$1) if (color$1.hasOwnProperty(key)) {
	var hex = color$1[key];
	if (key === "theme") tokens.darkColor.theme = color$1.theme.slice();
	else if (key === "highlight") tokens.darkColor.highlight = "rgba(255,231,130,0.4)";
	else if (key.indexOf("accent") === 0) tokens.darkColor[key] = modifyHSL(hex, null, function(s) {
		return s * .5;
	}, function(l) {
		return Math.min(1, 1.3 - l);
	});
	else tokens.darkColor[key] = modifyHSL(hex, null, function(s) {
		return s * .9;
	}, function(l) {
		return 1 - Math.pow(l, 1.5);
	});
}
tokens.size = {
	xxs: 2,
	xs: 5,
	s: 10,
	m: 15,
	l: 20,
	xl: 30,
	xxl: 40,
	xxxl: 50
};
var tokens_default = tokens;

//#endregion
//#region node_modules/echarts/lib/model/globalDefault.js
var platform = "";
if (typeof navigator !== "undefined") platform = navigator.platform || "";
var decalColor = "rgba(0, 0, 0, 0.2)";
var themeColor = tokens_default.color.theme[0];
var lightThemeColor = modifyHSL(themeColor, null, null, .9);
var globalDefault_default = {
	darkMode: "auto",
	colorBy: "series",
	color: tokens_default.color.theme,
	gradientColor: [lightThemeColor, themeColor],
	aria: { decal: { decals: [
		{
			color: decalColor,
			dashArrayX: [1, 0],
			dashArrayY: [2, 5],
			symbolSize: 1,
			rotation: Math.PI / 6
		},
		{
			color: decalColor,
			symbol: "circle",
			dashArrayX: [[8, 8], [
				0,
				8,
				8,
				0
			]],
			dashArrayY: [6, 0],
			symbolSize: .8
		},
		{
			color: decalColor,
			dashArrayX: [1, 0],
			dashArrayY: [4, 3],
			rotation: -Math.PI / 4
		},
		{
			color: decalColor,
			dashArrayX: [[6, 6], [
				0,
				6,
				6,
				0
			]],
			dashArrayY: [6, 0]
		},
		{
			color: decalColor,
			dashArrayX: [[1, 0], [1, 6]],
			dashArrayY: [
				1,
				0,
				6,
				0
			],
			rotation: Math.PI / 4
		},
		{
			color: decalColor,
			symbol: "triangle",
			dashArrayX: [[9, 9], [
				0,
				9,
				9,
				0
			]],
			dashArrayY: [7, 2],
			symbolSize: .75
		}
	] } },
	textStyle: {
		fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
		fontSize: 12,
		fontStyle: "normal",
		fontWeight: "normal"
	},
	blendMode: null,
	stateAnimation: {
		duration: 300,
		easing: "cubicOut"
	},
	animation: "auto",
	animationDuration: 1e3,
	animationDurationUpdate: 500,
	animationEasing: "cubicInOut",
	animationEasingUpdate: "cubicInOut",
	animationThreshold: 2e3,
	progressiveThreshold: 3e3,
	progressive: 400,
	hoverLayerThreshold: 3e3,
	useUTC: false
};

//#endregion
//#region node_modules/echarts/lib/util/types.js
var VISUAL_DIMENSIONS = createHashMap([
	"tooltip",
	"label",
	"itemName",
	"itemId",
	"itemGroupId",
	"itemChildGroupId",
	"seriesName"
]);
var SOURCE_FORMAT_ORIGINAL = "original";
var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
var SOURCE_FORMAT_UNKNOWN = "unknown";
var SERIES_LAYOUT_BY_COLUMN = "column";
var SERIES_LAYOUT_BY_ROW = "row";

//#endregion
//#region node_modules/echarts/lib/data/helper/sourceHelper.js
var BE_ORDINAL = {
	Must: 1,
	Might: 2,
	Not: 3
};
var innerGlobalModel = makeInner();
/**
* MUST be called before mergeOption of all series.
*/
function resetSourceDefaulter(ecModel) {
	innerGlobalModel(ecModel).datasetMap = createHashMap();
}
/**
* [The strategy of the arrengment of data dimensions for dataset]:
* "value way": all axes are non-category axes. So series one by one take
*     several (the number is coordSysDims.length) dimensions from dataset.
*     The result of data arrengment of data dimensions like:
*     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |
* "category way": at least one axis is category axis. So the the first data
*     dimension is always mapped to the first category axis and shared by
*     all of the series. The other data dimensions are taken by series like
*     "value way" does.
*     The result of data arrengment of data dimensions like:
*     | ser_shared_x | ser0_y | ser1_y | ser2_y |
*
* @return encode Never be `null/undefined`.
*/
function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
	var encode = {};
	var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
	if (!datasetModel || !coordDimensions) return encode;
	var encodeItemName = [];
	var encodeSeriesName = [];
	var ecModel = seriesModel.ecModel;
	var datasetMap = innerGlobalModel(ecModel).datasetMap;
	var key$1 = datasetModel.uid + "_" + source.seriesLayoutBy;
	var baseCategoryDimIndex;
	var categoryWayValueDimStart;
	coordDimensions = coordDimensions.slice();
	each(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
		var coordDimInfo = isObject(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = { name: coordDimInfoLoose };
		if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
			baseCategoryDimIndex = coordDimIdx;
			categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
		}
		encode[coordDimInfo.name] = [];
	});
	var datasetRecord = datasetMap.get(key$1) || datasetMap.set(key$1, {
		categoryWayDim: categoryWayValueDimStart,
		valueWayDim: 0
	});
	each(coordDimensions, function(coordDimInfo, coordDimIdx) {
		var coordDimName = coordDimInfo.name;
		var count$1 = getDataDimCountOnCoordDim(coordDimInfo);
		if (baseCategoryDimIndex == null) {
			var start$1 = datasetRecord.valueWayDim;
			pushDim(encode[coordDimName], start$1, count$1);
			pushDim(encodeSeriesName, start$1, count$1);
			datasetRecord.valueWayDim += count$1;
		} else if (baseCategoryDimIndex === coordDimIdx) {
			pushDim(encode[coordDimName], 0, count$1);
			pushDim(encodeItemName, 0, count$1);
		} else {
			var start$1 = datasetRecord.categoryWayDim;
			pushDim(encode[coordDimName], start$1, count$1);
			pushDim(encodeSeriesName, start$1, count$1);
			datasetRecord.categoryWayDim += count$1;
		}
	});
	function pushDim(dimIdxArr, idxFrom, idxCount) {
		for (var i$1 = 0; i$1 < idxCount; i$1++) dimIdxArr.push(idxFrom + i$1);
	}
	function getDataDimCountOnCoordDim(coordDimInfo) {
		var dimsDef = coordDimInfo.dimsDef;
		return dimsDef ? dimsDef.length : 1;
	}
	encodeItemName.length && (encode.itemName = encodeItemName);
	encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
	return encode;
}
/**
* Work for data like [{name: ..., value: ...}, ...].
*
* @return encode Never be `null/undefined`.
*/
function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
	var encode = {};
	if (!querySeriesUpstreamDatasetModel(seriesModel)) return encode;
	var sourceFormat = source.sourceFormat;
	var dimensionsDefine = source.dimensionsDefine;
	var potentialNameDimIndex;
	if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) each(dimensionsDefine, function(dim, idx) {
		if ((isObject(dim) ? dim.name : dim) === "name") potentialNameDimIndex = idx;
	});
	var idxResult = function() {
		var idxRes0 = {};
		var idxRes1 = {};
		var guessRecords = [];
		for (var i$1 = 0, len$1 = Math.min(5, dimCount); i$1 < len$1; i$1++) {
			var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i$1);
			guessRecords.push(guessResult);
			var isPureNumber = guessResult === BE_ORDINAL.Not;
			if (isPureNumber && idxRes0.v == null && i$1 !== potentialNameDimIndex) idxRes0.v = i$1;
			if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) idxRes0.n = i$1;
			if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) return idxRes0;
			if (!isPureNumber) {
				if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i$1 !== potentialNameDimIndex) idxRes1.v = i$1;
				if (idxRes1.n == null || idxRes1.n === idxRes1.v) idxRes1.n = i$1;
			}
		}
		function fulfilled(idxResult$1) {
			return idxResult$1.v != null && idxResult$1.n != null;
		}
		return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
	}();
	if (idxResult) {
		encode.value = [idxResult.v];
		var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
		encode.itemName = [nameDimIndex];
		encode.seriesName = [nameDimIndex];
	}
	return encode;
}
/**
* @return If return null/undefined, indicate that should not use datasetModel.
*/
function querySeriesUpstreamDatasetModel(seriesModel) {
	if (!seriesModel.get("data", true)) return queryReferringComponents(seriesModel.ecModel, "dataset", {
		index: seriesModel.get("datasetIndex", true),
		id: seriesModel.get("datasetId", true)
	}, SINGLE_REFERRING).models[0];
}
/**
* @return Always return an array event empty.
*/
function queryDatasetUpstreamDatasetModels(datasetModel) {
	if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) return [];
	return queryReferringComponents(datasetModel.ecModel, "dataset", {
		index: datasetModel.get("fromDatasetIndex", true),
		id: datasetModel.get("fromDatasetId", true)
	}, SINGLE_REFERRING).models;
}
/**
* The rule should not be complex, otherwise user might not
* be able to known where the data is wrong.
* The code is ugly, but how to make it neat?
*/
function guessOrdinal(source, dimIndex) {
	return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
}
function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
	var result;
	var maxLoop = 5;
	if (isTypedArray(data)) return BE_ORDINAL.Not;
	var dimName;
	var dimType;
	if (dimensionsDefine) {
		var dimDefItem = dimensionsDefine[dimIndex];
		if (isObject(dimDefItem)) {
			dimName = dimDefItem.name;
			dimType = dimDefItem.type;
		} else if (isString(dimDefItem)) dimName = dimDefItem;
	}
	if (dimType != null) return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
	if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
		var dataArrayRows = data;
		if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
			var sample = dataArrayRows[dimIndex];
			for (var i$1 = 0; i$1 < (sample || []).length && i$1 < maxLoop; i$1++) if ((result = detectValue(sample[startIndex + i$1])) != null) return result;
		} else for (var i$1 = 0; i$1 < dataArrayRows.length && i$1 < maxLoop; i$1++) {
			var row = dataArrayRows[startIndex + i$1];
			if (row && (result = detectValue(row[dimIndex])) != null) return result;
		}
	} else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
		var dataObjectRows = data;
		if (!dimName) return BE_ORDINAL.Not;
		for (var i$1 = 0; i$1 < dataObjectRows.length && i$1 < maxLoop; i$1++) {
			var item = dataObjectRows[i$1];
			if (item && (result = detectValue(item[dimName])) != null) return result;
		}
	} else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
		var dataKeyedColumns = data;
		if (!dimName) return BE_ORDINAL.Not;
		var sample = dataKeyedColumns[dimName];
		if (!sample || isTypedArray(sample)) return BE_ORDINAL.Not;
		for (var i$1 = 0; i$1 < sample.length && i$1 < maxLoop; i$1++) if ((result = detectValue(sample[i$1])) != null) return result;
	} else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
		var dataOriginal = data;
		for (var i$1 = 0; i$1 < dataOriginal.length && i$1 < maxLoop; i$1++) {
			var item = dataOriginal[i$1];
			var val = getDataItemValue(item);
			if (!isArray(val)) return BE_ORDINAL.Not;
			if ((result = detectValue(val[dimIndex])) != null) return result;
		}
	}
	function detectValue(val$1) {
		var beStr = isString(val$1);
		if (val$1 != null && Number.isFinite(Number(val$1)) && val$1 !== "") return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
		else if (beStr && val$1 !== "-") return BE_ORDINAL.Must;
	}
	return BE_ORDINAL.Not;
}

//#endregion
//#region node_modules/echarts/lib/model/internalComponentCreator.js
var internalOptionCreatorMap = createHashMap();
function registerInternalOptionCreator(mainType, creator) {
	assert(internalOptionCreatorMap.get(mainType) == null && creator);
	internalOptionCreatorMap.set(mainType, creator);
}
function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
	var internalOptionCreator = internalOptionCreatorMap.get(mainType);
	if (!internalOptionCreator) return newCmptOptionList;
	var internalOptions = internalOptionCreator(ecModel);
	if (!internalOptions) return newCmptOptionList;
	for (var i$1 = 0; i$1 < internalOptions.length; i$1++) assert(isComponentIdInternal(internalOptions[i$1]));
	return newCmptOptionList.concat(internalOptions);
}

//#endregion
//#region node_modules/echarts/lib/model/mixin/palette.js
var innerColor = makeInner();
var innerDecal = makeInner();
var PaletteMixin = function() {
	function PaletteMixin$1() {}
	PaletteMixin$1.prototype.getColorFromPalette = function(name, scope, requestNum) {
		var defaultPalette = normalizeToArray(this.get("color", true));
		var layeredPalette = this.get("colorLayer", true);
		return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
	};
	PaletteMixin$1.prototype.clearColorPalette = function() {
		clearPalette(this, innerColor);
	};
	return PaletteMixin$1;
}();
function getDecalFromPalette(ecModel, name, scope, requestNum) {
	return getFromPalette(ecModel, innerDecal, normalizeToArray(ecModel.get([
		"aria",
		"decal",
		"decals"
	])), null, name, scope, requestNum);
}
function getNearestPalette(palettes, requestColorNum) {
	var paletteNum = palettes.length;
	for (var i$1 = 0; i$1 < paletteNum; i$1++) if (palettes[i$1].length > requestColorNum) return palettes[i$1];
	return palettes[paletteNum - 1];
}
/**
* @param name MUST NOT be null/undefined. Otherwise call this function
*             twise with the same parameters will get different result.
* @param scope default this.
* @return Can be null/undefined
*/
function getFromPalette(that, inner$24, defaultPalette, layeredPalette, name, scope, requestNum) {
	scope = scope || that;
	var scopeFields = inner$24(scope);
	var paletteIdx = scopeFields.paletteIdx || 0;
	var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
	if (paletteNameMap.hasOwnProperty(name)) return paletteNameMap[name];
	var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
	palette = palette || defaultPalette;
	if (!palette || !palette.length) return;
	var pickedPaletteItem = palette[paletteIdx];
	if (name) paletteNameMap[name] = pickedPaletteItem;
	scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
	return pickedPaletteItem;
}
function clearPalette(that, inner$24) {
	inner$24(that).paletteIdx = 0;
	inner$24(that).paletteNameMap = {};
}

//#endregion
//#region node_modules/echarts/lib/model/Global.js
var reCreateSeriesIndices;
var assertSeriesInitialized;
var initBase;
var OPTION_INNER_KEY = "\0_ec_inner";
var OPTION_INNER_VALUE = 1;
var BUITIN_COMPONENTS_MAP = {
	grid: "GridComponent",
	polar: "PolarComponent",
	geo: "GeoComponent",
	singleAxis: "SingleAxisComponent",
	parallel: "ParallelComponent",
	calendar: "CalendarComponent",
	matrix: "MatrixComponent",
	graphic: "GraphicComponent",
	toolbox: "ToolboxComponent",
	tooltip: "TooltipComponent",
	axisPointer: "AxisPointerComponent",
	brush: "BrushComponent",
	title: "TitleComponent",
	timeline: "TimelineComponent",
	markPoint: "MarkPointComponent",
	markLine: "MarkLineComponent",
	markArea: "MarkAreaComponent",
	legend: "LegendComponent",
	dataZoom: "DataZoomComponent",
	visualMap: "VisualMapComponent",
	xAxis: "GridComponent",
	yAxis: "GridComponent",
	angleAxis: "PolarComponent",
	radiusAxis: "PolarComponent"
};
var BUILTIN_CHARTS_MAP = {
	line: "LineChart",
	bar: "BarChart",
	pie: "PieChart",
	scatter: "ScatterChart",
	radar: "RadarChart",
	map: "MapChart",
	tree: "TreeChart",
	treemap: "TreemapChart",
	graph: "GraphChart",
	chord: "ChordChart",
	gauge: "GaugeChart",
	funnel: "FunnelChart",
	parallel: "ParallelChart",
	sankey: "SankeyChart",
	boxplot: "BoxplotChart",
	candlestick: "CandlestickChart",
	effectScatter: "EffectScatterChart",
	lines: "LinesChart",
	heatmap: "HeatmapChart",
	pictorialBar: "PictorialBarChart",
	themeRiver: "ThemeRiverChart",
	sunburst: "SunburstChart",
	custom: "CustomChart"
};
var componetsMissingLogPrinted = {};
function checkMissingComponents(option) {
	each(option, function(componentOption, mainType) {
		if (!Component_default.hasClass(mainType)) {
			var componentImportName = BUITIN_COMPONENTS_MAP[mainType];
			if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {
				error("Component " + mainType + " is used but not imported.\nimport { " + componentImportName + " } from 'echarts/components';\necharts.use([" + componentImportName + "]);");
				componetsMissingLogPrinted[componentImportName] = true;
			}
		}
	});
}
var GlobalModel = function(_super) {
	__extends(GlobalModel$1, _super);
	function GlobalModel$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	GlobalModel$1.prototype.init = function(option, parentModel, ecModel, theme$1, locale, optionManager) {
		theme$1 = theme$1 || {};
		this.option = null;
		this._theme = new Model_default(theme$1);
		this._locale = new Model_default(locale);
		this._optionManager = optionManager;
	};
	GlobalModel$1.prototype.setOption = function(option, opts, optionPreprocessorFuncs$1) {
		assert(option != null, "option is null/undefined");
		assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()");
		var innerOpt = normalizeSetOptionInput(opts);
		this._optionManager.setOption(option, optionPreprocessorFuncs$1, innerOpt);
		this._resetOption(null, innerOpt);
	};
	/**
	* @param type null/undefined: reset all.
	*        'recreate': force recreate all.
	*        'timeline': only reset timeline option
	*        'media': only reset media query option
	* @return Whether option changed.
	*/
	GlobalModel$1.prototype.resetOption = function(type, opt) {
		return this._resetOption(type, normalizeSetOptionInput(opt));
	};
	GlobalModel$1.prototype._resetOption = function(type, opt) {
		var optionChanged = false;
		var optionManager = this._optionManager;
		if (!type || type === "recreate") {
			var baseOption = optionManager.mountOption(type === "recreate");
			checkMissingComponents(baseOption);
			if (!this.option || type === "recreate") initBase(this, baseOption);
			else {
				this.restoreData();
				this._mergeOption(baseOption, opt);
			}
			optionChanged = true;
		}
		if (type === "timeline" || type === "media") this.restoreData();
		if (!type || type === "recreate" || type === "timeline") {
			var timelineOption = optionManager.getTimelineOption(this);
			if (timelineOption) {
				optionChanged = true;
				this._mergeOption(timelineOption, opt);
			}
		}
		if (!type || type === "recreate" || type === "media") {
			var mediaOptions = optionManager.getMediaOption(this);
			if (mediaOptions.length) each(mediaOptions, function(mediaOption) {
				optionChanged = true;
				this._mergeOption(mediaOption, opt);
			}, this);
		}
		return optionChanged;
	};
	GlobalModel$1.prototype.mergeOption = function(option) {
		this._mergeOption(option, null);
	};
	GlobalModel$1.prototype._mergeOption = function(newOption, opt) {
		var option = this.option;
		var componentsMap = this._componentsMap;
		var componentsCount = this._componentsCount;
		var newCmptTypes = [];
		var newCmptTypeMap = createHashMap();
		var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
		resetSourceDefaulter(this);
		each(newOption, function(componentOption, mainType) {
			if (componentOption == null) return;
			if (!Component_default.hasClass(mainType)) option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);
			else if (mainType) {
				newCmptTypes.push(mainType);
				newCmptTypeMap.set(mainType, true);
			}
		});
		if (replaceMergeMainTypeMap) replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
			if (Component_default.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
				newCmptTypes.push(mainTypeInReplaceMerge);
				newCmptTypeMap.set(mainTypeInReplaceMerge, true);
			}
		});
		Component_default.topologicalTravel(newCmptTypes, Component_default.getAllClassMainTypes(), visitComponent, this);
		function visitComponent(mainType) {
			var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
			var oldCmptList = componentsMap.get(mainType);
			var mergeMode = !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge";
			var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
			setComponentTypeToKeyInfo(mappingResult, mainType, Component_default);
			option[mainType] = null;
			componentsMap.set(mainType, null);
			componentsCount.set(mainType, 0);
			var optionsByMainType = [];
			var cmptsByMainType = [];
			var cmptsCountByMainType = 0;
			var tooltipExists;
			var tooltipWarningLogged;
			each(mappingResult, function(resultItem, index) {
				var componentModel = resultItem.existing;
				var newCmptOption = resultItem.newOption;
				if (!newCmptOption) {
					if (componentModel) {
						componentModel.mergeOption({}, this);
						componentModel.optionUpdated({}, false);
					}
				} else {
					var isSeriesType = mainType === "series";
					var ComponentModelClass = Component_default.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType);
					if (!ComponentModelClass) {
						var subType = resultItem.keyInfo.subType;
						var seriesImportName = BUILTIN_CHARTS_MAP[subType];
						if (!componetsMissingLogPrinted[subType]) {
							componetsMissingLogPrinted[subType] = true;
							if (seriesImportName) error("Series " + subType + " is used but not imported.\nimport { " + seriesImportName + " } from 'echarts/charts';\necharts.use([" + seriesImportName + "]);");
							else error("Unknown series " + subType);
						}
						return;
					}
					if (mainType === "tooltip") {
						if (tooltipExists) {
							if (!tooltipWarningLogged) {
								warn("Currently only one tooltip component is allowed.");
								tooltipWarningLogged = true;
							}
							return;
						}
						tooltipExists = true;
					}
					if (componentModel && componentModel.constructor === ComponentModelClass) {
						componentModel.name = resultItem.keyInfo.name;
						componentModel.mergeOption(newCmptOption, this);
						componentModel.optionUpdated(newCmptOption, false);
					} else {
						var extraOpt = extend({ componentIndex: index }, resultItem.keyInfo);
						componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
						extend(componentModel, extraOpt);
						if (resultItem.brandNew) componentModel.__requireNewView = true;
						componentModel.init(newCmptOption, this, this);
						componentModel.optionUpdated(null, true);
					}
				}
				if (componentModel) {
					optionsByMainType.push(componentModel.option);
					cmptsByMainType.push(componentModel);
					cmptsCountByMainType++;
				} else {
					optionsByMainType.push(void 0);
					cmptsByMainType.push(void 0);
				}
			}, this);
			option[mainType] = optionsByMainType;
			componentsMap.set(mainType, cmptsByMainType);
			componentsCount.set(mainType, cmptsCountByMainType);
			if (mainType === "series") reCreateSeriesIndices(this);
		}
		if (!this._seriesIndices) reCreateSeriesIndices(this);
	};
	/**
	* Get option for output (cloned option and inner info removed)
	*/
	GlobalModel$1.prototype.getOption = function() {
		var option = clone(this.option);
		each(option, function(optInMainType, mainType) {
			if (Component_default.hasClass(mainType)) {
				var opts = normalizeToArray(optInMainType);
				var realLen = opts.length;
				var metNonInner = false;
				for (var i$1 = realLen - 1; i$1 >= 0; i$1--) if (opts[i$1] && !isComponentIdInternal(opts[i$1])) metNonInner = true;
				else {
					opts[i$1] = null;
					!metNonInner && realLen--;
				}
				opts.length = realLen;
				option[mainType] = opts;
			}
		});
		delete option[OPTION_INNER_KEY];
		return option;
	};
	GlobalModel$1.prototype.setTheme = function(theme$1) {
		this._theme = new Model_default(theme$1);
		this._resetOption("recreate", null);
	};
	GlobalModel$1.prototype.getTheme = function() {
		return this._theme;
	};
	GlobalModel$1.prototype.getLocaleModel = function() {
		return this._locale;
	};
	GlobalModel$1.prototype.setUpdatePayload = function(payload) {
		this._payload = payload;
	};
	GlobalModel$1.prototype.getUpdatePayload = function() {
		return this._payload;
	};
	/**
	* @param idx If not specified, return the first one.
	*/
	GlobalModel$1.prototype.getComponent = function(mainType, idx) {
		var list = this._componentsMap.get(mainType);
		if (list) {
			var cmpt = list[idx || 0];
			if (cmpt) return cmpt;
			else if (idx == null) {
				for (var i$1 = 0; i$1 < list.length; i$1++) if (list[i$1]) return list[i$1];
			}
		}
	};
	/**
	* @return Never be null/undefined.
	*/
	GlobalModel$1.prototype.queryComponents = function(condition) {
		var mainType = condition.mainType;
		if (!mainType) return [];
		var index = condition.index;
		var id = condition.id;
		var name = condition.name;
		var cmpts = this._componentsMap.get(mainType);
		if (!cmpts || !cmpts.length) return [];
		var result;
		if (index != null) {
			result = [];
			each(normalizeToArray(index), function(idx) {
				cmpts[idx] && result.push(cmpts[idx]);
			});
		} else if (id != null) result = queryByIdOrName("id", id, cmpts);
		else if (name != null) result = queryByIdOrName("name", name, cmpts);
		else result = filter(cmpts, function(cmpt) {
			return !!cmpt;
		});
		return filterBySubType(result, condition);
	};
	/**
	* The interface is different from queryComponents,
	* which is convenient for inner usage.
	*
	* @usage
	* let result = findComponents(
	*     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
	* );
	* let result = findComponents(
	*     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
	* );
	* let result = findComponents(
	*     {mainType: 'series',
	*     filter: function (model, index) {...}}
	* );
	* // result like [component0, componnet1, ...]
	*/
	GlobalModel$1.prototype.findComponents = function(condition) {
		var query = condition.query;
		var mainType = condition.mainType;
		var queryCond = getQueryCond(query);
		return doFilter(filterBySubType(queryCond ? this.queryComponents(queryCond) : filter(this._componentsMap.get(mainType), function(cmpt) {
			return !!cmpt;
		}), condition));
		function getQueryCond(q) {
			var indexAttr = mainType + "Index";
			var idAttr = mainType + "Id";
			var nameAttr = mainType + "Name";
			return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
				mainType,
				index: q[indexAttr],
				id: q[idAttr],
				name: q[nameAttr]
			} : null;
		}
		function doFilter(res) {
			return condition.filter ? filter(res, condition.filter) : res;
		}
	};
	GlobalModel$1.prototype.eachComponent = function(mainType, cb, context) {
		var componentsMap = this._componentsMap;
		if (isFunction(mainType)) {
			var ctxForAll_1 = cb;
			var cbForAll_1 = mainType;
			componentsMap.each(function(cmpts$1, componentType) {
				for (var i$2 = 0; cmpts$1 && i$2 < cmpts$1.length; i$2++) {
					var cmpt$1 = cmpts$1[i$2];
					cmpt$1 && cbForAll_1.call(ctxForAll_1, componentType, cmpt$1, cmpt$1.componentIndex);
				}
			});
		} else {
			var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null;
			for (var i$1 = 0; cmpts && i$1 < cmpts.length; i$1++) {
				var cmpt = cmpts[i$1];
				cmpt && cb.call(context, cmpt, cmpt.componentIndex);
			}
		}
	};
	/**
	* Get series list before filtered by name.
	*/
	GlobalModel$1.prototype.getSeriesByName = function(name) {
		var nameStr = convertOptionIdName(name, null);
		return filter(this._componentsMap.get("series"), function(oneSeries) {
			return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
		});
	};
	/**
	* Get series list before filtered by index.
	*/
	GlobalModel$1.prototype.getSeriesByIndex = function(seriesIndex) {
		return this._componentsMap.get("series")[seriesIndex];
	};
	/**
	* Get series list before filtered by type.
	* FIXME: rename to getRawSeriesByType?
	*/
	GlobalModel$1.prototype.getSeriesByType = function(subType) {
		return filter(this._componentsMap.get("series"), function(oneSeries) {
			return !!oneSeries && oneSeries.subType === subType;
		});
	};
	/**
	* Get all series before filtered.
	*/
	GlobalModel$1.prototype.getSeries = function() {
		return filter(this._componentsMap.get("series"), function(oneSeries) {
			return !!oneSeries;
		});
	};
	/**
	* Count series before filtered.
	*/
	GlobalModel$1.prototype.getSeriesCount = function() {
		return this._componentsCount.get("series");
	};
	/**
	* After filtering, series may be different
	* from raw series.
	*/
	GlobalModel$1.prototype.eachSeries = function(cb, context) {
		assertSeriesInitialized(this);
		each(this._seriesIndices, function(rawSeriesIndex) {
			var series = this._componentsMap.get("series")[rawSeriesIndex];
			cb.call(context, series, rawSeriesIndex);
		}, this);
	};
	/**
	* Iterate raw series before filtered.
	*
	* @param {Function} cb
	* @param {*} context
	*/
	GlobalModel$1.prototype.eachRawSeries = function(cb, context) {
		each(this._componentsMap.get("series"), function(series) {
			series && cb.call(context, series, series.componentIndex);
		});
	};
	/**
	* After filtering, series may be different.
	* from raw series.
	*/
	GlobalModel$1.prototype.eachSeriesByType = function(subType, cb, context) {
		assertSeriesInitialized(this);
		each(this._seriesIndices, function(rawSeriesIndex) {
			var series = this._componentsMap.get("series")[rawSeriesIndex];
			if (series.subType === subType) cb.call(context, series, rawSeriesIndex);
		}, this);
	};
	/**
	* Iterate raw series before filtered of given type.
	*/
	GlobalModel$1.prototype.eachRawSeriesByType = function(subType, cb, context) {
		return each(this.getSeriesByType(subType), cb, context);
	};
	GlobalModel$1.prototype.isSeriesFiltered = function(seriesModel) {
		assertSeriesInitialized(this);
		return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
	};
	GlobalModel$1.prototype.getCurrentSeriesIndices = function() {
		return (this._seriesIndices || []).slice();
	};
	GlobalModel$1.prototype.filterSeries = function(cb, context) {
		assertSeriesInitialized(this);
		var newSeriesIndices = [];
		each(this._seriesIndices, function(seriesRawIdx) {
			var series = this._componentsMap.get("series")[seriesRawIdx];
			cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
		}, this);
		this._seriesIndices = newSeriesIndices;
		this._seriesIndicesMap = createHashMap(newSeriesIndices);
	};
	GlobalModel$1.prototype.restoreData = function(payload) {
		reCreateSeriesIndices(this);
		var componentsMap = this._componentsMap;
		var componentTypes = [];
		componentsMap.each(function(components, componentType) {
			if (Component_default.hasClass(componentType)) componentTypes.push(componentType);
		});
		Component_default.topologicalTravel(componentTypes, Component_default.getAllClassMainTypes(), function(componentType) {
			each(componentsMap.get(componentType), function(component) {
				if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) component.restoreData();
			});
		});
	};
	GlobalModel$1.internalField = function() {
		reCreateSeriesIndices = function(ecModel) {
			var seriesIndices = ecModel._seriesIndices = [];
			each(ecModel._componentsMap.get("series"), function(series) {
				series && seriesIndices.push(series.componentIndex);
			});
			ecModel._seriesIndicesMap = createHashMap(seriesIndices);
		};
		assertSeriesInitialized = function(ecModel) {
			if (!ecModel._seriesIndices) throw new Error("Option should contains series.");
		};
		initBase = function(ecModel, baseOption) {
			ecModel.option = {};
			ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
			ecModel._componentsMap = createHashMap({ series: [] });
			ecModel._componentsCount = createHashMap();
			var airaOption = baseOption.aria;
			if (isObject(airaOption) && airaOption.enabled == null) airaOption.enabled = true;
			mergeTheme(baseOption, ecModel._theme.option);
			merge(baseOption, globalDefault_default, false);
			ecModel._mergeOption(baseOption, null);
		};
	}();
	return GlobalModel$1;
}(Model_default);
function isNotTargetSeries(seriesModel, payload) {
	if (payload) {
		var index = payload.seriesIndex;
		var id = payload.seriesId;
		var name_1 = payload.seriesName;
		return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
	}
}
function mergeTheme(option, theme$1) {
	var notMergeColorLayer = option.color && !option.colorLayer;
	each(theme$1, function(themeItem, name) {
		if (name === "colorLayer" && notMergeColorLayer || name === "color" && option.color) return;
		if (!Component_default.hasClass(name)) {
			if (typeof themeItem === "object") option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);
			else if (option[name] == null) option[name] = themeItem;
		}
	});
}
function queryByIdOrName(attr, idOrName, cmpts) {
	if (isArray(idOrName)) {
		var keyMap_1 = createHashMap();
		each(idOrName, function(idOrNameItem) {
			if (idOrNameItem != null) convertOptionIdName(idOrNameItem, null) != null && keyMap_1.set(idOrNameItem, true);
		});
		return filter(cmpts, function(cmpt) {
			return cmpt && keyMap_1.get(cmpt[attr]);
		});
	} else {
		var idName_1 = convertOptionIdName(idOrName, null);
		return filter(cmpts, function(cmpt) {
			return cmpt && idName_1 != null && cmpt[attr] === idName_1;
		});
	}
}
function filterBySubType(components, condition) {
	return condition.hasOwnProperty("subType") ? filter(components, function(cmpt) {
		return cmpt && cmpt.subType === condition.subType;
	}) : components;
}
function normalizeSetOptionInput(opts) {
	var replaceMergeMainTypeMap = createHashMap();
	opts && each(normalizeToArray(opts.replaceMerge), function(mainType) {
		assert(Component_default.hasClass(mainType), "\"" + mainType + "\" is not valid component main type in \"replaceMerge\"");
		replaceMergeMainTypeMap.set(mainType, true);
	});
	return { replaceMergeMainTypeMap };
}
mixin(GlobalModel, PaletteMixin);
var Global_default = GlobalModel;

//#endregion
//#region node_modules/echarts/lib/core/ExtensionAPI.js
var availableMethods = [
	"getDom",
	"getZr",
	"getWidth",
	"getHeight",
	"getDevicePixelRatio",
	"dispatchAction",
	"isSSR",
	"isDisposed",
	"on",
	"off",
	"getDataURL",
	"getConnectedDataURL",
	"getOption",
	"getId",
	"updateLabelLayout"
];
var ExtensionAPI = function() {
	function ExtensionAPI$1(ecInstance) {
		each(availableMethods, function(methodName) {
			this[methodName] = bind(ecInstance[methodName], ecInstance);
		}, this);
	}
	return ExtensionAPI$1;
}();
var ExtensionAPI_default = ExtensionAPI;

//#endregion
//#region node_modules/echarts/lib/model/OptionManager.js
var QUERY_REG = /^(min|max)?(.+)$/;
/**
* TERM EXPLANATIONS:
* See `ECOption` and `ECUnitOption` in `src/util/types.ts`.
*/
var OptionManager = function() {
	function OptionManager$1(api) {
		this._timelineOptions = [];
		this._mediaList = [];
		/**
		* -1, means default.
		* empty means no media.
		*/
		this._currentMediaIndices = [];
		this._api = api;
	}
	OptionManager$1.prototype.setOption = function(rawOption, optionPreprocessorFuncs$1, opt) {
		if (rawOption) {
			each(normalizeToArray(rawOption.series), function(series) {
				series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
			});
			each(normalizeToArray(rawOption.dataset), function(dataset) {
				dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);
			});
		}
		rawOption = clone(rawOption);
		var optionBackup = this._optionBackup;
		var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs$1, !optionBackup);
		this._newBaseOption = newParsedOption.baseOption;
		if (optionBackup) {
			if (newParsedOption.timelineOptions.length) optionBackup.timelineOptions = newParsedOption.timelineOptions;
			if (newParsedOption.mediaList.length) optionBackup.mediaList = newParsedOption.mediaList;
			if (newParsedOption.mediaDefault) optionBackup.mediaDefault = newParsedOption.mediaDefault;
		} else this._optionBackup = newParsedOption;
	};
	OptionManager$1.prototype.mountOption = function(isRecreate) {
		var optionBackup = this._optionBackup;
		this._timelineOptions = optionBackup.timelineOptions;
		this._mediaList = optionBackup.mediaList;
		this._mediaDefault = optionBackup.mediaDefault;
		this._currentMediaIndices = [];
		return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
	};
	OptionManager$1.prototype.getTimelineOption = function(ecModel) {
		var option;
		var timelineOptions = this._timelineOptions;
		if (timelineOptions.length) {
			var timelineModel = ecModel.getComponent("timeline");
			if (timelineModel) option = clone(timelineOptions[timelineModel.getCurrentIndex()]);
		}
		return option;
	};
	OptionManager$1.prototype.getMediaOption = function(ecModel) {
		var ecWidth = this._api.getWidth();
		var ecHeight = this._api.getHeight();
		var mediaList = this._mediaList;
		var mediaDefault = this._mediaDefault;
		var indices = [];
		var result = [];
		if (!mediaList.length && !mediaDefault) return result;
		for (var i$1 = 0, len$1 = mediaList.length; i$1 < len$1; i$1++) if (applyMediaQuery(mediaList[i$1].query, ecWidth, ecHeight)) indices.push(i$1);
		if (!indices.length && mediaDefault) indices = [-1];
		if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) result = map(indices, function(index) {
			return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
		});
		this._currentMediaIndices = indices;
		return result;
	};
	return OptionManager$1;
}();
/**
* [RAW_OPTION_PATTERNS]
* (Note: "series: []" represents all other props in `ECUnitOption`)
*
* (1) No prop "baseOption" declared:
* Root option is used as "baseOption" (except prop "options" and "media").
* ```js
* option = {
*     series: [],
*     timeline: {},
*     options: [],
* };
* option = {
*     series: [],
*     media: {},
* };
* option = {
*     series: [],
*     timeline: {},
*     options: [],
*     media: {},
* }
* ```
*
* (2) Prop "baseOption" declared:
* If "baseOption" declared, `ECUnitOption` props can only be declared
* inside "baseOption" except prop "timeline" (compat ec2).
* ```js
* option = {
*     baseOption: {
*         timeline: {},
*         series: [],
*     },
*     options: []
* };
* option = {
*     baseOption: {
*         series: [],
*     },
*     media: []
* };
* option = {
*     baseOption: {
*         timeline: {},
*         series: [],
*     },
*     options: []
*     media: []
* };
* option = {
*     // ec3 compat ec2: allow (only) `timeline` declared
*     // outside baseOption. Keep this setting for compat.
*     timeline: {},
*     baseOption: {
*         series: [],
*     },
*     options: [],
*     media: []
* };
* ```
*/
function parseRawOption(rawOption, optionPreprocessorFuncs$1, isNew) {
	var mediaList = [];
	var mediaDefault;
	var baseOption;
	var declaredBaseOption = rawOption.baseOption;
	var timelineOnRoot = rawOption.timeline;
	var timelineOptionsOnRoot = rawOption.options;
	var mediaOnRoot = rawOption.media;
	var hasMedia = !!rawOption.media;
	var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
	if (declaredBaseOption) {
		baseOption = declaredBaseOption;
		if (!baseOption.timeline) baseOption.timeline = timelineOnRoot;
	} else {
		if (hasTimeline || hasMedia) rawOption.options = rawOption.media = null;
		baseOption = rawOption;
	}
	if (hasMedia) if (isArray(mediaOnRoot)) each(mediaOnRoot, function(singleMedia) {
		if (singleMedia && !singleMedia.option && isObject(singleMedia.query) && isObject(singleMedia.query.option)) error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }");
		if (singleMedia && singleMedia.option) {
			if (singleMedia.query) mediaList.push(singleMedia);
			else if (!mediaDefault) mediaDefault = singleMedia;
		}
	});
	else error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }");
	doPreprocess(baseOption);
	each(timelineOptionsOnRoot, function(option) {
		return doPreprocess(option);
	});
	each(mediaList, function(media) {
		return doPreprocess(media.option);
	});
	function doPreprocess(option) {
		each(optionPreprocessorFuncs$1, function(preProcess) {
			preProcess(option, isNew);
		});
	}
	return {
		baseOption,
		timelineOptions: timelineOptionsOnRoot || [],
		mediaDefault,
		mediaList
	};
}
/**
* @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
* Support: width, height, aspectRatio
* Can use max or min as prefix.
*/
function applyMediaQuery(query, ecWidth, ecHeight) {
	var realMap = {
		width: ecWidth,
		height: ecHeight,
		aspectratio: ecWidth / ecHeight
	};
	var applicable = true;
	each(query, function(value, attr) {
		var matched = attr.match(QUERY_REG);
		if (!matched || !matched[1] || !matched[2]) return;
		var operator = matched[1];
		if (!compare(realMap[matched[2].toLowerCase()], value, operator)) applicable = false;
	});
	return applicable;
}
function compare(real, expect, operator) {
	if (operator === "min") return real >= expect;
	else if (operator === "max") return real <= expect;
	else return real === expect;
}
function indicesEquals(indices1, indices2) {
	return indices1.join(",") === indices2.join(",");
}
/**
* Consider case:
* `chart.setOption(opt1);`
* Then user do some interaction like dataZoom, dataView changing.
* `chart.setOption(opt2);`
* Then user press 'reset button' in toolbox.
*
* After doing that all of the interaction effects should be reset, the
* chart should be the same as the result of invoke
* `chart.setOption(opt1); chart.setOption(opt2);`.
*
* Although it is not able ensure that
* `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
* `chart.setOption(merge(opt1, opt2));` exactly,
* this might be the only simple way to implement that feature.
*
* MEMO: We've considered some other approaches:
* 1. Each model handles its self restoration but not uniform treatment.
*     (Too complex in logic and error-prone)
* 2. Use a shadow ecModel. (Performance expensive)
*
* FIXME: A possible solution:
* Add a extra level of model for each component model. The inheritance chain would be:
* ecModel <- componentModel <- componentActionModel <- dataItemModel
* And all of the actions can only modify the `componentActionModel` rather than
* `componentModel`. `setOption` will only modify the `ecModel` and `componentModel`.
* When "resotre" action triggered, model from `componentActionModel` will be discarded
* instead of recreating the "ecModel" from the "_optionBackup".
*/
var OptionManager_default = OptionManager;

//#endregion
//#region node_modules/echarts/lib/preprocessor/helper/compatStyle.js
var each$14 = each;
var isObject$3 = isObject;
var POSSIBLE_STYLES = [
	"areaStyle",
	"lineStyle",
	"nodeStyle",
	"linkStyle",
	"chordStyle",
	"label",
	"labelLine"
];
function compatEC2ItemStyle(opt) {
	var itemStyleOpt = opt && opt.itemStyle;
	if (!itemStyleOpt) return;
	for (var i$1 = 0, len$1 = POSSIBLE_STYLES.length; i$1 < len$1; i$1++) {
		var styleName = POSSIBLE_STYLES[i$1];
		var normalItemStyleOpt = itemStyleOpt.normal;
		var emphasisItemStyleOpt = itemStyleOpt.emphasis;
		if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
			deprecateReplaceLog("itemStyle.normal." + styleName, styleName);
			opt[styleName] = opt[styleName] || {};
			if (!opt[styleName].normal) opt[styleName].normal = normalItemStyleOpt[styleName];
			else merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
			normalItemStyleOpt[styleName] = null;
		}
		if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
			deprecateReplaceLog("itemStyle.emphasis." + styleName, "emphasis." + styleName);
			opt[styleName] = opt[styleName] || {};
			if (!opt[styleName].emphasis) opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
			else merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
			emphasisItemStyleOpt[styleName] = null;
		}
	}
}
function convertNormalEmphasis(opt, optType, useExtend) {
	if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
		var normalOpt = opt[optType].normal;
		var emphasisOpt = opt[optType].emphasis;
		if (normalOpt) {
			deprecateLog("'normal' hierarchy in " + optType + " has been removed since 4.0. All style properties are configured in " + optType + " directly now.");
			if (useExtend) {
				opt[optType].normal = opt[optType].emphasis = null;
				defaults(opt[optType], normalOpt);
			} else opt[optType] = normalOpt;
		}
		if (emphasisOpt) {
			deprecateLog(optType + ".emphasis has been changed to emphasis." + optType + " since 4.0");
			opt.emphasis = opt.emphasis || {};
			opt.emphasis[optType] = emphasisOpt;
			if (emphasisOpt.focus) opt.emphasis.focus = emphasisOpt.focus;
			if (emphasisOpt.blurScope) opt.emphasis.blurScope = emphasisOpt.blurScope;
		}
	}
}
function removeEC3NormalStatus(opt) {
	convertNormalEmphasis(opt, "itemStyle");
	convertNormalEmphasis(opt, "lineStyle");
	convertNormalEmphasis(opt, "areaStyle");
	convertNormalEmphasis(opt, "label");
	convertNormalEmphasis(opt, "labelLine");
	convertNormalEmphasis(opt, "upperLabel");
	convertNormalEmphasis(opt, "edgeLabel");
}
function compatTextStyle(opt, propName) {
	var labelOptSingle = isObject$3(opt) && opt[propName];
	var textStyle = isObject$3(labelOptSingle) && labelOptSingle.textStyle;
	if (textStyle) {
		deprecateLog("textStyle hierarchy in " + propName + " has been removed since 4.0. All textStyle properties are configured in " + propName + " directly now.");
		for (var i$1 = 0, len$1 = TEXT_STYLE_OPTIONS.length; i$1 < len$1; i$1++) {
			var textPropName = TEXT_STYLE_OPTIONS[i$1];
			if (textStyle.hasOwnProperty(textPropName)) labelOptSingle[textPropName] = textStyle[textPropName];
		}
	}
}
function compatEC3CommonStyles(opt) {
	if (opt) {
		removeEC3NormalStatus(opt);
		compatTextStyle(opt, "label");
		opt.emphasis && compatTextStyle(opt.emphasis, "label");
	}
}
function processSeries(seriesOpt) {
	if (!isObject$3(seriesOpt)) return;
	compatEC2ItemStyle(seriesOpt);
	removeEC3NormalStatus(seriesOpt);
	compatTextStyle(seriesOpt, "label");
	compatTextStyle(seriesOpt, "upperLabel");
	compatTextStyle(seriesOpt, "edgeLabel");
	if (seriesOpt.emphasis) {
		compatTextStyle(seriesOpt.emphasis, "label");
		compatTextStyle(seriesOpt.emphasis, "upperLabel");
		compatTextStyle(seriesOpt.emphasis, "edgeLabel");
	}
	var markPoint = seriesOpt.markPoint;
	if (markPoint) {
		compatEC2ItemStyle(markPoint);
		compatEC3CommonStyles(markPoint);
	}
	var markLine = seriesOpt.markLine;
	if (markLine) {
		compatEC2ItemStyle(markLine);
		compatEC3CommonStyles(markLine);
	}
	var markArea = seriesOpt.markArea;
	if (markArea) compatEC3CommonStyles(markArea);
	var data = seriesOpt.data;
	if (seriesOpt.type === "graph") {
		data = data || seriesOpt.nodes;
		var edgeData = seriesOpt.links || seriesOpt.edges;
		if (edgeData && !isTypedArray(edgeData)) for (var i$1 = 0; i$1 < edgeData.length; i$1++) compatEC3CommonStyles(edgeData[i$1]);
		each(seriesOpt.categories, function(opt) {
			removeEC3NormalStatus(opt);
		});
	}
	if (data && !isTypedArray(data)) for (var i$1 = 0; i$1 < data.length; i$1++) compatEC3CommonStyles(data[i$1]);
	markPoint = seriesOpt.markPoint;
	if (markPoint && markPoint.data) {
		var mpData = markPoint.data;
		for (var i$1 = 0; i$1 < mpData.length; i$1++) compatEC3CommonStyles(mpData[i$1]);
	}
	markLine = seriesOpt.markLine;
	if (markLine && markLine.data) {
		var mlData = markLine.data;
		for (var i$1 = 0; i$1 < mlData.length; i$1++) if (isArray(mlData[i$1])) {
			compatEC3CommonStyles(mlData[i$1][0]);
			compatEC3CommonStyles(mlData[i$1][1]);
		} else compatEC3CommonStyles(mlData[i$1]);
	}
	if (seriesOpt.type === "gauge") {
		compatTextStyle(seriesOpt, "axisLabel");
		compatTextStyle(seriesOpt, "title");
		compatTextStyle(seriesOpt, "detail");
	} else if (seriesOpt.type === "treemap") {
		convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
		each(seriesOpt.levels, function(opt) {
			removeEC3NormalStatus(opt);
		});
	} else if (seriesOpt.type === "tree") removeEC3NormalStatus(seriesOpt.leaves);
}
function toArr(o) {
	return isArray(o) ? o : o ? [o] : [];
}
function toObj(o) {
	return (isArray(o) ? o[0] : o) || {};
}
function globalCompatStyle(option, isTheme) {
	each$14(toArr(option.series), function(seriesOpt) {
		isObject$3(seriesOpt) && processSeries(seriesOpt);
	});
	var axes = [
		"xAxis",
		"yAxis",
		"radiusAxis",
		"angleAxis",
		"singleAxis",
		"parallelAxis",
		"radar"
	];
	isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
	each$14(axes, function(axisName) {
		each$14(toArr(option[axisName]), function(axisOpt) {
			if (axisOpt) {
				compatTextStyle(axisOpt, "axisLabel");
				compatTextStyle(axisOpt.axisPointer, "label");
			}
		});
	});
	each$14(toArr(option.parallel), function(parallelOpt) {
		var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
		compatTextStyle(parallelAxisDefault, "axisLabel");
		compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
	});
	each$14(toArr(option.calendar), function(calendarOpt) {
		convertNormalEmphasis(calendarOpt, "itemStyle");
		compatTextStyle(calendarOpt, "dayLabel");
		compatTextStyle(calendarOpt, "monthLabel");
		compatTextStyle(calendarOpt, "yearLabel");
	});
	each$14(toArr(option.radar), function(radarOpt) {
		compatTextStyle(radarOpt, "name");
		if (radarOpt.name && radarOpt.axisName == null) {
			radarOpt.axisName = radarOpt.name;
			delete radarOpt.name;
			deprecateLog("name property in radar component has been changed to axisName");
		}
		if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
			radarOpt.axisNameGap = radarOpt.nameGap;
			delete radarOpt.nameGap;
			deprecateLog("nameGap property in radar component has been changed to axisNameGap");
		}
		each$14(radarOpt.indicator, function(indicatorOpt) {
			if (indicatorOpt.text) deprecateReplaceLog("text", "name", "radar.indicator");
		});
	});
	each$14(toArr(option.geo), function(geoOpt) {
		if (isObject$3(geoOpt)) {
			compatEC3CommonStyles(geoOpt);
			each$14(toArr(geoOpt.regions), function(regionObj) {
				compatEC3CommonStyles(regionObj);
			});
		}
	});
	each$14(toArr(option.timeline), function(timelineOpt) {
		compatEC3CommonStyles(timelineOpt);
		convertNormalEmphasis(timelineOpt, "label");
		convertNormalEmphasis(timelineOpt, "itemStyle");
		convertNormalEmphasis(timelineOpt, "controlStyle", true);
		var data = timelineOpt.data;
		isArray(data) && each(data, function(item) {
			if (isObject(item)) {
				convertNormalEmphasis(item, "label");
				convertNormalEmphasis(item, "itemStyle");
			}
		});
	});
	each$14(toArr(option.toolbox), function(toolboxOpt) {
		convertNormalEmphasis(toolboxOpt, "iconStyle");
		each$14(toolboxOpt.feature, function(featureOpt) {
			convertNormalEmphasis(featureOpt, "iconStyle");
		});
	});
	compatTextStyle(toObj(option.axisPointer), "label");
	compatTextStyle(toObj(option.tooltip).axisPointer, "label");
}

//#endregion
//#region node_modules/echarts/lib/preprocessor/backwardCompat.js
function get(opt, path) {
	var pathArr = path.split(",");
	var obj = opt;
	for (var i$1 = 0; i$1 < pathArr.length; i$1++) {
		obj = obj && obj[pathArr[i$1]];
		if (obj == null) break;
	}
	return obj;
}
function set(opt, path, val, overwrite) {
	var pathArr = path.split(",");
	var obj = opt;
	var key$1;
	var i$1 = 0;
	for (; i$1 < pathArr.length - 1; i$1++) {
		key$1 = pathArr[i$1];
		if (obj[key$1] == null) obj[key$1] = {};
		obj = obj[key$1];
	}
	if (overwrite || obj[pathArr[i$1]] == null) obj[pathArr[i$1]] = val;
}
function compatLayoutProperties(option) {
	option && each(LAYOUT_PROPERTIES, function(prop) {
		if (prop[0] in option && !(prop[1] in option)) option[prop[1]] = option[prop[0]];
	});
}
var LAYOUT_PROPERTIES = [
	["x", "left"],
	["y", "top"],
	["x2", "right"],
	["y2", "bottom"]
];
var COMPATITABLE_COMPONENTS = [
	"grid",
	"geo",
	"parallel",
	"legend",
	"toolbox",
	"title",
	"visualMap",
	"dataZoom",
	"timeline"
];
var BAR_ITEM_STYLE_MAP = [
	["borderRadius", "barBorderRadius"],
	["borderColor", "barBorderColor"],
	["borderWidth", "barBorderWidth"]
];
function compatBarItemStyle(option) {
	var itemStyle = option && option.itemStyle;
	if (itemStyle) for (var i$1 = 0; i$1 < BAR_ITEM_STYLE_MAP.length; i$1++) {
		var oldName = BAR_ITEM_STYLE_MAP[i$1][1];
		var newName = BAR_ITEM_STYLE_MAP[i$1][0];
		if (itemStyle[oldName] != null) {
			itemStyle[newName] = itemStyle[oldName];
			deprecateReplaceLog(oldName, newName);
		}
	}
}
function compatPieLabel(option) {
	if (!option) return;
	if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
		deprecateReplaceLog("label.margin", "label.edgeDistance", "pie");
		option.edgeDistance = option.margin;
	}
}
function compatSunburstState(option) {
	if (!option) return;
	if (option.downplay && !option.blur) {
		option.blur = option.downplay;
		deprecateReplaceLog("downplay", "blur", "sunburst");
	}
}
function compatGraphFocus(option) {
	if (!option) return;
	if (option.focusNodeAdjacency != null) {
		option.emphasis = option.emphasis || {};
		if (option.emphasis.focus == null) {
			deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey");
			option.emphasis.focus = "adjacency";
		}
	}
}
function traverseTree(data, cb) {
	if (data) for (var i$1 = 0; i$1 < data.length; i$1++) {
		cb(data[i$1]);
		data[i$1] && traverseTree(data[i$1].children, cb);
	}
}
function globalBackwardCompat(option, isTheme) {
	globalCompatStyle(option, isTheme);
	option.series = normalizeToArray(option.series);
	each(option.series, function(seriesOpt) {
		if (!isObject(seriesOpt)) return;
		var seriesType$1 = seriesOpt.type;
		if (seriesType$1 === "line") {
			if (seriesOpt.clipOverflow != null) {
				seriesOpt.clip = seriesOpt.clipOverflow;
				deprecateReplaceLog("clipOverflow", "clip", "line");
			}
		} else if (seriesType$1 === "pie" || seriesType$1 === "gauge") {
			if (seriesOpt.clockWise != null) {
				seriesOpt.clockwise = seriesOpt.clockWise;
				deprecateReplaceLog("clockWise", "clockwise");
			}
			compatPieLabel(seriesOpt.label);
			var data = seriesOpt.data;
			if (data && !isTypedArray(data)) for (var i$1 = 0; i$1 < data.length; i$1++) compatPieLabel(data[i$1]);
			if (seriesOpt.hoverOffset != null) {
				seriesOpt.emphasis = seriesOpt.emphasis || {};
				if (seriesOpt.emphasis.scaleSize = null) {
					deprecateReplaceLog("hoverOffset", "emphasis.scaleSize");
					seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
				}
			}
		} else if (seriesType$1 === "gauge") {
			var pointerColor = get(seriesOpt, "pointer.color");
			pointerColor != null && set(seriesOpt, "itemStyle.color", pointerColor);
		} else if (seriesType$1 === "bar") {
			compatBarItemStyle(seriesOpt);
			compatBarItemStyle(seriesOpt.backgroundStyle);
			compatBarItemStyle(seriesOpt.emphasis);
			var data = seriesOpt.data;
			if (data && !isTypedArray(data)) {
				for (var i$1 = 0; i$1 < data.length; i$1++) if (typeof data[i$1] === "object") {
					compatBarItemStyle(data[i$1]);
					compatBarItemStyle(data[i$1] && data[i$1].emphasis);
				}
			}
		} else if (seriesType$1 === "sunburst") {
			var highlightPolicy = seriesOpt.highlightPolicy;
			if (highlightPolicy) {
				seriesOpt.emphasis = seriesOpt.emphasis || {};
				if (!seriesOpt.emphasis.focus) {
					seriesOpt.emphasis.focus = highlightPolicy;
					deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst");
				}
			}
			compatSunburstState(seriesOpt);
			traverseTree(seriesOpt.data, compatSunburstState);
		} else if (seriesType$1 === "graph" || seriesType$1 === "sankey") compatGraphFocus(seriesOpt);
		else if (seriesType$1 === "map") {
			if (seriesOpt.mapType && !seriesOpt.map) {
				deprecateReplaceLog("mapType", "map", "map");
				seriesOpt.map = seriesOpt.mapType;
			}
			if (seriesOpt.mapLocation) {
				deprecateLog("`mapLocation` is not used anymore.");
				defaults(seriesOpt, seriesOpt.mapLocation);
			}
		}
		if (seriesOpt.hoverAnimation != null) {
			seriesOpt.emphasis = seriesOpt.emphasis || {};
			if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
				deprecateReplaceLog("hoverAnimation", "emphasis.scale");
				seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
			}
		}
		compatLayoutProperties(seriesOpt);
	});
	if (option.dataRange) option.visualMap = option.dataRange;
	each(COMPATITABLE_COMPONENTS, function(componentName) {
		var options = option[componentName];
		if (options) {
			if (!isArray(options)) options = [options];
			each(options, function(option$1) {
				compatLayoutProperties(option$1);
			});
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/processor/dataStack.js
function dataStack$1(ecModel) {
	var stackInfoMap = createHashMap();
	ecModel.eachSeries(function(seriesModel) {
		var stack = seriesModel.get("stack");
		if (stack) {
			var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
			var data = seriesModel.getData();
			var stackInfo = {
				stackResultDimension: data.getCalculationInfo("stackResultDimension"),
				stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
				stackedDimension: data.getCalculationInfo("stackedDimension"),
				stackedByDimension: data.getCalculationInfo("stackedByDimension"),
				isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
				data,
				seriesModel
			};
			if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) return;
			stackInfoList.push(stackInfo);
		}
	});
	stackInfoMap.each(function(stackInfoList) {
		if (stackInfoList.length === 0) return;
		if ((stackInfoList[0].seriesModel.get("stackOrder") || "seriesAsc") === "seriesDesc") stackInfoList.reverse();
		each(stackInfoList, function(stackInfo, index) {
			stackInfo.data.setCalculationInfo("stackedOnSeries", index > 0 ? stackInfoList[index - 1].seriesModel : null);
		});
		calculateStack(stackInfoList);
	});
}
function calculateStack(stackInfoList) {
	each(stackInfoList, function(targetStackInfo, idxInStack) {
		var resultVal = [];
		var resultNaN = [NaN, NaN];
		var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
		var targetData = targetStackInfo.data;
		var isStackedByIndex = targetStackInfo.isStackedByIndex;
		var stackStrategy = targetStackInfo.seriesModel.get("stackStrategy") || "samesign";
		targetData.modify(dims, function(v0, v1$1, dataIndex) {
			var sum$1 = targetData.get(targetStackInfo.stackedDimension, dataIndex);
			if (isNaN(sum$1)) return resultNaN;
			var byValue;
			var stackedDataRawIndex;
			if (isStackedByIndex) stackedDataRawIndex = targetData.getRawIndex(dataIndex);
			else byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
			var stackedOver = NaN;
			for (var j = idxInStack - 1; j >= 0; j--) {
				var stackInfo = stackInfoList[j];
				if (!isStackedByIndex) stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
				if (stackedDataRawIndex >= 0) {
					var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
					if (stackStrategy === "all" || stackStrategy === "positive" && val > 0 || stackStrategy === "negative" && val < 0 || stackStrategy === "samesign" && sum$1 >= 0 && val > 0 || stackStrategy === "samesign" && sum$1 <= 0 && val < 0) {
						sum$1 = addSafe(sum$1, val);
						stackedOver = val;
						break;
					}
				}
			}
			resultVal[0] = sum$1;
			resultVal[1] = stackedOver;
			return resultVal;
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/data/Source.js
var SourceImpl = function() {
	function SourceImpl$1(fields) {
		this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
		this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
		this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
		this.startIndex = fields.startIndex || 0;
		this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
		this.metaRawOption = fields.metaRawOption;
		var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
		if (dimensionsDefine) for (var i$1 = 0; i$1 < dimensionsDefine.length; i$1++) {
			var dim = dimensionsDefine[i$1];
			if (dim.type == null) {
				if (guessOrdinal(this, i$1) === BE_ORDINAL.Must) dim.type = "ordinal";
			}
		}
	}
	return SourceImpl$1;
}();
function isSourceInstance(val) {
	return val instanceof SourceImpl;
}
/**
* Create a source from option.
* NOTE: Created source is immutable. Don't change any properties in it.
*/
function createSource(sourceData, thisMetaRawOption, sourceFormat) {
	sourceFormat = sourceFormat || detectSourceFormat(sourceData);
	var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
	var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
	return new SourceImpl({
		data: sourceData,
		sourceFormat,
		seriesLayoutBy,
		dimensionsDefine: determined.dimensionsDefine,
		startIndex: determined.startIndex,
		dimensionsDetectedCount: determined.dimensionsDetectedCount,
		metaRawOption: clone(thisMetaRawOption)
	});
}
/**
* Wrap original series data for some compatibility cases.
*/
function createSourceFromSeriesDataOption(data) {
	return new SourceImpl({
		data,
		sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
	});
}
/**
* Clone source but excludes source data.
*/
function cloneSourceShallow(source) {
	return new SourceImpl({
		data: source.data,
		sourceFormat: source.sourceFormat,
		seriesLayoutBy: source.seriesLayoutBy,
		dimensionsDefine: clone(source.dimensionsDefine),
		startIndex: source.startIndex,
		dimensionsDetectedCount: source.dimensionsDetectedCount
	});
}
/**
* Note: An empty array will be detected as `SOURCE_FORMAT_ARRAY_ROWS`.
*/
function detectSourceFormat(data) {
	var sourceFormat = SOURCE_FORMAT_UNKNOWN;
	if (isTypedArray(data)) sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
	else if (isArray(data)) {
		if (data.length === 0) sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
		for (var i$1 = 0, len$1 = data.length; i$1 < len$1; i$1++) {
			var item = data[i$1];
			if (item == null) continue;
			else if (isArray(item) || isTypedArray(item)) {
				sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
				break;
			} else if (isObject(item)) {
				sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
				break;
			}
		}
	} else if (isObject(data)) {
		for (var key$1 in data) if (hasOwn(data, key$1) && isArrayLike(data[key$1])) {
			sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
			break;
		}
	}
	return sourceFormat;
}
/**
* Determine the source definitions from data standalone dimensions definitions
* are not specified.
*/
function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
	var dimensionsDetectedCount;
	var startIndex;
	if (!data) return {
		dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
		startIndex,
		dimensionsDetectedCount
	};
	if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
		var dataArrayRows = data;
		if (sourceHeader === "auto" || sourceHeader == null) arrayRowsTravelFirst(function(val) {
			if (val != null && val !== "-") if (isString(val)) startIndex ??= 1;
			else startIndex = 0;
		}, seriesLayoutBy, dataArrayRows, 10);
		else startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
		if (!dimensionsDefine && startIndex === 1) {
			dimensionsDefine = [];
			arrayRowsTravelFirst(function(val, index) {
				dimensionsDefine[index] = val != null ? val + "" : "";
			}, seriesLayoutBy, dataArrayRows, Infinity);
		}
		dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
	} else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
		if (!dimensionsDefine) dimensionsDefine = objectRowsCollectDimensions(data);
	} else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
		if (!dimensionsDefine) {
			dimensionsDefine = [];
			each(data, function(colArr, key$1) {
				dimensionsDefine.push(key$1);
			});
		}
	} else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
		var value0 = getDataItemValue(data[0]);
		dimensionsDetectedCount = isArray(value0) && value0.length || 1;
	} else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) assert(!!dimensionsDefine, "dimensions must be given if data is TypedArray.");
	return {
		startIndex,
		dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
		dimensionsDetectedCount
	};
}
function objectRowsCollectDimensions(data) {
	var firstIndex = 0;
	var obj;
	while (firstIndex < data.length && !(obj = data[firstIndex++]));
	if (obj) return keys(obj);
}
function normalizeDimensionsOption(dimensionsDefine) {
	if (!dimensionsDefine) return;
	var nameMap = createHashMap();
	return map(dimensionsDefine, function(rawItem, index) {
		rawItem = isObject(rawItem) ? rawItem : { name: rawItem };
		var item = {
			name: rawItem.name,
			displayName: rawItem.displayName,
			type: rawItem.type
		};
		if (item.name == null) return item;
		item.name += "";
		if (item.displayName == null) item.displayName = item.name;
		var exist = nameMap.get(item.name);
		if (!exist) nameMap.set(item.name, { count: 1 });
		else item.name += "-" + exist.count++;
		return item;
	});
}
function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
	if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) for (var i$1 = 0; i$1 < data.length && i$1 < maxLoop; i$1++) cb(data[i$1] ? data[i$1][0] : null, i$1);
	else {
		var value0 = data[0] || [];
		for (var i$1 = 0; i$1 < value0.length && i$1 < maxLoop; i$1++) cb(value0[i$1], i$1);
	}
}
function shouldRetrieveDataByName(source) {
	var sourceFormat = source.sourceFormat;
	return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
}

//#endregion
//#region node_modules/echarts/lib/data/helper/dataProvider.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var _a, _b, _c, _d;
var providerMethods;
var mountMethods;
/**
* If normal array used, mutable chunk size is supported.
* If typed array used, chunk size must be fixed.
*/
var DefaultDataProvider = function() {
	function DefaultDataProvider$1(sourceParam, dimSize) {
		var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
		this._source = source;
		var data = this._data = source.data;
		var sourceFormat = source.sourceFormat;
		var seriesLayoutBy = source.seriesLayoutBy;
		if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
			if (dimSize == null) throw new Error("Typed array data must specify dimension size");
			this._offset = 0;
			this._dimSize = dimSize;
			this._data = data;
		}
		var validator = rawSourceDataValidatorMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
		validator && validator(data, source.dimensionsDefine);
		mountMethods(this, data, source);
	}
	DefaultDataProvider$1.prototype.getSource = function() {
		return this._source;
	};
	DefaultDataProvider$1.prototype.count = function() {
		return 0;
	};
	DefaultDataProvider$1.prototype.getItem = function(idx, out$1) {};
	DefaultDataProvider$1.prototype.appendData = function(newData) {};
	DefaultDataProvider$1.prototype.clean = function() {};
	DefaultDataProvider$1.protoInitialize = function() {
		var proto = DefaultDataProvider$1.prototype;
		proto.pure = false;
		proto.persistent = true;
	}();
	DefaultDataProvider$1.internalField = function() {
		var _a$1;
		mountMethods = function(provider, data, source) {
			var sourceFormat = source.sourceFormat;
			var seriesLayoutBy = source.seriesLayoutBy;
			var startIndex = source.startIndex;
			var dimsDef = source.dimensionsDefine;
			var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
			assert(methods, "Invalide sourceFormat: " + sourceFormat);
			extend(provider, methods);
			if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
				provider.getItem = getItemForTypedArray;
				provider.count = countForTypedArray;
				provider.fillStorage = fillStorageForTypedArray;
			} else {
				provider.getItem = bind(getRawSourceItemGetter(sourceFormat, seriesLayoutBy), null, data, startIndex, dimsDef);
				provider.count = bind(getRawSourceDataCounter(sourceFormat, seriesLayoutBy), null, data, startIndex, dimsDef);
			}
		};
		var getItemForTypedArray = function(idx, out$1) {
			idx = idx - this._offset;
			out$1 = out$1 || [];
			var data = this._data;
			var dimSize = this._dimSize;
			var offset = dimSize * idx;
			for (var i$1 = 0; i$1 < dimSize; i$1++) out$1[i$1] = data[offset + i$1];
			return out$1;
		};
		var fillStorageForTypedArray = function(start$1, end$1, storage$1, extent) {
			var data = this._data;
			var dimSize = this._dimSize;
			for (var dim = 0; dim < dimSize; dim++) {
				var dimExtent = extent[dim];
				var min$2 = dimExtent[0] == null ? Infinity : dimExtent[0];
				var max$2 = dimExtent[1] == null ? -Infinity : dimExtent[1];
				var count$1 = end$1 - start$1;
				var arr = storage$1[dim];
				for (var i$1 = 0; i$1 < count$1; i$1++) {
					var val = data[i$1 * dimSize + dim];
					arr[start$1 + i$1] = val;
					val < min$2 && (min$2 = val);
					val > max$2 && (max$2 = val);
				}
				dimExtent[0] = min$2;
				dimExtent[1] = max$2;
			}
		};
		var countForTypedArray = function() {
			return this._data ? this._data.length / this._dimSize : 0;
		};
		providerMethods = (_a$1 = {}, _a$1[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
			pure: true,
			appendData: appendDataSimply
		}, _a$1[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
			pure: true,
			appendData: function() {
				throw new Error("Do not support appendData when set seriesLayoutBy: \"row\".");
			}
		}, _a$1[SOURCE_FORMAT_OBJECT_ROWS] = {
			pure: true,
			appendData: appendDataSimply
		}, _a$1[SOURCE_FORMAT_KEYED_COLUMNS] = {
			pure: true,
			appendData: function(newData) {
				var data = this._data;
				each(newData, function(newCol, key$1) {
					var oldCol = data[key$1] || (data[key$1] = []);
					for (var i$1 = 0; i$1 < (newCol || []).length; i$1++) oldCol.push(newCol[i$1]);
				});
			}
		}, _a$1[SOURCE_FORMAT_ORIGINAL] = { appendData: appendDataSimply }, _a$1[SOURCE_FORMAT_TYPED_ARRAY] = {
			persistent: false,
			pure: true,
			appendData: function(newData) {
				assert(isTypedArray(newData), "Added data must be TypedArray if data in initialization is TypedArray");
				this._data = newData;
			},
			clean: function() {
				this._offset += this.count();
				this._data = null;
			}
		}, _a$1);
		function appendDataSimply(newData) {
			for (var i$1 = 0; i$1 < newData.length; i$1++) this._data.push(newData[i$1]);
		}
	}();
	return DefaultDataProvider$1;
}();
var validateSimply = function(rawData) {
	if (!isArray(rawData)) error("series.data or dataset.source must be an array.");
};
/**
* Only run in dev mode - hint users for debug.
*/
var rawSourceDataValidatorMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = validateSimply, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = validateSimply, _a[SOURCE_FORMAT_OBJECT_ROWS] = validateSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, dimsDef) {
	for (var i$1 = 0; i$1 < dimsDef.length; i$1++) if (dimsDef[i$1].name == null) error("dimension name must not be null/undefined.");
}, _a[SOURCE_FORMAT_ORIGINAL] = validateSimply, _a);
var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
	return rawData[idx];
};
var rawSourceItemGetterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef, idx) {
	return rawData[idx + startIndex];
}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef, idx, out$1) {
	idx += startIndex;
	var item = out$1 || [];
	var data = rawData;
	for (var i$1 = 0; i$1 < data.length; i$1++) {
		var row = data[i$1];
		item[i$1] = row ? row[idx] : null;
	}
	return item;
}, _b[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef, idx, out$1) {
	var item = out$1 || [];
	for (var i$1 = 0; i$1 < dimsDef.length; i$1++) {
		var dimName = dimsDef[i$1].name;
		var col = dimName != null ? rawData[dimName] : null;
		item[i$1] = col ? col[idx] : null;
	}
	return item;
}, _b[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _b);
function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
	var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
	assert(method, "Do not support get item on \"" + sourceFormat + "\", \"" + seriesLayoutBy + "\".");
	return method;
}
var countSimply = function(rawData, startIndex, dimsDef) {
	return rawData.length;
};
var rawSourceDataCounterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef) {
	return Math.max(0, rawData.length - startIndex);
}, _c[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef) {
	var row = rawData[0];
	return row ? Math.max(0, row.length - startIndex) : 0;
}, _c[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _c[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef) {
	var dimName = dimsDef[0].name;
	var col = dimName != null ? rawData[dimName] : null;
	return col ? col.length : 0;
}, _c[SOURCE_FORMAT_ORIGINAL] = countSimply, _c);
function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
	var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
	assert(method, "Do not support count on \"" + sourceFormat + "\", \"" + seriesLayoutBy + "\".");
	return method;
}
var getRawValueSimply = function(dataItem, dimIndex, property) {
	return dataItem[dimIndex];
};
var rawSourceValueGetterMap = (_d = {}, _d[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _d[SOURCE_FORMAT_OBJECT_ROWS] = function(dataItem, dimIndex, property) {
	return dataItem[property];
}, _d[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _d[SOURCE_FORMAT_ORIGINAL] = function(dataItem, dimIndex, property) {
	var value = getDataItemValue(dataItem);
	return !(value instanceof Array) ? value : value[dimIndex];
}, _d[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _d);
function getRawSourceValueGetter(sourceFormat) {
	var method = rawSourceValueGetterMap[sourceFormat];
	assert(method, "Do not support get value on \"" + sourceFormat + "\".");
	return method;
}
function getMethodMapKey(sourceFormat, seriesLayoutBy) {
	return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
}
function retrieveRawValue(data, dataIndex, dim) {
	if (!data) return;
	var dataItem = data.getRawDataItem(dataIndex);
	if (dataItem == null) return;
	var store = data.getStore();
	var sourceFormat = store.getSource().sourceFormat;
	if (dim != null) {
		var dimIndex = data.getDimensionIndex(dim);
		var property = store.getDimensionProperty(dimIndex);
		return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);
	} else {
		var result = dataItem;
		if (sourceFormat === SOURCE_FORMAT_ORIGINAL) result = getDataItemValue(dataItem);
		return result;
	}
}

//#endregion
//#region node_modules/echarts/lib/model/mixin/dataFormat.js
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
var DataFormatMixin = function() {
	function DataFormatMixin$1() {}
	/**
	* Get params for formatter
	*/
	DataFormatMixin$1.prototype.getDataParams = function(dataIndex, dataType) {
		var data = this.getData(dataType);
		var rawValue = this.getRawValue(dataIndex, dataType);
		var rawDataIndex = data.getRawIndex(dataIndex);
		var name = data.getName(dataIndex);
		var itemOpt = data.getRawDataItem(dataIndex);
		var style = data.getItemVisual(dataIndex, "style");
		var color$2 = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
		var borderColor = style && style.stroke;
		var mainType = this.mainType;
		var isSeries$1 = mainType === "series";
		var userOutput = data.userOutput && data.userOutput.get();
		return {
			componentType: mainType,
			componentSubType: this.subType,
			componentIndex: this.componentIndex,
			seriesType: isSeries$1 ? this.subType : null,
			seriesIndex: this.seriesIndex,
			seriesId: isSeries$1 ? this.id : null,
			seriesName: isSeries$1 ? this.name : null,
			name,
			dataIndex: rawDataIndex,
			data: itemOpt,
			dataType,
			value: rawValue,
			color: color$2,
			borderColor,
			dimensionNames: userOutput ? userOutput.fullDimensions : null,
			encode: userOutput ? userOutput.encode : null,
			$vars: [
				"seriesName",
				"name",
				"value"
			]
		};
	};
	/**
	* Format label
	* @param dataIndex
	* @param status 'normal' by default
	* @param dataType
	* @param labelDimIndex Only used in some chart that
	*        use formatter in different dimensions, like radar.
	* @param formatter Formatter given outside.
	* @return return null/undefined if no formatter
	*/
	DataFormatMixin$1.prototype.getFormattedLabel = function(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
		status = status || "normal";
		var data = this.getData(dataType);
		var params = this.getDataParams(dataIndex, dataType);
		if (extendParams) params.value = extendParams.interpolatedValue;
		if (labelDimIndex != null && isArray(params.value)) params.value = params.value[labelDimIndex];
		if (!formatter) formatter = data.getItemModel(dataIndex).get(status === "normal" ? ["label", "formatter"] : [
			status,
			"label",
			"formatter"
		]);
		if (isFunction(formatter)) {
			params.status = status;
			params.dimensionIndex = labelDimIndex;
			return formatter(params);
		} else if (isString(formatter)) return formatTpl(formatter, params).replace(DIMENSION_LABEL_REG, function(origin, dimStr) {
			var len$1 = dimStr.length;
			var dimLoose = dimStr;
			if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len$1 - 1) === "]") {
				dimLoose = +dimLoose.slice(1, len$1 - 1);
				if (isNaN(dimLoose)) error("Invalide label formatter: @" + dimStr + ", only support @[0], @[1], @[2], ...");
			}
			var val = retrieveRawValue(data, dataIndex, dimLoose);
			if (extendParams && isArray(extendParams.interpolatedValue)) {
				var dimIndex = data.getDimensionIndex(dimLoose);
				if (dimIndex >= 0) val = extendParams.interpolatedValue[dimIndex];
			}
			return val != null ? val + "" : "";
		});
	};
	/**
	* Get raw value in option
	*/
	DataFormatMixin$1.prototype.getRawValue = function(idx, dataType) {
		return retrieveRawValue(this.getData(dataType), idx);
	};
	/**
	* Should be implemented.
	* @param {number} dataIndex
	* @param {boolean} [multipleSeries=false]
	* @param {string} [dataType]
	*/
	DataFormatMixin$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {};
	return DataFormatMixin$1;
}();
/**
* For backward compat, normalize the return from `formatTooltip`.
*/
function normalizeTooltipFormatResult(result) {
	var markupText;
	var markupFragment;
	if (isObject(result)) if (result.type) markupFragment = result;
	else console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(result));
	else markupText = result;
	return {
		text: markupText,
		frag: markupFragment
	};
}

//#endregion
//#region node_modules/echarts/lib/core/task.js
/**
* @param {Object} define
* @return See the return of `createTask`.
*/
function createTask(define) {
	return new Task(define);
}
var Task = function() {
	function Task$1(define) {
		define = define || {};
		this._reset = define.reset;
		this._plan = define.plan;
		this._count = define.count;
		this._onDirty = define.onDirty;
		this._dirty = true;
	}
	/**
	* @param step Specified step.
	* @param skip Skip customer perform call.
	* @param modBy Sampling window size.
	* @param modDataCount Sampling count.
	* @return whether unfinished.
	*/
	Task$1.prototype.perform = function(performArgs) {
		var upTask = this._upstream;
		var skip = performArgs && performArgs.skip;
		if (this._dirty && upTask) {
			var context = this.context;
			context.data = context.outputData = upTask.context.outputData;
		}
		if (this.__pipeline) this.__pipeline.currentTask = this;
		var planResult;
		if (this._plan && !skip) planResult = this._plan(this.context);
		var lastModBy = normalizeModBy(this._modBy);
		var lastModDataCount = this._modDataCount || 0;
		var modBy = normalizeModBy(performArgs && performArgs.modBy);
		var modDataCount = performArgs && performArgs.modDataCount || 0;
		if (lastModBy !== modBy || lastModDataCount !== modDataCount) planResult = "reset";
		function normalizeModBy(val) {
			!(val >= 1) && (val = 1);
			return val;
		}
		var forceFirstProgress;
		if (this._dirty || planResult === "reset") {
			this._dirty = false;
			forceFirstProgress = this._doReset(skip);
		}
		this._modBy = modBy;
		this._modDataCount = modDataCount;
		var step = performArgs && performArgs.step;
		if (upTask) {
			assert(upTask._outputDueEnd != null);
			this._dueEnd = upTask._outputDueEnd;
		} else {
			assert(!this._progress || this._count);
			this._dueEnd = this._count ? this._count(this.context) : Infinity;
		}
		if (this._progress) {
			var start$1 = this._dueIndex;
			var end$1 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
			if (!skip && (forceFirstProgress || start$1 < end$1)) {
				var progress = this._progress;
				if (isArray(progress)) for (var i$1 = 0; i$1 < progress.length; i$1++) this._doProgress(progress[i$1], start$1, end$1, modBy, modDataCount);
				else this._doProgress(progress, start$1, end$1, modBy, modDataCount);
			}
			this._dueIndex = end$1;
			var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end$1;
			assert(outputDueEnd >= this._outputDueEnd);
			this._outputDueEnd = outputDueEnd;
		} else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
		return this.unfinished();
	};
	Task$1.prototype.dirty = function() {
		this._dirty = true;
		this._onDirty && this._onDirty(this.context);
	};
	Task$1.prototype._doProgress = function(progress, start$1, end$1, modBy, modDataCount) {
		iterator.reset(start$1, end$1, modBy, modDataCount);
		this._callingProgress = progress;
		this._callingProgress({
			start: start$1,
			end: end$1,
			count: end$1 - start$1,
			next: iterator.next
		}, this.context);
	};
	Task$1.prototype._doReset = function(skip) {
		this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
		this._settedOutputEnd = null;
		var progress;
		var forceFirstProgress;
		if (!skip && this._reset) {
			progress = this._reset(this.context);
			if (progress && progress.progress) {
				forceFirstProgress = progress.forceFirstProgress;
				progress = progress.progress;
			}
			if (isArray(progress) && !progress.length) progress = null;
		}
		this._progress = progress;
		this._modBy = this._modDataCount = null;
		var downstream = this._downstream;
		downstream && downstream.dirty();
		return forceFirstProgress;
	};
	Task$1.prototype.unfinished = function() {
		return this._progress && this._dueIndex < this._dueEnd;
	};
	/**
	* @param downTask The downstream task.
	* @return The downstream task.
	*/
	Task$1.prototype.pipe = function(downTask) {
		assert(downTask && !downTask._disposed && downTask !== this);
		if (this._downstream !== downTask || this._dirty) {
			this._downstream = downTask;
			downTask._upstream = this;
			downTask.dirty();
		}
	};
	Task$1.prototype.dispose = function() {
		if (this._disposed) return;
		this._upstream && (this._upstream._downstream = null);
		this._downstream && (this._downstream._upstream = null);
		this._dirty = false;
		this._disposed = true;
	};
	Task$1.prototype.getUpstream = function() {
		return this._upstream;
	};
	Task$1.prototype.getDownstream = function() {
		return this._downstream;
	};
	Task$1.prototype.setOutputEnd = function(end$1) {
		this._outputDueEnd = this._settedOutputEnd = end$1;
	};
	return Task$1;
}();
var iterator = function() {
	var end$1;
	var current;
	var modBy;
	var modDataCount;
	var winCount;
	var it = { reset: function(s, e$1, sStep, sCount) {
		current = s;
		end$1 = e$1;
		modBy = sStep;
		modDataCount = sCount;
		winCount = Math.ceil(modDataCount / modBy);
		it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
	} };
	return it;
	function sequentialNext() {
		return current < end$1 ? current++ : null;
	}
	function modNext() {
		var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
		var result = current >= end$1 ? null : dataIndex < modDataCount ? dataIndex : current;
		current++;
		return result;
	}
}();

//#endregion
//#region node_modules/echarts/lib/data/helper/dataValueHelper.js
/**
* Convert raw the value in to inner value in List.
*
* [Performance sensitive]
*
* [Caution]: this is the key logic of user value parser.
* For backward compatibility, do not modify it until you have to!
*/
function parseDataValue(value, opt) {
	var dimType = opt && opt.type;
	if (dimType === "ordinal") return value;
	if (dimType === "time" && !isNumber(value) && value != null && value !== "-") value = +parseDate(value);
	return value == null || value === "" ? NaN : Number(value);
}
var valueParserMap = createHashMap({
	"number": function(val) {
		return parseFloat(val);
	},
	"time": function(val) {
		return +parseDate(val);
	},
	"trim": function(val) {
		return isString(val) ? trim(val) : val;
	}
});
function getRawValueParser(type) {
	return valueParserMap.get(type);
}
var ORDER_COMPARISON_OP_MAP = {
	lt: function(lval, rval) {
		return lval < rval;
	},
	lte: function(lval, rval) {
		return lval <= rval;
	},
	gt: function(lval, rval) {
		return lval > rval;
	},
	gte: function(lval, rval) {
		return lval >= rval;
	}
};
var FilterOrderComparator = function() {
	function FilterOrderComparator$1(op, rval) {
		if (!isNumber(rval)) {
			var errMsg = "";
			errMsg = "rvalue of \"<\", \">\", \"<=\", \">=\" can only be number in filter.";
			throwError(errMsg);
		}
		this._opFn = ORDER_COMPARISON_OP_MAP[op];
		this._rvalFloat = numericToNumber(rval);
	}
	FilterOrderComparator$1.prototype.evaluate = function(lval) {
		return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);
	};
	return FilterOrderComparator$1;
}();
var SortOrderComparator = function() {
	/**
	* @param order by default: 'asc'
	* @param incomparable by default: Always on the tail.
	*        That is, if 'asc' => 'max', if 'desc' => 'min'
	*        See the definition of "incomparable" in [SORT_COMPARISON_RULE].
	*/
	function SortOrderComparator$1(order, incomparable) {
		var isDesc = order === "desc";
		this._resultLT = isDesc ? 1 : -1;
		if (incomparable == null) incomparable = isDesc ? "min" : "max";
		this._incomparable = incomparable === "min" ? -Infinity : Infinity;
	}
	SortOrderComparator$1.prototype.evaluate = function(lval, rval) {
		var lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);
		var rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);
		var lvalNotNumeric = isNaN(lvalFloat);
		var rvalNotNumeric = isNaN(rvalFloat);
		if (lvalNotNumeric) lvalFloat = this._incomparable;
		if (rvalNotNumeric) rvalFloat = this._incomparable;
		if (lvalNotNumeric && rvalNotNumeric) {
			var lvalIsStr = isString(lval);
			var rvalIsStr = isString(rval);
			if (lvalIsStr) lvalFloat = rvalIsStr ? lval : 0;
			if (rvalIsStr) rvalFloat = lvalIsStr ? rval : 0;
		}
		return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
	};
	return SortOrderComparator$1;
}();
var FilterEqualityComparator = function() {
	function FilterEqualityComparator$1(isEq, rval) {
		this._rval = rval;
		this._isEQ = isEq;
		this._rvalTypeof = typeof rval;
		this._rvalFloat = numericToNumber(rval);
	}
	FilterEqualityComparator$1.prototype.evaluate = function(lval) {
		var eqResult = lval === this._rval;
		if (!eqResult) {
			var lvalTypeof = typeof lval;
			if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === "number" || this._rvalTypeof === "number")) eqResult = numericToNumber(lval) === this._rvalFloat;
		}
		return this._isEQ ? eqResult : !eqResult;
	};
	return FilterEqualityComparator$1;
}();
/**
* [FILTER_COMPARISON_RULE]
* `lt`|`lte`|`gt`|`gte`:
* + rval must be a number. And lval will be converted to number (`numericToNumber`) to compare.
* `eq`:
* + If same type, compare with `===`.
* + If there is one number, convert to number (`numericToNumber`) to compare.
* + Else return `false`.
* `ne`:
* + Not `eq`.
*
*
* [SORT_COMPARISON_RULE]
* All the values are grouped into three categories:
* + "numeric" (number and numeric string)
* + "non-numeric-string" (string that excluding numeric string)
* + "others"
* "numeric" vs "numeric": values are ordered by number order.
* "non-numeric-string" vs "non-numeric-string": values are ordered by ES spec (#sec-abstract-relational-comparison).
* "others" vs "others": do not change order (always return 0).
* "numeric" vs "non-numeric-string": "non-numeric-string" is treated as "incomparable".
* "number" vs "others": "others" is treated as "incomparable".
* "non-numeric-string" vs "others": "others" is treated as "incomparable".
* "incomparable" will be seen as -Infinity or Infinity (depends on the settings).
* MEMO:
*   Non-numeric string sort makes sense when we need to put the items with the same tag together.
*   But if we support string sort, we still need to avoid the misleading like `'2' > '12'`,
*   So we treat "numeric-string" sorted by number order rather than string comparison.
*
*
* [CHECK_LIST_OF_THE_RULE_DESIGN]
* + Do not support string comparison until required. And also need to
*   avoid the misleading of "2" > "12".
* + Should avoid the misleading case:
*   `" 22 " gte "22"` is `true` but `" 22 " eq "22"` is `false`.
* + JS bad case should be avoided: null <= 0, [] <= 0, ' ' <= 0, ...
* + Only "numeric" can be converted to comparable number, otherwise converted to NaN.
*   See `util/number.ts#numericToNumber`.
*
* @return If `op` is not `RelationalOperator`, return null;
*/
function createFilterComparator(op, rval) {
	return op === "eq" || op === "ne" ? new FilterEqualityComparator(op === "eq", rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;
}

//#endregion
//#region node_modules/echarts/lib/data/helper/transform.js
/**
* TODO: disable writable.
* This structure will be exposed to users.
*/
var ExternalSource = function() {
	function ExternalSource$1() {}
	ExternalSource$1.prototype.getRawData = function() {
		throw new Error("not supported");
	};
	ExternalSource$1.prototype.getRawDataItem = function(dataIndex) {
		throw new Error("not supported");
	};
	ExternalSource$1.prototype.cloneRawData = function() {};
	/**
	* @return If dimension not found, return null/undefined.
	*/
	ExternalSource$1.prototype.getDimensionInfo = function(dim) {};
	/**
	* dimensions defined if and only if either:
	* (a) dataset.dimensions are declared.
	* (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).
	* If dimensions are defined, `dimensionInfoAll` is corresponding to
	* the defined dimensions.
	* Otherwise, `dimensionInfoAll` is determined by data columns.
	* @return Always return an array (even empty array).
	*/
	ExternalSource$1.prototype.cloneAllDimensionInfo = function() {};
	ExternalSource$1.prototype.count = function() {};
	/**
	* Only support by dimension index.
	* No need to support by dimension name in transform function,
	* because transform function is not case-specific, no need to use name literally.
	*/
	ExternalSource$1.prototype.retrieveValue = function(dataIndex, dimIndex) {};
	ExternalSource$1.prototype.retrieveValueFromItem = function(dataItem, dimIndex) {};
	ExternalSource$1.prototype.convertValue = function(rawVal, dimInfo) {
		return parseDataValue(rawVal, dimInfo);
	};
	return ExternalSource$1;
}();
function createExternalSource(internalSource, externalTransform) {
	var extSource = new ExternalSource();
	var data = internalSource.data;
	var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
	var sourceHeaderCount = internalSource.startIndex;
	var errMsg = "";
	if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
		errMsg = "`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform.";
		throwError(errMsg);
	}
	var dimensions = [];
	var dimsByName = {};
	var dimsDef = internalSource.dimensionsDefine;
	if (dimsDef) each(dimsDef, function(dimDef, idx) {
		var name = dimDef.name;
		var dimDefExt = {
			index: idx,
			name,
			displayName: dimDef.displayName
		};
		dimensions.push(dimDefExt);
		if (name != null) {
			var errMsg_1 = "";
			if (hasOwn(dimsByName, name)) {
				errMsg_1 = "dimension name \"" + name + "\" duplicated.";
				throwError(errMsg_1);
			}
			dimsByName[name] = dimDefExt;
		}
	});
	else for (var i$1 = 0; i$1 < internalSource.dimensionsDetectedCount || 0; i$1++) dimensions.push({ index: i$1 });
	var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
	if (externalTransform.__isBuiltIn) {
		extSource.getRawDataItem = function(dataIndex) {
			return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
		};
		extSource.getRawData = bind(getRawData, null, internalSource);
	}
	extSource.cloneRawData = bind(cloneRawData, null, internalSource);
	extSource.count = bind(getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN), null, data, sourceHeaderCount, dimensions);
	var rawValueGetter = getRawSourceValueGetter(sourceFormat);
	extSource.retrieveValue = function(dataIndex, dimIndex) {
		return retrieveValueFromItem(rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex), dimIndex);
	};
	var retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
		if (dataItem == null) return;
		var dimDef = dimensions[dimIndex];
		if (dimDef) return rawValueGetter(dataItem, dimIndex, dimDef.name);
	};
	extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);
	extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);
	return extSource;
}
function getRawData(upstream) {
	var sourceFormat = upstream.sourceFormat;
	if (!isSupportedSourceFormat(sourceFormat)) {
		var errMsg = "";
		errMsg = "`getRawData` is not supported in source format " + sourceFormat;
		throwError(errMsg);
	}
	return upstream.data;
}
function cloneRawData(upstream) {
	var sourceFormat = upstream.sourceFormat;
	var data = upstream.data;
	if (!isSupportedSourceFormat(sourceFormat)) {
		var errMsg = "";
		errMsg = "`cloneRawData` is not supported in source format " + sourceFormat;
		throwError(errMsg);
	}
	if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
		var result = [];
		for (var i$1 = 0, len$1 = data.length; i$1 < len$1; i$1++) result.push(data[i$1].slice());
		return result;
	} else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
		var result = [];
		for (var i$1 = 0, len$1 = data.length; i$1 < len$1; i$1++) result.push(extend({}, data[i$1]));
		return result;
	}
}
function getDimensionInfo(dimensions, dimsByName, dim) {
	if (dim == null) return;
	if (isNumber(dim) || !isNaN(dim) && !hasOwn(dimsByName, dim)) return dimensions[dim];
	else if (hasOwn(dimsByName, dim)) return dimsByName[dim];
}
function cloneAllDimensionInfo(dimensions) {
	return clone(dimensions);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(externalTransform) {
	externalTransform = clone(externalTransform);
	var type = externalTransform.type;
	var errMsg = "";
	if (!type) {
		errMsg = "Must have a `type` when `registerTransform`.";
		throwError(errMsg);
	}
	var typeParsed = type.split(":");
	if (typeParsed.length !== 2) {
		errMsg = "Name must include namespace like \"ns:regression\".";
		throwError(errMsg);
	}
	var isBuiltIn = false;
	if (typeParsed[0] === "echarts") {
		type = typeParsed[1];
		isBuiltIn = true;
	}
	externalTransform.__isBuiltIn = isBuiltIn;
	externalTransformMap.set(type, externalTransform);
}
function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
	var pipedTransOption = normalizeToArray(rawTransOption);
	var pipeLen = pipedTransOption.length;
	var errMsg = "";
	if (!pipeLen) {
		errMsg = "If `transform` declared, it should at least contain one transform.";
		throwError(errMsg);
	}
	for (var i$1 = 0, len$1 = pipeLen; i$1 < len$1; i$1++) {
		var transOption = pipedTransOption[i$1];
		sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i$1);
		if (i$1 !== len$1 - 1) sourceList.length = Math.max(sourceList.length, 1);
	}
	return sourceList;
}
function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
	var errMsg = "";
	if (!upSourceList.length) {
		errMsg = "Must have at least one upstream dataset.";
		throwError(errMsg);
	}
	if (!isObject(transOption)) {
		errMsg = "transform declaration must be an object rather than " + typeof transOption + ".";
		throwError(errMsg);
	}
	var transType = transOption.type;
	var externalTransform = externalTransformMap.get(transType);
	if (!externalTransform) {
		errMsg = "Can not find transform on type \"" + transType + "\".";
		throwError(errMsg);
	}
	var extUpSourceList = map(upSourceList, function(upSource) {
		return createExternalSource(upSource, externalTransform);
	});
	var resultList = normalizeToArray(externalTransform.transform({
		upstream: extUpSourceList[0],
		upstreamList: extUpSourceList,
		config: clone(transOption.config)
	}));
	if (transOption.print) log(map(resultList, function(extSource) {
		var pipeIndexStr = pipeIndex != null ? " === pipe index: " + pipeIndex : "";
		return [
			"=== dataset index: " + infoForPrint.datasetIndex + pipeIndexStr + " ===",
			"- transform result data:",
			makePrintable(extSource.data),
			"- transform result dimensions:",
			makePrintable(extSource.dimensions)
		].join("\n");
	}).join("\n"));
	return map(resultList, function(result, resultIndex) {
		var errMsg$1 = "";
		if (!isObject(result)) {
			errMsg$1 = "A transform should not return some empty results.";
			throwError(errMsg$1);
		}
		if (!result.data) {
			errMsg$1 = "Transform result data should be not be null or undefined";
			throwError(errMsg$1);
		}
		if (!isSupportedSourceFormat(detectSourceFormat(result.data))) {
			errMsg$1 = "Transform result data should be array rows or object rows.";
			throwError(errMsg$1);
		}
		var resultMetaRawOption;
		var firstUpSource = upSourceList[0];
		/**
		* Intuitively, the end users known the content of the original `dataset.source`,
		* calucating the transform result in mind.
		* Suppose the original `dataset.source` is:
		* ```js
		* [
		*     ['product', '2012', '2013', '2014', '2015'],
		*     ['AAA', 41.1, 30.4, 65.1, 53.3],
		*     ['BBB', 86.5, 92.1, 85.7, 83.1],
		*     ['CCC', 24.1, 67.2, 79.5, 86.4]
		* ]
		* ```
		* The dimension info have to be detected from the source data.
		* Some of the transformers (like filter, sort) will follow the dimension info
		* of upstream, while others use new dimensions (like aggregate).
		* Transformer can output a field `dimensions` to define the its own output dimensions.
		* We also allow transformers to ignore the output `dimensions` field, and
		* inherit the upstream dimensions definition. It can reduce the burden of handling
		* dimensions in transformers.
		*
		* See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.
		*/
		if (firstUpSource && resultIndex === 0 && !result.dimensions) {
			var startIndex = firstUpSource.startIndex;
			if (startIndex) result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
			resultMetaRawOption = {
				seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
				sourceHeader: startIndex,
				dimensions: firstUpSource.metaRawOption.dimensions
			};
		} else resultMetaRawOption = {
			seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
			sourceHeader: 0,
			dimensions: result.dimensions
		};
		return createSource(result.data, resultMetaRawOption, null);
	});
}
function isSupportedSourceFormat(sourceFormat) {
	return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
}

//#endregion
//#region node_modules/echarts/lib/data/DataStore.js
var UNDEFINED = "undefined";
var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
/**
* Multi dimensional data store
*/
var dataCtors = {
	"float": CtorFloat64Array,
	"int": CtorInt32Array,
	"ordinal": Array,
	"number": Array,
	"time": CtorFloat64Array
};
var defaultDimValueGetters;
function getIndicesCtor(rawCount) {
	return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
	return [Infinity, -Infinity];
}
function cloneChunk(originalChunk) {
	var Ctor = originalChunk.constructor;
	return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}
function prepareStore(store, dimIdx, dimType, end$1, append) {
	var DataCtor = dataCtors[dimType || "float"];
	if (append) {
		var oldStore = store[dimIdx];
		var oldLen = oldStore && oldStore.length;
		if (!(oldLen === end$1)) {
			var newStore = new DataCtor(end$1);
			for (var j = 0; j < oldLen; j++) newStore[j] = oldStore[j];
			store[dimIdx] = newStore;
		}
	} else store[dimIdx] = new DataCtor(end$1);
}
/**
* Basically, DataStore API keep immutable.
*/
var DataStore = function() {
	function DataStore$1() {
		this._chunks = [];
		this._rawExtent = [];
		this._extent = [];
		this._count = 0;
		this._rawCount = 0;
		this._calcDimNameToIdx = createHashMap();
	}
	/**
	* Initialize from data
	*/
	DataStore$1.prototype.initData = function(provider, inputDimensions, dimValueGetter) {
		assert(isFunction(provider.getItem) && isFunction(provider.count), "Invalid data provider.");
		this._provider = provider;
		this._chunks = [];
		this._indices = null;
		this.getRawIndex = this._getRawIdxIdentity;
		var source = provider.getSource();
		var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
		this._dimValueGetter = dimValueGetter || defaultGetter;
		this._rawExtent = [];
		var willRetrieveDataByName = shouldRetrieveDataByName(source);
		this._dimensions = map(inputDimensions, function(dim) {
			if (willRetrieveDataByName) assert(dim.property != null);
			return {
				type: dim.type,
				property: dim.property
			};
		});
		this._initDataFromProvider(0, provider.count());
	};
	DataStore$1.prototype.getProvider = function() {
		return this._provider;
	};
	/**
	* Caution: even when a `source` instance owned by a series, the created data store
	* may still be shared by different sereis (the source hash does not use all `source`
	* props, see `sourceManager`). In this case, the `source` props that are not used in
	* hash (like `source.dimensionDefine`) probably only belongs to a certain series and
	* thus should not be fetch here.
	*/
	DataStore$1.prototype.getSource = function() {
		return this._provider.getSource();
	};
	/**
	* @caution Only used in dataStack.
	*/
	DataStore$1.prototype.ensureCalculationDimension = function(dimName, type) {
		var calcDimNameToIdx = this._calcDimNameToIdx;
		var dimensions = this._dimensions;
		var calcDimIdx = calcDimNameToIdx.get(dimName);
		if (calcDimIdx != null) {
			if (dimensions[calcDimIdx].type === type) return calcDimIdx;
		} else calcDimIdx = dimensions.length;
		dimensions[calcDimIdx] = { type };
		calcDimNameToIdx.set(dimName, calcDimIdx);
		this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
		this._rawExtent[calcDimIdx] = getInitialExtent();
		return calcDimIdx;
	};
	DataStore$1.prototype.collectOrdinalMeta = function(dimIdx, ordinalMeta) {
		var chunk = this._chunks[dimIdx];
		var dim = this._dimensions[dimIdx];
		var rawExtents = this._rawExtent;
		var offset = dim.ordinalOffset || 0;
		var len$1 = chunk.length;
		if (offset === 0) rawExtents[dimIdx] = getInitialExtent();
		var dimRawExtent = rawExtents[dimIdx];
		for (var i$1 = offset; i$1 < len$1; i$1++) {
			var val = chunk[i$1] = ordinalMeta.parseAndCollect(chunk[i$1]);
			if (!isNaN(val)) {
				dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
				dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
			}
		}
		dim.ordinalMeta = ordinalMeta;
		dim.ordinalOffset = len$1;
		dim.type = "ordinal";
	};
	DataStore$1.prototype.getOrdinalMeta = function(dimIdx) {
		return this._dimensions[dimIdx].ordinalMeta;
	};
	DataStore$1.prototype.getDimensionProperty = function(dimIndex) {
		var item = this._dimensions[dimIndex];
		return item && item.property;
	};
	/**
	* Caution: Can be only called on raw data (before `this._indices` created).
	*/
	DataStore$1.prototype.appendData = function(data) {
		assert(!this._indices, "appendData can only be called on raw data.");
		var provider = this._provider;
		var start$1 = this.count();
		provider.appendData(data);
		var end$1 = provider.count();
		if (!provider.persistent) end$1 += start$1;
		if (start$1 < end$1) this._initDataFromProvider(start$1, end$1, true);
		return [start$1, end$1];
	};
	DataStore$1.prototype.appendValues = function(values, minFillLen) {
		var chunks = this._chunks;
		var dimensions = this._dimensions;
		var dimLen = dimensions.length;
		var rawExtent = this._rawExtent;
		var start$1 = this.count();
		var end$1 = start$1 + Math.max(values.length, minFillLen || 0);
		for (var i$1 = 0; i$1 < dimLen; i$1++) {
			var dim = dimensions[i$1];
			prepareStore(chunks, i$1, dim.type, end$1, true);
		}
		var emptyDataItem = [];
		for (var idx = start$1; idx < end$1; idx++) {
			var sourceIdx = idx - start$1;
			for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
				var dim = dimensions[dimIdx];
				var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
				chunks[dimIdx][idx] = val;
				var dimRawExtent = rawExtent[dimIdx];
				val < dimRawExtent[0] && (dimRawExtent[0] = val);
				val > dimRawExtent[1] && (dimRawExtent[1] = val);
			}
		}
		this._rawCount = this._count = end$1;
		return {
			start: start$1,
			end: end$1
		};
	};
	DataStore$1.prototype._initDataFromProvider = function(start$1, end$1, append) {
		var provider = this._provider;
		var chunks = this._chunks;
		var dimensions = this._dimensions;
		var dimLen = dimensions.length;
		var rawExtent = this._rawExtent;
		var dimNames = map(dimensions, function(dim$1) {
			return dim$1.property;
		});
		for (var i$1 = 0; i$1 < dimLen; i$1++) {
			var dim = dimensions[i$1];
			if (!rawExtent[i$1]) rawExtent[i$1] = getInitialExtent();
			prepareStore(chunks, i$1, dim.type, end$1, append);
		}
		if (provider.fillStorage) provider.fillStorage(start$1, end$1, chunks, rawExtent);
		else {
			var dataItem = [];
			for (var idx = start$1; idx < end$1; idx++) {
				dataItem = provider.getItem(idx, dataItem);
				for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
					var dimStorage = chunks[dimIdx];
					var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
					dimStorage[idx] = val;
					var dimRawExtent = rawExtent[dimIdx];
					val < dimRawExtent[0] && (dimRawExtent[0] = val);
					val > dimRawExtent[1] && (dimRawExtent[1] = val);
				}
			}
		}
		if (!provider.persistent && provider.clean) provider.clean();
		this._rawCount = this._count = end$1;
		this._extent = [];
	};
	DataStore$1.prototype.count = function() {
		return this._count;
	};
	/**
	* Get value. Return NaN if idx is out of range.
	*/
	DataStore$1.prototype.get = function(dim, idx) {
		if (!(idx >= 0 && idx < this._count)) return NaN;
		var dimStore = this._chunks[dim];
		return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
	};
	DataStore$1.prototype.getValues = function(dimensions, idx) {
		var values = [];
		var dimArr = [];
		if (idx == null) {
			idx = dimensions;
			dimensions = [];
			for (var i$1 = 0; i$1 < this._dimensions.length; i$1++) dimArr.push(i$1);
		} else dimArr = dimensions;
		for (var i$1 = 0, len$1 = dimArr.length; i$1 < len$1; i$1++) values.push(this.get(dimArr[i$1], idx));
		return values;
	};
	/**
	* @param dim concrete dim
	*/
	DataStore$1.prototype.getByRawIndex = function(dim, rawIdx) {
		if (!(rawIdx >= 0 && rawIdx < this._rawCount)) return NaN;
		var dimStore = this._chunks[dim];
		return dimStore ? dimStore[rawIdx] : NaN;
	};
	/**
	* Get sum of data in one dimension
	*/
	DataStore$1.prototype.getSum = function(dim) {
		var dimData = this._chunks[dim];
		var sum$1 = 0;
		if (dimData) for (var i$1 = 0, len$1 = this.count(); i$1 < len$1; i$1++) {
			var value = this.get(dim, i$1);
			if (!isNaN(value)) sum$1 += value;
		}
		return sum$1;
	};
	/**
	* Get median of data in one dimension
	*/
	DataStore$1.prototype.getMedian = function(dim) {
		var dimDataArray = [];
		this.each([dim], function(val) {
			if (!isNaN(val)) dimDataArray.push(val);
		});
		var sortedDimDataArray = dimDataArray.sort(function(a, b) {
			return a - b;
		});
		var len$1 = this.count();
		return len$1 === 0 ? 0 : len$1 % 2 === 1 ? sortedDimDataArray[(len$1 - 1) / 2] : (sortedDimDataArray[len$1 / 2] + sortedDimDataArray[len$1 / 2 - 1]) / 2;
	};
	/**
	* Retrieve the index with given raw data index.
	*/
	DataStore$1.prototype.indexOfRawIndex = function(rawIndex) {
		if (rawIndex >= this._rawCount || rawIndex < 0) return -1;
		if (!this._indices) return rawIndex;
		var indices = this._indices;
		var rawDataIndex = indices[rawIndex];
		if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) return rawIndex;
		var left = 0;
		var right = this._count - 1;
		while (left <= right) {
			var mid = (left + right) / 2 | 0;
			if (indices[mid] < rawIndex) left = mid + 1;
			else if (indices[mid] > rawIndex) right = mid - 1;
			else return mid;
		}
		return -1;
	};
	DataStore$1.prototype.getIndices = function() {
		var newIndices;
		var indices = this._indices;
		if (indices) {
			var Ctor = indices.constructor;
			var thisCount = this._count;
			if (Ctor === Array) {
				newIndices = new Ctor(thisCount);
				for (var i$1 = 0; i$1 < thisCount; i$1++) newIndices[i$1] = indices[i$1];
			} else newIndices = new Ctor(indices.buffer, 0, thisCount);
		} else {
			var Ctor = getIndicesCtor(this._rawCount);
			newIndices = new Ctor(this.count());
			for (var i$1 = 0; i$1 < newIndices.length; i$1++) newIndices[i$1] = i$1;
		}
		return newIndices;
	};
	/**
	* Data filter.
	*/
	DataStore$1.prototype.filter = function(dims, cb) {
		if (!this._count) return this;
		var newStore = this.clone();
		var count$1 = newStore.count();
		var newIndices = new (getIndicesCtor(newStore._rawCount))(count$1);
		var value = [];
		var dimSize = dims.length;
		var offset = 0;
		var dim0 = dims[0];
		var chunks = newStore._chunks;
		for (var i$1 = 0; i$1 < count$1; i$1++) {
			var keep = void 0;
			var rawIdx = newStore.getRawIndex(i$1);
			if (dimSize === 0) keep = cb(i$1);
			else if (dimSize === 1) {
				var val = chunks[dim0][rawIdx];
				keep = cb(val, i$1);
			} else {
				var k$1 = 0;
				for (; k$1 < dimSize; k$1++) value[k$1] = chunks[dims[k$1]][rawIdx];
				value[k$1] = i$1;
				keep = cb.apply(null, value);
			}
			if (keep) newIndices[offset++] = rawIdx;
		}
		if (offset < count$1) newStore._indices = newIndices;
		newStore._count = offset;
		newStore._extent = [];
		newStore._updateGetRawIdx();
		return newStore;
	};
	/**
	* Select data in range. (For optimization of filter)
	* (Manually inline code, support 5 million data filtering in data zoom.)
	*/
	DataStore$1.prototype.selectRange = function(range) {
		var newStore = this.clone();
		var len$1 = newStore._count;
		if (!len$1) return this;
		var dims = keys(range);
		var dimSize = dims.length;
		if (!dimSize) return this;
		var originalCount = newStore.count();
		var newIndices = new (getIndicesCtor(newStore._rawCount))(originalCount);
		var offset = 0;
		var dim0 = dims[0];
		var min$2 = range[dim0][0];
		var max$2 = range[dim0][1];
		var storeArr = newStore._chunks;
		var quickFinished = false;
		if (!newStore._indices) {
			var idx = 0;
			if (dimSize === 1) {
				var dimStorage = storeArr[dims[0]];
				for (var i$1 = 0; i$1 < len$1; i$1++) {
					var val = dimStorage[i$1];
					if (val >= min$2 && val <= max$2 || isNaN(val)) newIndices[offset++] = idx;
					idx++;
				}
				quickFinished = true;
			} else if (dimSize === 2) {
				var dimStorage = storeArr[dims[0]];
				var dimStorage2 = storeArr[dims[1]];
				var min2$1 = range[dims[1]][0];
				var max2$1 = range[dims[1]][1];
				for (var i$1 = 0; i$1 < len$1; i$1++) {
					var val = dimStorage[i$1];
					var val2 = dimStorage2[i$1];
					if ((val >= min$2 && val <= max$2 || isNaN(val)) && (val2 >= min2$1 && val2 <= max2$1 || isNaN(val2))) newIndices[offset++] = idx;
					idx++;
				}
				quickFinished = true;
			}
		}
		if (!quickFinished) if (dimSize === 1) for (var i$1 = 0; i$1 < originalCount; i$1++) {
			var rawIndex = newStore.getRawIndex(i$1);
			var val = storeArr[dims[0]][rawIndex];
			if (val >= min$2 && val <= max$2 || isNaN(val)) newIndices[offset++] = rawIndex;
		}
		else for (var i$1 = 0; i$1 < originalCount; i$1++) {
			var keep = true;
			var rawIndex = newStore.getRawIndex(i$1);
			for (var k$1 = 0; k$1 < dimSize; k$1++) {
				var dimk = dims[k$1];
				var val = storeArr[dimk][rawIndex];
				if (val < range[dimk][0] || val > range[dimk][1]) keep = false;
			}
			if (keep) newIndices[offset++] = newStore.getRawIndex(i$1);
		}
		if (offset < originalCount) newStore._indices = newIndices;
		newStore._count = offset;
		newStore._extent = [];
		newStore._updateGetRawIdx();
		return newStore;
	};
	/**
	* Data mapping to a new List with given dimensions
	*/
	DataStore$1.prototype.map = function(dims, cb) {
		var target = this.clone(dims);
		this._updateDims(target, dims, cb);
		return target;
	};
	/**
	* @caution Danger!! Only used in dataStack.
	*/
	DataStore$1.prototype.modify = function(dims, cb) {
		this._updateDims(this, dims, cb);
	};
	DataStore$1.prototype._updateDims = function(target, dims, cb) {
		var targetChunks = target._chunks;
		var tmpRetValue = [];
		var dimSize = dims.length;
		var dataCount = target.count();
		var values = [];
		var rawExtent = target._rawExtent;
		for (var i$1 = 0; i$1 < dims.length; i$1++) rawExtent[dims[i$1]] = getInitialExtent();
		for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
			var rawIndex = target.getRawIndex(dataIndex);
			for (var k$1 = 0; k$1 < dimSize; k$1++) values[k$1] = targetChunks[dims[k$1]][rawIndex];
			values[dimSize] = dataIndex;
			var retValue = cb && cb.apply(null, values);
			if (retValue != null) {
				if (typeof retValue !== "object") {
					tmpRetValue[0] = retValue;
					retValue = tmpRetValue;
				}
				for (var i$1 = 0; i$1 < retValue.length; i$1++) {
					var dim = dims[i$1];
					var val = retValue[i$1];
					var rawExtentOnDim = rawExtent[dim];
					var dimStore = targetChunks[dim];
					if (dimStore) dimStore[rawIndex] = val;
					if (val < rawExtentOnDim[0]) rawExtentOnDim[0] = val;
					if (val > rawExtentOnDim[1]) rawExtentOnDim[1] = val;
				}
			}
		}
	};
	/**
	* Large data down sampling using largest-triangle-three-buckets
	* @param {string} valueDimension
	* @param {number} targetCount
	*/
	DataStore$1.prototype.lttbDownSample = function(valueDimension, rate) {
		var target = this.clone([valueDimension], true);
		var dimStore = target._chunks[valueDimension];
		var len$1 = this.count();
		var sampledIndex = 0;
		var frameSize = Math.floor(1 / rate);
		var currentRawIndex = this.getRawIndex(0);
		var maxArea;
		var area;
		var nextRawIndex;
		var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len$1 / frameSize) + 2) * 2, len$1));
		newIndices[sampledIndex++] = currentRawIndex;
		for (var i$1 = 1; i$1 < len$1 - 1; i$1 += frameSize) {
			var nextFrameStart = Math.min(i$1 + frameSize, len$1 - 1);
			var nextFrameEnd = Math.min(i$1 + frameSize * 2, len$1);
			var avgX = (nextFrameEnd + nextFrameStart) / 2;
			var avgY = 0;
			for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
				var rawIndex = this.getRawIndex(idx);
				var y = dimStore[rawIndex];
				if (isNaN(y)) continue;
				avgY += y;
			}
			avgY /= nextFrameEnd - nextFrameStart;
			var frameStart = i$1;
			var frameEnd = Math.min(i$1 + frameSize, len$1);
			var pointAX = i$1 - 1;
			var pointAY = dimStore[currentRawIndex];
			maxArea = -1;
			nextRawIndex = frameStart;
			var firstNaNIndex = -1;
			var countNaN = 0;
			for (var idx = frameStart; idx < frameEnd; idx++) {
				var rawIndex = this.getRawIndex(idx);
				var y = dimStore[rawIndex];
				if (isNaN(y)) {
					countNaN++;
					if (firstNaNIndex < 0) firstNaNIndex = rawIndex;
					continue;
				}
				area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));
				if (area > maxArea) {
					maxArea = area;
					nextRawIndex = rawIndex;
				}
			}
			if (countNaN > 0 && countNaN < frameEnd - frameStart) {
				newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
				nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
			}
			newIndices[sampledIndex++] = nextRawIndex;
			currentRawIndex = nextRawIndex;
		}
		newIndices[sampledIndex++] = this.getRawIndex(len$1 - 1);
		target._count = sampledIndex;
		target._indices = newIndices;
		target.getRawIndex = this._getRawIdx;
		return target;
	};
	/**
	* Large data down sampling using min-max
	* @param {string} valueDimension
	* @param {number} rate
	*/
	DataStore$1.prototype.minmaxDownSample = function(valueDimension, rate) {
		var target = this.clone([valueDimension], true);
		var targetStorage = target._chunks;
		var frameSize = Math.floor(1 / rate);
		var dimStore = targetStorage[valueDimension];
		var len$1 = this.count();
		var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len$1 / frameSize) * 2);
		var offset = 0;
		for (var i$1 = 0; i$1 < len$1; i$1 += frameSize) {
			var minIndex = i$1;
			var minValue = dimStore[this.getRawIndex(minIndex)];
			var maxIndex = i$1;
			var maxValue = dimStore[this.getRawIndex(maxIndex)];
			var thisFrameSize = frameSize;
			if (i$1 + frameSize > len$1) thisFrameSize = len$1 - i$1;
			for (var k$1 = 0; k$1 < thisFrameSize; k$1++) {
				var value = dimStore[this.getRawIndex(i$1 + k$1)];
				if (value < minValue) {
					minValue = value;
					minIndex = i$1 + k$1;
				}
				if (value > maxValue) {
					maxValue = value;
					maxIndex = i$1 + k$1;
				}
			}
			var rawMinIndex = this.getRawIndex(minIndex);
			var rawMaxIndex = this.getRawIndex(maxIndex);
			if (minIndex < maxIndex) {
				newIndices[offset++] = rawMinIndex;
				newIndices[offset++] = rawMaxIndex;
			} else {
				newIndices[offset++] = rawMaxIndex;
				newIndices[offset++] = rawMinIndex;
			}
		}
		target._count = offset;
		target._indices = newIndices;
		target._updateGetRawIdx();
		return target;
	};
	/**
	* Large data down sampling on given dimension
	* @param sampleIndex Sample index for name and id
	*/
	DataStore$1.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
		var target = this.clone([dimension], true);
		var targetStorage = target._chunks;
		var frameValues = [];
		var frameSize = Math.floor(1 / rate);
		var dimStore = targetStorage[dimension];
		var len$1 = this.count();
		var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
		var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len$1 / frameSize));
		var offset = 0;
		for (var i$1 = 0; i$1 < len$1; i$1 += frameSize) {
			if (frameSize > len$1 - i$1) {
				frameSize = len$1 - i$1;
				frameValues.length = frameSize;
			}
			for (var k$1 = 0; k$1 < frameSize; k$1++) frameValues[k$1] = dimStore[this.getRawIndex(i$1 + k$1)];
			var value = sampleValue(frameValues);
			var sampleFrameIdx = this.getRawIndex(Math.min(i$1 + sampleIndex(frameValues, value) || 0, len$1 - 1));
			dimStore[sampleFrameIdx] = value;
			if (value < rawExtentOnDim[0]) rawExtentOnDim[0] = value;
			if (value > rawExtentOnDim[1]) rawExtentOnDim[1] = value;
			newIndices[offset++] = sampleFrameIdx;
		}
		target._count = offset;
		target._indices = newIndices;
		target._updateGetRawIdx();
		return target;
	};
	/**
	* Data iteration
	* @param ctx default this
	* @example
	*  list.each('x', function (x, idx) {});
	*  list.each(['x', 'y'], function (x, y, idx) {});
	*  list.each(function (idx) {})
	*/
	DataStore$1.prototype.each = function(dims, cb) {
		if (!this._count) return;
		var dimSize = dims.length;
		var chunks = this._chunks;
		for (var i$1 = 0, len$1 = this.count(); i$1 < len$1; i$1++) {
			var rawIdx = this.getRawIndex(i$1);
			switch (dimSize) {
				case 0:
					cb(i$1);
					break;
				case 1:
					cb(chunks[dims[0]][rawIdx], i$1);
					break;
				case 2:
					cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i$1);
					break;
				default:
					var k$1 = 0;
					var value = [];
					for (; k$1 < dimSize; k$1++) value[k$1] = chunks[dims[k$1]][rawIdx];
					value[k$1] = i$1;
					cb.apply(null, value);
			}
		}
	};
	/**
	* Get extent of data in one dimension
	*/
	DataStore$1.prototype.getDataExtent = function(dim) {
		var dimData = this._chunks[dim];
		var initialExtent = getInitialExtent();
		if (!dimData) return initialExtent;
		var currEnd = this.count();
		var useRaw = !this._indices;
		var dimExtent;
		if (useRaw) return this._rawExtent[dim].slice();
		dimExtent = this._extent[dim];
		if (dimExtent) return dimExtent.slice();
		dimExtent = initialExtent;
		var min$2 = dimExtent[0];
		var max$2 = dimExtent[1];
		for (var i$1 = 0; i$1 < currEnd; i$1++) {
			var value = dimData[this.getRawIndex(i$1)];
			value < min$2 && (min$2 = value);
			value > max$2 && (max$2 = value);
		}
		dimExtent = [min$2, max$2];
		this._extent[dim] = dimExtent;
		return dimExtent;
	};
	/**
	* Get raw data item
	*/
	DataStore$1.prototype.getRawDataItem = function(idx) {
		var rawIdx = this.getRawIndex(idx);
		if (!this._provider.persistent) {
			var val = [];
			var chunks = this._chunks;
			for (var i$1 = 0; i$1 < chunks.length; i$1++) val.push(chunks[i$1][rawIdx]);
			return val;
		} else return this._provider.getItem(rawIdx);
	};
	/**
	* Clone shallow.
	*
	* @param clonedDims Determine which dims to clone. Will share the data if not specified.
	*/
	DataStore$1.prototype.clone = function(clonedDims, ignoreIndices) {
		var target = new DataStore$1();
		var chunks = this._chunks;
		var clonedDimsMap = clonedDims && reduce(clonedDims, function(obj, dimIdx) {
			obj[dimIdx] = true;
			return obj;
		}, {});
		if (clonedDimsMap) for (var i$1 = 0; i$1 < chunks.length; i$1++) target._chunks[i$1] = !clonedDimsMap[i$1] ? chunks[i$1] : cloneChunk(chunks[i$1]);
		else target._chunks = chunks;
		this._copyCommonProps(target);
		if (!ignoreIndices) target._indices = this._cloneIndices();
		target._updateGetRawIdx();
		return target;
	};
	DataStore$1.prototype._copyCommonProps = function(target) {
		target._count = this._count;
		target._rawCount = this._rawCount;
		target._provider = this._provider;
		target._dimensions = this._dimensions;
		target._extent = clone(this._extent);
		target._rawExtent = clone(this._rawExtent);
	};
	DataStore$1.prototype._cloneIndices = function() {
		if (this._indices) {
			var Ctor = this._indices.constructor;
			var indices = void 0;
			if (Ctor === Array) {
				var thisCount = this._indices.length;
				indices = new Ctor(thisCount);
				for (var i$1 = 0; i$1 < thisCount; i$1++) indices[i$1] = this._indices[i$1];
			} else indices = new Ctor(this._indices);
			return indices;
		}
		return null;
	};
	DataStore$1.prototype._getRawIdxIdentity = function(idx) {
		return idx;
	};
	DataStore$1.prototype._getRawIdx = function(idx) {
		if (idx < this._count && idx >= 0) return this._indices[idx];
		return -1;
	};
	DataStore$1.prototype._updateGetRawIdx = function() {
		this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
	};
	DataStore$1.internalField = function() {
		function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {
			return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
		}
		defaultDimValueGetters = {
			arrayRows: getDimValueSimply,
			objectRows: function(dataItem, property, dataIndex, dimIndex) {
				return parseDataValue(dataItem[property], this._dimensions[dimIndex]);
			},
			keyedColumns: getDimValueSimply,
			original: function(dataItem, property, dataIndex, dimIndex) {
				var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
				return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
			},
			typedArray: function(dataItem, property, dataIndex, dimIndex) {
				return dataItem[dimIndex];
			}
		};
	}();
	return DataStore$1;
}();
var DataStore_default = DataStore;

//#endregion
//#region node_modules/echarts/lib/data/helper/sourceManager.js
/**
* [REQUIREMENT_MEMO]:
* (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.
* (1) Keep support the feature: `metaRawOption` can be specified both on `series` and
* `root-dataset`. Them on `series` has higher priority.
* (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might
* confuse users: whether those props indicate how to visit the upstream source or visit
* the transform result source, and some transforms has nothing to do with these props,
* and some transforms might have multiple upstream.
* (3) Transforms should specify `metaRawOption` in each output, just like they can be
* declared in `root-dataset`.
* (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.
* That is for reducing complexity in transforms.
* PENDING: Whether to provide transposition transform?
*
* [IMPLEMENTAION_MEMO]:
* "sourceVisitConfig" are calculated from `metaRawOption` and `data`.
* They will not be calculated until `source` is about to be visited (to prevent from
* duplicate calcuation). `source` is visited only in series and input to transforms.
*
* [DIMENSION_INHERIT_RULE]:
* By default the dimensions are inherited from ancestors, unless a transform return
* a new dimensions definition.
* Consider the case:
* ```js
* dataset: [{
*     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]
* }, {
*     transform: { type: 'filter', ... }
* }]
* dataset: [{
*     dimension: ['Product', 'Sales', 'Prise'],
*     source: [ ['Cookies', 321, 44.21], ...]
* }, {
*     transform: { type: 'filter', ... }
* }]
* ```
* The two types of option should have the same behavior after transform.
*
*
* [SCENARIO]:
* (1) Provide source data directly:
* ```js
* series: {
*     encode: {...},
*     dimensions: [...]
*     seriesLayoutBy: 'row',
*     data: [[...]]
* }
* ```
* (2) Series refer to dataset.
* ```js
* series: [{
*     encode: {...}
*     // Ignore datasetIndex means `datasetIndex: 0`
*     // and the dimensions defination in dataset is used
* }, {
*     encode: {...},
*     seriesLayoutBy: 'column',
*     datasetIndex: 1
* }]
* ```
* (3) dataset transform
* ```js
* dataset: [{
*     source: [...]
* }, {
*     source: [...]
* }, {
*     // By default from 0.
*     transform: { type: 'filter', config: {...} }
* }, {
*     // Piped.
*     transform: [
*         { type: 'filter', config: {...} },
*         { type: 'sort', config: {...} }
*     ]
* }, {
*     id: 'regressionData',
*     fromDatasetIndex: 1,
*     // Third-party transform
*     transform: { type: 'ecStat:regression', config: {...} }
* }, {
*     // retrieve the extra result.
*     id: 'regressionFormula',
*     fromDatasetId: 'regressionData',
*     fromTransformResult: 1
* }]
* ```
*/
var SourceManager = function() {
	function SourceManager$1(sourceHost) {
		this._sourceList = [];
		this._storeList = [];
		this._upstreamSignList = [];
		this._versionSignBase = 0;
		this._dirty = true;
		this._sourceHost = sourceHost;
	}
	/**
	* Mark dirty.
	*/
	SourceManager$1.prototype.dirty = function() {
		this._setLocalSource([], []);
		this._storeList = [];
		this._dirty = true;
	};
	SourceManager$1.prototype._setLocalSource = function(sourceList, upstreamSignList) {
		this._sourceList = sourceList;
		this._upstreamSignList = upstreamSignList;
		this._versionSignBase++;
		if (this._versionSignBase > 9e10) this._versionSignBase = 0;
	};
	/**
	* For detecting whether the upstream source is dirty, so that
	* the local cached source (in `_sourceList`) should be discarded.
	*/
	SourceManager$1.prototype._getVersionSign = function() {
		return this._sourceHost.uid + "_" + this._versionSignBase;
	};
	/**
	* Always return a source instance. Otherwise throw error.
	*/
	SourceManager$1.prototype.prepareSource = function() {
		if (this._isDirty()) {
			this._createSource();
			this._dirty = false;
		}
	};
	SourceManager$1.prototype._createSource = function() {
		this._setLocalSource([], []);
		var sourceHost = this._sourceHost;
		var upSourceMgrList = this._getUpstreamSourceManagers();
		var hasUpstream = !!upSourceMgrList.length;
		var resultSourceList;
		var upstreamSignList;
		if (isSeries(sourceHost)) {
			var seriesModel = sourceHost;
			var data = void 0;
			var sourceFormat = void 0;
			var upSource = void 0;
			if (hasUpstream) {
				var upSourceMgr = upSourceMgrList[0];
				upSourceMgr.prepareSource();
				upSource = upSourceMgr.getSource();
				data = upSource.data;
				sourceFormat = upSource.sourceFormat;
				upstreamSignList = [upSourceMgr._getVersionSign()];
			} else {
				data = seriesModel.get("data", true);
				sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
				upstreamSignList = [];
			}
			var newMetaRawOption = this._getSourceMetaRawOption() || {};
			var upMetaRawOption = upSource && upSource.metaRawOption || {};
			var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
			var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
			var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
			resultSourceList = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions ? [createSource(data, {
				seriesLayoutBy,
				sourceHeader,
				dimensions
			}, sourceFormat)] : [];
		} else {
			var datasetModel = sourceHost;
			if (hasUpstream) {
				var result = this._applyTransform(upSourceMgrList);
				resultSourceList = result.sourceList;
				upstreamSignList = result.upstreamSignList;
			} else {
				resultSourceList = [createSource(datasetModel.get("source", true), this._getSourceMetaRawOption(), null)];
				upstreamSignList = [];
			}
		}
		assert(resultSourceList && upstreamSignList);
		this._setLocalSource(resultSourceList, upstreamSignList);
	};
	SourceManager$1.prototype._applyTransform = function(upMgrList) {
		var datasetModel = this._sourceHost;
		var transformOption = datasetModel.get("transform", true);
		var fromTransformResult = datasetModel.get("fromTransformResult", true);
		assert(fromTransformResult != null || transformOption != null);
		if (fromTransformResult != null) {
			var errMsg = "";
			if (upMgrList.length !== 1) {
				errMsg = "When using `fromTransformResult`, there should be only one upstream dataset";
				doThrow(errMsg);
			}
		}
		var sourceList;
		var upSourceList = [];
		var upstreamSignList = [];
		each(upMgrList, function(upMgr) {
			upMgr.prepareSource();
			var upSource = upMgr.getSource(fromTransformResult || 0);
			var errMsg$1 = "";
			if (fromTransformResult != null && !upSource) {
				errMsg$1 = "Can not retrieve result by `fromTransformResult`: " + fromTransformResult;
				doThrow(errMsg$1);
			}
			upSourceList.push(upSource);
			upstreamSignList.push(upMgr._getVersionSign());
		});
		if (transformOption) sourceList = applyDataTransform(transformOption, upSourceList, { datasetIndex: datasetModel.componentIndex });
		else if (fromTransformResult != null) sourceList = [cloneSourceShallow(upSourceList[0])];
		return {
			sourceList,
			upstreamSignList
		};
	};
	SourceManager$1.prototype._isDirty = function() {
		if (this._dirty) return true;
		var upSourceMgrList = this._getUpstreamSourceManagers();
		for (var i$1 = 0; i$1 < upSourceMgrList.length; i$1++) {
			var upSrcMgr = upSourceMgrList[i$1];
			if (upSrcMgr._isDirty() || this._upstreamSignList[i$1] !== upSrcMgr._getVersionSign()) return true;
		}
	};
	/**
	* @param sourceIndex By default 0, means "main source".
	*                    In most cases there is only one source.
	*/
	SourceManager$1.prototype.getSource = function(sourceIndex) {
		sourceIndex = sourceIndex || 0;
		var source = this._sourceList[sourceIndex];
		if (!source) {
			var upSourceMgrList = this._getUpstreamSourceManagers();
			return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
		}
		return source;
	};
	/**
	*
	* Get a data store which can be shared across series.
	* Only available for series.
	*
	* @param seriesDimRequest Dimensions that are generated in series.
	*        Should have been sorted by `storeDimIndex` asc.
	*/
	SourceManager$1.prototype.getSharedDataStore = function(seriesDimRequest) {
		assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
		var schema = seriesDimRequest.makeStoreSchema();
		return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
	};
	SourceManager$1.prototype._innerGetDataStore = function(storeDims, seriesSource, sourceReadKey) {
		var sourceIndex = 0;
		var storeList = this._storeList;
		var cachedStoreMap = storeList[sourceIndex];
		if (!cachedStoreMap) cachedStoreMap = storeList[sourceIndex] = {};
		var cachedStore = cachedStoreMap[sourceReadKey];
		if (!cachedStore) {
			var upSourceMgr = this._getUpstreamSourceManagers()[0];
			if (isSeries(this._sourceHost) && upSourceMgr) cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
			else {
				cachedStore = new DataStore_default();
				cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
			}
			cachedStoreMap[sourceReadKey] = cachedStore;
		}
		return cachedStore;
	};
	/**
	* PENDING: Is it fast enough?
	* If no upstream, return empty array.
	*/
	SourceManager$1.prototype._getUpstreamSourceManagers = function() {
		var sourceHost = this._sourceHost;
		if (isSeries(sourceHost)) {
			var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
			return !datasetModel ? [] : [datasetModel.getSourceManager()];
		} else return map(queryDatasetUpstreamDatasetModels(sourceHost), function(datasetModel$1) {
			return datasetModel$1.getSourceManager();
		});
	};
	SourceManager$1.prototype._getSourceMetaRawOption = function() {
		var sourceHost = this._sourceHost;
		var seriesLayoutBy;
		var sourceHeader;
		var dimensions;
		if (isSeries(sourceHost)) {
			seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
			sourceHeader = sourceHost.get("sourceHeader", true);
			dimensions = sourceHost.get("dimensions", true);
		} else if (!this._getUpstreamSourceManagers().length) {
			var model = sourceHost;
			seriesLayoutBy = model.get("seriesLayoutBy", true);
			sourceHeader = model.get("sourceHeader", true);
			dimensions = model.get("dimensions", true);
		}
		return {
			seriesLayoutBy,
			sourceHeader,
			dimensions
		};
	};
	return SourceManager$1;
}();
function disableTransformOptionMerge(datasetModel) {
	datasetModel.option.transform && setAsPrimitive(datasetModel.option.transform);
}
function isSeries(sourceHost) {
	return sourceHost.mainType === "series";
}
function doThrow(errMsg) {
	throw new Error(errMsg);
}

//#endregion
//#region node_modules/echarts/lib/component/tooltip/tooltipMarkup.js
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipLineHeight(textStyle) {
	var lineHeight = textStyle.lineHeight;
	if (lineHeight == null) return TOOLTIP_LINE_HEIGHT_CSS;
	else return "line-height:" + encodeHTML(lineHeight + "") + "px";
}
function getTooltipTextStyle(textStyle, renderMode) {
	var nameFontColor = textStyle.color || tokens_default.color.tertiary;
	var nameFontSize = textStyle.fontSize || 12;
	var nameFontWeight = textStyle.fontWeight || "400";
	var valueFontColor = textStyle.color || tokens_default.color.secondary;
	var valueFontSize = textStyle.fontSize || 14;
	var valueFontWeight = textStyle.fontWeight || "900";
	if (renderMode === "html") return {
		nameStyle: "font-size:" + encodeHTML(nameFontSize + "") + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ""),
		valueStyle: "font-size:" + encodeHTML(valueFontSize + "") + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + "")
	};
	else return {
		nameStyle: {
			fontSize: nameFontSize,
			fill: nameFontColor,
			fontWeight: nameFontWeight
		},
		valueStyle: {
			fontSize: valueFontSize,
			fill: valueFontColor,
			fontWeight: valueFontWeight
		}
	};
}
var HTML_GAPS = [
	0,
	10,
	20,
	30
];
var RICH_TEXT_GAPS = [
	"",
	"\n",
	"\n\n",
	"\n\n\n"
];
function createTooltipMarkup(type, option) {
	option.type = type;
	return option;
}
function isSectionFragment(frag) {
	return frag.type === "section";
}
function getBuilder(frag) {
	return isSectionFragment(frag) ? buildSection : buildNameValue;
}
function getBlockGapLevel(frag) {
	if (isSectionFragment(frag)) {
		var gapLevel_1 = 0;
		var subBlockLen = frag.blocks.length;
		var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
		each(frag.blocks, function(subBlock) {
			var subGapLevel = getBlockGapLevel(subBlock);
			if (subGapLevel >= gapLevel_1) gapLevel_1 = subGapLevel + +(hasInnerGap_1 && (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
		});
		return gapLevel_1;
	}
	return 0;
}
function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
	var noHeader = fragment.noHeader;
	var gaps = getGap(getBlockGapLevel(fragment));
	var subMarkupTextList = [];
	var subBlocks = fragment.blocks || [];
	assert(!subBlocks || isArray(subBlocks));
	subBlocks = subBlocks || [];
	var orderMode = ctx.orderMode;
	if (fragment.sortBlocks && orderMode) {
		subBlocks = subBlocks.slice();
		var orderMap = {
			valueAsc: "asc",
			valueDesc: "desc"
		};
		if (hasOwn(orderMap, orderMode)) {
			var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
			subBlocks.sort(function(a, b) {
				return comparator_1.evaluate(a.sortParam, b.sortParam);
			});
		} else if (orderMode === "seriesDesc") subBlocks.reverse();
	}
	each(subBlocks, function(subBlock, idx) {
		var valueFormatter = fragment.valueFormatter;
		var subMarkupText$1 = getBuilder(subBlock)(valueFormatter ? extend(extend({}, ctx), { valueFormatter }) : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle);
		subMarkupText$1 != null && subMarkupTextList.push(subMarkupText$1);
	});
	var subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(toolTipTextStyle, subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
	if (noHeader) return subMarkupText;
	var displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
	var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;
	var tooltipLineHeight = getTooltipLineHeight(toolTipTextStyle);
	if (ctx.renderMode === "richText") return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
	else return wrapBlockHTML(toolTipTextStyle, "<div style=\"" + nameStyle + ";" + tooltipLineHeight + ";\">" + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
}
function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
	var renderMode = ctx.renderMode;
	var noName = fragment.noName;
	var noValue = fragment.noValue;
	var noMarker = !fragment.markerType;
	var name = fragment.name;
	var useUTC = ctx.useUTC;
	var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function(value) {
		value = isArray(value) ? value : [value];
		return map(value, function(val, idx) {
			return makeValueReadable(val, isArray(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
		});
	};
	if (noName && noValue) return;
	var markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || tokens_default.color.secondary, renderMode);
	var readableName = noName ? "" : makeValueReadable(name, "ordinal", useUTC);
	var valueTypeOption = fragment.valueType;
	var readableValueList = noValue ? [] : valueFormatter(fragment.value, fragment.dataIndex);
	var valueAlignRight = !noMarker || !noName;
	var valueCloseToMarker = !noMarker && noName;
	var _a$1 = getTooltipTextStyle(toolTipTextStyle, renderMode), nameStyle = _a$1.nameStyle, valueStyle = _a$1.valueStyle;
	return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML(toolTipTextStyle, (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
}
/**
* @return markupText. null/undefined means no content.
*/
function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
	if (!fragment) return;
	return getBuilder(fragment)({
		useUTC,
		renderMode,
		orderMode,
		markupStyleCreator,
		valueFormatter: fragment.valueFormatter
	}, fragment, 0, toolTipTextStyle);
}
function getGap(gapLevel) {
	return {
		html: HTML_GAPS[gapLevel],
		richText: RICH_TEXT_GAPS[gapLevel]
	};
}
function wrapBlockHTML(textStyle, encodedContent, topGap) {
	var clearfix = "<div style=\"clear:both\"></div>";
	var marginCSS = "margin: " + topGap + "px 0 0";
	var tooltipLineHeight = getTooltipLineHeight(textStyle);
	return "<div style=\"" + marginCSS + ";" + tooltipLineHeight + ";\">" + encodedContent + clearfix + "</div>";
}
function wrapInlineNameHTML(name, leftHasMarker, style) {
	var marginCss = leftHasMarker ? "margin-left:2px" : "";
	return "<span style=\"" + style + ";" + marginCss + "\">" + encodeHTML(name) + "</span>";
}
function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
	var alignCSS = alignRight ? "float:right;margin-left:" + (valueCloseToMarker ? "10px" : "20px") : "";
	valueList = isArray(valueList) ? valueList : [valueList];
	return "<span style=\"" + alignCSS + ";" + style + "\">" + map(valueList, function(value) {
		return encodeHTML(value);
	}).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(ctx, name, style) {
	return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
}
function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
	var styles = [style];
	var paddingLeft = valueCloseToMarker ? 10 : 20;
	alignRight && styles.push({
		padding: [
			0,
			0,
			0,
			paddingLeft
		],
		align: "right"
	});
	return ctx.markupStyleCreator.wrapRichTextStyle(isArray(values) ? values.join("  ") : values, styles);
}
function retrieveVisualColorForTooltipMarker(series, dataIndex) {
	var color$2 = series.getData().getItemVisual(dataIndex, "style")[series.visualDrawType];
	return convertToColorString(color$2);
}
function getPaddingFromTooltipModel(model, renderMode) {
	var padding = model.get("padding");
	return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
}
/**
* The major feature is generate styles for `renderMode: 'richText'`.
* But it also serves `renderMode: 'html'` to provide
* "renderMode-independent" API.
*/
var TooltipMarkupStyleCreator = function() {
	function TooltipMarkupStyleCreator$1() {
		this.richTextStyles = {};
		this._nextStyleNameId = getRandomIdBase();
	}
	TooltipMarkupStyleCreator$1.prototype._generateStyleName = function() {
		return "__EC_aUTo_" + this._nextStyleNameId++;
	};
	TooltipMarkupStyleCreator$1.prototype.makeTooltipMarker = function(markerType, colorStr, renderMode) {
		var markerId = renderMode === "richText" ? this._generateStyleName() : null;
		var marker = getTooltipMarker({
			color: colorStr,
			type: markerType,
			renderMode,
			markerId
		});
		if (isString(marker)) return marker;
		else {
			assert(markerId);
			this.richTextStyles[markerId] = marker.style;
			return marker.content;
		}
	};
	/**
	* @usage
	* ```ts
	* const styledText = markupStyleCreator.wrapRichTextStyle([
	*     // The styles will be auto merged.
	*     {
	*         fontSize: 12,
	*         color: 'blue'
	*     },
	*     {
	*         padding: 20
	*     }
	* ]);
	* ```
	*/
	TooltipMarkupStyleCreator$1.prototype.wrapRichTextStyle = function(text, styles) {
		var finalStl = {};
		if (isArray(styles)) each(styles, function(stl) {
			return extend(finalStl, stl);
		});
		else extend(finalStl, styles);
		var styleName = this._generateStyleName();
		this.richTextStyles[styleName] = finalStl;
		return "{" + styleName + "|" + text + "}";
	};
	return TooltipMarkupStyleCreator$1;
}();

//#endregion
//#region node_modules/echarts/lib/component/tooltip/seriesFormatTooltip.js
function defaultSeriesFormatTooltip(opt) {
	var series = opt.series;
	var dataIndex = opt.dataIndex;
	var multipleSeries = opt.multipleSeries;
	var data = series.getData();
	var tooltipDims = data.mapDimensionsAll("defaultedTooltip");
	var tooltipDimLen = tooltipDims.length;
	var value = series.getRawValue(dataIndex);
	var isValueArr = isArray(value);
	var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
	var inlineValue;
	var inlineValueType;
	var subBlocks;
	var sortParam;
	if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
		var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
		inlineValue = formatArrResult.inlineValues;
		inlineValueType = formatArrResult.inlineValueTypes;
		subBlocks = formatArrResult.blocks;
		sortParam = formatArrResult.inlineValues[0];
	} else if (tooltipDimLen) {
		var dimInfo = data.getDimensionInfo(tooltipDims[0]);
		sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
		inlineValueType = dimInfo.type;
	} else sortParam = inlineValue = isValueArr ? value[0] : value;
	var seriesNameSpecified = isNameSpecified(series);
	var seriesName = seriesNameSpecified && series.name || "";
	var itemName = data.getName(dataIndex);
	var inlineName = multipleSeries ? seriesName : itemName;
	return createTooltipMarkup("section", {
		header: seriesName,
		noHeader: multipleSeries || !seriesNameSpecified,
		sortParam,
		blocks: [createTooltipMarkup("nameValue", {
			markerType: "item",
			markerColor,
			name: inlineName,
			noName: !trim(inlineName),
			value: inlineValue,
			valueType: inlineValueType,
			dataIndex
		})].concat(subBlocks || [])
	});
}
function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
	var data = series.getData();
	var isValueMultipleLine = reduce(value, function(isValueMultipleLine$1, val, idx) {
		var dimItem = data.getDimensionInfo(idx);
		return isValueMultipleLine$1 = isValueMultipleLine$1 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
	}, false);
	var inlineValues = [];
	var inlineValueTypes = [];
	var blocks = [];
	tooltipDims.length ? each(tooltipDims, function(dim) {
		setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
	}) : each(value, setEachItem);
	function setEachItem(val, dim) {
		var dimInfo = data.getDimensionInfo(dim);
		if (!dimInfo || dimInfo.otherDims.tooltip === false) return;
		if (isValueMultipleLine) blocks.push(createTooltipMarkup("nameValue", {
			markerType: "subItem",
			markerColor: colorStr,
			name: dimInfo.displayName,
			value: val,
			valueType: dimInfo.type
		}));
		else {
			inlineValues.push(val);
			inlineValueTypes.push(dimInfo.type);
		}
	}
	return {
		inlineValues,
		inlineValueTypes,
		blocks
	};
}

//#endregion
//#region node_modules/echarts/lib/model/Series.js
var inner$22 = makeInner();
function getSelectionKey(data, dataIndex) {
	return data.getName(dataIndex) || data.getId(dataIndex);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
var SeriesModel = function(_super) {
	__extends(SeriesModel$1, _super);
	function SeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this._selectedDataIndicesMap = {};
		return _this;
	}
	SeriesModel$1.prototype.init = function(option, parentModel, ecModel) {
		this.seriesIndex = this.componentIndex;
		this.dataTask = createTask({
			count: dataTaskCount,
			reset: dataTaskReset
		});
		this.dataTask.context = { model: this };
		this.mergeDefaultAndTheme(option, ecModel);
		(inner$22(this).sourceManager = new SourceManager(this)).prepareSource();
		var data = this.getInitialData(option, ecModel);
		wrapData(data, this);
		this.dataTask.context.data = data;
		assert(data, "getInitialData returned invalid data.");
		inner$22(this).dataBeforeProcessed = data;
		autoSeriesName(this);
		this._initSelectedMapFromData(data);
	};
	/**
	* Util for merge default and theme to option
	*/
	SeriesModel$1.prototype.mergeDefaultAndTheme = function(option, ecModel) {
		var layoutMode = fetchLayoutMode(this);
		var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
		var themeSubType = this.subType;
		if (Component_default.hasClass(themeSubType)) themeSubType += "Series";
		merge(option, ecModel.getTheme().get(this.subType));
		merge(option, this.getDefaultOption());
		defaultEmphasis(option, "label", ["show"]);
		this.fillDataTextStyle(option.data);
		if (layoutMode) mergeLayoutParam(option, inputPositionParams, layoutMode);
	};
	SeriesModel$1.prototype.mergeOption = function(newSeriesOption, ecModel) {
		newSeriesOption = merge(this.option, newSeriesOption, true);
		this.fillDataTextStyle(newSeriesOption.data);
		var layoutMode = fetchLayoutMode(this);
		if (layoutMode) mergeLayoutParam(this.option, newSeriesOption, layoutMode);
		var sourceManager = inner$22(this).sourceManager;
		sourceManager.dirty();
		sourceManager.prepareSource();
		var data = this.getInitialData(newSeriesOption, ecModel);
		wrapData(data, this);
		this.dataTask.dirty();
		this.dataTask.context.data = data;
		inner$22(this).dataBeforeProcessed = data;
		autoSeriesName(this);
		this._initSelectedMapFromData(data);
	};
	SeriesModel$1.prototype.fillDataTextStyle = function(data) {
		if (data && !isTypedArray(data)) {
			var props = ["show"];
			for (var i$1 = 0; i$1 < data.length; i$1++) if (data[i$1] && data[i$1].label) defaultEmphasis(data[i$1], "label", props);
		}
	};
	/**
	* Init a data structure from data related option in series
	* Must be overridden.
	*/
	SeriesModel$1.prototype.getInitialData = function(option, ecModel) {};
	/**
	* Append data to list
	*/
	SeriesModel$1.prototype.appendData = function(params) {
		this.getRawData().appendData(params.data);
	};
	/**
	* Consider some method like `filter`, `map` need make new data,
	* We should make sure that `seriesModel.getData()` get correct
	* data in the stream procedure. So we fetch data from upstream
	* each time `task.perform` called.
	*/
	SeriesModel$1.prototype.getData = function(dataType) {
		var task = getCurrentTask(this);
		if (task) {
			var data = task.context.data;
			return dataType == null || !data.getLinkedData ? data : data.getLinkedData(dataType);
		} else return inner$22(this).data;
	};
	SeriesModel$1.prototype.getAllData = function() {
		var mainData = this.getData();
		return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{ data: mainData }];
	};
	SeriesModel$1.prototype.setData = function(data) {
		var task = getCurrentTask(this);
		if (task) {
			var context = task.context;
			context.outputData = data;
			if (task !== this.dataTask) context.data = data;
		}
		inner$22(this).data = data;
	};
	SeriesModel$1.prototype.getEncode = function() {
		var encode = this.get("encode", true);
		if (encode) return createHashMap(encode);
	};
	SeriesModel$1.prototype.getSourceManager = function() {
		return inner$22(this).sourceManager;
	};
	SeriesModel$1.prototype.getSource = function() {
		return this.getSourceManager().getSource();
	};
	/**
	* Get data before processed
	*/
	SeriesModel$1.prototype.getRawData = function() {
		return inner$22(this).dataBeforeProcessed;
	};
	SeriesModel$1.prototype.getColorBy = function() {
		return this.get("colorBy") || "series";
	};
	SeriesModel$1.prototype.isColorBySeries = function() {
		return this.getColorBy() === "series";
	};
	/**
	* Get base axis if has coordinate system and has axis.
	* By default use coordSys.getBaseAxis();
	* Can be overridden for some chart.
	* @return {type} description
	*/
	SeriesModel$1.prototype.getBaseAxis = function() {
		var coordSys = this.coordinateSystem;
		return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
	};
	/**
	* Retrieve the index of nearest value in the view coordinate.
	* Data position is compared with each axis's dataToCoord.
	*
	* @param axisDim axis dimension
	* @param dim data dimension
	* @param value
	* @param [maxDistance=Infinity] The maximum distance in view coordinate space
	* @return If and only if multiple indices has
	*         the same value, they are put to the result.
	*/
	SeriesModel$1.prototype.indicesOfNearest = function(axisDim, dim, value, maxDistance) {
		var data = this.getData();
		var coordSys = this.coordinateSystem;
		var axis = coordSys && coordSys.getAxis(axisDim);
		if (!coordSys || !axis) return [];
		var targetCoord = axis.dataToCoord(value);
		if (maxDistance == null) maxDistance = Infinity;
		var nearestIndices = [];
		var minDist = Infinity;
		var minDiff = -1;
		var nearestIndicesLen = 0;
		data.each(dim, function(dimValue, idx) {
			var diff = targetCoord - axis.dataToCoord(dimValue);
			var dist$2 = Math.abs(diff);
			if (dist$2 <= maxDistance) {
				if (dist$2 < minDist || dist$2 === minDist && diff >= 0 && minDiff < 0) {
					minDist = dist$2;
					minDiff = diff;
					nearestIndicesLen = 0;
				}
				if (diff === minDiff) nearestIndices[nearestIndicesLen++] = idx;
			}
		});
		nearestIndices.length = nearestIndicesLen;
		return nearestIndices;
	};
	/**
	* Default tooltip formatter
	*
	* @param dataIndex
	* @param multipleSeries
	* @param dataType
	* @param renderMode valid values: 'html'(by default) and 'richText'.
	*        'html' is used for rendering tooltip in extra DOM form, and the result
	*        string is used as DOM HTML content.
	*        'richText' is used for rendering tooltip in rich text form, for those where
	*        DOM operation is not supported.
	* @return formatted tooltip with `html` and `markers`
	*        Notice: The override method can also return string
	*/
	SeriesModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		return defaultSeriesFormatTooltip({
			series: this,
			dataIndex,
			multipleSeries
		});
	};
	SeriesModel$1.prototype.isAnimationEnabled = function() {
		var ecModel = this.ecModel;
		if (env_default.node && !(ecModel && ecModel.ssr)) return false;
		var animationEnabled = this.getShallow("animation");
		if (animationEnabled) {
			if (this.getData().count() > this.getShallow("animationThreshold")) animationEnabled = false;
		}
		return !!animationEnabled;
	};
	SeriesModel$1.prototype.restoreData = function() {
		this.dataTask.dirty();
	};
	SeriesModel$1.prototype.getColorFromPalette = function(name, scope, requestColorNum) {
		var ecModel = this.ecModel;
		var color$2 = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
		if (!color$2) color$2 = ecModel.getColorFromPalette(name, scope, requestColorNum);
		return color$2;
	};
	/**
	* Use `data.mapDimensionsAll(coordDim)` instead.
	* @deprecated
	*/
	SeriesModel$1.prototype.coordDimToDataDim = function(coordDim) {
		return this.getRawData().mapDimensionsAll(coordDim);
	};
	/**
	* Get progressive rendering count each step
	*/
	SeriesModel$1.prototype.getProgressive = function() {
		return this.get("progressive");
	};
	/**
	* Get progressive rendering count each step
	*/
	SeriesModel$1.prototype.getProgressiveThreshold = function() {
		return this.get("progressiveThreshold");
	};
	SeriesModel$1.prototype.select = function(innerDataIndices, dataType) {
		this._innerSelect(this.getData(dataType), innerDataIndices);
	};
	SeriesModel$1.prototype.unselect = function(innerDataIndices, dataType) {
		var selectedMap = this.option.selectedMap;
		if (!selectedMap) return;
		var selectedMode = this.option.selectedMode;
		var data = this.getData(dataType);
		if (selectedMode === "series" || selectedMap === "all") {
			this.option.selectedMap = {};
			this._selectedDataIndicesMap = {};
			return;
		}
		for (var i$1 = 0; i$1 < innerDataIndices.length; i$1++) {
			var dataIndex = innerDataIndices[i$1];
			var nameOrId = getSelectionKey(data, dataIndex);
			selectedMap[nameOrId] = false;
			this._selectedDataIndicesMap[nameOrId] = -1;
		}
	};
	SeriesModel$1.prototype.toggleSelect = function(innerDataIndices, dataType) {
		var tmpArr$1 = [];
		for (var i$1 = 0; i$1 < innerDataIndices.length; i$1++) {
			tmpArr$1[0] = innerDataIndices[i$1];
			this.isSelected(innerDataIndices[i$1], dataType) ? this.unselect(tmpArr$1, dataType) : this.select(tmpArr$1, dataType);
		}
	};
	SeriesModel$1.prototype.getSelectedDataIndices = function() {
		if (this.option.selectedMap === "all") return [].slice.call(this.getData().getIndices());
		var selectedDataIndicesMap = this._selectedDataIndicesMap;
		var nameOrIds = keys(selectedDataIndicesMap);
		var dataIndices = [];
		for (var i$1 = 0; i$1 < nameOrIds.length; i$1++) {
			var dataIndex = selectedDataIndicesMap[nameOrIds[i$1]];
			if (dataIndex >= 0) dataIndices.push(dataIndex);
		}
		return dataIndices;
	};
	SeriesModel$1.prototype.isSelected = function(dataIndex, dataType) {
		var selectedMap = this.option.selectedMap;
		if (!selectedMap) return false;
		var data = this.getData(dataType);
		return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
	};
	SeriesModel$1.prototype.isUniversalTransitionEnabled = function() {
		if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) return true;
		var universalTransitionOpt = this.option.universalTransition;
		if (!universalTransitionOpt) return false;
		if (universalTransitionOpt === true) return true;
		return universalTransitionOpt && universalTransitionOpt.enabled;
	};
	SeriesModel$1.prototype._innerSelect = function(data, innerDataIndices) {
		var _a$1, _b$1;
		var option = this.option;
		var selectedMode = option.selectedMode;
		var len$1 = innerDataIndices.length;
		if (!selectedMode || !len$1) return;
		if (selectedMode === "series") option.selectedMap = "all";
		else if (selectedMode === "multiple") {
			if (!isObject(option.selectedMap)) option.selectedMap = {};
			var selectedMap = option.selectedMap;
			for (var i$1 = 0; i$1 < len$1; i$1++) {
				var dataIndex = innerDataIndices[i$1];
				var nameOrId = getSelectionKey(data, dataIndex);
				selectedMap[nameOrId] = true;
				this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
			}
		} else if (selectedMode === "single" || selectedMode === true) {
			var lastDataIndex = innerDataIndices[len$1 - 1];
			var nameOrId = getSelectionKey(data, lastDataIndex);
			option.selectedMap = (_a$1 = {}, _a$1[nameOrId] = true, _a$1);
			this._selectedDataIndicesMap = (_b$1 = {}, _b$1[nameOrId] = data.getRawIndex(lastDataIndex), _b$1);
		}
	};
	SeriesModel$1.prototype._initSelectedMapFromData = function(data) {
		if (this.option.selectedMap) return;
		var dataIndices = [];
		if (data.hasItemOption) data.each(function(idx) {
			var rawItem = data.getRawDataItem(idx);
			if (rawItem && rawItem.selected) dataIndices.push(idx);
		});
		if (dataIndices.length > 0) this._innerSelect(data, dataIndices);
	};
	SeriesModel$1.registerClass = function(clz) {
		return Component_default.registerClass(clz);
	};
	SeriesModel$1.protoInitialize = function() {
		var proto = SeriesModel$1.prototype;
		proto.type = "series.__base__";
		proto.seriesIndex = 0;
		proto.ignoreStyleOnData = false;
		proto.hasSymbolVisual = false;
		proto.defaultSymbol = "circle";
		proto.visualStyleAccessPath = "itemStyle";
		proto.visualDrawType = "fill";
	}();
	return SeriesModel$1;
}(Component_default);
mixin(SeriesModel, DataFormatMixin);
mixin(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, Component_default);
/**
* MUST be called after `prepareSource` called
* Here we need to make auto series, especially for auto legend. But we
* do not modify series.name in option to avoid side effects.
*/
function autoSeriesName(seriesModel) {
	var name = seriesModel.name;
	if (!isNameSpecified(seriesModel)) seriesModel.name = getSeriesAutoName(seriesModel) || name;
}
function getSeriesAutoName(seriesModel) {
	var data = seriesModel.getRawData();
	var dataDims = data.mapDimensionsAll("seriesName");
	var nameArr = [];
	each(dataDims, function(dataDim) {
		var dimInfo = data.getDimensionInfo(dataDim);
		dimInfo.displayName && nameArr.push(dimInfo.displayName);
	});
	return nameArr.join(" ");
}
function dataTaskCount(context) {
	return context.model.getRawData().count();
}
function dataTaskReset(context) {
	var seriesModel = context.model;
	seriesModel.setData(seriesModel.getRawData().cloneShallow());
	return dataTaskProgress;
}
function dataTaskProgress(param, context) {
	if (context.outputData && param.end > context.outputData.count()) context.model.getRawData().cloneShallow(context.outputData);
}
function wrapData(data, seriesModel) {
	each(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
		data.wrapMethod(methodName, curry(onDataChange, seriesModel));
	});
}
function onDataChange(seriesModel, newList) {
	var task = getCurrentTask(seriesModel);
	if (task) task.setOutputEnd((newList || this).count());
	return newList;
}
function getCurrentTask(seriesModel) {
	var scheduler = (seriesModel.ecModel || {}).scheduler;
	var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
	if (pipeline) {
		var task = pipeline.currentTask;
		if (task) {
			var agentStubMap = task.agentStubMap;
			if (agentStubMap) task = agentStubMap.get(seriesModel.uid);
		}
		return task;
	}
}
var Series_default = SeriesModel;

//#endregion
//#region node_modules/echarts/lib/view/Component.js
var ComponentView = function() {
	function ComponentView$1() {
		this.group = new Group_default();
		this.uid = getUID("viewComponent");
	}
	ComponentView$1.prototype.init = function(ecModel, api) {};
	ComponentView$1.prototype.render = function(model, ecModel, api, payload) {};
	ComponentView$1.prototype.dispose = function(ecModel, api) {};
	ComponentView$1.prototype.updateView = function(model, ecModel, api, payload) {};
	ComponentView$1.prototype.updateLayout = function(model, ecModel, api, payload) {};
	ComponentView$1.prototype.updateVisual = function(model, ecModel, api, payload) {};
	/**
	* Hook for toggle blur target series.
	* Can be used in marker for blur or leave blur the markers
	*/
	ComponentView$1.prototype.toggleBlurSeries = function(seriesModels, isBlur, ecModel) {};
	/**
	* Traverse the new rendered elements.
	*
	* It will traverse the new added element in progressive rendering.
	* And traverse all in normal rendering.
	*/
	ComponentView$1.prototype.eachRendered = function(cb) {
		var group = this.group;
		if (group) group.traverse(cb);
	};
	return ComponentView$1;
}();
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
var Component_default$1 = ComponentView;

//#endregion
//#region node_modules/echarts/lib/chart/helper/createRenderPlanner.js
/**
* @return {string} If large mode changed, return string 'reset';
*/
function createRenderPlanner() {
	var inner$24 = makeInner();
	return function(seriesModel) {
		var fields = inner$24(seriesModel);
		var pipelineContext = seriesModel.pipelineContext;
		var originalLarge = !!fields.large;
		var originalProgressive = !!fields.progressiveRender;
		var large = fields.large = !!(pipelineContext && pipelineContext.large);
		var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
		return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
	};
}

//#endregion
//#region node_modules/echarts/lib/view/Chart.js
var inner$21 = makeInner();
var renderPlanner = createRenderPlanner();
var ChartView = function() {
	function ChartView$1() {
		this.group = new Group_default();
		this.uid = getUID("viewChart");
		this.renderTask = createTask({
			plan: renderTaskPlan,
			reset: renderTaskReset
		});
		this.renderTask.context = { view: this };
	}
	ChartView$1.prototype.init = function(ecModel, api) {};
	ChartView$1.prototype.render = function(seriesModel, ecModel, api, payload) {
		throw new Error("render method must been implemented");
	};
	/**
	* Highlight series or specified data item.
	*/
	ChartView$1.prototype.highlight = function(seriesModel, ecModel, api, payload) {
		var data = seriesModel.getData(payload && payload.dataType);
		if (!data) {
			error("Unknown dataType " + payload.dataType);
			return;
		}
		toggleHighlight(data, payload, "emphasis");
	};
	/**
	* Downplay series or specified data item.
	*/
	ChartView$1.prototype.downplay = function(seriesModel, ecModel, api, payload) {
		var data = seriesModel.getData(payload && payload.dataType);
		if (!data) {
			error("Unknown dataType " + payload.dataType);
			return;
		}
		toggleHighlight(data, payload, "normal");
	};
	/**
	* Remove self.
	*/
	ChartView$1.prototype.remove = function(ecModel, api) {
		this.group.removeAll();
	};
	/**
	* Dispose self.
	*/
	ChartView$1.prototype.dispose = function(ecModel, api) {};
	ChartView$1.prototype.updateView = function(seriesModel, ecModel, api, payload) {
		this.render(seriesModel, ecModel, api, payload);
	};
	ChartView$1.prototype.updateLayout = function(seriesModel, ecModel, api, payload) {
		this.render(seriesModel, ecModel, api, payload);
	};
	ChartView$1.prototype.updateVisual = function(seriesModel, ecModel, api, payload) {
		this.render(seriesModel, ecModel, api, payload);
	};
	/**
	* Traverse the new rendered elements.
	*
	* It will traverse the new added element in progressive rendering.
	* And traverse all in normal rendering.
	*/
	ChartView$1.prototype.eachRendered = function(cb) {
		traverseElements(this.group, cb);
	};
	ChartView$1.markUpdateMethod = function(payload, methodName) {
		inner$21(payload).updateMethod = methodName;
	};
	ChartView$1.protoInitialize = function() {
		var proto = ChartView$1.prototype;
		proto.type = "chart";
	}();
	return ChartView$1;
}();
/**
* Set state of single element
*/
function elSetState(el, state, highlightDigit) {
	if (el && isHighDownDispatcher(el)) (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
}
function toggleHighlight(data, payload, state) {
	var dataIndex = queryDataIndex(data, payload);
	var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
	if (dataIndex != null) each(normalizeToArray(dataIndex), function(dataIdx) {
		elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
	});
	else data.eachItemGraphicEl(function(el) {
		elSetState(el, state, highlightDigit);
	});
}
enableClassExtend(ChartView, ["dispose"]);
enableClassManagement(ChartView);
function renderTaskPlan(context) {
	return renderPlanner(context.model);
}
function renderTaskReset(context) {
	var seriesModel = context.model;
	var ecModel = context.ecModel;
	var api = context.api;
	var payload = context.payload;
	var progressiveRender = seriesModel.pipelineContext.progressiveRender;
	var view = context.view;
	var updateMethod = payload && inner$21(payload).updateMethod;
	var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
	if (methodName !== "render") view[methodName](seriesModel, ecModel, api, payload);
	return progressMethodMap[methodName];
}
var progressMethodMap = {
	incrementalPrepareRender: { progress: function(params, context) {
		context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
	} },
	render: {
		forceFirstProgress: true,
		progress: function(params, context) {
			context.view.render(context.model, context.ecModel, context.api, context.payload);
		}
	}
};
var Chart_default = ChartView;

//#endregion
//#region node_modules/echarts/lib/util/throttle.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var ORIGIN_METHOD = "\0__throttleOriginMethod";
var RATE = "\0__throttleRate";
var THROTTLE_TYPE = "\0__throttleType";
/**
* @public
* @param {(Function)} fn
* @param {number} [delay=0] Unit: ms.
* @param {boolean} [debounce=false]
*        true: If call interval less than `delay`, only the last call works.
*        false: If call interval less than `delay, call works on fixed rate.
* @return {(Function)} throttled fn.
*/
function throttle(fn, delay, debounce) {
	var currCall;
	var lastCall = 0;
	var lastExec = 0;
	var timer = null;
	var diff;
	var scope;
	var args;
	var debounceNextCall;
	delay = delay || 0;
	function exec() {
		lastExec = (/* @__PURE__ */ new Date()).getTime();
		timer = null;
		fn.apply(scope, args || []);
	}
	var cb = function() {
		var cbArgs = [];
		for (var _i = 0; _i < arguments.length; _i++) cbArgs[_i] = arguments[_i];
		currCall = (/* @__PURE__ */ new Date()).getTime();
		scope = this;
		args = cbArgs;
		var thisDelay = debounceNextCall || delay;
		var thisDebounce = debounceNextCall || debounce;
		debounceNextCall = null;
		diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
		clearTimeout(timer);
		if (thisDebounce) timer = setTimeout(exec, thisDelay);
		else if (diff >= 0) exec();
		else timer = setTimeout(exec, -diff);
		lastCall = currCall;
	};
	/**
	* Clear throttle.
	* @public
	*/
	cb.clear = function() {
		if (timer) {
			clearTimeout(timer);
			timer = null;
		}
	};
	/**
	* Enable debounce once.
	*/
	cb.debounceNextCall = function(debounceDelay) {
		debounceNextCall = debounceDelay;
	};
	return cb;
}
/**
* Create throttle method or update throttle rate.
*
* @example
* ComponentView.prototype.render = function () {
*     ...
*     throttle.createOrUpdate(
*         this,
*         '_dispatchAction',
*         this.model.get('throttle'),
*         'fixRate'
*     );
* };
* ComponentView.prototype.remove = function () {
*     throttle.clear(this, '_dispatchAction');
* };
* ComponentView.prototype.dispose = function () {
*     throttle.clear(this, '_dispatchAction');
* };
*
*/
function createOrUpdate(obj, fnAttr, rate, throttleType) {
	var fn = obj[fnAttr];
	if (!fn) return;
	var originFn = fn[ORIGIN_METHOD] || fn;
	var lastThrottleType = fn[THROTTLE_TYPE];
	if (fn[RATE] !== rate || lastThrottleType !== throttleType) {
		if (rate == null || !throttleType) return obj[fnAttr] = originFn;
		fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
		fn[ORIGIN_METHOD] = originFn;
		fn[THROTTLE_TYPE] = throttleType;
		fn[RATE] = rate;
	}
	return fn;
}
/**
* Clear throttle. Example see throttle.createOrUpdate.
*/
function clear(obj, fnAttr) {
	var fn = obj[fnAttr];
	if (fn && fn[ORIGIN_METHOD]) {
		fn.clear && fn.clear();
		obj[fnAttr] = fn[ORIGIN_METHOD];
	}
}

//#endregion
//#region node_modules/echarts/lib/visual/style.js
var inner$20 = makeInner();
var defaultStyleMappers = {
	itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
	lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
};
var defaultColorKey = {
	lineStyle: "stroke",
	itemStyle: "fill"
};
function getStyleMapper(seriesModel, stylePath) {
	var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
	if (!styleMapper) {
		console.warn("Unknown style type '" + stylePath + "'.");
		return defaultStyleMappers.itemStyle;
	}
	return styleMapper;
}
function getDefaultColorKey(seriesModel, stylePath) {
	var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
	if (!colorKey) {
		console.warn("Unknown style type '" + stylePath + "'.");
		return "fill";
	}
	return colorKey;
}
var seriesStyleTask = {
	createOnAllSeries: true,
	performRawSeries: true,
	reset: function(seriesModel, ecModel) {
		var data = seriesModel.getData();
		var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
		var styleModel = seriesModel.getModel(stylePath);
		var globalStyle = getStyleMapper(seriesModel, stylePath)(styleModel);
		var decalOption = styleModel.getShallow("decal");
		if (decalOption) {
			data.setVisual("decal", decalOption);
			decalOption.dirty = true;
		}
		var colorKey = getDefaultColorKey(seriesModel, stylePath);
		var color$2 = globalStyle[colorKey];
		var colorCallback = isFunction(color$2) ? color$2 : null;
		var hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
		if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
			var colorPalette = seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());
			if (!globalStyle[colorKey]) {
				globalStyle[colorKey] = colorPalette;
				data.setVisual("colorFromPalette", true);
			}
			globalStyle.fill = globalStyle.fill === "auto" || isFunction(globalStyle.fill) ? colorPalette : globalStyle.fill;
			globalStyle.stroke = globalStyle.stroke === "auto" || isFunction(globalStyle.stroke) ? colorPalette : globalStyle.stroke;
		}
		data.setVisual("style", globalStyle);
		data.setVisual("drawType", colorKey);
		if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
			data.setVisual("colorFromPalette", false);
			return { dataEach: function(data$1, idx) {
				var dataParams = seriesModel.getDataParams(idx);
				var itemStyle = extend({}, globalStyle);
				itemStyle[colorKey] = colorCallback(dataParams);
				data$1.setItemVisual(idx, "style", itemStyle);
			} };
		}
	}
};
var sharedModel = new Model_default();
var dataStyleTask = {
	createOnAllSeries: true,
	performRawSeries: true,
	reset: function(seriesModel, ecModel) {
		if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) return;
		var data = seriesModel.getData();
		var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
		var getStyle$1 = getStyleMapper(seriesModel, stylePath);
		var colorKey = data.getVisual("drawType");
		return { dataEach: data.hasItemOption ? function(data$1, idx) {
			var rawItem = data$1.getRawDataItem(idx);
			if (rawItem && rawItem[stylePath]) {
				sharedModel.option = rawItem[stylePath];
				var style = getStyle$1(sharedModel);
				extend(data$1.ensureUniqueItemVisual(idx, "style"), style);
				if (sharedModel.option.decal) {
					data$1.setItemVisual(idx, "decal", sharedModel.option.decal);
					sharedModel.option.decal.dirty = true;
				}
				if (colorKey in style) data$1.setItemVisual(idx, "colorFromPalette", false);
			}
		} : null };
	}
};
var dataColorPaletteTask = {
	performRawSeries: true,
	overallReset: function(ecModel) {
		var paletteScopeGroupByType = createHashMap();
		ecModel.eachSeries(function(seriesModel) {
			var colorBy = seriesModel.getColorBy();
			if (seriesModel.isColorBySeries()) return;
			var key$1 = seriesModel.type + "-" + colorBy;
			var colorScope = paletteScopeGroupByType.get(key$1);
			if (!colorScope) {
				colorScope = {};
				paletteScopeGroupByType.set(key$1, colorScope);
			}
			inner$20(seriesModel).scope = colorScope;
		});
		ecModel.eachSeries(function(seriesModel) {
			if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) return;
			var dataAll = seriesModel.getRawData();
			var idxMap = {};
			var data = seriesModel.getData();
			var colorScope = inner$20(seriesModel).scope;
			var colorKey = getDefaultColorKey(seriesModel, seriesModel.visualStyleAccessPath || "itemStyle");
			data.each(function(idx) {
				var rawIdx = data.getRawIndex(idx);
				idxMap[rawIdx] = idx;
			});
			dataAll.each(function(rawIdx) {
				var idx = idxMap[rawIdx];
				if (data.getItemVisual(idx, "colorFromPalette")) {
					var itemStyle = data.ensureUniqueItemVisual(idx, "style");
					var name_1 = dataAll.getName(rawIdx) || rawIdx + "";
					var dataCount = dataAll.count();
					itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
				}
			});
		});
	}
};

//#endregion
//#region node_modules/echarts/lib/loading/default.js
var PI$5 = Math.PI;
/**
* @param {module:echarts/ExtensionAPI} api
* @param {Object} [opts]
* @param {string} [opts.text]
* @param {string} [opts.color]
* @param {string} [opts.textColor]
* @return {module:zrender/Element}
*/
function defaultLoading(api, opts) {
	opts = opts || {};
	defaults(opts, {
		text: "loading",
		textColor: tokens_default.color.primary,
		fontSize: 12,
		fontWeight: "normal",
		fontStyle: "normal",
		fontFamily: "sans-serif",
		maskColor: "rgba(255,255,255,0.8)",
		showSpinner: true,
		color: tokens_default.color.theme[0],
		spinnerRadius: 10,
		lineWidth: 5,
		zlevel: 0
	});
	var group = new Group_default();
	var mask = new Rect_default({
		style: { fill: opts.maskColor },
		zlevel: opts.zlevel,
		z: 1e4
	});
	group.add(mask);
	var textContent = new Text_default({
		style: {
			text: opts.text,
			fill: opts.textColor,
			fontSize: opts.fontSize,
			fontWeight: opts.fontWeight,
			fontStyle: opts.fontStyle,
			fontFamily: opts.fontFamily
		},
		zlevel: opts.zlevel,
		z: 10001
	});
	var labelRect = new Rect_default({
		style: { fill: "none" },
		textContent,
		textConfig: {
			position: "right",
			distance: 10
		},
		zlevel: opts.zlevel,
		z: 10001
	});
	group.add(labelRect);
	var arc;
	if (opts.showSpinner) {
		arc = new Arc_default({
			shape: {
				startAngle: -PI$5 / 2,
				endAngle: -PI$5 / 2 + .1,
				r: opts.spinnerRadius
			},
			style: {
				stroke: opts.color,
				lineCap: "round",
				lineWidth: opts.lineWidth
			},
			zlevel: opts.zlevel,
			z: 10001
		});
		arc.animateShape(true).when(1e3, { endAngle: PI$5 * 3 / 2 }).start("circularInOut");
		arc.animateShape(true).when(1e3, { startAngle: PI$5 * 3 / 2 }).delay(300).start("circularInOut");
		group.add(arc);
	}
	group.resize = function() {
		var textWidth = textContent.getBoundingRect().width;
		var r = opts.showSpinner ? opts.spinnerRadius : 0;
		var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r);
		var cy = api.getHeight() / 2;
		opts.showSpinner && arc.setShape({
			cx,
			cy
		});
		labelRect.setShape({
			x: cx - r,
			y: cy - r,
			width: r * 2,
			height: r * 2
		});
		mask.setShape({
			x: 0,
			y: 0,
			width: api.getWidth(),
			height: api.getHeight()
		});
	};
	group.resize();
	return group;
}

//#endregion
//#region node_modules/echarts/lib/core/Scheduler.js
var Scheduler = function() {
	function Scheduler$1(ecInstance, api, dataProcessorHandlers, visualHandlers) {
		this._stageTaskMap = createHashMap();
		this.ecInstance = ecInstance;
		this.api = api;
		dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
		visualHandlers = this._visualHandlers = visualHandlers.slice();
		this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
	}
	Scheduler$1.prototype.restoreData = function(ecModel, payload) {
		ecModel.restoreData(payload);
		this._stageTaskMap.each(function(taskRecord) {
			var overallTask = taskRecord.overallTask;
			overallTask && overallTask.dirty();
		});
	};
	Scheduler$1.prototype.getPerformArgs = function(task, isBlock) {
		if (!task.__pipeline) return;
		var pipeline = this._pipelineMap.get(task.__pipeline.id);
		var pCtx = pipeline.context;
		var step = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex ? pipeline.step : null;
		var modDataCount = pCtx && pCtx.modDataCount;
		return {
			step,
			modBy: modDataCount != null ? Math.ceil(modDataCount / step) : null,
			modDataCount
		};
	};
	Scheduler$1.prototype.getPipeline = function(pipelineId) {
		return this._pipelineMap.get(pipelineId);
	};
	/**
	* Current, progressive rendering starts from visual and layout.
	* Always detect render mode in the same stage, avoiding that incorrect
	* detection caused by data filtering.
	* Caution:
	* `updateStreamModes` use `seriesModel.getData()`.
	*/
	Scheduler$1.prototype.updateStreamModes = function(seriesModel, view) {
		var pipeline = this._pipelineMap.get(seriesModel.uid);
		var dataLen = seriesModel.getData().count();
		var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
		var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
		seriesModel.pipelineContext = pipeline.context = {
			progressiveRender,
			modDataCount: seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null,
			large
		};
	};
	Scheduler$1.prototype.restorePipelines = function(ecModel) {
		var scheduler = this;
		var pipelineMap = scheduler._pipelineMap = createHashMap();
		ecModel.eachSeries(function(seriesModel) {
			var progressive = seriesModel.getProgressive();
			var pipelineId = seriesModel.uid;
			pipelineMap.set(pipelineId, {
				id: pipelineId,
				head: null,
				tail: null,
				threshold: seriesModel.getProgressiveThreshold(),
				progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
				blockIndex: -1,
				step: Math.round(progressive || 700),
				count: 0
			});
			scheduler._pipe(seriesModel, seriesModel.dataTask);
		});
	};
	Scheduler$1.prototype.prepareStageTasks = function() {
		var stageTaskMap = this._stageTaskMap;
		var ecModel = this.api.getModel();
		var api = this.api;
		each(this._allHandlers, function(handler) {
			var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
			var errMsg = "";
			errMsg = "\"reset\" and \"overallReset\" must not be both specified.";
			assert(!(handler.reset && handler.overallReset), errMsg);
			handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);
			handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);
		}, this);
	};
	Scheduler$1.prototype.prepareView = function(view, model, ecModel, api) {
		var renderTask = view.renderTask;
		var context = renderTask.context;
		context.model = model;
		context.ecModel = ecModel;
		context.api = api;
		renderTask.__block = !view.incrementalPrepareRender;
		this._pipe(model, renderTask);
	};
	Scheduler$1.prototype.performDataProcessorTasks = function(ecModel, payload) {
		this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, { block: true });
	};
	Scheduler$1.prototype.performVisualTasks = function(ecModel, payload, opt) {
		this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
	};
	Scheduler$1.prototype._performStageTasks = function(stageHandlers, ecModel, payload, opt) {
		opt = opt || {};
		var unfinished = false;
		var scheduler = this;
		each(stageHandlers, function(stageHandler, idx) {
			if (opt.visualType && opt.visualType !== stageHandler.visualType) return;
			var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
			var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
			var overallTask = stageHandlerRecord.overallTask;
			if (overallTask) {
				var overallNeedDirty_1;
				var agentStubMap = overallTask.agentStubMap;
				agentStubMap.each(function(stub) {
					if (needSetDirty(opt, stub)) {
						stub.dirty();
						overallNeedDirty_1 = true;
					}
				});
				overallNeedDirty_1 && overallTask.dirty();
				scheduler.updatePayload(overallTask, payload);
				var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
				agentStubMap.each(function(stub) {
					stub.perform(performArgs_1);
				});
				if (overallTask.perform(performArgs_1)) unfinished = true;
			} else if (seriesTaskMap) seriesTaskMap.each(function(task, pipelineId) {
				if (needSetDirty(opt, task)) task.dirty();
				var performArgs = scheduler.getPerformArgs(task, opt.block);
				performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
				scheduler.updatePayload(task, payload);
				if (task.perform(performArgs)) unfinished = true;
			});
		});
		function needSetDirty(opt$1, task) {
			return opt$1.setDirty && (!opt$1.dirtyMap || opt$1.dirtyMap.get(task.__pipeline.id));
		}
		this.unfinished = unfinished || this.unfinished;
	};
	Scheduler$1.prototype.performSeriesTasks = function(ecModel) {
		var unfinished;
		ecModel.eachSeries(function(seriesModel) {
			unfinished = seriesModel.dataTask.perform() || unfinished;
		});
		this.unfinished = unfinished || this.unfinished;
	};
	Scheduler$1.prototype.plan = function() {
		this._pipelineMap.each(function(pipeline) {
			var task = pipeline.tail;
			do {
				if (task.__block) {
					pipeline.blockIndex = task.__idxInPipeline;
					break;
				}
				task = task.getUpstream();
			} while (task);
		});
	};
	Scheduler$1.prototype.updatePayload = function(task, payload) {
		payload !== "remain" && (task.context.payload = payload);
	};
	Scheduler$1.prototype._createSeriesStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
		var scheduler = this;
		var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
		var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
		var seriesType$1 = stageHandler.seriesType;
		var getTargetSeries = stageHandler.getTargetSeries;
		if (stageHandler.createOnAllSeries) ecModel.eachRawSeries(create$3);
		else if (seriesType$1) ecModel.eachRawSeriesByType(seriesType$1, create$3);
		else if (getTargetSeries) getTargetSeries(ecModel, api).each(create$3);
		function create$3(seriesModel) {
			var pipelineId = seriesModel.uid;
			var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
				plan: seriesTaskPlan,
				reset: seriesTaskReset,
				count: seriesTaskCount
			}));
			task.context = {
				model: seriesModel,
				ecModel,
				api,
				useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
				plan: stageHandler.plan,
				reset: stageHandler.reset,
				scheduler
			};
			scheduler._pipe(seriesModel, task);
		}
	};
	Scheduler$1.prototype._createOverallStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
		var scheduler = this;
		var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({ reset: overallTaskReset });
		overallTask.context = {
			ecModel,
			api,
			overallReset: stageHandler.overallReset,
			scheduler
		};
		var oldAgentStubMap = overallTask.agentStubMap;
		var newAgentStubMap = overallTask.agentStubMap = createHashMap();
		var seriesType$1 = stageHandler.seriesType;
		var getTargetSeries = stageHandler.getTargetSeries;
		var overallProgress = true;
		var shouldOverallTaskDirty = false;
		var errMsg = "";
		errMsg = "\"createOnAllSeries\" is not supported for \"overallReset\", because it will block all streams.";
		assert(!stageHandler.createOnAllSeries, errMsg);
		if (seriesType$1) ecModel.eachRawSeriesByType(seriesType$1, createStub);
		else if (getTargetSeries) getTargetSeries(ecModel, api).each(createStub);
		else {
			overallProgress = false;
			each(ecModel.getSeries(), createStub);
		}
		function createStub(seriesModel) {
			var pipelineId = seriesModel.uid;
			var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({
				reset: stubReset,
				onDirty: stubOnDirty
			})));
			stub.context = {
				model: seriesModel,
				overallProgress
			};
			stub.agent = overallTask;
			stub.__block = overallProgress;
			scheduler._pipe(seriesModel, stub);
		}
		if (shouldOverallTaskDirty) overallTask.dirty();
	};
	Scheduler$1.prototype._pipe = function(seriesModel, task) {
		var pipelineId = seriesModel.uid;
		var pipeline = this._pipelineMap.get(pipelineId);
		!pipeline.head && (pipeline.head = task);
		pipeline.tail && pipeline.tail.pipe(task);
		pipeline.tail = task;
		task.__idxInPipeline = pipeline.count++;
		task.__pipeline = pipeline;
	};
	Scheduler$1.wrapStageHandler = function(stageHandler, visualType) {
		if (isFunction(stageHandler)) stageHandler = {
			overallReset: stageHandler,
			seriesType: detectSeriseType(stageHandler)
		};
		stageHandler.uid = getUID("stageHandler");
		visualType && (stageHandler.visualType = visualType);
		return stageHandler;
	};
	return Scheduler$1;
}();
function overallTaskReset(context) {
	context.overallReset(context.ecModel, context.api, context.payload);
}
function stubReset(context) {
	return context.overallProgress && stubProgress;
}
function stubProgress() {
	this.agent.dirty();
	this.getDownstream().dirty();
}
function stubOnDirty() {
	this.agent && this.agent.dirty();
}
function seriesTaskPlan(context) {
	return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
}
function seriesTaskReset(context) {
	if (context.useClearVisual) context.data.clearAllVisual();
	var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
	return resetDefines.length > 1 ? map(resetDefines, function(v, idx) {
		return makeSeriesTaskProgress(idx);
	}) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(resetDefineIdx) {
	return function(params, context) {
		var data = context.data;
		var resetDefine = context.resetDefines[resetDefineIdx];
		if (resetDefine && resetDefine.dataEach) for (var i$1 = params.start; i$1 < params.end; i$1++) resetDefine.dataEach(data, i$1);
		else if (resetDefine && resetDefine.progress) resetDefine.progress(params, data);
	};
}
function seriesTaskCount(context) {
	return context.data.count();
}
/**
* Only some legacy stage handlers (usually in echarts extensions) are pure function.
* To ensure that they can work normally, they should work in block mode, that is,
* they should not be started util the previous tasks finished. So they cause the
* progressive rendering disabled. We try to detect the series type, to narrow down
* the block range to only the series type they concern, but not all series.
*/
function detectSeriseType(legacyFunc) {
	seriesType = null;
	try {
		legacyFunc(ecModelMock, apiMock);
	} catch (e$1) {}
	return seriesType;
}
var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, Global_default);
mockMethods(apiMock, ExtensionAPI_default);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
	seriesType = type;
};
ecModelMock.eachComponent = function(cond) {
	if (cond.mainType === "series" && cond.subType) seriesType = cond.subType;
};
function mockMethods(target, Clz) {
	for (var name_1 in Clz.prototype) target[name_1] = noop;
}
var Scheduler_default = Scheduler;

//#endregion
//#region node_modules/echarts/lib/theme/dark.js
var color = tokens_default.darkColor;
var backgroundColor = color.background;
var axisCommon = function() {
	return {
		axisLine: { lineStyle: { color: color.axisLine } },
		splitLine: { lineStyle: { color: color.axisSplitLine } },
		splitArea: { areaStyle: { color: [color.backgroundTint, color.backgroundTransparent] } },
		minorSplitLine: { lineStyle: { color: color.axisMinorSplitLine } },
		axisLabel: { color: color.axisLabel },
		axisName: {}
	};
};
var matrixAxis = {
	label: { color: color.secondary },
	itemStyle: { borderColor: color.borderTint },
	dividerLineStyle: { color: color.border }
};
var theme = {
	darkMode: true,
	color: color.theme,
	backgroundColor,
	axisPointer: {
		lineStyle: { color: color.border },
		crossStyle: { color: color.borderShade },
		label: { color: color.tertiary }
	},
	legend: {
		textStyle: { color: color.secondary },
		pageTextStyle: { color: color.tertiary }
	},
	textStyle: { color: color.secondary },
	title: {
		textStyle: { color: color.primary },
		subtextStyle: { color: color.quaternary }
	},
	toolbox: { iconStyle: { borderColor: color.accent50 } },
	tooltip: {
		backgroundColor: color.neutral20,
		defaultBorderColor: color.border,
		textStyle: { color: color.tertiary }
	},
	dataZoom: {
		borderColor: color.accent10,
		textStyle: { color: color.tertiary },
		brushStyle: { color: color.backgroundTint },
		handleStyle: {
			color: color.neutral00,
			borderColor: color.accent20
		},
		moveHandleStyle: { color: color.accent40 },
		emphasis: { handleStyle: { borderColor: color.accent50 } },
		dataBackground: {
			lineStyle: { color: color.accent30 },
			areaStyle: { color: color.accent20 }
		},
		selectedDataBackground: {
			lineStyle: { color: color.accent50 },
			areaStyle: { color: color.accent30 }
		}
	},
	visualMap: {
		textStyle: { color: color.secondary },
		handleStyle: { borderColor: color.neutral30 }
	},
	timeline: {
		lineStyle: { color: color.accent10 },
		label: { color: color.tertiary },
		controlStyle: {
			color: color.accent30,
			borderColor: color.accent30
		}
	},
	calendar: {
		itemStyle: {
			color: color.neutral00,
			borderColor: color.neutral20
		},
		dayLabel: { color: color.tertiary },
		monthLabel: { color: color.secondary },
		yearLabel: { color: color.secondary }
	},
	matrix: {
		x: matrixAxis,
		y: matrixAxis,
		backgroundColor: { borderColor: color.axisLine },
		body: { itemStyle: { borderColor: color.borderTint } }
	},
	timeAxis: axisCommon(),
	logAxis: axisCommon(),
	valueAxis: axisCommon(),
	categoryAxis: axisCommon(),
	line: { symbol: "circle" },
	graph: { color: color.theme },
	gauge: {
		title: { color: color.secondary },
		axisLine: { lineStyle: { color: [[1, color.neutral05]] } },
		axisLabel: { color: color.axisLabel },
		detail: { color: color.primary }
	},
	candlestick: { itemStyle: {
		color: "#f64e56",
		color0: "#54ea92",
		borderColor: "#f64e56",
		borderColor0: "#54ea92"
	} },
	funnel: { itemStyle: { borderColor: color.background } },
	radar: function() {
		var radar = axisCommon();
		radar.axisName = { color: color.axisLabel };
		radar.axisLine.lineStyle.color = color.neutral20;
		return radar;
	}(),
	treemap: { breadcrumb: {
		itemStyle: {
			color: color.neutral20,
			textStyle: { color: color.secondary }
		},
		emphasis: { itemStyle: { color: color.neutral30 } }
	} },
	sunburst: { itemStyle: { borderColor: color.background } },
	map: {
		itemStyle: {
			borderColor: color.border,
			areaColor: color.neutral10
		},
		label: { color: color.tertiary },
		emphasis: {
			label: { color: color.primary },
			itemStyle: { areaColor: color.highlight }
		},
		select: {
			label: { color: color.primary },
			itemStyle: { areaColor: color.highlight }
		}
	},
	geo: {
		itemStyle: {
			borderColor: color.border,
			areaColor: color.neutral10
		},
		emphasis: {
			label: { color: color.primary },
			itemStyle: { areaColor: color.highlight }
		},
		select: {
			label: { color: color.primary },
			itemStyle: { color: color.highlight }
		}
	}
};
theme.categoryAxis.splitLine.show = false;
var dark_default = theme;

//#endregion
//#region node_modules/echarts/lib/util/ECEventProcessor.js
/**
* Usage of query:
* `chart.on('click', query, handler);`
* The `query` can be:
* + The component type query string, only `mainType` or `mainType.subType`,
*   like: 'xAxis', 'series', 'xAxis.category' or 'series.line'.
* + The component query object, like:
*   `{seriesIndex: 2}`, `{seriesName: 'xx'}`, `{seriesId: 'some'}`,
*   `{xAxisIndex: 2}`, `{xAxisName: 'xx'}`, `{xAxisId: 'some'}`.
* + The data query object, like:
*   `{dataIndex: 123}`, `{dataType: 'link'}`, `{name: 'some'}`.
* + The other query object (cmponent customized query), like:
*   `{element: 'some'}` (only available in custom series).
*
* Caveat: If a prop in the `query` object is `null/undefined`, it is the
* same as there is no such prop in the `query` object.
*/
var ECEventProcessor = function() {
	function ECEventProcessor$1() {}
	ECEventProcessor$1.prototype.normalizeQuery = function(query) {
		var cptQuery = {};
		var dataQuery = {};
		var otherQuery = {};
		if (isString(query)) {
			var condCptType = parseClassType(query);
			cptQuery.mainType = condCptType.main || null;
			cptQuery.subType = condCptType.sub || null;
		} else {
			var suffixes_1 = [
				"Index",
				"Name",
				"Id"
			];
			var dataKeys_1 = {
				name: 1,
				dataIndex: 1,
				dataType: 1
			};
			each(query, function(val, key$1) {
				var reserved = false;
				for (var i$1 = 0; i$1 < suffixes_1.length; i$1++) {
					var propSuffix = suffixes_1[i$1];
					var suffixPos = key$1.lastIndexOf(propSuffix);
					if (suffixPos > 0 && suffixPos === key$1.length - propSuffix.length) {
						var mainType = key$1.slice(0, suffixPos);
						if (mainType !== "data") {
							cptQuery.mainType = mainType;
							cptQuery[propSuffix.toLowerCase()] = val;
							reserved = true;
						}
					}
				}
				if (dataKeys_1.hasOwnProperty(key$1)) {
					dataQuery[key$1] = val;
					reserved = true;
				}
				if (!reserved) otherQuery[key$1] = val;
			});
		}
		return {
			cptQuery,
			dataQuery,
			otherQuery
		};
	};
	ECEventProcessor$1.prototype.filter = function(eventType, query) {
		var eventInfo = this.eventInfo;
		if (!eventInfo) return true;
		var targetEl = eventInfo.targetEl;
		var packedEvent = eventInfo.packedEvent;
		var model = eventInfo.model;
		var view = eventInfo.view;
		if (!model || !view) return true;
		var cptQuery = query.cptQuery;
		var dataQuery = query.dataQuery;
		return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
		function check(query$1, host, prop, propOnHost) {
			return query$1[prop] == null || host[propOnHost || prop] === query$1[prop];
		}
	};
	ECEventProcessor$1.prototype.afterTrigger = function() {
		this.eventInfo = null;
	};
	return ECEventProcessor$1;
}();

//#endregion
//#region node_modules/echarts/lib/visual/symbol.js
var SYMBOL_PROPS_WITH_CB = [
	"symbol",
	"symbolSize",
	"symbolRotate",
	"symbolOffset"
];
var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]);
var seriesSymbolTask = {
	createOnAllSeries: true,
	performRawSeries: true,
	reset: function(seriesModel, ecModel) {
		var data = seriesModel.getData();
		if (seriesModel.legendIcon) data.setVisual("legendIcon", seriesModel.legendIcon);
		if (!seriesModel.hasSymbolVisual) return;
		var symbolOptions = {};
		var symbolOptionsCb = {};
		var hasCallback = false;
		for (var i$1 = 0; i$1 < SYMBOL_PROPS_WITH_CB.length; i$1++) {
			var symbolPropName = SYMBOL_PROPS_WITH_CB[i$1];
			var val = seriesModel.get(symbolPropName);
			if (isFunction(val)) {
				hasCallback = true;
				symbolOptionsCb[symbolPropName] = val;
			} else symbolOptions[symbolPropName] = val;
		}
		symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
		data.setVisual(extend({
			legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
			symbolKeepAspect: seriesModel.get("symbolKeepAspect")
		}, symbolOptions));
		if (ecModel.isSeriesFiltered(seriesModel)) return;
		var symbolPropsCb = keys(symbolOptionsCb);
		function dataEach(data$1, idx) {
			var rawValue = seriesModel.getRawValue(idx);
			var params = seriesModel.getDataParams(idx);
			for (var i$2 = 0; i$2 < symbolPropsCb.length; i$2++) {
				var symbolPropName$1 = symbolPropsCb[i$2];
				data$1.setItemVisual(idx, symbolPropName$1, symbolOptionsCb[symbolPropName$1](rawValue, params));
			}
		}
		return { dataEach: hasCallback ? dataEach : null };
	}
};
var dataSymbolTask = {
	createOnAllSeries: true,
	performRawSeries: true,
	reset: function(seriesModel, ecModel) {
		if (!seriesModel.hasSymbolVisual) return;
		if (ecModel.isSeriesFiltered(seriesModel)) return;
		var data = seriesModel.getData();
		function dataEach(data$1, idx) {
			var itemModel = data$1.getItemModel(idx);
			for (var i$1 = 0; i$1 < SYMBOL_PROPS.length; i$1++) {
				var symbolPropName = SYMBOL_PROPS[i$1];
				var val = itemModel.getShallow(symbolPropName, true);
				if (val != null) data$1.setItemVisual(idx, symbolPropName, val);
			}
		}
		return { dataEach: data.hasItemOption ? dataEach : null };
	}
};

//#endregion
//#region node_modules/echarts/lib/visual/helper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function getItemVisualFromData(data, dataIndex, key$1) {
	switch (key$1) {
		case "color": return data.getItemVisual(dataIndex, "style")[data.getVisual("drawType")];
		case "opacity": return data.getItemVisual(dataIndex, "style").opacity;
		case "symbol":
		case "symbolSize":
		case "liftZ": return data.getItemVisual(dataIndex, key$1);
		default: console.warn("Unknown visual type " + key$1);
	}
}
function getVisualFromData(data, key$1) {
	switch (key$1) {
		case "color": return data.getVisual("style")[data.getVisual("drawType")];
		case "opacity": return data.getVisual("style").opacity;
		case "symbol":
		case "symbolSize":
		case "liftZ": return data.getVisual(key$1);
		default: console.warn("Unknown visual type " + key$1);
	}
}
function setItemVisualFromData(data, dataIndex, key$1, value) {
	switch (key$1) {
		case "color":
			var style = data.ensureUniqueItemVisual(dataIndex, "style");
			style[data.getVisual("drawType")] = value;
			data.setItemVisual(dataIndex, "colorFromPalette", false);
			break;
		case "opacity":
			data.ensureUniqueItemVisual(dataIndex, "style").opacity = value;
			break;
		case "symbol":
		case "symbolSize":
		case "liftZ":
			data.setItemVisual(dataIndex, key$1, value);
			break;
		default: console.warn("Unknown visual type " + key$1);
	}
}

//#endregion
//#region node_modules/echarts/lib/legacy/dataSelectAction.js
function createLegacyDataSelectAction(seriesType$1, ecRegisterAction) {
	function getSeriesIndices(ecModel, payload) {
		var seriesIndices = [];
		ecModel.eachComponent({
			mainType: "series",
			subType: seriesType$1,
			query: payload
		}, function(seriesModel) {
			seriesIndices.push(seriesModel.seriesIndex);
		});
		return seriesIndices;
	}
	each([
		[seriesType$1 + "ToggleSelect", "toggleSelect"],
		[seriesType$1 + "Select", "select"],
		[seriesType$1 + "UnSelect", "unselect"]
	], function(eventsMap) {
		ecRegisterAction(eventsMap[0], function(payload, ecModel, api) {
			payload = extend({}, payload);
			deprecateReplaceLog(payload.type, eventsMap[1]);
			api.dispatchAction(extend(payload, {
				type: eventsMap[1],
				seriesIndex: getSeriesIndices(ecModel, payload)
			}));
		});
	});
}
function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
	var legacyEventName = type + eventPostfix;
	if (!ecIns.isSilent(legacyEventName)) {
		deprecateLog("event " + legacyEventName + " is deprecated.");
		ecModel.eachComponent({
			mainType: "series",
			subType: "pie"
		}, function(seriesModel) {
			var seriesIndex = seriesModel.seriesIndex;
			var selectedMap = seriesModel.option.selectedMap;
			var selected = payload.selected;
			for (var i$1 = 0; i$1 < selected.length; i$1++) if (selected[i$1].seriesIndex === seriesIndex) {
				var data = seriesModel.getData();
				var dataIndex = queryDataIndex(data, payload.fromActionPayload);
				ecIns.trigger(legacyEventName, {
					type: legacyEventName,
					seriesId: seriesModel.id,
					name: isArray(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
					selected: isString(selectedMap) ? selectedMap : extend({}, selectedMap)
				});
			}
		});
	}
}
function handleLegacySelectEvents(messageCenter, ecIns, api) {
	messageCenter.on("selectchanged", function(params) {
		var ecModel = api.getModel();
		if (params.isFromClick) {
			handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
			handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
		} else if (params.fromAction === "select") {
			handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
			handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
		} else if (params.fromAction === "unselect") {
			handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
			handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/util/event.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function findEventDispatcher(target, det, returnFirstMatch) {
	var found;
	while (target) {
		if (det(target)) {
			found = target;
			if (returnFirstMatch) break;
		}
		target = target.__hostTarget || target.parent;
	}
	return found;
}

//#endregion
//#region node_modules/zrender/lib/core/WeakMap.js
var wmUniqueIndex = Math.round(Math.random() * 9);
var supportDefineProperty = typeof Object.defineProperty === "function";
var WeakMap = function() {
	function WeakMap$1() {
		this._id = "__ec_inner_" + wmUniqueIndex++;
	}
	WeakMap$1.prototype.get = function(key$1) {
		return this._guard(key$1)[this._id];
	};
	WeakMap$1.prototype.set = function(key$1, value) {
		var target = this._guard(key$1);
		if (supportDefineProperty) Object.defineProperty(target, this._id, {
			value,
			enumerable: false,
			configurable: true
		});
		else target[this._id] = value;
		return this;
	};
	WeakMap$1.prototype["delete"] = function(key$1) {
		if (this.has(key$1)) {
			delete this._guard(key$1)[this._id];
			return true;
		}
		return false;
	};
	WeakMap$1.prototype.has = function(key$1) {
		return !!this._guard(key$1)[this._id];
	};
	WeakMap$1.prototype._guard = function(key$1) {
		if (key$1 !== Object(key$1)) throw TypeError("Value of WeakMap is not a non-null object.");
		return key$1;
	};
	return WeakMap$1;
}();
var WeakMap_default = WeakMap;

//#endregion
//#region node_modules/echarts/lib/util/symbol.js
/**
* Triangle shape
* @inner
*/
var Triangle = Path_default.extend({
	type: "triangle",
	shape: {
		cx: 0,
		cy: 0,
		width: 0,
		height: 0
	},
	buildPath: function(path, shape) {
		var cx = shape.cx;
		var cy = shape.cy;
		var width = shape.width / 2;
		var height = shape.height / 2;
		path.moveTo(cx, cy - height);
		path.lineTo(cx + width, cy + height);
		path.lineTo(cx - width, cy + height);
		path.closePath();
	}
});
/**
* Diamond shape
* @inner
*/
var Diamond = Path_default.extend({
	type: "diamond",
	shape: {
		cx: 0,
		cy: 0,
		width: 0,
		height: 0
	},
	buildPath: function(path, shape) {
		var cx = shape.cx;
		var cy = shape.cy;
		var width = shape.width / 2;
		var height = shape.height / 2;
		path.moveTo(cx, cy - height);
		path.lineTo(cx + width, cy);
		path.lineTo(cx, cy + height);
		path.lineTo(cx - width, cy);
		path.closePath();
	}
});
/**
* Pin shape
* @inner
*/
var Pin = Path_default.extend({
	type: "pin",
	shape: {
		x: 0,
		y: 0,
		width: 0,
		height: 0
	},
	buildPath: function(path, shape) {
		var x = shape.x;
		var y = shape.y;
		var w = shape.width / 5 * 3;
		var h = Math.max(w, shape.height);
		var r = w / 2;
		var dy = r * r / (h - r);
		var cy = y - h + r + dy;
		var angle = Math.asin(dy / r);
		var dx = Math.cos(angle) * r;
		var tanX = Math.sin(angle);
		var tanY = Math.cos(angle);
		var cpLen = r * .6;
		var cpLen2 = r * .7;
		path.moveTo(x - dx, cy + dy);
		path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
		path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
		path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
		path.closePath();
	}
});
/**
* Arrow shape
* @inner
*/
var Arrow = Path_default.extend({
	type: "arrow",
	shape: {
		x: 0,
		y: 0,
		width: 0,
		height: 0
	},
	buildPath: function(ctx, shape) {
		var height = shape.height;
		var width = shape.width;
		var x = shape.x;
		var y = shape.y;
		var dx = width / 3 * 2;
		ctx.moveTo(x, y);
		ctx.lineTo(x + dx, y + height);
		ctx.lineTo(x, y + height / 4 * 3);
		ctx.lineTo(x - dx, y + height);
		ctx.lineTo(x, y);
		ctx.closePath();
	}
});
/**
* Map of path constructors
*/
var symbolCtors = {
	line: Line_default,
	rect: Rect_default,
	roundRect: Rect_default,
	square: Rect_default,
	circle: Circle_default,
	diamond: Diamond,
	pin: Pin,
	arrow: Arrow,
	triangle: Triangle
};
var symbolShapeMakers = {
	line: function(x, y, w, h, shape) {
		shape.x1 = x;
		shape.y1 = y + h / 2;
		shape.x2 = x + w;
		shape.y2 = y + h / 2;
	},
	rect: function(x, y, w, h, shape) {
		shape.x = x;
		shape.y = y;
		shape.width = w;
		shape.height = h;
	},
	roundRect: function(x, y, w, h, shape) {
		shape.x = x;
		shape.y = y;
		shape.width = w;
		shape.height = h;
		shape.r = Math.min(w, h) / 4;
	},
	square: function(x, y, w, h, shape) {
		var size = Math.min(w, h);
		shape.x = x;
		shape.y = y;
		shape.width = size;
		shape.height = size;
	},
	circle: function(x, y, w, h, shape) {
		shape.cx = x + w / 2;
		shape.cy = y + h / 2;
		shape.r = Math.min(w, h) / 2;
	},
	diamond: function(x, y, w, h, shape) {
		shape.cx = x + w / 2;
		shape.cy = y + h / 2;
		shape.width = w;
		shape.height = h;
	},
	pin: function(x, y, w, h, shape) {
		shape.x = x + w / 2;
		shape.y = y + h / 2;
		shape.width = w;
		shape.height = h;
	},
	arrow: function(x, y, w, h, shape) {
		shape.x = x + w / 2;
		shape.y = y + h / 2;
		shape.width = w;
		shape.height = h;
	},
	triangle: function(x, y, w, h, shape) {
		shape.cx = x + w / 2;
		shape.cy = y + h / 2;
		shape.width = w;
		shape.height = h;
	}
};
var symbolBuildProxies = {};
each(symbolCtors, function(Ctor, name) {
	symbolBuildProxies[name] = new Ctor();
});
var SymbolClz = Path_default.extend({
	type: "symbol",
	shape: {
		symbolType: "",
		x: 0,
		y: 0,
		width: 0,
		height: 0
	},
	calculateTextPosition: function(out$1, config, rect) {
		var res = calculateTextPosition(out$1, config, rect);
		var shape = this.shape;
		if (shape && shape.symbolType === "pin" && config.position === "inside") res.y = rect.y + rect.height * .4;
		return res;
	},
	buildPath: function(ctx, shape, inBundle) {
		var symbolType = shape.symbolType;
		if (symbolType !== "none") {
			var proxySymbol = symbolBuildProxies[symbolType];
			if (!proxySymbol) {
				symbolType = "rect";
				proxySymbol = symbolBuildProxies[symbolType];
			}
			symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
			proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
		}
	}
});
function symbolPathSetColor(color$2, innerColor$1) {
	if (this.type !== "image") {
		var symbolStyle = this.style;
		if (this.__isEmptyBrush) {
			symbolStyle.stroke = color$2;
			symbolStyle.fill = innerColor$1 || tokens_default.color.neutral00;
			symbolStyle.lineWidth = 2;
		} else if (this.shape.symbolType === "line") symbolStyle.stroke = color$2;
		else symbolStyle.fill = color$2;
		this.markRedraw();
	}
}
/**
* Create a symbol element with given symbol configuration: shape, x, y, width, height, color
*/
function createSymbol(symbolType, x, y, w, h, color$2, keepAspect) {
	var isEmpty = symbolType.indexOf("empty") === 0;
	if (isEmpty) symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	var symbolPath;
	if (symbolType.indexOf("image://") === 0) symbolPath = makeImage(symbolType.slice(8), new BoundingRect_default(x, y, w, h), keepAspect ? "center" : "cover");
	else if (symbolType.indexOf("path://") === 0) symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect_default(x, y, w, h), keepAspect ? "center" : "cover");
	else symbolPath = new SymbolClz({ shape: {
		symbolType,
		x,
		y,
		width: w,
		height: h
	} });
	symbolPath.__isEmptyBrush = isEmpty;
	symbolPath.setColor = symbolPathSetColor;
	if (color$2) symbolPath.setColor(color$2);
	return symbolPath;
}
function normalizeSymbolSize(symbolSize) {
	if (!isArray(symbolSize)) symbolSize = [+symbolSize, +symbolSize];
	return [symbolSize[0] || 0, symbolSize[1] || 0];
}
function normalizeSymbolOffset(symbolOffset, symbolSize) {
	if (symbolOffset == null) return;
	if (!isArray(symbolOffset)) symbolOffset = [symbolOffset, symbolOffset];
	return [parsePercent$1(symbolOffset[0], symbolSize[0]) || 0, parsePercent$1(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
}

//#endregion
//#region node_modules/zrender/lib/canvas/helper.js
function isSafeNum(num) {
	return isFinite(num);
}
function createLinearGradient(ctx, obj, rect) {
	var x = obj.x == null ? 0 : obj.x;
	var x2 = obj.x2 == null ? 1 : obj.x2;
	var y = obj.y == null ? 0 : obj.y;
	var y2 = obj.y2 == null ? 0 : obj.y2;
	if (!obj.global) {
		x = x * rect.width + rect.x;
		x2 = x2 * rect.width + rect.x;
		y = y * rect.height + rect.y;
		y2 = y2 * rect.height + rect.y;
	}
	x = isSafeNum(x) ? x : 0;
	x2 = isSafeNum(x2) ? x2 : 1;
	y = isSafeNum(y) ? y : 0;
	y2 = isSafeNum(y2) ? y2 : 0;
	return ctx.createLinearGradient(x, y, x2, y2);
}
function createRadialGradient(ctx, obj, rect) {
	var width = rect.width;
	var height = rect.height;
	var min$2 = Math.min(width, height);
	var x = obj.x == null ? .5 : obj.x;
	var y = obj.y == null ? .5 : obj.y;
	var r = obj.r == null ? .5 : obj.r;
	if (!obj.global) {
		x = x * width + rect.x;
		y = y * height + rect.y;
		r = r * min$2;
	}
	x = isSafeNum(x) ? x : .5;
	y = isSafeNum(y) ? y : .5;
	r = r >= 0 && isSafeNum(r) ? r : .5;
	return ctx.createRadialGradient(x, y, 0, x, y, r);
}
function getCanvasGradient(ctx, obj, rect) {
	var canvasGradient = obj.type === "radial" ? createRadialGradient(ctx, obj, rect) : createLinearGradient(ctx, obj, rect);
	var colorStops = obj.colorStops;
	for (var i$1 = 0; i$1 < colorStops.length; i$1++) canvasGradient.addColorStop(colorStops[i$1].offset, colorStops[i$1].color);
	return canvasGradient;
}
function isClipPathChanged(clipPaths, prevClipPaths) {
	if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) return false;
	if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) return true;
	for (var i$1 = 0; i$1 < clipPaths.length; i$1++) if (clipPaths[i$1] !== prevClipPaths[i$1]) return true;
	return false;
}
function parseInt10(val) {
	return parseInt(val, 10);
}
function getSize$1(root, whIdx, opts) {
	var wh = ["width", "height"][whIdx];
	var cwh = ["clientWidth", "clientHeight"][whIdx];
	var plt = ["paddingLeft", "paddingTop"][whIdx];
	var prb = ["paddingRight", "paddingBottom"][whIdx];
	if (opts[wh] != null && opts[wh] !== "auto") return parseFloat(opts[wh]);
	var stl = document.defaultView.getComputedStyle(root);
	return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
}

//#endregion
//#region node_modules/zrender/lib/canvas/dashStyle.js
function normalizeLineDash(lineType, lineWidth) {
	if (!lineType || lineType === "solid" || !(lineWidth > 0)) return null;
	return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber(lineType) ? [lineType] : isArray(lineType) ? lineType : null;
}
function getLineDash(el) {
	var style = el.style;
	var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
	var lineDashOffset = style.lineDashOffset;
	if (lineDash) {
		var lineScale_1 = style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1;
		if (lineScale_1 && lineScale_1 !== 1) {
			lineDash = map(lineDash, function(rawVal) {
				return rawVal / lineScale_1;
			});
			lineDashOffset /= lineScale_1;
		}
	}
	return [lineDash, lineDashOffset];
}

//#endregion
//#region node_modules/zrender/lib/canvas/graphic.js
var pathProxyForDraw = new PathProxy_default(true);
function styleHasStroke(style) {
	var stroke = style.stroke;
	return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
}
function isValidStrokeFillStyle(strokeOrFill) {
	return typeof strokeOrFill === "string" && strokeOrFill !== "none";
}
function styleHasFill(style) {
	var fill = style.fill;
	return fill != null && fill !== "none";
}
function doFillPath(ctx, style) {
	if (style.fillOpacity != null && style.fillOpacity !== 1) {
		var originalGlobalAlpha = ctx.globalAlpha;
		ctx.globalAlpha = style.fillOpacity * style.opacity;
		ctx.fill();
		ctx.globalAlpha = originalGlobalAlpha;
	} else ctx.fill();
}
function doStrokePath(ctx, style) {
	if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
		var originalGlobalAlpha = ctx.globalAlpha;
		ctx.globalAlpha = style.strokeOpacity * style.opacity;
		ctx.stroke();
		ctx.globalAlpha = originalGlobalAlpha;
	} else ctx.stroke();
}
function createCanvasPattern(ctx, pattern, el) {
	var image = createOrUpdateImage(pattern.image, pattern.__image, el);
	if (isImageReady(image)) {
		var canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
		if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
			var matrix = new DOMMatrix();
			matrix.translateSelf(pattern.x || 0, pattern.y || 0);
			matrix.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
			matrix.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
			canvasPattern.setTransform(matrix);
		}
		return canvasPattern;
	}
}
function brushPath(ctx, el, style, inBatch) {
	var _a$1;
	var hasStroke = styleHasStroke(style);
	var hasFill = styleHasFill(style);
	var strokePercent = style.strokePercent;
	var strokePart = strokePercent < 1;
	var firstDraw = !el.path;
	if ((!el.silent || strokePart) && firstDraw) el.createPathProxy();
	var path = el.path || pathProxyForDraw;
	var dirtyFlag = el.__dirty;
	if (!inBatch) {
		var fill = style.fill;
		var stroke = style.stroke;
		var hasFillGradient = hasFill && !!fill.colorStops;
		var hasStrokeGradient = hasStroke && !!stroke.colorStops;
		var hasFillPattern = hasFill && !!fill.image;
		var hasStrokePattern = hasStroke && !!stroke.image;
		var fillGradient = void 0;
		var strokeGradient = void 0;
		var fillPattern = void 0;
		var strokePattern = void 0;
		var rect = void 0;
		if (hasFillGradient || hasStrokeGradient) rect = el.getBoundingRect();
		if (hasFillGradient) {
			fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el.__canvasFillGradient;
			el.__canvasFillGradient = fillGradient;
		}
		if (hasStrokeGradient) {
			strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el.__canvasStrokeGradient;
			el.__canvasStrokeGradient = strokeGradient;
		}
		if (hasFillPattern) {
			fillPattern = dirtyFlag || !el.__canvasFillPattern ? createCanvasPattern(ctx, fill, el) : el.__canvasFillPattern;
			el.__canvasFillPattern = fillPattern;
		}
		if (hasStrokePattern) {
			strokePattern = dirtyFlag || !el.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el) : el.__canvasStrokePattern;
			el.__canvasStrokePattern = strokePattern;
		}
		if (hasFillGradient) ctx.fillStyle = fillGradient;
		else if (hasFillPattern) if (fillPattern) ctx.fillStyle = fillPattern;
		else hasFill = false;
		if (hasStrokeGradient) ctx.strokeStyle = strokeGradient;
		else if (hasStrokePattern) if (strokePattern) ctx.strokeStyle = strokePattern;
		else hasStroke = false;
	}
	var scale$3 = el.getGlobalScale();
	path.setScale(scale$3[0], scale$3[1], el.segmentIgnoreThreshold);
	var lineDash;
	var lineDashOffset;
	if (ctx.setLineDash && style.lineDash) _a$1 = getLineDash(el), lineDash = _a$1[0], lineDashOffset = _a$1[1];
	var needsRebuild = true;
	if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
		path.setDPR(ctx.dpr);
		if (strokePart) path.setContext(null);
		else {
			path.setContext(ctx);
			needsRebuild = false;
		}
		path.reset();
		el.buildPath(path, el.shape, inBatch);
		path.toStatic();
		el.pathUpdated();
	}
	if (needsRebuild) path.rebuildPath(ctx, strokePart ? strokePercent : 1);
	if (lineDash) {
		ctx.setLineDash(lineDash);
		ctx.lineDashOffset = lineDashOffset;
	}
	if (!inBatch) if (style.strokeFirst) {
		if (hasStroke) doStrokePath(ctx, style);
		if (hasFill) doFillPath(ctx, style);
	} else {
		if (hasFill) doFillPath(ctx, style);
		if (hasStroke) doStrokePath(ctx, style);
	}
	if (lineDash) ctx.setLineDash([]);
}
function brushImage(ctx, el, style) {
	var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
	if (!image || !isImageReady(image)) return;
	var x = style.x || 0;
	var y = style.y || 0;
	var width = el.getWidth();
	var height = el.getHeight();
	var aspect = image.width / image.height;
	if (width == null && height != null) width = height * aspect;
	else if (height == null && width != null) height = width / aspect;
	else if (width == null && height == null) {
		width = image.width;
		height = image.height;
	}
	if (style.sWidth && style.sHeight) {
		var sx = style.sx || 0;
		var sy = style.sy || 0;
		ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
	} else if (style.sx && style.sy) {
		var sx = style.sx;
		var sy = style.sy;
		var sWidth = width - sx;
		var sHeight = height - sy;
		ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
	} else ctx.drawImage(image, x, y, width, height);
}
function brushText(ctx, el, style) {
	var _a$1;
	var text = style.text;
	text != null && (text += "");
	if (text) {
		ctx.font = style.font || DEFAULT_FONT;
		ctx.textAlign = style.textAlign;
		ctx.textBaseline = style.textBaseline;
		var lineDash = void 0;
		var lineDashOffset = void 0;
		if (ctx.setLineDash && style.lineDash) _a$1 = getLineDash(el), lineDash = _a$1[0], lineDashOffset = _a$1[1];
		if (lineDash) {
			ctx.setLineDash(lineDash);
			ctx.lineDashOffset = lineDashOffset;
		}
		if (style.strokeFirst) {
			if (styleHasStroke(style)) ctx.strokeText(text, style.x, style.y);
			if (styleHasFill(style)) ctx.fillText(text, style.x, style.y);
		} else {
			if (styleHasFill(style)) ctx.fillText(text, style.x, style.y);
			if (styleHasStroke(style)) ctx.strokeText(text, style.x, style.y);
		}
		if (lineDash) ctx.setLineDash([]);
	}
}
var SHADOW_NUMBER_PROPS = [
	"shadowBlur",
	"shadowOffsetX",
	"shadowOffsetY"
];
var STROKE_PROPS = [
	["lineCap", "butt"],
	["lineJoin", "miter"],
	["miterLimit", 10]
];
function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
	var styleChanged = false;
	if (!forceSetAll) {
		prevStyle = prevStyle || {};
		if (style === prevStyle) return false;
	}
	if (forceSetAll || style.opacity !== prevStyle.opacity) {
		flushPathDrawn(ctx, scope);
		styleChanged = true;
		var opacity = Math.max(Math.min(style.opacity, 1), 0);
		ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
	}
	if (forceSetAll || style.blend !== prevStyle.blend) {
		if (!styleChanged) {
			flushPathDrawn(ctx, scope);
			styleChanged = true;
		}
		ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
	}
	for (var i$1 = 0; i$1 < SHADOW_NUMBER_PROPS.length; i$1++) {
		var propName = SHADOW_NUMBER_PROPS[i$1];
		if (forceSetAll || style[propName] !== prevStyle[propName]) {
			if (!styleChanged) {
				flushPathDrawn(ctx, scope);
				styleChanged = true;
			}
			ctx[propName] = ctx.dpr * (style[propName] || 0);
		}
	}
	if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
		if (!styleChanged) {
			flushPathDrawn(ctx, scope);
			styleChanged = true;
		}
		ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
	}
	return styleChanged;
}
function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
	var style = getStyle(el, scope.inHover);
	var prevStyle = forceSetAll ? null : prevEl && getStyle(prevEl, scope.inHover) || {};
	if (style === prevStyle) return false;
	var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
	if (forceSetAll || style.fill !== prevStyle.fill) {
		if (!styleChanged) {
			flushPathDrawn(ctx, scope);
			styleChanged = true;
		}
		isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
	}
	if (forceSetAll || style.stroke !== prevStyle.stroke) {
		if (!styleChanged) {
			flushPathDrawn(ctx, scope);
			styleChanged = true;
		}
		isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
	}
	if (forceSetAll || style.opacity !== prevStyle.opacity) {
		if (!styleChanged) {
			flushPathDrawn(ctx, scope);
			styleChanged = true;
		}
		ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	}
	if (el.hasStroke()) {
		var newLineWidth = style.lineWidth / (style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1);
		if (ctx.lineWidth !== newLineWidth) {
			if (!styleChanged) {
				flushPathDrawn(ctx, scope);
				styleChanged = true;
			}
			ctx.lineWidth = newLineWidth;
		}
	}
	for (var i$1 = 0; i$1 < STROKE_PROPS.length; i$1++) {
		var prop = STROKE_PROPS[i$1];
		var propName = prop[0];
		if (forceSetAll || style[propName] !== prevStyle[propName]) {
			if (!styleChanged) {
				flushPathDrawn(ctx, scope);
				styleChanged = true;
			}
			ctx[propName] = style[propName] || prop[1];
		}
	}
	return styleChanged;
}
function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
	return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
}
function setContextTransform(ctx, el) {
	var m$1 = el.transform;
	var dpr$1 = ctx.dpr || 1;
	if (m$1) ctx.setTransform(dpr$1 * m$1[0], dpr$1 * m$1[1], dpr$1 * m$1[2], dpr$1 * m$1[3], dpr$1 * m$1[4], dpr$1 * m$1[5]);
	else ctx.setTransform(dpr$1, 0, 0, dpr$1, 0, 0);
}
function updateClipStatus(clipPaths, ctx, scope) {
	var allClipped = false;
	for (var i$1 = 0; i$1 < clipPaths.length; i$1++) {
		var clipPath = clipPaths[i$1];
		allClipped = allClipped || clipPath.isZeroArea();
		setContextTransform(ctx, clipPath);
		ctx.beginPath();
		clipPath.buildPath(ctx, clipPath.shape);
		ctx.clip();
	}
	scope.allClipped = allClipped;
}
function isTransformChanged(m0, m1) {
	if (m0 && m1) return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
	else if (!m0 && !m1) return false;
	return true;
}
var DRAW_TYPE_PATH = 1;
var DRAW_TYPE_IMAGE = 2;
var DRAW_TYPE_TEXT = 3;
var DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(style) {
	var hasFill = styleHasFill(style);
	var hasStroke = styleHasStroke(style);
	return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
}
function flushPathDrawn(ctx, scope) {
	scope.batchFill && ctx.fill();
	scope.batchStroke && ctx.stroke();
	scope.batchFill = "";
	scope.batchStroke = "";
}
function getStyle(el, inHover) {
	return inHover ? el.__hoverStyle || el.style : el.style;
}
function brushSingle(ctx, el) {
	brush(ctx, el, {
		inHover: false,
		viewWidth: 0,
		viewHeight: 0
	}, true);
}
function brush(ctx, el, scope, isLast) {
	var m$1 = el.transform;
	if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
		el.__dirty &= ~REDRAW_BIT;
		el.__isRendered = false;
		return;
	}
	var clipPaths = el.__clipPaths;
	var prevElClipPaths = scope.prevElClipPaths;
	var forceSetTransform = false;
	var forceSetStyle = false;
	if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
		if (prevElClipPaths && prevElClipPaths.length) {
			flushPathDrawn(ctx, scope);
			ctx.restore();
			forceSetStyle = forceSetTransform = true;
			scope.prevElClipPaths = null;
			scope.allClipped = false;
			scope.prevEl = null;
		}
		if (clipPaths && clipPaths.length) {
			flushPathDrawn(ctx, scope);
			ctx.save();
			updateClipStatus(clipPaths, ctx, scope);
			forceSetTransform = true;
		}
		scope.prevElClipPaths = clipPaths;
	}
	if (scope.allClipped) {
		el.__isRendered = false;
		return;
	}
	el.beforeBrush && el.beforeBrush();
	el.innerBeforeBrush();
	var prevEl = scope.prevEl;
	if (!prevEl) forceSetStyle = forceSetTransform = true;
	var canBatchPath = el instanceof Path_default && el.autoBatch && canPathBatch(el.style);
	if (forceSetTransform || isTransformChanged(m$1, prevEl.transform)) {
		flushPathDrawn(ctx, scope);
		setContextTransform(ctx, el);
	} else if (!canBatchPath) flushPathDrawn(ctx, scope);
	var style = getStyle(el, scope.inHover);
	if (el instanceof Path_default) {
		if (scope.lastDrawType !== DRAW_TYPE_PATH) {
			forceSetStyle = true;
			scope.lastDrawType = DRAW_TYPE_PATH;
		}
		bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
		if (!canBatchPath || !scope.batchFill && !scope.batchStroke) ctx.beginPath();
		brushPath(ctx, el, style, canBatchPath);
		if (canBatchPath) {
			scope.batchFill = style.fill || "";
			scope.batchStroke = style.stroke || "";
		}
	} else if (el instanceof TSpan_default) {
		if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
			forceSetStyle = true;
			scope.lastDrawType = DRAW_TYPE_TEXT;
		}
		bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
		brushText(ctx, el, style);
	} else if (el instanceof Image_default) {
		if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
			forceSetStyle = true;
			scope.lastDrawType = DRAW_TYPE_IMAGE;
		}
		bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
		brushImage(ctx, el, style);
	} else if (el.getTemporalDisplayables) {
		if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
			forceSetStyle = true;
			scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
		}
		brushIncremental(ctx, el, scope);
	}
	if (canBatchPath && isLast) flushPathDrawn(ctx, scope);
	el.innerAfterBrush();
	el.afterBrush && el.afterBrush();
	scope.prevEl = el;
	el.__dirty = 0;
	el.__isRendered = true;
}
function brushIncremental(ctx, el, scope) {
	var displayables = el.getDisplayables();
	var temporalDisplayables = el.getTemporalDisplayables();
	ctx.save();
	var innerScope = {
		prevElClipPaths: null,
		prevEl: null,
		allClipped: false,
		viewWidth: scope.viewWidth,
		viewHeight: scope.viewHeight,
		inHover: scope.inHover
	};
	var i$1;
	var len$1;
	for (i$1 = el.getCursor(), len$1 = displayables.length; i$1 < len$1; i$1++) {
		var displayable = displayables[i$1];
		displayable.beforeBrush && displayable.beforeBrush();
		displayable.innerBeforeBrush();
		brush(ctx, displayable, innerScope, i$1 === len$1 - 1);
		displayable.innerAfterBrush();
		displayable.afterBrush && displayable.afterBrush();
		innerScope.prevEl = displayable;
	}
	for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
		var displayable = temporalDisplayables[i_1];
		displayable.beforeBrush && displayable.beforeBrush();
		displayable.innerBeforeBrush();
		brush(ctx, displayable, innerScope, i_1 === len_1 - 1);
		displayable.innerAfterBrush();
		displayable.afterBrush && displayable.afterBrush();
		innerScope.prevEl = displayable;
	}
	el.clearTemporalDisplayables();
	el.notClear = true;
	ctx.restore();
}

//#endregion
//#region node_modules/echarts/lib/util/decal.js
var decalMap = new WeakMap_default();
var decalCache = new LRU_default(100);
var decalKeys = [
	"symbol",
	"symbolSize",
	"symbolKeepAspect",
	"color",
	"backgroundColor",
	"dashArrayX",
	"dashArrayY",
	"maxTileWidth",
	"maxTileHeight"
];
/**
* Create or update pattern image from decal options
*
* @param {InnerDecalObject | 'none'} decalObject decal options, 'none' if no decal
* @return {Pattern} pattern with generated image, null if no decal
*/
function createOrUpdatePatternFromDecal(decalObject, api) {
	if (decalObject === "none") return null;
	var dpr$1 = api.getDevicePixelRatio();
	var zr = api.getZr();
	var isSVG = zr.painter.type === "svg";
	if (decalObject.dirty) decalMap["delete"](decalObject);
	var oldPattern = decalMap.get(decalObject);
	if (oldPattern) return oldPattern;
	var decalOpt = defaults(decalObject, {
		symbol: "rect",
		symbolSize: 1,
		symbolKeepAspect: true,
		color: "rgba(0, 0, 0, 0.2)",
		backgroundColor: null,
		dashArrayX: 5,
		dashArrayY: 5,
		rotation: 0,
		maxTileWidth: 512,
		maxTileHeight: 512
	});
	if (decalOpt.backgroundColor === "none") decalOpt.backgroundColor = null;
	var pattern = { repeat: "repeat" };
	setPatternnSource(pattern);
	pattern.rotation = decalOpt.rotation;
	pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr$1;
	decalMap.set(decalObject, pattern);
	decalObject.dirty = false;
	return pattern;
	function setPatternnSource(pattern$1) {
		var keys$1 = [dpr$1];
		var isValidKey = true;
		for (var i$1 = 0; i$1 < decalKeys.length; ++i$1) {
			var value = decalOpt[decalKeys[i$1]];
			if (value != null && !isArray(value) && !isString(value) && !isNumber(value) && typeof value !== "boolean") {
				isValidKey = false;
				break;
			}
			keys$1.push(value);
		}
		var cacheKey;
		if (isValidKey) {
			cacheKey = keys$1.join(",") + (isSVG ? "-svg" : "");
			var cache = decalCache.get(cacheKey);
			if (cache) isSVG ? pattern$1.svgElement = cache : pattern$1.image = cache;
		}
		var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
		var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
		var symbolArray = normalizeSymbolArray(decalOpt.symbol);
		var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
		var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
		var canvas = !isSVG && platformApi.createCanvas();
		var svgRoot = isSVG && {
			tag: "g",
			attrs: {},
			key: "dcl",
			children: []
		};
		var pSize = getPatternSize();
		var ctx;
		if (canvas) {
			canvas.width = pSize.width * dpr$1;
			canvas.height = pSize.height * dpr$1;
			ctx = canvas.getContext("2d");
		}
		brushDecal();
		if (isValidKey) decalCache.put(cacheKey, canvas || svgRoot);
		pattern$1.image = canvas;
		pattern$1.svgElement = svgRoot;
		pattern$1.svgWidth = pSize.width;
		pattern$1.svgHeight = pSize.height;
		/**
		* Get minimum length that can make a repeatable pattern.
		*
		* @return {Object} pattern width and height
		*/
		function getPatternSize() {
			/**
			* For example, if dash is [[3, 2], [2, 1]] for X, it looks like
			* |---  ---  ---  ---  --- ...
			* |-- -- -- -- -- -- -- -- ...
			* |---  ---  ---  ---  --- ...
			* |-- -- -- -- -- -- -- -- ...
			* So the minimum length of X is 15,
			* which is the least common multiple of `3 + 2` and `2 + 1`
			* |---  ---  ---  |---  --- ...
			* |-- -- -- -- -- |-- -- -- ...
			*/
			var width = 1;
			for (var i$2 = 0, xlen = lineBlockLengthsX.length; i$2 < xlen; ++i$2) width = getLeastCommonMultiple(width, lineBlockLengthsX[i$2]);
			var symbolRepeats = 1;
			for (var i$2 = 0, xlen = symbolArray.length; i$2 < xlen; ++i$2) symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i$2].length);
			width *= symbolRepeats;
			var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
			var warn$1 = function(attrName) {
				console.warn("Calculated decal size is greater than " + attrName + " due to decal option settings so " + attrName + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + attrName + " to be larger to avoid incontinuity.");
			};
			if (width > decalOpt.maxTileWidth) warn$1("maxTileWidth");
			if (height > decalOpt.maxTileHeight) warn$1("maxTileHeight");
			return {
				width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
				height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
			};
		}
		function brushDecal() {
			if (ctx) {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				if (decalOpt.backgroundColor) {
					ctx.fillStyle = decalOpt.backgroundColor;
					ctx.fillRect(0, 0, canvas.width, canvas.height);
				}
			}
			var ySum = 0;
			for (var i$2 = 0; i$2 < dashArrayY.length; ++i$2) ySum += dashArrayY[i$2];
			if (ySum <= 0) return;
			var y = -lineBlockLengthY;
			var yId = 0;
			var yIdTotal = 0;
			var xId0 = 0;
			while (y < pSize.height) {
				if (yId % 2 === 0) {
					var symbolYId = yIdTotal / 2 % symbolArray.length;
					var x = 0;
					var xId1 = 0;
					var xId1Total = 0;
					while (x < pSize.width * 2) {
						var xSum = 0;
						for (var i$2 = 0; i$2 < dashArrayX[xId0].length; ++i$2) xSum += dashArrayX[xId0][i$2];
						if (xSum <= 0) break;
						if (xId1 % 2 === 0) {
							var size = (1 - decalOpt.symbolSize) * .5;
							var left = x + dashArrayX[xId0][xId1] * size;
							var top_1 = y + dashArrayY[yId] * size;
							var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
							var height = dashArrayY[yId] * decalOpt.symbolSize;
							var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
							brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);
						}
						x += dashArrayX[xId0][xId1];
						++xId1Total;
						++xId1;
						if (xId1 === dashArrayX[xId0].length) xId1 = 0;
					}
					++xId0;
					if (xId0 === dashArrayX.length) xId0 = 0;
				}
				y += dashArrayY[yId];
				++yIdTotal;
				++yId;
				if (yId === dashArrayY.length) yId = 0;
			}
			function brushSymbol(x$1, y$1, width$1, height$1, symbolType) {
				var scale$3 = isSVG ? 1 : dpr$1;
				var symbol = createSymbol(symbolType, x$1 * scale$3, y$1 * scale$3, width$1 * scale$3, height$1 * scale$3, decalOpt.color, decalOpt.symbolKeepAspect);
				if (isSVG) {
					var symbolVNode = zr.painter.renderOneToVNode(symbol);
					if (symbolVNode) svgRoot.children.push(symbolVNode);
				} else brushSingle(ctx, symbol);
			}
		}
	}
}
/**
* Convert symbol array into normalized array
*
* @param {string | (string | string[])[]} symbol symbol input
* @return {string[][]} normolized symbol array
*/
function normalizeSymbolArray(symbol) {
	if (!symbol || symbol.length === 0) return [["rect"]];
	if (isString(symbol)) return [[symbol]];
	var isAllString = true;
	for (var i$1 = 0; i$1 < symbol.length; ++i$1) if (!isString(symbol[i$1])) {
		isAllString = false;
		break;
	}
	if (isAllString) return normalizeSymbolArray([symbol]);
	var result = [];
	for (var i$1 = 0; i$1 < symbol.length; ++i$1) if (isString(symbol[i$1])) result.push([symbol[i$1]]);
	else result.push(symbol[i$1]);
	return result;
}
/**
* Convert dash input into dashArray
*
* @param {DecalDashArrayX} dash dash input
* @return {number[][]} normolized dash array
*/
function normalizeDashArrayX(dash) {
	if (!dash || dash.length === 0) return [[0, 0]];
	if (isNumber(dash)) {
		var dashValue = Math.ceil(dash);
		return [[dashValue, dashValue]];
	}
	/**
	* [20, 5] should be normalized into [[20, 5]],
	* while [20, [5, 10]] should be normalized into [[20, 20], [5, 10]]
	*/
	var isAllNumber = true;
	for (var i$1 = 0; i$1 < dash.length; ++i$1) if (!isNumber(dash[i$1])) {
		isAllNumber = false;
		break;
	}
	if (isAllNumber) return normalizeDashArrayX([dash]);
	var result = [];
	for (var i$1 = 0; i$1 < dash.length; ++i$1) if (isNumber(dash[i$1])) {
		var dashValue = Math.ceil(dash[i$1]);
		result.push([dashValue, dashValue]);
	} else {
		var dashValue = map(dash[i$1], function(n) {
			return Math.ceil(n);
		});
		if (dashValue.length % 2 === 1) result.push(dashValue.concat(dashValue));
		else result.push(dashValue);
	}
	return result;
}
/**
* Convert dash input into dashArray
*
* @param {DecalDashArrayY} dash dash input
* @return {number[]} normolized dash array
*/
function normalizeDashArrayY(dash) {
	if (!dash || typeof dash === "object" && dash.length === 0) return [0, 0];
	if (isNumber(dash)) {
		var dashValue_1 = Math.ceil(dash);
		return [dashValue_1, dashValue_1];
	}
	var dashValue = map(dash, function(n) {
		return Math.ceil(n);
	});
	return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
}
/**
* Get block length of each line. A block is the length of dash line and space.
* For example, a line with [4, 1] has a dash line of 4 and a space of 1 after
* that, so the block length of this line is 5.
*
* @param {number[][]} dash dash array of X or Y
* @return {number[]} block length of each line
*/
function getLineBlockLengthX(dash) {
	return map(dash, function(line) {
		return getLineBlockLengthY(line);
	});
}
function getLineBlockLengthY(dash) {
	var blockLength = 0;
	for (var i$1 = 0; i$1 < dash.length; ++i$1) blockLength += dash[i$1];
	if (dash.length % 2 === 1) return blockLength * 2;
	return blockLength;
}

//#endregion
//#region node_modules/echarts/lib/visual/decal.js
function decalVisual(ecModel, api) {
	ecModel.eachRawSeries(function(seriesModel) {
		if (ecModel.isSeriesFiltered(seriesModel)) return;
		var data = seriesModel.getData();
		if (data.hasItemVisual()) data.each(function(idx) {
			var decal$1 = data.getItemVisual(idx, "decal");
			if (decal$1) {
				var itemStyle = data.ensureUniqueItemVisual(idx, "style");
				itemStyle.decal = createOrUpdatePatternFromDecal(decal$1, api);
			}
		});
		var decal = data.getVisual("decal");
		if (decal) {
			var style = data.getVisual("style");
			style.decal = createOrUpdatePatternFromDecal(decal, api);
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/core/lifecycle.js
var lifecycle = new Eventful_default();
var lifecycle_default = lifecycle;

//#endregion
//#region node_modules/echarts/lib/core/impl.js
var implsStore = {};
function registerImpl(name, impl) {
	if (implsStore[name]) error("Already has an implementation of " + name + ".");
	implsStore[name] = impl;
}
function getImpl(name) {
	if (!implsStore[name]) error("Implementation of " + name + " doesn't exists.");
	return implsStore[name];
}

//#endregion
//#region node_modules/echarts/lib/chart/custom/customSeriesRegister.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var customRenderers = {};
function registerCustomSeries$1(type, renderItem) {
	customRenderers[type] = renderItem;
}
function getCustomSeries(type) {
	return customRenderers[type];
}

//#endregion
//#region node_modules/echarts/lib/core/echarts.js
var version = "6.0.0";
var dependencies = { zrender: "6.0.0" };
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
var PRIORITY_PROCESSOR_DATASTACK = 900;
var PRIORITY_PROCESSOR_FILTER = 1e3;
var PRIORITY_PROCESSOR_DEFAULT = 2e3;
var PRIORITY_PROCESSOR_STATISTIC = 5e3;
var PRIORITY_VISUAL_LAYOUT = 1e3;
var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
var PRIORITY_VISUAL_GLOBAL = 2e3;
var PRIORITY_VISUAL_CHART = 3e3;
var PRIORITY_VISUAL_COMPONENT = 4e3;
var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
var PRIORITY_VISUAL_BRUSH = 5e3;
var PRIORITY_VISUAL_ARIA = 6e3;
var PRIORITY_VISUAL_DECAL = 7e3;
var PRIORITY = {
	PROCESSOR: {
		FILTER: PRIORITY_PROCESSOR_FILTER,
		SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
		STATISTIC: PRIORITY_PROCESSOR_STATISTIC
	},
	VISUAL: {
		LAYOUT: PRIORITY_VISUAL_LAYOUT,
		PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
		GLOBAL: PRIORITY_VISUAL_GLOBAL,
		CHART: PRIORITY_VISUAL_CHART,
		POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
		COMPONENT: PRIORITY_VISUAL_COMPONENT,
		BRUSH: PRIORITY_VISUAL_BRUSH,
		CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
		ARIA: PRIORITY_VISUAL_ARIA,
		DECAL: PRIORITY_VISUAL_DECAL
	}
};
var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
var MAIN_PROCESS_VERSION_KEY = "__mainProcessVersion";
var PENDING_UPDATE = "__pendingUpdate";
var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
var ACTION_REG = /^[a-zA-Z0-9_]+$/;
var CONNECT_STATUS_KEY = "__connectUpdateStatus";
var CONNECT_STATUS_PENDING = 0;
var CONNECT_STATUS_UPDATING = 1;
var CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(method) {
	return function() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		if (this.isDisposed()) {
			disposedWarning(this.id);
			return;
		}
		return toLowercaseNameAndCallEventful(this, method, args);
	};
}
function createRegisterEventWithLowercaseMessageCenter(method) {
	return function() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		return toLowercaseNameAndCallEventful(this, method, args);
	};
}
function toLowercaseNameAndCallEventful(host, method, args) {
	args[0] = args[0] && args[0].toLowerCase();
	return Eventful_default.prototype[method].apply(host, args);
}
var MessageCenter = function(_super) {
	__extends(MessageCenter$1, _super);
	function MessageCenter$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	return MessageCenter$1;
}(Eventful_default);
var messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare;
var prepareView;
var updateDirectly;
var updateMethods;
var doConvertPixel;
var updateStreamModes;
var doDispatchAction;
var flushPendingActions;
var triggerUpdatedEvent;
var bindRenderedEvent;
var bindMouseEvent;
var render;
var renderComponents;
var renderSeries;
var createExtensionAPI;
var enableConnect;
var markStatusToUpdate;
var applyChangedStates;
var updateMainProcessVersion;
var ECharts = function(_super) {
	__extends(ECharts$1, _super);
	function ECharts$1(dom, theme$1, opts) {
		var _this = _super.call(this, new ECEventProcessor()) || this;
		_this._chartsViews = [];
		_this._chartsMap = {};
		_this._componentsViews = [];
		_this._componentsMap = {};
		_this._pendingActions = [];
		opts = opts || {};
		_this._dom = dom;
		var defaultRenderer = "canvas";
		var defaultCoarsePointer = "auto";
		var defaultUseDirtyRect = false;
		_this[MAIN_PROCESS_VERSION_KEY] = 1;
		var root = env_default.hasGlobalWindow ? window : global;
		if (root) {
			defaultRenderer = retrieve2(root.__ECHARTS__DEFAULT__RENDERER__, defaultRenderer);
			defaultCoarsePointer = retrieve2(root.__ECHARTS__DEFAULT__COARSE_POINTER, defaultCoarsePointer);
			defaultUseDirtyRect = retrieve2(root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, defaultUseDirtyRect);
		}
		if (opts.ssr) registerSSRDataGetter(function(el) {
			var ecData = getECData(el);
			var dataIndex = ecData.dataIndex;
			if (dataIndex == null) return;
			var hashMap = createHashMap();
			hashMap.set("series_index", ecData.seriesIndex);
			hashMap.set("data_index", dataIndex);
			ecData.ssrType && hashMap.set("ssr_type", ecData.ssrType);
			return hashMap;
		});
		var zr = _this._zr = init$2(dom, {
			renderer: opts.renderer || defaultRenderer,
			devicePixelRatio: opts.devicePixelRatio,
			width: opts.width,
			height: opts.height,
			ssr: opts.ssr,
			useDirtyRect: retrieve2(opts.useDirtyRect, defaultUseDirtyRect),
			useCoarsePointer: retrieve2(opts.useCoarsePointer, defaultCoarsePointer),
			pointerSize: opts.pointerSize
		});
		_this._ssr = opts.ssr;
		_this._throttledZrFlush = throttle(bind(zr.flush, zr), 17);
		_this._updateTheme(theme$1);
		_this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
		_this._coordSysMgr = new CoordinateSystem_default();
		var api = _this._api = createExtensionAPI(_this);
		function prioritySortFunc(a, b) {
			return a.__prio - b.__prio;
		}
		sort$2(visualFuncs, prioritySortFunc);
		sort$2(dataProcessorFuncs, prioritySortFunc);
		_this._scheduler = new Scheduler_default(_this, api, dataProcessorFuncs, visualFuncs);
		_this._messageCenter = new MessageCenter();
		_this._initEvents();
		_this.resize = bind(_this.resize, _this);
		zr.animation.on("frame", _this._onframe, _this);
		bindRenderedEvent(zr, _this);
		bindMouseEvent(zr, _this);
		setAsPrimitive(_this);
		return _this;
	}
	ECharts$1.prototype._onframe = function() {
		if (this._disposed) return;
		applyChangedStates(this);
		var scheduler = this._scheduler;
		if (this[PENDING_UPDATE]) {
			var silent = this[PENDING_UPDATE].silent;
			this[IN_MAIN_PROCESS_KEY] = true;
			updateMainProcessVersion(this);
			try {
				prepare(this);
				updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
			} catch (e$1) {
				this[IN_MAIN_PROCESS_KEY] = false;
				this[PENDING_UPDATE] = null;
				throw e$1;
			}
			this._zr.flush();
			this[IN_MAIN_PROCESS_KEY] = false;
			this[PENDING_UPDATE] = null;
			flushPendingActions.call(this, silent);
			triggerUpdatedEvent.call(this, silent);
		} else if (scheduler.unfinished) {
			var remainTime = TEST_FRAME_REMAIN_TIME;
			var ecModel = this._model;
			var api = this._api;
			scheduler.unfinished = false;
			do {
				var startTime = +/* @__PURE__ */ new Date();
				scheduler.performSeriesTasks(ecModel);
				scheduler.performDataProcessorTasks(ecModel);
				updateStreamModes(this, ecModel);
				scheduler.performVisualTasks(ecModel);
				renderSeries(this, this._model, api, "remain", {});
				remainTime -= +/* @__PURE__ */ new Date() - startTime;
			} while (remainTime > 0 && scheduler.unfinished);
			if (!scheduler.unfinished) this._zr.flush();
		}
	};
	ECharts$1.prototype.getDom = function() {
		return this._dom;
	};
	ECharts$1.prototype.getId = function() {
		return this.id;
	};
	ECharts$1.prototype.getZr = function() {
		return this._zr;
	};
	ECharts$1.prototype.isSSR = function() {
		return this._ssr;
	};
	ECharts$1.prototype.setOption = function(option, notMerge, lazyUpdate) {
		if (this[IN_MAIN_PROCESS_KEY]) {
			error("`setOption` should not be called during main process.");
			return;
		}
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var silent;
		var replaceMerge;
		var transitionOpt;
		if (isObject(notMerge)) {
			lazyUpdate = notMerge.lazyUpdate;
			silent = notMerge.silent;
			replaceMerge = notMerge.replaceMerge;
			transitionOpt = notMerge.transition;
			notMerge = notMerge.notMerge;
		}
		this[IN_MAIN_PROCESS_KEY] = true;
		updateMainProcessVersion(this);
		if (!this._model || notMerge) {
			var optionManager = new OptionManager_default(this._api);
			var theme$1 = this._theme;
			var ecModel = this._model = new Global_default();
			ecModel.scheduler = this._scheduler;
			ecModel.ssr = this._ssr;
			ecModel.init(null, null, null, theme$1, this._locale, optionManager);
		}
		this._model.setOption(option, { replaceMerge }, optionPreprocessorFuncs);
		var updateParams = {
			seriesTransition: transitionOpt,
			optionChanged: true
		};
		if (lazyUpdate) {
			this[PENDING_UPDATE] = {
				silent,
				updateParams
			};
			this[IN_MAIN_PROCESS_KEY] = false;
			this.getZr().wakeUp();
		} else {
			try {
				prepare(this);
				updateMethods.update.call(this, null, updateParams);
			} catch (e$1) {
				this[PENDING_UPDATE] = null;
				this[IN_MAIN_PROCESS_KEY] = false;
				throw e$1;
			}
			if (!this._ssr) this._zr.flush();
			this[PENDING_UPDATE] = null;
			this[IN_MAIN_PROCESS_KEY] = false;
			flushPendingActions.call(this, silent);
			triggerUpdatedEvent.call(this, silent);
		}
	};
	/**
	* Update theme with name or theme option and repaint the chart.
	* @param theme Theme name or theme option.
	* @param opts Optional settings
	*/
	ECharts$1.prototype.setTheme = function(theme$1, opts) {
		if (this[IN_MAIN_PROCESS_KEY]) {
			error("`setTheme` should not be called during main process.");
			return;
		}
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var ecModel = this._model;
		if (!ecModel) return;
		var silent = opts && opts.silent;
		var updateParams = null;
		if (this[PENDING_UPDATE]) {
			if (silent == null) silent = this[PENDING_UPDATE].silent;
			updateParams = this[PENDING_UPDATE].updateParams;
			this[PENDING_UPDATE] = null;
		}
		this[IN_MAIN_PROCESS_KEY] = true;
		updateMainProcessVersion(this);
		try {
			this._updateTheme(theme$1);
			ecModel.setTheme(this._theme);
			prepare(this);
			updateMethods.update.call(this, { type: "setTheme" }, updateParams);
		} catch (e$1) {
			this[IN_MAIN_PROCESS_KEY] = false;
			throw e$1;
		}
		this[IN_MAIN_PROCESS_KEY] = false;
		flushPendingActions.call(this, silent);
		triggerUpdatedEvent.call(this, silent);
	};
	ECharts$1.prototype._updateTheme = function(theme$1) {
		if (isString(theme$1)) theme$1 = themeStorage[theme$1];
		if (theme$1) {
			theme$1 = clone(theme$1);
			theme$1 && globalBackwardCompat(theme$1, true);
			this._theme = theme$1;
		}
	};
	ECharts$1.prototype.getModel = function() {
		return this._model;
	};
	ECharts$1.prototype.getOption = function() {
		return this._model && this._model.getOption();
	};
	ECharts$1.prototype.getWidth = function() {
		return this._zr.getWidth();
	};
	ECharts$1.prototype.getHeight = function() {
		return this._zr.getHeight();
	};
	ECharts$1.prototype.getDevicePixelRatio = function() {
		return this._zr.painter.dpr || env_default.hasGlobalWindow && window.devicePixelRatio || 1;
	};
	/**
	* Get canvas which has all thing rendered
	* @deprecated Use renderToCanvas instead.
	*/
	ECharts$1.prototype.getRenderedCanvas = function(opts) {
		deprecateReplaceLog("getRenderedCanvas", "renderToCanvas");
		return this.renderToCanvas(opts);
	};
	ECharts$1.prototype.renderToCanvas = function(opts) {
		opts = opts || {};
		var painter = this._zr.painter;
		if (painter.type !== "canvas") throw new Error("renderToCanvas can only be used in the canvas renderer.");
		return painter.getRenderedCanvas({
			backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
			pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
		});
	};
	ECharts$1.prototype.renderToSVGString = function(opts) {
		opts = opts || {};
		var painter = this._zr.painter;
		if (painter.type !== "svg") throw new Error("renderToSVGString can only be used in the svg renderer.");
		return painter.renderToString({ useViewBox: opts.useViewBox });
	};
	/**
	* Get svg data url
	*/
	ECharts$1.prototype.getSvgDataURL = function() {
		var zr = this._zr;
		each(zr.storage.getDisplayList(), function(el) {
			el.stopAnimation(null, true);
		});
		return zr.painter.toDataURL();
	};
	ECharts$1.prototype.getDataURL = function(opts) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		opts = opts || {};
		var excludeComponents = opts.excludeComponents;
		var ecModel = this._model;
		var excludesComponentViews = [];
		var self$1 = this;
		each(excludeComponents, function(componentType) {
			ecModel.eachComponent({ mainType: componentType }, function(component) {
				var view = self$1._componentsMap[component.__viewId];
				if (!view.group.ignore) {
					excludesComponentViews.push(view);
					view.group.ignore = true;
				}
			});
		});
		var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
		each(excludesComponentViews, function(view) {
			view.group.ignore = false;
		});
		return url;
	};
	ECharts$1.prototype.getConnectedDataURL = function(opts) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var isSvg = opts.type === "svg";
		var groupId = this.group;
		var mathMin$12 = Math.min;
		var mathMax$12 = Math.max;
		var MAX_NUMBER = Infinity;
		if (connectedGroups[groupId]) {
			var left_1 = MAX_NUMBER;
			var top_1 = MAX_NUMBER;
			var right_1 = -MAX_NUMBER;
			var bottom_1 = -MAX_NUMBER;
			var canvasList_1 = [];
			var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
			each(instances, function(chart, id) {
				if (chart.group === groupId) {
					var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone(opts));
					var boundingRect = chart.getDom().getBoundingClientRect();
					left_1 = mathMin$12(boundingRect.left, left_1);
					top_1 = mathMin$12(boundingRect.top, top_1);
					right_1 = mathMax$12(boundingRect.right, right_1);
					bottom_1 = mathMax$12(boundingRect.bottom, bottom_1);
					canvasList_1.push({
						dom: canvas,
						left: boundingRect.left,
						top: boundingRect.top
					});
				}
			});
			left_1 *= dpr_1;
			top_1 *= dpr_1;
			right_1 *= dpr_1;
			bottom_1 *= dpr_1;
			var width = right_1 - left_1;
			var height = bottom_1 - top_1;
			var targetCanvas = platformApi.createCanvas();
			var zr_1 = init$2(targetCanvas, { renderer: isSvg ? "svg" : "canvas" });
			zr_1.resize({
				width,
				height
			});
			if (isSvg) {
				var content_1 = "";
				each(canvasList_1, function(item) {
					var x = item.left - left_1;
					var y = item.top - top_1;
					content_1 += "<g transform=\"translate(" + x + "," + y + ")\">" + item.dom + "</g>";
				});
				zr_1.painter.getSvgRoot().innerHTML = content_1;
				if (opts.connectedBackgroundColor) zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
				zr_1.refreshImmediately();
				return zr_1.painter.toDataURL();
			} else {
				if (opts.connectedBackgroundColor) zr_1.add(new Rect_default({
					shape: {
						x: 0,
						y: 0,
						width,
						height
					},
					style: { fill: opts.connectedBackgroundColor }
				}));
				each(canvasList_1, function(item) {
					var img = new Image_default({ style: {
						x: item.left * dpr_1 - left_1,
						y: item.top * dpr_1 - top_1,
						image: item.dom
					} });
					zr_1.add(img);
				});
				zr_1.refreshImmediately();
				return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
			}
		} else return this.getDataURL(opts);
	};
	ECharts$1.prototype.convertToPixel = function(finder, value, opt) {
		return doConvertPixel(this, "convertToPixel", finder, value, opt);
	};
	/**
	* Convert from logical coordinate system to pixel coordinate system.
	* See CoordinateSystem#convertToPixel.
	*
	* @see CoordinateSystem['dataToLayout'] for parameters and return.
	* @see CoordinateSystemDataCoord
	*/
	ECharts$1.prototype.convertToLayout = function(finder, value, opt) {
		return doConvertPixel(this, "convertToLayout", finder, value, opt);
	};
	ECharts$1.prototype.convertFromPixel = function(finder, value, opt) {
		return doConvertPixel(this, "convertFromPixel", finder, value, opt);
	};
	/**
	* Is the specified coordinate systems or components contain the given pixel point.
	* @param {Array|number} value
	* @return {boolean} result
	*/
	ECharts$1.prototype.containPixel = function(finder, value) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var ecModel = this._model;
		var result;
		each(parseFinder(ecModel, finder), function(models, key$1) {
			key$1.indexOf("Models") >= 0 && each(models, function(model) {
				var coordSys = model.coordinateSystem;
				if (coordSys && coordSys.containPoint) result = result || !!coordSys.containPoint(value);
				else if (key$1 === "seriesModels") {
					var view = this._chartsMap[model.__viewId];
					if (view && view.containPoint) result = result || view.containPoint(value, model);
					else warn(key$1 + ": " + (view ? "The found component do not support containPoint." : "No view mapping to the found component."));
				} else warn(key$1 + ": containPoint is not supported");
			}, this);
		}, this);
		return !!result;
	};
	/**
	* Get visual from series or data.
	* @param finder
	*        If string, e.g., 'series', means {seriesIndex: 0}.
	*        If Object, could contain some of these properties below:
	*        {
	*            seriesIndex / seriesId / seriesName,
	*            dataIndex / dataIndexInside
	*        }
	*        If dataIndex is not specified, series visual will be fetched,
	*        but not data item visual.
	*        If all of seriesIndex, seriesId, seriesName are not specified,
	*        visual will be fetched from first series.
	* @param visualType 'color', 'symbol', 'symbolSize'
	*/
	ECharts$1.prototype.getVisual = function(finder, visualType) {
		var ecModel = this._model;
		var parsedFinder = parseFinder(ecModel, finder, { defaultMainType: "series" });
		var seriesModel = parsedFinder.seriesModel;
		if (!seriesModel) warn("There is no specified series model");
		var data = seriesModel.getData();
		var dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
		return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
	};
	/**
	* Get view of corresponding component model
	*/
	ECharts$1.prototype.getViewOfComponentModel = function(componentModel) {
		return this._componentsMap[componentModel.__viewId];
	};
	/**
	* Get view of corresponding series model
	*/
	ECharts$1.prototype.getViewOfSeriesModel = function(seriesModel) {
		return this._chartsMap[seriesModel.__viewId];
	};
	ECharts$1.prototype._initEvents = function() {
		var _this = this;
		each(MOUSE_EVENT_NAMES, function(eveName) {
			var handler = function(e$1) {
				var ecModel = _this.getModel();
				var el = e$1.target;
				var params;
				var isGlobalOut = eveName === "globalout";
				if (isGlobalOut) params = {};
				else el && findEventDispatcher(el, function(parent) {
					var ecData = getECData(parent);
					if (ecData && ecData.dataIndex != null) {
						var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
						params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType, el) || {};
						return true;
					} else if (ecData.eventData) {
						params = extend({}, ecData.eventData);
						return true;
					}
				}, true);
				if (params) {
					var componentType = params.componentType;
					var componentIndex = params.componentIndex;
					if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
						componentType = "series";
						componentIndex = params.seriesIndex;
					}
					var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
					var view = model && _this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
					if (!isGlobalOut && !(model && view)) warn("model or view can not be found by params");
					params.event = e$1;
					params.type = eveName;
					_this._$eventProcessor.eventInfo = {
						targetEl: el,
						packedEvent: params,
						model,
						view
					};
					_this.trigger(eveName, params);
				}
			};
			handler.zrEventfulCallAtLast = true;
			_this._zr.on(eveName, handler, _this);
		});
		var messageCenter = this._messageCenter;
		each(publicEventTypeMap, function(_, eventType) {
			messageCenter.on(eventType, function(event) {
				_this.trigger(eventType, event);
			});
		});
		handleLegacySelectEvents(messageCenter, this, this._api);
	};
	ECharts$1.prototype.isDisposed = function() {
		return this._disposed;
	};
	ECharts$1.prototype.clear = function() {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this.setOption({ series: [] }, true);
	};
	ECharts$1.prototype.dispose = function() {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this._disposed = true;
		if (this.getDom()) setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
		var chart = this;
		var api = chart._api;
		var ecModel = chart._model;
		each(chart._componentsViews, function(component) {
			component.dispose(ecModel, api);
		});
		each(chart._chartsViews, function(chart$1) {
			chart$1.dispose(ecModel, api);
		});
		chart._zr.dispose();
		chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
		delete instances[chart.id];
	};
	/**
	* Resize the chart
	*/
	ECharts$1.prototype.resize = function(opts) {
		if (this[IN_MAIN_PROCESS_KEY]) {
			error("`resize` should not be called during main process.");
			return;
		}
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this._zr.resize(opts);
		var ecModel = this._model;
		this._loadingFX && this._loadingFX.resize();
		if (!ecModel) return;
		var needPrepare = ecModel.resetOption("media");
		var silent = opts && opts.silent;
		if (this[PENDING_UPDATE]) {
			if (silent == null) silent = this[PENDING_UPDATE].silent;
			needPrepare = true;
			this[PENDING_UPDATE] = null;
		}
		this[IN_MAIN_PROCESS_KEY] = true;
		updateMainProcessVersion(this);
		try {
			needPrepare && prepare(this);
			updateMethods.update.call(this, {
				type: "resize",
				animation: extend({ duration: 0 }, opts && opts.animation)
			});
		} catch (e$1) {
			this[IN_MAIN_PROCESS_KEY] = false;
			throw e$1;
		}
		this[IN_MAIN_PROCESS_KEY] = false;
		flushPendingActions.call(this, silent);
		triggerUpdatedEvent.call(this, silent);
	};
	ECharts$1.prototype.showLoading = function(name, cfg) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		if (isObject(name)) {
			cfg = name;
			name = "";
		}
		name = name || "default";
		this.hideLoading();
		if (!loadingEffects[name]) {
			warn("Loading effects " + name + " not exists.");
			return;
		}
		var el = loadingEffects[name](this._api, cfg);
		var zr = this._zr;
		this._loadingFX = el;
		zr.add(el);
	};
	/**
	* Hide loading effect
	*/
	ECharts$1.prototype.hideLoading = function() {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this._loadingFX && this._zr.remove(this._loadingFX);
		this._loadingFX = null;
	};
	ECharts$1.prototype.makeActionFromEvent = function(eventObj) {
		var payload = extend({}, eventObj);
		payload.type = connectionEventRevertMap[eventObj.type];
		return payload;
	};
	/**
	* @param opt If pass boolean, means opt.silent
	* @param opt.silent Default `false`. Whether trigger events.
	* @param opt.flush Default `undefined`.
	*        true: Flush immediately, and then pixel in canvas can be fetched
	*            immediately. Caution: it might affect performance.
	*        false: Not flush.
	*        undefined: Auto decide whether perform flush.
	*/
	ECharts$1.prototype.dispatchAction = function(payload, opt) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		if (!isObject(opt)) opt = { silent: !!opt };
		if (!actions[payload.type]) return;
		if (!this._model) return;
		if (this[IN_MAIN_PROCESS_KEY]) {
			this._pendingActions.push(payload);
			return;
		}
		var silent = opt.silent;
		doDispatchAction.call(this, payload, silent);
		var flush = opt.flush;
		if (flush) this._zr.flush();
		else if (flush !== false && env_default.browser.weChat) this._throttledZrFlush();
		flushPendingActions.call(this, silent);
		triggerUpdatedEvent.call(this, silent);
	};
	ECharts$1.prototype.updateLabelLayout = function() {
		lifecycle_default.trigger("series:layoutlabels", this._model, this._api, { updatedSeries: [] });
	};
	ECharts$1.prototype.appendData = function(params) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var seriesIndex = params.seriesIndex;
		var seriesModel = this.getModel().getSeriesByIndex(seriesIndex);
		assert(params.data && seriesModel);
		seriesModel.appendData(params);
		this._scheduler.unfinished = true;
		this.getZr().wakeUp();
	};
	ECharts$1.internalField = function() {
		prepare = function(ecIns) {
			var scheduler = ecIns._scheduler;
			scheduler.restorePipelines(ecIns._model);
			scheduler.prepareStageTasks();
			prepareView(ecIns, true);
			prepareView(ecIns, false);
			scheduler.plan();
		};
		/**
		* Prepare view instances of charts and components
		*/
		prepareView = function(ecIns, isComponent) {
			var ecModel = ecIns._model;
			var scheduler = ecIns._scheduler;
			var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
			var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
			var zr = ecIns._zr;
			var api = ecIns._api;
			for (var i$1 = 0; i$1 < viewList.length; i$1++) viewList[i$1].__alive = false;
			isComponent ? ecModel.eachComponent(function(componentType, model) {
				componentType !== "series" && doPrepare(model);
			}) : ecModel.eachSeries(doPrepare);
			function doPrepare(model) {
				var requireNewView = model.__requireNewView;
				model.__requireNewView = false;
				var viewId = "_ec_" + model.id + "_" + model.type;
				var view$1 = !requireNewView && viewMap[viewId];
				if (!view$1) {
					var classType = parseClassType(model.type);
					var Clazz = isComponent ? Component_default$1.getClass(classType.main, classType.sub) : Chart_default.getClass(classType.sub);
					assert(Clazz, classType.sub + " does not exist.");
					view$1 = new Clazz();
					view$1.init(ecModel, api);
					viewMap[viewId] = view$1;
					viewList.push(view$1);
					zr.add(view$1.group);
				}
				model.__viewId = view$1.__id = viewId;
				view$1.__alive = true;
				view$1.__model = model;
				view$1.group.__ecComponentInfo = {
					mainType: model.mainType,
					index: model.componentIndex
				};
				!isComponent && scheduler.prepareView(view$1, model, ecModel, api);
			}
			for (var i$1 = 0; i$1 < viewList.length;) {
				var view = viewList[i$1];
				if (!view.__alive) {
					!isComponent && view.renderTask.dispose();
					zr.remove(view.group);
					view.dispose(ecModel, api);
					viewList.splice(i$1, 1);
					if (viewMap[view.__id] === view) delete viewMap[view.__id];
					view.__id = view.group.__ecComponentInfo = null;
				} else i$1++;
			}
		};
		updateDirectly = function(ecIns, method, payload, mainType, subType) {
			var ecModel = ecIns._model;
			ecModel.setUpdatePayload(payload);
			if (!mainType) {
				each([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
				return;
			}
			var query = {};
			query[mainType + "Id"] = payload[mainType + "Id"];
			query[mainType + "Index"] = payload[mainType + "Index"];
			query[mainType + "Name"] = payload[mainType + "Name"];
			var condition = {
				mainType,
				query
			};
			subType && (condition.subType = subType);
			var excludeSeriesId = payload.excludeSeriesId;
			var excludeSeriesIdMap;
			if (excludeSeriesId != null) {
				excludeSeriesIdMap = createHashMap();
				each(normalizeToArray(excludeSeriesId), function(id) {
					var modelId = convertOptionIdName(id, null);
					if (modelId != null) excludeSeriesIdMap.set(modelId, true);
				});
			}
			ecModel && ecModel.eachComponent(condition, function(model) {
				if (excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null) return;
				if (isHighDownPayload(payload)) if (model instanceof Series_default) {
					if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) blurSeriesFromHighlightPayload(model, payload, ecIns._api);
				} else {
					var _a$1 = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api), focusSelf = _a$1.focusSelf, dispatchers = _a$1.dispatchers;
					if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) blurComponent(model.mainType, model.componentIndex, ecIns._api);
					if (dispatchers) each(dispatchers, function(dispatcher) {
						payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
					});
				}
				else if (isSelectChangePayload(payload)) {
					if (model instanceof Series_default) {
						toggleSelectionFromPayload(model, payload, ecIns._api);
						updateSeriesElementSelection(model);
						markStatusToUpdate(ecIns);
					}
				}
			}, ecIns);
			ecModel && ecModel.eachComponent(condition, function(model) {
				if (excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null) return;
				callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
			}, ecIns);
			function callView(view) {
				view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
			}
		};
		updateMethods = {
			prepareAndUpdate: function(payload) {
				prepare(this);
				updateMethods.update.call(this, payload, payload && { optionChanged: payload.newOption != null });
			},
			update: function(payload, updateParams) {
				var ecModel = this._model;
				var api = this._api;
				var zr = this._zr;
				var coordSysMgr = this._coordSysMgr;
				var scheduler = this._scheduler;
				if (!ecModel) return;
				ecModel.setUpdatePayload(payload);
				scheduler.restoreData(ecModel, payload);
				scheduler.performSeriesTasks(ecModel);
				coordSysMgr.create(ecModel, api);
				scheduler.performDataProcessorTasks(ecModel, payload);
				updateStreamModes(this, ecModel);
				coordSysMgr.update(ecModel, api);
				clearColorPalette(ecModel);
				scheduler.performVisualTasks(ecModel, payload);
				var backgroundColor$1 = ecModel.get("backgroundColor") || "transparent";
				zr.setBackgroundColor(backgroundColor$1);
				var darkMode = ecModel.get("darkMode");
				if (darkMode != null && darkMode !== "auto") zr.setDarkMode(darkMode);
				render(this, ecModel, api, payload, updateParams);
				lifecycle_default.trigger("afterupdate", ecModel, api);
			},
			updateTransform: function(payload) {
				var _this = this;
				var ecModel = this._model;
				var api = this._api;
				if (!ecModel) return;
				ecModel.setUpdatePayload(payload);
				var componentDirtyList = [];
				ecModel.eachComponent(function(componentType, componentModel) {
					if (componentType === "series") return;
					var componentView = _this.getViewOfComponentModel(componentModel);
					if (componentView && componentView.__alive) if (componentView.updateTransform) {
						var result = componentView.updateTransform(componentModel, ecModel, api, payload);
						result && result.update && componentDirtyList.push(componentView);
					} else componentDirtyList.push(componentView);
				});
				var seriesDirtyMap = createHashMap();
				ecModel.eachSeries(function(seriesModel) {
					var chartView = _this._chartsMap[seriesModel.__viewId];
					if (chartView.updateTransform) {
						var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
						result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
					} else seriesDirtyMap.set(seriesModel.uid, 1);
				});
				clearColorPalette(ecModel);
				this._scheduler.performVisualTasks(ecModel, payload, {
					setDirty: true,
					dirtyMap: seriesDirtyMap
				});
				renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);
				lifecycle_default.trigger("afterupdate", ecModel, api);
			},
			updateView: function(payload) {
				var ecModel = this._model;
				if (!ecModel) return;
				ecModel.setUpdatePayload(payload);
				Chart_default.markUpdateMethod(payload, "updateView");
				clearColorPalette(ecModel);
				this._scheduler.performVisualTasks(ecModel, payload, { setDirty: true });
				render(this, ecModel, this._api, payload, {});
				lifecycle_default.trigger("afterupdate", ecModel, this._api);
			},
			updateVisual: function(payload) {
				var _this = this;
				var ecModel = this._model;
				if (!ecModel) return;
				ecModel.setUpdatePayload(payload);
				ecModel.eachSeries(function(seriesModel) {
					seriesModel.getData().clearAllVisual();
				});
				Chart_default.markUpdateMethod(payload, "updateVisual");
				clearColorPalette(ecModel);
				this._scheduler.performVisualTasks(ecModel, payload, {
					visualType: "visual",
					setDirty: true
				});
				ecModel.eachComponent(function(componentType, componentModel) {
					if (componentType !== "series") {
						var componentView = _this.getViewOfComponentModel(componentModel);
						componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
					}
				});
				ecModel.eachSeries(function(seriesModel) {
					_this._chartsMap[seriesModel.__viewId].updateVisual(seriesModel, ecModel, _this._api, payload);
				});
				lifecycle_default.trigger("afterupdate", ecModel, this._api);
			},
			updateLayout: function(payload) {
				updateMethods.update.call(this, payload);
			}
		};
		function doConvertPixelImpl(ecIns, methodName, finder, value, opt) {
			if (ecIns._disposed) {
				disposedWarning(ecIns.id);
				return;
			}
			var ecModel = ecIns._model;
			var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
			var result;
			var parsedFinder = parseFinder(ecModel, finder);
			for (var i$1 = 0; i$1 < coordSysList.length; i$1++) {
				var coordSys = coordSysList[i$1];
				if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value, opt)) != null) return result;
			}
			warn("No coordinate system that supports " + methodName + " found by the given finder.");
		}
		doConvertPixel = doConvertPixelImpl;
		updateStreamModes = function(ecIns, ecModel) {
			var chartsMap = ecIns._chartsMap;
			var scheduler = ecIns._scheduler;
			ecModel.eachSeries(function(seriesModel) {
				scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
			});
		};
		doDispatchAction = function(payload, silent) {
			var _this = this;
			var ecModel = this.getModel();
			var payloadType = payload.type;
			var escapeConnect = payload.escapeConnect;
			var actionInfo$1 = actions[payloadType];
			var cptTypeTmp = (actionInfo$1.update || "update").split(":");
			var updateMethod = cptTypeTmp.pop();
			var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
			this[IN_MAIN_PROCESS_KEY] = true;
			updateMainProcessVersion(this);
			var payloads = [payload];
			var batched = false;
			if (payload.batch) {
				batched = true;
				payloads = map(payload.batch, function(item) {
					item = defaults(extend({}, item), payload);
					item.batch = null;
					return item;
				});
			}
			var eventObjBatch = [];
			var eventObj;
			var actionResultBatch = [];
			var nonRefinedEventType = actionInfo$1.nonRefinedEventType;
			var isSelectChange = isSelectChangePayload(payload);
			var isHighDown = isHighDownPayload(payload);
			if (isHighDown) allLeaveBlur(this._api);
			each(payloads, function(batchItem) {
				var actionResult = actionInfo$1.action(batchItem, ecModel, _this._api);
				if (actionInfo$1.refineEvent) actionResultBatch.push(actionResult);
				else eventObj = actionResult;
				eventObj = eventObj || extend({}, batchItem);
				eventObj.type = nonRefinedEventType;
				eventObjBatch.push(eventObj);
				if (isHighDown) {
					var _a$1 = preParseFinder(payload), queryOptionMap = _a$1.queryOptionMap;
					var componentMainType = _a$1.mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
					updateDirectly(_this, updateMethod, batchItem, componentMainType);
					markStatusToUpdate(_this);
				} else if (isSelectChange) {
					updateDirectly(_this, updateMethod, batchItem, "series");
					markStatusToUpdate(_this);
				} else if (cptType) updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
			});
			if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) try {
				if (this[PENDING_UPDATE]) {
					prepare(this);
					updateMethods.update.call(this, payload);
					this[PENDING_UPDATE] = null;
				} else updateMethods[updateMethod].call(this, payload);
			} catch (e$1) {
				this[IN_MAIN_PROCESS_KEY] = false;
				throw e$1;
			}
			if (batched) eventObj = {
				type: nonRefinedEventType,
				escapeConnect,
				batch: eventObjBatch
			};
			else eventObj = eventObjBatch[0];
			this[IN_MAIN_PROCESS_KEY] = false;
			if (!silent) {
				var refinedEvent = void 0;
				if (actionInfo$1.refineEvent) {
					var eventContent = actionInfo$1.refineEvent(actionResultBatch, payload, ecModel, this._api).eventContent;
					assert(isObject(eventContent));
					refinedEvent = defaults({ type: actionInfo$1.refinedEventType }, eventContent);
					refinedEvent.fromAction = payload.type;
					refinedEvent.fromActionPayload = payload;
					refinedEvent.escapeConnect = true;
				}
				var messageCenter = this._messageCenter;
				messageCenter.trigger(eventObj.type, eventObj);
				if (refinedEvent) messageCenter.trigger(refinedEvent.type, refinedEvent);
			}
		};
		flushPendingActions = function(silent) {
			var pendingActions = this._pendingActions;
			while (pendingActions.length) {
				var payload = pendingActions.shift();
				doDispatchAction.call(this, payload, silent);
			}
		};
		triggerUpdatedEvent = function(silent) {
			!silent && this.trigger("updated");
		};
		/**
		* Event `rendered` is triggered when zr
		* rendered. It is useful for realtime
		* snapshot (reflect animation).
		*
		* Event `finished` is triggered when:
		* (1) zrender rendering finished.
		* (2) initial animation finished.
		* (3) progressive rendering finished.
		* (4) no pending action.
		* (5) no delayed setOption needs to be processed.
		*/
		bindRenderedEvent = function(zr, ecIns) {
			zr.on("rendered", function(params) {
				ecIns.trigger("rendered", params);
				if (zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) ecIns.trigger("finished");
			});
		};
		bindMouseEvent = function(zr, ecIns) {
			zr.on("mouseover", function(e$1) {
				var el = e$1.target;
				var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
				if (dispatcher) {
					handleGlobalMouseOverForHighDown(dispatcher, e$1, ecIns._api);
					markStatusToUpdate(ecIns);
				}
			}).on("mouseout", function(e$1) {
				var el = e$1.target;
				var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
				if (dispatcher) {
					handleGlobalMouseOutForHighDown(dispatcher, e$1, ecIns._api);
					markStatusToUpdate(ecIns);
				}
			}).on("click", function(e$1) {
				var el = e$1.target;
				var dispatcher = findEventDispatcher(el, function(target) {
					return getECData(target).dataIndex != null;
				}, true);
				if (dispatcher) {
					var actionType = dispatcher.selected ? "unselect" : "select";
					var ecData = getECData(dispatcher);
					ecIns._api.dispatchAction({
						type: actionType,
						dataType: ecData.dataType,
						dataIndexInside: ecData.dataIndex,
						seriesIndex: ecData.seriesIndex,
						isFromClick: true
					});
				}
			});
		};
		function clearColorPalette(ecModel) {
			ecModel.clearColorPalette();
			ecModel.eachSeries(function(seriesModel) {
				seriesModel.clearColorPalette();
			});
		}
		function allocateZlevels(ecModel) {
			var componentZLevels = [];
			var seriesZLevels = [];
			var hasSeparateZLevel = false;
			ecModel.eachComponent(function(componentType, componentModel) {
				var zlevel = componentModel.get("zlevel") || 0;
				var z = componentModel.get("z") || 0;
				var zlevelKey = componentModel.getZLevelKey();
				hasSeparateZLevel = hasSeparateZLevel || !!zlevelKey;
				(componentType === "series" ? seriesZLevels : componentZLevels).push({
					zlevel,
					z,
					idx: componentModel.componentIndex,
					type: componentType,
					key: zlevelKey
				});
			});
			if (hasSeparateZLevel) {
				var zLevels = componentZLevels.concat(seriesZLevels);
				var lastSeriesZLevel_1;
				var lastSeriesKey_1;
				sort$2(zLevels, function(a, b) {
					if (a.zlevel === b.zlevel) return a.z - b.z;
					return a.zlevel - b.zlevel;
				});
				each(zLevels, function(item) {
					var componentModel = ecModel.getComponent(item.type, item.idx);
					var zlevel = item.zlevel;
					var key$1 = item.key;
					if (lastSeriesZLevel_1 != null) zlevel = Math.max(lastSeriesZLevel_1, zlevel);
					if (key$1) {
						if (zlevel === lastSeriesZLevel_1 && key$1 !== lastSeriesKey_1) zlevel++;
						lastSeriesKey_1 = key$1;
					} else if (lastSeriesKey_1) {
						if (zlevel === lastSeriesZLevel_1) zlevel++;
						lastSeriesKey_1 = "";
					}
					lastSeriesZLevel_1 = zlevel;
					componentModel.setZLevel(zlevel);
				});
			}
		}
		render = function(ecIns, ecModel, api, payload, updateParams) {
			allocateZlevels(ecModel);
			renderComponents(ecIns, ecModel, api, payload, updateParams);
			each(ecIns._chartsViews, function(chart) {
				chart.__alive = false;
			});
			renderSeries(ecIns, ecModel, api, payload, updateParams);
			each(ecIns._chartsViews, function(chart) {
				if (!chart.__alive) chart.remove(ecModel, api);
			});
		};
		renderComponents = function(ecIns, ecModel, api, payload, updateParams, dirtyList) {
			each(dirtyList || ecIns._componentsViews, function(componentView) {
				var componentModel = componentView.__model;
				clearStates(componentModel, componentView);
				componentView.render(componentModel, ecModel, api, payload);
				updateZ$4(componentModel, componentView);
				updateStates(componentModel, componentView);
			});
		};
		/**
		* Render each chart and component
		*/
		renderSeries = function(ecIns, ecModel, api, payload, updateParams, dirtyMap) {
			var scheduler = ecIns._scheduler;
			updateParams = extend(updateParams || {}, { updatedSeries: ecModel.getSeries() });
			lifecycle_default.trigger("series:beforeupdate", ecModel, api, updateParams);
			var unfinished = false;
			ecModel.eachSeries(function(seriesModel) {
				var chartView = ecIns._chartsMap[seriesModel.__viewId];
				chartView.__alive = true;
				var renderTask = chartView.renderTask;
				scheduler.updatePayload(renderTask, payload);
				clearStates(seriesModel, chartView);
				if (dirtyMap && dirtyMap.get(seriesModel.uid)) renderTask.dirty();
				if (renderTask.perform(scheduler.getPerformArgs(renderTask))) unfinished = true;
				chartView.group.silent = !!seriesModel.get("silent");
				updateBlend(seriesModel, chartView);
				updateSeriesElementSelection(seriesModel);
			});
			scheduler.unfinished = unfinished || scheduler.unfinished;
			lifecycle_default.trigger("series:layoutlabels", ecModel, api, updateParams);
			lifecycle_default.trigger("series:transition", ecModel, api, updateParams);
			ecModel.eachSeries(function(seriesModel) {
				var chartView = ecIns._chartsMap[seriesModel.__viewId];
				updateZ$4(seriesModel, chartView);
				updateStates(seriesModel, chartView);
			});
			updateHoverLayerStatus(ecIns, ecModel);
			lifecycle_default.trigger("series:afterupdate", ecModel, api, updateParams);
		};
		markStatusToUpdate = function(ecIns) {
			ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
			ecIns.getZr().wakeUp();
		};
		updateMainProcessVersion = function(ecIns) {
			ecIns[MAIN_PROCESS_VERSION_KEY] = (ecIns[MAIN_PROCESS_VERSION_KEY] + 1) % 1e3;
		};
		applyChangedStates = function(ecIns) {
			if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) return;
			ecIns.getZr().storage.traverse(function(el) {
				if (isElementRemoved(el)) return;
				applyElementStates(el);
			});
			ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
		};
		function applyElementStates(el) {
			var newStates = [];
			var oldStates = el.currentStates;
			for (var i$1 = 0; i$1 < oldStates.length; i$1++) {
				var stateName = oldStates[i$1];
				if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) newStates.push(stateName);
			}
			if (el.selected && el.states.select) newStates.push("select");
			if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) newStates.push("emphasis");
			else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) newStates.push("blur");
			el.useStates(newStates);
		}
		function updateHoverLayerStatus(ecIns, ecModel) {
			var storage$1 = ecIns._zr.storage;
			var elCount = 0;
			storage$1.traverse(function(el) {
				if (!el.isGroup) elCount++;
			});
			if (elCount > ecModel.get("hoverLayerThreshold") && !env_default.node && !env_default.worker) ecModel.eachSeries(function(seriesModel) {
				if (seriesModel.preventUsingHoverLayer) return;
				var chartView = ecIns._chartsMap[seriesModel.__viewId];
				if (chartView.__alive) chartView.eachRendered(function(el) {
					if (el.states.emphasis) el.states.emphasis.hoverLayer = true;
				});
			});
		}
		/**
		* Update chart and blend.
		*/
		function updateBlend(seriesModel, chartView) {
			var blendMode = seriesModel.get("blendMode") || null;
			chartView.eachRendered(function(el) {
				if (!el.isGroup) el.style.blend = blendMode;
			});
		}
		function updateZ$4(model, view) {
			if (model.preventAutoZ) return;
			var zInfo = retrieveZInfo(model);
			view.eachRendered(function(el) {
				traverseUpdateZ(el, zInfo.z, zInfo.zlevel);
				return true;
			});
		}
		function clearStates(model, view) {
			view.eachRendered(function(el) {
				if (isElementRemoved(el)) return;
				var textContent = el.getTextContent();
				var textGuide = el.getTextGuideLine();
				if (el.stateTransition) el.stateTransition = null;
				if (textContent && textContent.stateTransition) textContent.stateTransition = null;
				if (textGuide && textGuide.stateTransition) textGuide.stateTransition = null;
				if (el.hasState()) {
					el.prevStates = el.currentStates;
					el.clearStates();
				} else if (el.prevStates) el.prevStates = null;
			});
		}
		function updateStates(model, view) {
			var stateAnimationModel = model.getModel("stateAnimation");
			var enableAnimation = model.isAnimationEnabled();
			var duration = stateAnimationModel.get("duration");
			var stateTransition = duration > 0 ? {
				duration,
				delay: stateAnimationModel.get("delay"),
				easing: stateAnimationModel.get("easing")
			} : null;
			view.eachRendered(function(el) {
				if (el.states && el.states.emphasis) {
					if (isElementRemoved(el)) return;
					if (el instanceof Path_default) savePathStates(el);
					if (el.__dirty) {
						var prevStates = el.prevStates;
						if (prevStates) el.useStates(prevStates);
					}
					if (enableAnimation) {
						el.stateTransition = stateTransition;
						var textContent = el.getTextContent();
						var textGuide = el.getTextGuideLine();
						if (textContent) textContent.stateTransition = stateTransition;
						if (textGuide) textGuide.stateTransition = stateTransition;
					}
					if (el.__dirty) applyElementStates(el);
				}
			});
		}
		createExtensionAPI = function(ecIns) {
			return new (function(_super$1) {
				__extends(class_1, _super$1);
				function class_1() {
					return _super$1 !== null && _super$1.apply(this, arguments) || this;
				}
				class_1.prototype.getCoordinateSystems = function() {
					return ecIns._coordSysMgr.getCoordinateSystems();
				};
				class_1.prototype.getComponentByElement = function(el) {
					while (el) {
						var modelInfo = el.__ecComponentInfo;
						if (modelInfo != null) return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
						el = el.parent;
					}
				};
				class_1.prototype.enterEmphasis = function(el, highlightDigit) {
					enterEmphasis(el, highlightDigit);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.leaveEmphasis = function(el, highlightDigit) {
					leaveEmphasis(el, highlightDigit);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.enterBlur = function(el) {
					enterBlur(el);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.leaveBlur = function(el) {
					leaveBlur(el);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.enterSelect = function(el) {
					enterSelect(el);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.leaveSelect = function(el) {
					leaveSelect(el);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.getModel = function() {
					return ecIns.getModel();
				};
				class_1.prototype.getViewOfComponentModel = function(componentModel) {
					return ecIns.getViewOfComponentModel(componentModel);
				};
				class_1.prototype.getViewOfSeriesModel = function(seriesModel) {
					return ecIns.getViewOfSeriesModel(seriesModel);
				};
				class_1.prototype.getMainProcessVersion = function() {
					return ecIns[MAIN_PROCESS_VERSION_KEY];
				};
				return class_1;
			}(ExtensionAPI_default))(ecIns);
		};
		enableConnect = function(chart) {
			function updateConnectedChartsStatus(charts, status) {
				for (var i$1 = 0; i$1 < charts.length; i$1++) {
					var otherChart = charts[i$1];
					otherChart[CONNECT_STATUS_KEY] = status;
				}
			}
			each(connectionEventRevertMap, function(_, eventType) {
				chart._messageCenter.on(eventType, function(event) {
					if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
						if (event && event.escapeConnect) return;
						var action_1 = chart.makeActionFromEvent(event);
						var otherCharts_1 = [];
						each(instances, function(otherChart) {
							if (otherChart !== chart && otherChart.group === chart.group) otherCharts_1.push(otherChart);
						});
						updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
						each(otherCharts_1, function(otherChart) {
							if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) otherChart.dispatchAction(action_1);
						});
						updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
					}
				});
			});
		};
	}();
	return ECharts$1;
}(Eventful_default);
var echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
/**
* @deprecated
*/
echartsProto.one = function(eventName, cb, ctx) {
	var self$1 = this;
	deprecateLog("ECharts#one is deprecated.");
	function wrapped() {
		var args2 = [];
		for (var _i = 0; _i < arguments.length; _i++) args2[_i] = arguments[_i];
		cb && cb.apply && cb.apply(this, args2);
		self$1.off(eventName, wrapped);
	}
	this.on.call(this, eventName, wrapped, ctx);
};
var MOUSE_EVENT_NAMES = [
	"click",
	"dblclick",
	"mouseover",
	"mouseout",
	"mousemove",
	"mousedown",
	"mouseup",
	"globalout",
	"contextmenu"
];
function disposedWarning(id) {
	warn("Instance " + id + " has been disposed");
}
var actions = {};
/**
* Map event type to action type for reproducing action from event for `connect`.
*/
var connectionEventRevertMap = {};
/**
* To remove duplication.
*/
var publicEventTypeMap = {};
var dataProcessorFuncs = [];
var optionPreprocessorFuncs = [];
var visualFuncs = [];
var themeStorage = {};
var loadingEffects = {};
var instances = {};
var connectedGroups = {};
var idBase = +/* @__PURE__ */ new Date() - 0;
var groupIdBase = +/* @__PURE__ */ new Date() - 0;
var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
/**
* @param opts.devicePixelRatio Use window.devicePixelRatio by default
* @param opts.renderer Can choose 'canvas' or 'svg' to render the chart.
* @param opts.width Use clientWidth of the input `dom` by default.
*        Can be 'auto' (the same as null/undefined)
* @param opts.height Use clientHeight of the input `dom` by default.
*        Can be 'auto' (the same as null/undefined)
* @param opts.locale Specify the locale.
* @param opts.useDirtyRect Enable dirty rectangle rendering or not.
*/
function init(dom, theme$1, opts) {
	var isClient = !(opts && opts.ssr);
	if (isClient) {
		if (!dom) throw new Error("Initialize failed: invalid dom.");
		var existInstance = getInstanceByDom(dom);
		if (existInstance) {
			warn("There is a chart instance already initialized on the dom.");
			return existInstance;
		}
		if (isDom(dom) && dom.nodeName.toUpperCase() !== "CANVAS" && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) warn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
	}
	var chart = new ECharts(dom, theme$1, opts);
	chart.id = "ec_" + idBase++;
	instances[chart.id] = chart;
	isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
	enableConnect(chart);
	lifecycle_default.trigger("afterinit", chart);
	return chart;
}
/**
* @usage
* (A)
* ```js
* let chart1 = echarts.init(dom1);
* let chart2 = echarts.init(dom2);
* chart1.group = 'xxx';
* chart2.group = 'xxx';
* echarts.connect('xxx');
* ```
* (B)
* ```js
* let chart1 = echarts.init(dom1);
* let chart2 = echarts.init(dom2);
* echarts.connect('xxx', [chart1, chart2]);
* ```
*/
function connect(groupId) {
	if (isArray(groupId)) {
		var charts = groupId;
		groupId = null;
		each(charts, function(chart) {
			if (chart.group != null) groupId = chart.group;
		});
		groupId = groupId || "g_" + groupIdBase++;
		each(charts, function(chart) {
			chart.group = groupId;
		});
	}
	connectedGroups[groupId] = true;
	return groupId;
}
function disconnect(groupId) {
	connectedGroups[groupId] = false;
}
/**
* Alias and backward compatibility
* @deprecated
*/
var disConnect = disconnect;
/**
* Dispose a chart instance
*/
function dispose(chart) {
	if (isString(chart)) chart = instances[chart];
	else if (!(chart instanceof ECharts)) chart = getInstanceByDom(chart);
	if (chart instanceof ECharts && !chart.isDisposed()) chart.dispose();
}
function getInstanceByDom(dom) {
	return instances[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
}
function getInstanceById(key$1) {
	return instances[key$1];
}
/**
* Register theme
*/
function registerTheme(name, theme$1) {
	themeStorage[name] = theme$1;
}
/**
* Register option preprocessor
*/
function registerPreprocessor(preprocessorFunc) {
	if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) optionPreprocessorFuncs.push(preprocessorFunc);
}
function registerProcessor(priority, processor) {
	normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
}
/**
* Register postIniter
* @param {Function} postInitFunc
*/
function registerPostInit(postInitFunc) {
	registerUpdateLifecycle("afterinit", postInitFunc);
}
/**
* Register postUpdater
* @param {Function} postUpdateFunc
*/
function registerPostUpdate(postUpdateFunc) {
	registerUpdateLifecycle("afterupdate", postUpdateFunc);
}
function registerUpdateLifecycle(name, cb) {
	lifecycle_default.on(name, cb);
}
function registerAction(arg0, arg1, action) {
	var actionType;
	var publicEventType;
	var refineEvent;
	var update;
	var publishNonRefinedEvent;
	if (isFunction(arg1)) {
		action = arg1;
		arg1 = "";
	}
	if (isObject(arg0)) {
		actionType = arg0.type;
		publicEventType = arg0.event;
		update = arg0.update;
		publishNonRefinedEvent = arg0.publishNonRefinedEvent;
		if (!action) action = arg0.action;
		refineEvent = arg0.refineEvent;
	} else {
		actionType = arg0;
		publicEventType = arg1;
	}
	function createEventType(actionOrEventType) {
		return actionOrEventType.toLowerCase();
	}
	publicEventType = createEventType(publicEventType || actionType);
	var nonRefinedEventType = refineEvent ? createEventType(actionType) : publicEventType;
	if (actions[actionType]) return;
	assert(ACTION_REG.test(actionType) && ACTION_REG.test(publicEventType));
	if (refineEvent) assert(publicEventType !== actionType);
	actions[actionType] = {
		actionType,
		refinedEventType: publicEventType,
		nonRefinedEventType,
		update,
		action,
		refineEvent
	};
	publicEventTypeMap[publicEventType] = 1;
	if (refineEvent && publishNonRefinedEvent) publicEventTypeMap[nonRefinedEventType] = 1;
	if (connectionEventRevertMap[nonRefinedEventType]) error(nonRefinedEventType + " must not be shared; use \"refineEvent\" if you intend to share an event name.");
	connectionEventRevertMap[nonRefinedEventType] = actionType;
}
function registerCoordinateSystem(type, coordSysCreator) {
	CoordinateSystem_default.register(type, coordSysCreator);
}
/**
* Get dimensions of specified coordinate system.
* @param {string} type
* @return {Array.<string|Object>}
*/
function getCoordinateSystemDimensions(type) {
	var coordSysCreator = CoordinateSystem_default.get(type);
	if (coordSysCreator) return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
}
function registerCustomSeries(seriesType$1, renderItem) {
	registerCustomSeries$1(seriesType$1, renderItem);
}
function registerLayout(priority, layoutTask) {
	normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(priority, visualTask) {
	normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
	if (isFunction(priority) || isObject(priority)) {
		fn = priority;
		priority = defaultPriority;
	}
	if (isNaN(priority) || priority == null) throw new Error("Illegal priority");
	each(targetList, function(wrap) {
		assert(wrap.__raw !== fn);
	});
	if (indexOf(registeredTasks, fn) >= 0) return;
	registeredTasks.push(fn);
	var stageHandler = Scheduler_default.wrapStageHandler(fn, visualType);
	stageHandler.__prio = priority;
	stageHandler.__raw = fn;
	targetList.push(stageHandler);
}
function registerLoading(name, loadingFx) {
	loadingEffects[name] = loadingFx;
}
/**
* ZRender need a canvas context to do measureText.
* But in node environment canvas may be created by node-canvas.
* So we need to specify how to create a canvas instead of using document.createElement('canvas')
*
*
* @deprecated use setPlatformAPI({ createCanvas }) instead.
*
* @example
*     let Canvas = require('canvas');
*     let echarts = require('echarts');
*     echarts.setCanvasCreator(function () {
*         // Small size is enough.
*         return new Canvas(32, 32);
*     });
*/
function setCanvasCreator(creator) {
	deprecateLog("setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead.");
	setPlatformAPI({ createCanvas: creator });
}
/**
* The parameters and usage: see `geoSourceManager.registerMap`.
* Compatible with previous `echarts.registerMap`.
*/
function registerMap(mapName, geoJson, specialAreas) {
	var registerMap$2 = getImpl("registerMap");
	registerMap$2 && registerMap$2(mapName, geoJson, specialAreas);
}
function getMap(mapName) {
	var getMap$1 = getImpl("getMap");
	return getMap$1 && getMap$1(mapName);
}
var registerTransform = registerExternalTransform;
/**
* Globa dispatchAction to a specified chart instance.
*/
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack$1);
registerLoading("default", defaultLoading);
registerAction({
	type: HIGHLIGHT_ACTION_TYPE,
	event: HIGHLIGHT_ACTION_TYPE,
	update: HIGHLIGHT_ACTION_TYPE
}, noop);
registerAction({
	type: DOWNPLAY_ACTION_TYPE,
	event: DOWNPLAY_ACTION_TYPE,
	update: DOWNPLAY_ACTION_TYPE
}, noop);
registerAction({
	type: SELECT_ACTION_TYPE,
	event: SELECT_CHANGED_EVENT_TYPE,
	update: SELECT_ACTION_TYPE,
	action: noop,
	refineEvent: makeSelectChangedEvent,
	publishNonRefinedEvent: true
});
registerAction({
	type: UNSELECT_ACTION_TYPE,
	event: SELECT_CHANGED_EVENT_TYPE,
	update: UNSELECT_ACTION_TYPE,
	action: noop,
	refineEvent: makeSelectChangedEvent,
	publishNonRefinedEvent: true
});
registerAction({
	type: TOGGLE_SELECT_ACTION_TYPE,
	event: SELECT_CHANGED_EVENT_TYPE,
	update: TOGGLE_SELECT_ACTION_TYPE,
	action: noop,
	refineEvent: makeSelectChangedEvent,
	publishNonRefinedEvent: true
});
function makeSelectChangedEvent(actionResultBatch, payload, ecModel, api) {
	return { eventContent: {
		selected: getAllSelectedIndices(ecModel),
		isFromClick: payload.isFromClick || false
	} };
}
registerTheme("default", {});
registerTheme("dark", dark_default);
var dataTool = {};

//#endregion
//#region node_modules/echarts/lib/extension.js
var extensions = [];
var extensionRegisters = {
	registerPreprocessor,
	registerProcessor,
	registerPostInit,
	registerPostUpdate,
	registerUpdateLifecycle,
	registerAction,
	registerCoordinateSystem,
	registerLayout,
	registerVisual,
	registerTransform,
	registerLoading,
	registerMap,
	registerImpl,
	PRIORITY,
	ComponentModel: Component_default,
	ComponentView: Component_default$1,
	SeriesModel: Series_default,
	ChartView: Chart_default,
	registerComponentModel: function(ComponentModelClass) {
		Component_default.registerClass(ComponentModelClass);
	},
	registerComponentView: function(ComponentViewClass) {
		Component_default$1.registerClass(ComponentViewClass);
	},
	registerSeriesModel: function(SeriesModelClass) {
		Series_default.registerClass(SeriesModelClass);
	},
	registerChartView: function(ChartViewClass) {
		Chart_default.registerClass(ChartViewClass);
	},
	registerCustomSeries: function(seriesType$1, renderItem) {
		registerCustomSeries$1(seriesType$1, renderItem);
	},
	registerSubTypeDefaulter: function(componentType, defaulter) {
		Component_default.registerSubTypeDefaulter(componentType, defaulter);
	},
	registerPainter: function(painterType, PainterCtor) {
		registerPainter(painterType, PainterCtor);
	}
};
function use(ext) {
	if (isArray(ext)) {
		each(ext, function(singleExt) {
			use(singleExt);
		});
		return;
	}
	if (indexOf(extensions, ext) >= 0) return;
	extensions.push(ext);
	if (isFunction(ext)) ext = { install: ext };
	ext.install(extensionRegisters);
}

//#endregion
//#region node_modules/echarts/lib/data/DataDiffer.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
	return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
}
function defaultKeyGetter(item) {
	return item;
}
var DataDiffer = function() {
	/**
	* @param context Can be visited by this.context in callback.
	*/
	function DataDiffer$1(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
		this._old = oldArr;
		this._new = newArr;
		this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
		this._newKeyGetter = newKeyGetter || defaultKeyGetter;
		this.context = context;
		this._diffModeMultiple = diffMode === "multiple";
	}
	/**
	* Callback function when add a data
	*/
	DataDiffer$1.prototype.add = function(func) {
		this._add = func;
		return this;
	};
	/**
	* Callback function when update a data
	*/
	DataDiffer$1.prototype.update = function(func) {
		this._update = func;
		return this;
	};
	/**
	* Callback function when update a data and only work in `cbMode: 'byKey'`.
	*/
	DataDiffer$1.prototype.updateManyToOne = function(func) {
		this._updateManyToOne = func;
		return this;
	};
	/**
	* Callback function when update a data and only work in `cbMode: 'byKey'`.
	*/
	DataDiffer$1.prototype.updateOneToMany = function(func) {
		this._updateOneToMany = func;
		return this;
	};
	/**
	* Callback function when update a data and only work in `cbMode: 'byKey'`.
	*/
	DataDiffer$1.prototype.updateManyToMany = function(func) {
		this._updateManyToMany = func;
		return this;
	};
	/**
	* Callback function when remove a data
	*/
	DataDiffer$1.prototype.remove = function(func) {
		this._remove = func;
		return this;
	};
	DataDiffer$1.prototype.execute = function() {
		this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
	};
	DataDiffer$1.prototype._executeOneToOne = function() {
		var oldArr = this._old;
		var newArr = this._new;
		var newDataIndexMap = {};
		var oldDataKeyArr = new Array(oldArr.length);
		var newDataKeyArr = new Array(newArr.length);
		this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
		this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
		for (var i$1 = 0; i$1 < oldArr.length; i$1++) {
			var oldKey = oldDataKeyArr[i$1];
			var newIdxMapVal = newDataIndexMap[oldKey];
			var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
			if (newIdxMapValLen > 1) {
				var newIdx = newIdxMapVal.shift();
				if (newIdxMapVal.length === 1) newDataIndexMap[oldKey] = newIdxMapVal[0];
				this._update && this._update(newIdx, i$1);
			} else if (newIdxMapValLen === 1) {
				newDataIndexMap[oldKey] = null;
				this._update && this._update(newIdxMapVal, i$1);
			} else this._remove && this._remove(i$1);
		}
		this._performRestAdd(newDataKeyArr, newDataIndexMap);
	};
	/**
	* For example, consider the case:
	* oldData: [o0, o1, o2, o3, o4, o5, o6, o7],
	* newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],
	* Where:
	*     o0, o1, n0 has key 'a' (many to one)
	*     o5, n4, n5, n6 has key 'b' (one to many)
	*     o2, n1 has key 'c' (one to one)
	*     n2, n3 has key 'd' (add)
	*     o3, o4 has key 'e' (remove)
	*     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)
	* Then:
	*     (The order of the following directives are not ensured.)
	*     this._updateManyToOne(n0, [o0, o1]);
	*     this._updateOneToMany([n4, n5, n6], o5);
	*     this._update(n1, o2);
	*     this._remove(o3);
	*     this._remove(o4);
	*     this._remove(o6);
	*     this._remove(o7);
	*     this._add(n2);
	*     this._add(n3);
	*     this._add(n7);
	*     this._add(n8);
	*/
	DataDiffer$1.prototype._executeMultiple = function() {
		var oldArr = this._old;
		var newArr = this._new;
		var oldDataIndexMap = {};
		var newDataIndexMap = {};
		var oldDataKeyArr = [];
		var newDataKeyArr = [];
		this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
		this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
		for (var i$1 = 0; i$1 < oldDataKeyArr.length; i$1++) {
			var oldKey = oldDataKeyArr[i$1];
			var oldIdxMapVal = oldDataIndexMap[oldKey];
			var newIdxMapVal = newDataIndexMap[oldKey];
			var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
			var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
			if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
				this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
				newDataIndexMap[oldKey] = null;
			} else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
				this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
				newDataIndexMap[oldKey] = null;
			} else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
				this._update && this._update(newIdxMapVal, oldIdxMapVal);
				newDataIndexMap[oldKey] = null;
			} else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
				this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
				newDataIndexMap[oldKey] = null;
			} else if (oldIdxMapValLen > 1) for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) this._remove && this._remove(oldIdxMapVal[i_1]);
			else this._remove && this._remove(oldIdxMapVal);
		}
		this._performRestAdd(newDataKeyArr, newDataIndexMap);
	};
	DataDiffer$1.prototype._performRestAdd = function(newDataKeyArr, newDataIndexMap) {
		for (var i$1 = 0; i$1 < newDataKeyArr.length; i$1++) {
			var newKey = newDataKeyArr[i$1];
			var newIdxMapVal = newDataIndexMap[newKey];
			var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
			if (idxMapValLen > 1) for (var j = 0; j < idxMapValLen; j++) this._add && this._add(newIdxMapVal[j]);
			else if (idxMapValLen === 1) this._add && this._add(newIdxMapVal);
			newDataIndexMap[newKey] = null;
		}
	};
	DataDiffer$1.prototype._initIndexMap = function(arr, map$2, keyArr, keyGetterName) {
		var cbModeMultiple = this._diffModeMultiple;
		for (var i$1 = 0; i$1 < arr.length; i$1++) {
			var key$1 = "_ec_" + this[keyGetterName](arr[i$1], i$1);
			if (!cbModeMultiple) keyArr[i$1] = key$1;
			if (!map$2) continue;
			var idxMapVal = map$2[key$1];
			var idxMapValLen = dataIndexMapValueLength(idxMapVal);
			if (idxMapValLen === 0) {
				map$2[key$1] = i$1;
				if (cbModeMultiple) keyArr.push(key$1);
			} else if (idxMapValLen === 1) map$2[key$1] = [idxMapVal, i$1];
			else idxMapVal.push(i$1);
		}
	};
	return DataDiffer$1;
}();
var DataDiffer_default = DataDiffer;

//#endregion
//#region node_modules/echarts/lib/data/helper/dimensionHelper.js
var DimensionUserOuput = function() {
	function DimensionUserOuput$1(encode, dimRequest) {
		this._encode = encode;
		this._schema = dimRequest;
	}
	DimensionUserOuput$1.prototype.get = function() {
		return {
			fullDimensions: this._getFullDimensionNames(),
			encode: this._encode
		};
	};
	/**
	* Get all data store dimension names.
	* Theoretically a series data store is defined both by series and used dataset (if any).
	* If some dimensions are omitted for performance reason in `this.dimensions`,
	* the dimension name may not be auto-generated if user does not specify a dimension name.
	* In this case, the dimension name is `null`/`undefined`.
	*/
	DimensionUserOuput$1.prototype._getFullDimensionNames = function() {
		if (!this._cachedDimNames) this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
		return this._cachedDimNames;
	};
	return DimensionUserOuput$1;
}();
function summarizeDimensions(data, schema) {
	var summary = {};
	var encode = summary.encode = {};
	var notExtraCoordDimMap = createHashMap();
	var defaultedLabel = [];
	var defaultedTooltip = [];
	var userOutputEncode = {};
	each(data.dimensions, function(dimName) {
		var dimItem = data.getDimensionInfo(dimName);
		var coordDim = dimItem.coordDim;
		if (coordDim) {
			assert(VISUAL_DIMENSIONS.get(coordDim) == null);
			var coordDimIndex = dimItem.coordDimIndex;
			getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
			if (!dimItem.isExtraCoord) {
				notExtraCoordDimMap.set(coordDim, 1);
				if (mayLabelDimType(dimItem.type)) defaultedLabel[0] = dimName;
				getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
			}
			if (dimItem.defaultTooltip) defaultedTooltip.push(dimName);
		}
		VISUAL_DIMENSIONS.each(function(v, otherDim) {
			var encodeArr = getOrCreateEncodeArr(encode, otherDim);
			var dimIndex = dimItem.otherDims[otherDim];
			if (dimIndex != null && dimIndex !== false) encodeArr[dimIndex] = dimItem.name;
		});
	});
	var dataDimsOnCoord = [];
	var encodeFirstDimNotExtra = {};
	notExtraCoordDimMap.each(function(v, coordDim) {
		var dimArr = encode[coordDim];
		encodeFirstDimNotExtra[coordDim] = dimArr[0];
		dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
	});
	summary.dataDimsOnCoord = dataDimsOnCoord;
	summary.dataDimIndicesOnCoord = map(dataDimsOnCoord, function(dimName) {
		return data.getDimensionInfo(dimName).storeDimIndex;
	});
	summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
	var encodeLabel = encode.label;
	if (encodeLabel && encodeLabel.length) defaultedLabel = encodeLabel.slice();
	var encodeTooltip = encode.tooltip;
	if (encodeTooltip && encodeTooltip.length) defaultedTooltip = encodeTooltip.slice();
	else if (!defaultedTooltip.length) defaultedTooltip = defaultedLabel.slice();
	encode.defaultedLabel = defaultedLabel;
	encode.defaultedTooltip = defaultedTooltip;
	summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
	return summary;
}
function getOrCreateEncodeArr(encode, dim) {
	if (!encode.hasOwnProperty(dim)) encode[dim] = [];
	return encode[dim];
}
function getDimensionTypeByAxis(axisType) {
	return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
}
function mayLabelDimType(dimType) {
	return !(dimType === "ordinal" || dimType === "time");
}

//#endregion
//#region node_modules/echarts/lib/data/SeriesDimensionDefine.js
var SeriesDimensionDefine = function() {
	/**
	* @param opt All of the fields will be shallow copied.
	*/
	function SeriesDimensionDefine$1(opt) {
		/**
		* The format of `otherDims` is:
		* ```js
		* {
		*     tooltip?: number
		*     label?: number
		*     itemName?: number
		*     seriesName?: number
		* }
		* ```
		*
		* A `series.encode` can specified these fields:
		* ```js
		* encode: {
		*     // "3, 1, 5" is the index of data dimension.
		*     tooltip: [3, 1, 5],
		*     label: [0, 3],
		*     ...
		* }
		* ```
		* `otherDims` is the parse result of the `series.encode` above, like:
		* ```js
		* // Suppose the index of this data dimension is `3`.
		* this.otherDims = {
		*     // `3` is at the index `0` of the `encode.tooltip`
		*     tooltip: 0,
		*     // `3` is at the index `1` of the `encode.label`
		*     label: 1
		* };
		* ```
		*
		* This prop should never be `null`/`undefined` after initialized.
		*/
		this.otherDims = {};
		if (opt != null) extend(this, opt);
	}
	return SeriesDimensionDefine$1;
}();
var SeriesDimensionDefine_default = SeriesDimensionDefine;

//#endregion
//#region node_modules/echarts/lib/data/helper/SeriesDataSchema.js
var inner$19 = makeInner();
var dimTypeShort = {
	float: "f",
	int: "i",
	ordinal: "o",
	number: "n",
	time: "t"
};
/**
* Represents the dimension requirement of a series.
*
* NOTICE:
* When there are too many dimensions in dataset and many series, only the used dimensions
* (i.e., used by coord sys and declared in `series.encode`) are add to `dimensionDefineList`.
* But users may query data by other unused dimension names.
* In this case, users can only query data if and only if they have defined dimension names
* via ec option, so we provide `getDimensionIndexFromSource`, which only query them from
* `source` dimensions.
*/
var SeriesDataSchema = function() {
	function SeriesDataSchema$1(opt) {
		this.dimensions = opt.dimensions;
		this._dimOmitted = opt.dimensionOmitted;
		this.source = opt.source;
		this._fullDimCount = opt.fullDimensionCount;
		this._updateDimOmitted(opt.dimensionOmitted);
	}
	SeriesDataSchema$1.prototype.isDimensionOmitted = function() {
		return this._dimOmitted;
	};
	SeriesDataSchema$1.prototype._updateDimOmitted = function(dimensionOmitted) {
		this._dimOmitted = dimensionOmitted;
		if (!dimensionOmitted) return;
		if (!this._dimNameMap) this._dimNameMap = ensureSourceDimNameMap(this.source);
	};
	/**
	* @caution Can only be used when `dimensionOmitted: true`.
	*
	* Get index by user defined dimension name (i.e., not internal generate name).
	* That is, get index from `dimensionsDefine`.
	* If no `dimensionsDefine`, or no name get, return -1.
	*/
	SeriesDataSchema$1.prototype.getSourceDimensionIndex = function(dimName) {
		return retrieve2(this._dimNameMap.get(dimName), -1);
	};
	/**
	* @caution Can only be used when `dimensionOmitted: true`.
	*
	* Notice: may return `null`/`undefined` if user not specify dimension names.
	*/
	SeriesDataSchema$1.prototype.getSourceDimension = function(dimIndex) {
		var dimensionsDefine = this.source.dimensionsDefine;
		if (dimensionsDefine) return dimensionsDefine[dimIndex];
	};
	SeriesDataSchema$1.prototype.makeStoreSchema = function() {
		var dimCount = this._fullDimCount;
		var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
		var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
		var dimHash = "";
		var dims = [];
		for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
			var property = void 0;
			var type = void 0;
			var ordinalMeta = void 0;
			var seriesDimDef = this.dimensions[seriesDimIdx];
			if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
				property = willRetrieveDataByName ? seriesDimDef.name : null;
				type = seriesDimDef.type;
				ordinalMeta = seriesDimDef.ordinalMeta;
				seriesDimIdx++;
			} else {
				var sourceDimDef = this.getSourceDimension(fullDimIdx);
				if (sourceDimDef) {
					property = willRetrieveDataByName ? sourceDimDef.name : null;
					type = sourceDimDef.type;
				}
			}
			dims.push({
				property,
				type,
				ordinalMeta
			});
			if (willRetrieveDataByName && property != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) dimHash += makeHashStrict ? property.replace(/\`/g, "`1").replace(/\$/g, "`2") : property;
			dimHash += "$";
			dimHash += dimTypeShort[type] || "f";
			if (ordinalMeta) dimHash += ordinalMeta.uid;
			dimHash += "$";
		}
		var source = this.source;
		return {
			dimensions: dims,
			hash: [
				source.seriesLayoutBy,
				source.startIndex,
				dimHash
			].join("$$")
		};
	};
	SeriesDataSchema$1.prototype.makeOutputDimensionNames = function() {
		var result = [];
		for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
			var name_1 = void 0;
			var seriesDimDef = this.dimensions[seriesDimIdx];
			if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
				if (!seriesDimDef.isCalculationCoord) name_1 = seriesDimDef.name;
				seriesDimIdx++;
			} else {
				var sourceDimDef = this.getSourceDimension(fullDimIdx);
				if (sourceDimDef) name_1 = sourceDimDef.name;
			}
			result.push(name_1);
		}
		return result;
	};
	SeriesDataSchema$1.prototype.appendCalculationDimension = function(dimDef) {
		this.dimensions.push(dimDef);
		dimDef.isCalculationCoord = true;
		this._fullDimCount++;
		this._updateDimOmitted(true);
	};
	return SeriesDataSchema$1;
}();
function isSeriesDataSchema(schema) {
	return schema instanceof SeriesDataSchema;
}
function createDimNameMap(dimsDef) {
	var dataDimNameMap = createHashMap();
	for (var i$1 = 0; i$1 < (dimsDef || []).length; i$1++) {
		var dimDefItemRaw = dimsDef[i$1];
		var userDimName = isObject(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
		if (userDimName != null && dataDimNameMap.get(userDimName) == null) dataDimNameMap.set(userDimName, i$1);
	}
	return dataDimNameMap;
}
function ensureSourceDimNameMap(source) {
	var innerSource = inner$19(source);
	return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
}
function shouldOmitUnusedDimensions(dimCount) {
	return dimCount > 30;
}

//#endregion
//#region node_modules/echarts/lib/data/SeriesData.js
var isObject$2 = isObject;
var map$1 = map;
var CtorInt32Array$1 = typeof Int32Array === "undefined" ? Array : Int32Array;
var ID_PREFIX = "e\0\0";
var INDEX_NOT_FOUND = -1;
var TRANSFERABLE_PROPERTIES = [
	"hasItemOption",
	"_nameList",
	"_idList",
	"_invertedIndicesMap",
	"_dimSummary",
	"userOutput",
	"_rawData",
	"_dimValueGetter",
	"_nameDimIdx",
	"_idDimIdx",
	"_nameRepeatCount"
];
var CLONE_PROPERTIES = ["_approximateExtent"];
var prepareInvertedIndex;
var getId;
var getIdNameFromStore;
var normalizeDimensions;
var transferProperties;
var cloneListForMapAndSample;
var makeIdFromName;
var SeriesData = function() {
	/**
	* @param dimensionsInput.dimensions
	*        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
	*        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
	*/
	function SeriesData$1(dimensionsInput, hostModel) {
		this.type = "list";
		this._dimOmitted = false;
		this._nameList = [];
		this._idList = [];
		this._visual = {};
		this._layout = {};
		this._itemVisuals = [];
		this._itemLayouts = [];
		this._graphicEls = [];
		this._approximateExtent = {};
		this._calculationInfo = {};
		this.hasItemOption = false;
		this.TRANSFERABLE_METHODS = [
			"cloneShallow",
			"downSample",
			"minmaxDownSample",
			"lttbDownSample",
			"map"
		];
		this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
		this.DOWNSAMPLE_METHODS = [
			"downSample",
			"minmaxDownSample",
			"lttbDownSample"
		];
		var dimensions;
		var assignStoreDimIdx = false;
		if (isSeriesDataSchema(dimensionsInput)) {
			dimensions = dimensionsInput.dimensions;
			this._dimOmitted = dimensionsInput.isDimensionOmitted();
			this._schema = dimensionsInput;
		} else {
			assignStoreDimIdx = true;
			dimensions = dimensionsInput;
		}
		dimensions = dimensions || ["x", "y"];
		var dimensionInfos = {};
		var dimensionNames = [];
		var invertedIndicesMap = {};
		var needsHasOwn = false;
		var emptyObj = {};
		for (var i$1 = 0; i$1 < dimensions.length; i$1++) {
			var dimInfoInput = dimensions[i$1];
			var dimensionInfo = isString(dimInfoInput) ? new SeriesDimensionDefine_default({ name: dimInfoInput }) : !(dimInfoInput instanceof SeriesDimensionDefine_default) ? new SeriesDimensionDefine_default(dimInfoInput) : dimInfoInput;
			var dimensionName = dimensionInfo.name;
			dimensionInfo.type = dimensionInfo.type || "float";
			if (!dimensionInfo.coordDim) {
				dimensionInfo.coordDim = dimensionName;
				dimensionInfo.coordDimIndex = 0;
			}
			var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
			dimensionNames.push(dimensionName);
			dimensionInfos[dimensionName] = dimensionInfo;
			if (emptyObj[dimensionName] != null) needsHasOwn = true;
			if (dimensionInfo.createInvertedIndices) invertedIndicesMap[dimensionName] = [];
			var dimIdx = i$1;
			if (isNumber(dimensionInfo.storeDimIndex)) dimIdx = dimensionInfo.storeDimIndex;
			if (otherDims.itemName === 0) this._nameDimIdx = dimIdx;
			if (otherDims.itemId === 0) this._idDimIdx = dimIdx;
			assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);
			if (assignStoreDimIdx) dimensionInfo.storeDimIndex = i$1;
		}
		this.dimensions = dimensionNames;
		this._dimInfos = dimensionInfos;
		this._initGetDimensionInfo(needsHasOwn);
		this.hostModel = hostModel;
		this._invertedIndicesMap = invertedIndicesMap;
		if (this._dimOmitted) {
			var dimIdxToName_1 = this._dimIdxToName = createHashMap();
			each(dimensionNames, function(dimName) {
				dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
			});
		}
	}
	/**
	*
	* Get concrete dimension name by dimension name or dimension index.
	* If input a dimension name, do not validate whether the dimension name exits.
	*
	* @caution
	* @param dim Must make sure the dimension is `SeriesDimensionLoose`.
	* Because only those dimensions will have auto-generated dimension names if not
	* have a user-specified name, and other dimensions will get a return of null/undefined.
	*
	* @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:
	* ```js
	* const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);
	* ```
	*
	* @return Concrete dim name.
	*/
	SeriesData$1.prototype.getDimension = function(dim) {
		var dimIdx = this._recognizeDimIndex(dim);
		if (dimIdx == null) return dim;
		dimIdx = dim;
		if (!this._dimOmitted) return this.dimensions[dimIdx];
		var dimName = this._dimIdxToName.get(dimIdx);
		if (dimName != null) return dimName;
		var sourceDimDef = this._schema.getSourceDimension(dimIdx);
		if (sourceDimDef) return sourceDimDef.name;
	};
	/**
	* Get dimension index in data store. Return -1 if not found.
	* Can be used to index value from getRawValue.
	*/
	SeriesData$1.prototype.getDimensionIndex = function(dim) {
		var dimIdx = this._recognizeDimIndex(dim);
		if (dimIdx != null) return dimIdx;
		if (dim == null) return -1;
		var dimInfo = this._getDimInfo(dim);
		return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
	};
	/**
	* The meanings of the input parameter `dim`:
	*
	* + If dim is a number (e.g., `1`), it means the index of the dimension.
	*   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.
	* + If dim is a number-like string (e.g., `"1"`):
	*     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,
	*        it means that concrete name.
	*     + If not, it will be converted to a number, which means the index of the dimension.
	*        (why? because of the backward compatibility. We have been tolerating number-like string in
	*        dimension setting, although now it seems that it is not a good idea.)
	*     For example, `visualMap[i].dimension: "1"` is the same meaning as `visualMap[i].dimension: 1`,
	*     if no dimension name is defined as `"1"`.
	* + If dim is a not-number-like string, it means the concrete dim name.
	*   For example, it can be be default name `"x"`, `"y"`, `"z"`, `"lng"`, `"lat"`, `"angle"`, `"radius"`,
	*   or customized in `dimensions` property of option like `"age"`.
	*
	* @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).
	*/
	SeriesData$1.prototype._recognizeDimIndex = function(dim) {
		if (isNumber(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) return +dim;
	};
	SeriesData$1.prototype._getStoreDimIndex = function(dim) {
		var dimIdx = this.getDimensionIndex(dim);
		if (dimIdx == null) throw new Error("Unknown dimension " + dim);
		return dimIdx;
	};
	/**
	* Get type and calculation info of particular dimension
	* @param dim
	*        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
	*        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
	*/
	SeriesData$1.prototype.getDimensionInfo = function(dim) {
		return this._getDimInfo(this.getDimension(dim));
	};
	SeriesData$1.prototype._initGetDimensionInfo = function(needsHasOwn) {
		var dimensionInfos = this._dimInfos;
		this._getDimInfo = needsHasOwn ? function(dimName) {
			return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0;
		} : function(dimName) {
			return dimensionInfos[dimName];
		};
	};
	/**
	* concrete dimension name list on coord.
	*/
	SeriesData$1.prototype.getDimensionsOnCoord = function() {
		return this._dimSummary.dataDimsOnCoord.slice();
	};
	SeriesData$1.prototype.mapDimension = function(coordDim, idx) {
		var dimensionsSummary = this._dimSummary;
		if (idx == null) return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
		var dims = dimensionsSummary.encode[coordDim];
		return dims ? dims[idx] : null;
	};
	SeriesData$1.prototype.mapDimensionsAll = function(coordDim) {
		return (this._dimSummary.encode[coordDim] || []).slice();
	};
	SeriesData$1.prototype.getStore = function() {
		return this._store;
	};
	/**
	* Initialize from data
	* @param data source or data or data store.
	* @param nameList The name of a datum is used on data diff and
	*        default label/tooltip.
	*        A name can be specified in encode.itemName,
	*        or dataItem.name (only for series option data),
	*        or provided in nameList from outside.
	*/
	SeriesData$1.prototype.initData = function(data, nameList, dimValueGetter) {
		var _this = this;
		var store;
		if (data instanceof DataStore_default) store = data;
		if (!store) {
			var dimensions = this.dimensions;
			var provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
			store = new DataStore_default();
			var dimensionInfos = map$1(dimensions, function(dimName) {
				return {
					type: _this._dimInfos[dimName].type,
					property: dimName
				};
			});
			store.initData(provider, dimensionInfos, dimValueGetter);
		}
		this._store = store;
		this._nameList = (nameList || []).slice();
		this._idList = [];
		this._nameRepeatCount = {};
		this._doInit(0, store.count());
		this._dimSummary = summarizeDimensions(this, this._schema);
		this.userOutput = this._dimSummary.userOutput;
	};
	/**
	* Caution: Can be only called on raw data (before `this._indices` created).
	*/
	SeriesData$1.prototype.appendData = function(data) {
		var range = this._store.appendData(data);
		this._doInit(range[0], range[1]);
	};
	/**
	* Caution: Can be only called on raw data (before `this._indices` created).
	* This method does not modify `rawData` (`dataProvider`), but only
	* add values to store.
	*
	* The final count will be increased by `Math.max(values.length, names.length)`.
	*
	* @param values That is the SourceType: 'arrayRows', like
	*        [
	*            [12, 33, 44],
	*            [NaN, 43, 1],
	*            ['-', 'asdf', 0]
	*        ]
	*        Each item is exactly corresponding to a dimension.
	*/
	SeriesData$1.prototype.appendValues = function(values, names) {
		var _a$1 = this._store.appendValues(values, names && names.length), start$1 = _a$1.start, end$1 = _a$1.end;
		var shouldMakeIdFromName = this._shouldMakeIdFromName();
		this._updateOrdinalMeta();
		if (names) for (var idx = start$1; idx < end$1; idx++) {
			var sourceIdx = idx - start$1;
			this._nameList[idx] = names[sourceIdx];
			if (shouldMakeIdFromName) makeIdFromName(this, idx);
		}
	};
	SeriesData$1.prototype._updateOrdinalMeta = function() {
		var store = this._store;
		var dimensions = this.dimensions;
		for (var i$1 = 0; i$1 < dimensions.length; i$1++) {
			var dimInfo = this._dimInfos[dimensions[i$1]];
			if (dimInfo.ordinalMeta) store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
		}
	};
	SeriesData$1.prototype._shouldMakeIdFromName = function() {
		var provider = this._store.getProvider();
		return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
	};
	SeriesData$1.prototype._doInit = function(start$1, end$1) {
		if (start$1 >= end$1) return;
		var provider = this._store.getProvider();
		this._updateOrdinalMeta();
		var nameList = this._nameList;
		var idList = this._idList;
		if (provider.getSource().sourceFormat === SOURCE_FORMAT_ORIGINAL && !provider.pure) {
			var sharedDataItem = [];
			for (var idx = start$1; idx < end$1; idx++) {
				var dataItem = provider.getItem(idx, sharedDataItem);
				if (!this.hasItemOption && isDataItemOption(dataItem)) this.hasItemOption = true;
				if (dataItem) {
					var itemName = dataItem.name;
					if (nameList[idx] == null && itemName != null) nameList[idx] = convertOptionIdName(itemName, null);
					var itemId = dataItem.id;
					if (idList[idx] == null && itemId != null) idList[idx] = convertOptionIdName(itemId, null);
				}
			}
		}
		if (this._shouldMakeIdFromName()) for (var idx = start$1; idx < end$1; idx++) makeIdFromName(this, idx);
		prepareInvertedIndex(this);
	};
	/**
	* PENDING: In fact currently this function is only used to short-circuit
	* the calling of `scale.unionExtentFromData` when data have been filtered by modules
	* like "dataZoom". `scale.unionExtentFromData` is used to calculate data extent for series on
	* an axis, but if a "axis related data filter module" is used, the extent of the axis have
	* been fixed and no need to calling `scale.unionExtentFromData` actually.
	* But if we add "custom data filter" in future, which is not "axis related", this method may
	* be still needed.
	*
	* Optimize for the scenario that data is filtered by a given extent.
	* Consider that if data amount is more than hundreds of thousand,
	* extent calculation will cost more than 10ms and the cache will
	* be erased because of the filtering.
	*/
	SeriesData$1.prototype.getApproximateExtent = function(dim) {
		return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
	};
	/**
	* Calculate extent on a filtered data might be time consuming.
	* Approximate extent is only used for: calculate extent of filtered data outside.
	*/
	SeriesData$1.prototype.setApproximateExtent = function(extent, dim) {
		dim = this.getDimension(dim);
		this._approximateExtent[dim] = extent.slice();
	};
	SeriesData$1.prototype.getCalculationInfo = function(key$1) {
		return this._calculationInfo[key$1];
	};
	SeriesData$1.prototype.setCalculationInfo = function(key$1, value) {
		isObject$2(key$1) ? extend(this._calculationInfo, key$1) : this._calculationInfo[key$1] = value;
	};
	/**
	* @return Never be null/undefined. `number` will be converted to string. Because:
	* In most cases, name is used in display, where returning a string is more convenient.
	* In other cases, name is used in query (see `indexOfName`), where we can keep the
	* rule that name `2` equals to name `'2'`.
	*/
	SeriesData$1.prototype.getName = function(idx) {
		var rawIndex = this.getRawIndex(idx);
		var name = this._nameList[rawIndex];
		if (name == null && this._nameDimIdx != null) name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
		if (name == null) name = "";
		return name;
	};
	SeriesData$1.prototype._getCategory = function(dimIdx, idx) {
		var ordinal = this._store.get(dimIdx, idx);
		var ordinalMeta = this._store.getOrdinalMeta(dimIdx);
		if (ordinalMeta) return ordinalMeta.categories[ordinal];
		return ordinal;
	};
	/**
	* @return Never null/undefined. `number` will be converted to string. Because:
	* In all cases having encountered at present, id is used in making diff comparison, which
	* are usually based on hash map. We can keep the rule that the internal id are always string
	* (treat `2` is the same as `'2'`) to make the related logic simple.
	*/
	SeriesData$1.prototype.getId = function(idx) {
		return getId(this, this.getRawIndex(idx));
	};
	SeriesData$1.prototype.count = function() {
		return this._store.count();
	};
	/**
	* Get value. Return NaN if idx is out of range.
	*
	* @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.
	*/
	SeriesData$1.prototype.get = function(dim, idx) {
		var store = this._store;
		var dimInfo = this._dimInfos[dim];
		if (dimInfo) return store.get(dimInfo.storeDimIndex, idx);
	};
	/**
	* @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.
	*/
	SeriesData$1.prototype.getByRawIndex = function(dim, rawIdx) {
		var store = this._store;
		var dimInfo = this._dimInfos[dim];
		if (dimInfo) return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
	};
	SeriesData$1.prototype.getIndices = function() {
		return this._store.getIndices();
	};
	SeriesData$1.prototype.getDataExtent = function(dim) {
		return this._store.getDataExtent(this._getStoreDimIndex(dim));
	};
	SeriesData$1.prototype.getSum = function(dim) {
		return this._store.getSum(this._getStoreDimIndex(dim));
	};
	SeriesData$1.prototype.getMedian = function(dim) {
		return this._store.getMedian(this._getStoreDimIndex(dim));
	};
	SeriesData$1.prototype.getValues = function(dimensions, idx) {
		var _this = this;
		var store = this._store;
		return isArray(dimensions) ? store.getValues(map$1(dimensions, function(dim) {
			return _this._getStoreDimIndex(dim);
		}), idx) : store.getValues(dimensions);
	};
	/**
	* If value is NaN. Including '-'
	* Only check the coord dimensions.
	*/
	SeriesData$1.prototype.hasValue = function(idx) {
		var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
		for (var i$1 = 0, len$1 = dataDimIndicesOnCoord.length; i$1 < len$1; i$1++) if (isNaN(this._store.get(dataDimIndicesOnCoord[i$1], idx))) return false;
		return true;
	};
	/**
	* Retrieve the index with given name
	*/
	SeriesData$1.prototype.indexOfName = function(name) {
		for (var i$1 = 0, len$1 = this._store.count(); i$1 < len$1; i$1++) if (this.getName(i$1) === name) return i$1;
		return -1;
	};
	SeriesData$1.prototype.getRawIndex = function(idx) {
		return this._store.getRawIndex(idx);
	};
	SeriesData$1.prototype.indexOfRawIndex = function(rawIndex) {
		return this._store.indexOfRawIndex(rawIndex);
	};
	/**
	* Only support the dimension which inverted index created.
	* Do not support other cases until required.
	* @param dim concrete dim
	* @param value ordinal index
	* @return rawIndex
	*/
	SeriesData$1.prototype.rawIndexOf = function(dim, value) {
		var invertedIndices = dim && this._invertedIndicesMap[dim];
		if (!invertedIndices) throw new Error("Do not supported yet");
		var rawIndex = invertedIndices && invertedIndices[value];
		if (rawIndex == null || isNaN(rawIndex)) return INDEX_NOT_FOUND;
		return rawIndex;
	};
	SeriesData$1.prototype.each = function(dims, cb, ctx) {
		if (isFunction(dims)) {
			ctx = cb;
			cb = dims;
			dims = [];
		}
		var fCtx = ctx || this;
		var dimIndices = map$1(normalizeDimensions(dims), this._getStoreDimIndex, this);
		this._store.each(dimIndices, fCtx ? bind(cb, fCtx) : cb);
	};
	SeriesData$1.prototype.filterSelf = function(dims, cb, ctx) {
		if (isFunction(dims)) {
			ctx = cb;
			cb = dims;
			dims = [];
		}
		var fCtx = ctx || this;
		var dimIndices = map$1(normalizeDimensions(dims), this._getStoreDimIndex, this);
		this._store = this._store.filter(dimIndices, fCtx ? bind(cb, fCtx) : cb);
		return this;
	};
	/**
	* Select data in range. (For optimization of filter)
	* (Manually inline code, support 5 million data filtering in data zoom.)
	*/
	SeriesData$1.prototype.selectRange = function(range) {
		var _this = this;
		var innerRange = {};
		var dims = keys(range);
		var dimIndices = [];
		each(dims, function(dim) {
			var dimIdx = _this._getStoreDimIndex(dim);
			innerRange[dimIdx] = range[dim];
			dimIndices.push(dimIdx);
		});
		this._store = this._store.selectRange(innerRange);
		return this;
	};
	SeriesData$1.prototype.mapArray = function(dims, cb, ctx) {
		if (isFunction(dims)) {
			ctx = cb;
			cb = dims;
			dims = [];
		}
		ctx = ctx || this;
		var result = [];
		this.each(dims, function() {
			result.push(cb && cb.apply(this, arguments));
		}, ctx);
		return result;
	};
	SeriesData$1.prototype.map = function(dims, cb, ctx, ctxCompat) {
		var fCtx = ctx || ctxCompat || this;
		var dimIndices = map$1(normalizeDimensions(dims), this._getStoreDimIndex, this);
		var list = cloneListForMapAndSample(this);
		list._store = this._store.map(dimIndices, fCtx ? bind(cb, fCtx) : cb);
		return list;
	};
	SeriesData$1.prototype.modify = function(dims, cb, ctx, ctxCompat) {
		var _this = this;
		var fCtx = ctx || ctxCompat || this;
		each(normalizeDimensions(dims), function(dim) {
			if (!_this.getDimensionInfo(dim).isCalculationCoord) console.error("Danger: only stack dimension can be modified");
		});
		var dimIndices = map$1(normalizeDimensions(dims), this._getStoreDimIndex, this);
		this._store.modify(dimIndices, fCtx ? bind(cb, fCtx) : cb);
	};
	/**
	* Large data down sampling on given dimension
	* @param sampleIndex Sample index for name and id
	*/
	SeriesData$1.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
		var list = cloneListForMapAndSample(this);
		list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
		return list;
	};
	/**
	* Large data down sampling using min-max
	* @param {string} valueDimension
	* @param {number} rate
	*/
	SeriesData$1.prototype.minmaxDownSample = function(valueDimension, rate) {
		var list = cloneListForMapAndSample(this);
		list._store = this._store.minmaxDownSample(this._getStoreDimIndex(valueDimension), rate);
		return list;
	};
	/**
	* Large data down sampling using largest-triangle-three-buckets
	* @param {string} valueDimension
	* @param {number} targetCount
	*/
	SeriesData$1.prototype.lttbDownSample = function(valueDimension, rate) {
		var list = cloneListForMapAndSample(this);
		list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
		return list;
	};
	SeriesData$1.prototype.getRawDataItem = function(idx) {
		return this._store.getRawDataItem(idx);
	};
	/**
	* Get model of one data item.
	*/
	SeriesData$1.prototype.getItemModel = function(idx) {
		var hostModel = this.hostModel;
		return new Model_default(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);
	};
	/**
	* Create a data differ
	*/
	SeriesData$1.prototype.diff = function(otherList) {
		var thisList = this;
		return new DataDiffer_default(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
			return getId(otherList, idx);
		}, function(idx) {
			return getId(thisList, idx);
		});
	};
	/**
	* Get visual property.
	*/
	SeriesData$1.prototype.getVisual = function(key$1) {
		var visual = this._visual;
		return visual && visual[key$1];
	};
	SeriesData$1.prototype.setVisual = function(kvObj, val) {
		this._visual = this._visual || {};
		if (isObject$2(kvObj)) extend(this._visual, kvObj);
		else this._visual[kvObj] = val;
	};
	/**
	* Get visual property of single data item
	*/
	SeriesData$1.prototype.getItemVisual = function(idx, key$1) {
		var itemVisual = this._itemVisuals[idx];
		var val = itemVisual && itemVisual[key$1];
		if (val == null) return this.getVisual(key$1);
		return val;
	};
	/**
	* If exists visual property of single data item
	*/
	SeriesData$1.prototype.hasItemVisual = function() {
		return this._itemVisuals.length > 0;
	};
	/**
	* Make sure itemVisual property is unique
	*/
	SeriesData$1.prototype.ensureUniqueItemVisual = function(idx, key$1) {
		var itemVisuals = this._itemVisuals;
		var itemVisual = itemVisuals[idx];
		if (!itemVisual) itemVisual = itemVisuals[idx] = {};
		var val = itemVisual[key$1];
		if (val == null) {
			val = this.getVisual(key$1);
			if (isArray(val)) val = val.slice();
			else if (isObject$2(val)) val = extend({}, val);
			itemVisual[key$1] = val;
		}
		return val;
	};
	SeriesData$1.prototype.setItemVisual = function(idx, key$1, value) {
		var itemVisual = this._itemVisuals[idx] || {};
		this._itemVisuals[idx] = itemVisual;
		if (isObject$2(key$1)) extend(itemVisual, key$1);
		else itemVisual[key$1] = value;
	};
	/**
	* Clear itemVisuals and list visual.
	*/
	SeriesData$1.prototype.clearAllVisual = function() {
		this._visual = {};
		this._itemVisuals = [];
	};
	SeriesData$1.prototype.setLayout = function(key$1, val) {
		isObject$2(key$1) ? extend(this._layout, key$1) : this._layout[key$1] = val;
	};
	/**
	* Get layout property.
	*/
	SeriesData$1.prototype.getLayout = function(key$1) {
		return this._layout[key$1];
	};
	/**
	* Get layout of single data item
	*/
	SeriesData$1.prototype.getItemLayout = function(idx) {
		return this._itemLayouts[idx];
	};
	/**
	* Set layout of single data item
	*/
	SeriesData$1.prototype.setItemLayout = function(idx, layout$3, merge$1) {
		this._itemLayouts[idx] = merge$1 ? extend(this._itemLayouts[idx] || {}, layout$3) : layout$3;
	};
	/**
	* Clear all layout of single data item
	*/
	SeriesData$1.prototype.clearItemLayouts = function() {
		this._itemLayouts.length = 0;
	};
	/**
	* Set graphic element relative to data. It can be set as null
	*/
	SeriesData$1.prototype.setItemGraphicEl = function(idx, el) {
		setCommonECData(this.hostModel && this.hostModel.seriesIndex, this.dataType, idx, el);
		this._graphicEls[idx] = el;
	};
	SeriesData$1.prototype.getItemGraphicEl = function(idx) {
		return this._graphicEls[idx];
	};
	SeriesData$1.prototype.eachItemGraphicEl = function(cb, context) {
		each(this._graphicEls, function(el, idx) {
			if (el) cb && cb.call(context, el, idx);
		});
	};
	/**
	* Shallow clone a new list except visual and layout properties, and graph elements.
	* New list only change the indices.
	*/
	SeriesData$1.prototype.cloneShallow = function(list) {
		if (!list) list = new SeriesData$1(this._schema ? this._schema : map$1(this.dimensions, this._getDimInfo, this), this.hostModel);
		transferProperties(list, this);
		list._store = this._store;
		return list;
	};
	/**
	* Wrap some method to add more feature
	*/
	SeriesData$1.prototype.wrapMethod = function(methodName, injectFunction) {
		var originalMethod = this[methodName];
		if (!isFunction(originalMethod)) return;
		this.__wrappedMethods = this.__wrappedMethods || [];
		this.__wrappedMethods.push(methodName);
		this[methodName] = function() {
			var res = originalMethod.apply(this, arguments);
			return injectFunction.apply(this, [res].concat(slice(arguments)));
		};
	};
	SeriesData$1.internalField = function() {
		prepareInvertedIndex = function(data) {
			var invertedIndicesMap = data._invertedIndicesMap;
			each(invertedIndicesMap, function(invertedIndices, dim) {
				var dimInfo = data._dimInfos[dim];
				var ordinalMeta = dimInfo.ordinalMeta;
				var store = data._store;
				if (ordinalMeta) {
					invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array$1(ordinalMeta.categories.length);
					for (var i$1 = 0; i$1 < invertedIndices.length; i$1++) invertedIndices[i$1] = INDEX_NOT_FOUND;
					for (var i$1 = 0; i$1 < store.count(); i$1++) invertedIndices[store.get(dimInfo.storeDimIndex, i$1)] = i$1;
				}
			});
		};
		getIdNameFromStore = function(data, dimIdx, idx) {
			return convertOptionIdName(data._getCategory(dimIdx, idx), null);
		};
		/**
		* @see the comment of `List['getId']`.
		*/
		getId = function(data, rawIndex) {
			var id = data._idList[rawIndex];
			if (id == null && data._idDimIdx != null) id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
			if (id == null) id = ID_PREFIX + rawIndex;
			return id;
		};
		normalizeDimensions = function(dimensions) {
			if (!isArray(dimensions)) dimensions = dimensions != null ? [dimensions] : [];
			return dimensions;
		};
		/**
		* Data in excludeDimensions is copied, otherwise transferred.
		*/
		cloneListForMapAndSample = function(original) {
			var list = new SeriesData$1(original._schema ? original._schema : map$1(original.dimensions, original._getDimInfo, original), original.hostModel);
			transferProperties(list, original);
			return list;
		};
		transferProperties = function(target, source) {
			each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
				if (source.hasOwnProperty(propName)) target[propName] = source[propName];
			});
			target.__wrappedMethods = source.__wrappedMethods;
			each(CLONE_PROPERTIES, function(propName) {
				target[propName] = clone(source[propName]);
			});
			target._calculationInfo = extend({}, source._calculationInfo);
		};
		makeIdFromName = function(data, idx) {
			var nameList = data._nameList;
			var idList = data._idList;
			var nameDimIdx = data._nameDimIdx;
			var idDimIdx = data._idDimIdx;
			var name = nameList[idx];
			var id = idList[idx];
			if (name == null && nameDimIdx != null) nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
			if (id == null && idDimIdx != null) idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
			if (id == null && name != null) {
				var nameRepeatCount = data._nameRepeatCount;
				var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
				id = name;
				if (nmCnt > 1) id += "__ec__" + nmCnt;
				idList[idx] = id;
			}
		};
	}();
	return SeriesData$1;
}();
var SeriesData_default = SeriesData;

//#endregion
//#region node_modules/echarts/lib/data/helper/createDimensions.js
/**
* For outside usage compat (like echarts-gl are using it).
*/
function createDimensions(source, opt) {
	return prepareSeriesDataSchema(source, opt).dimensions;
}
/**
* This method builds the relationship between:
* + "what the coord sys or series requires (see `coordDimensions`)",
* + "what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)"
* + "what the data source provids (see `source`)".
*
* Some guess strategy will be adapted if user does not define something.
* If no 'value' dimension specified, the first no-named dimension will be
* named as 'value'.
*
* @return The results are always sorted by `storeDimIndex` asc.
*/
function prepareSeriesDataSchema(source, opt) {
	if (!isSourceInstance(source)) source = createSourceFromSeriesDataOption(source);
	opt = opt || {};
	var sysDims = opt.coordDimensions || [];
	var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
	var coordDimNameMap = createHashMap();
	var resultList = [];
	var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);
	var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
	var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
	var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
	var encodeDef = opt.encodeDefine;
	if (!encodeDef && opt.encodeDefaulter) encodeDef = opt.encodeDefaulter(source, dimCount);
	var encodeDefMap = createHashMap(encodeDef);
	var indicesMap = new CtorInt32Array(dimCount);
	for (var i$1 = 0; i$1 < indicesMap.length; i$1++) indicesMap[i$1] = -1;
	function getResultItem(dimIdx) {
		var idx = indicesMap[dimIdx];
		if (idx < 0) {
			var dimDefItemRaw = dimsDef[dimIdx];
			var dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : { name: dimDefItemRaw };
			var resultItem$1 = new SeriesDimensionDefine_default();
			var userDimName = dimDefItem.name;
			if (userDimName != null && dataDimNameMap.get(userDimName) != null) resultItem$1.name = resultItem$1.displayName = userDimName;
			dimDefItem.type != null && (resultItem$1.type = dimDefItem.type);
			dimDefItem.displayName != null && (resultItem$1.displayName = dimDefItem.displayName);
			indicesMap[dimIdx] = resultList.length;
			resultItem$1.storeDimIndex = dimIdx;
			resultList.push(resultItem$1);
			return resultItem$1;
		}
		return resultList[idx];
	}
	if (!omitUnusedDimensions) for (var i$1 = 0; i$1 < dimCount; i$1++) getResultItem(i$1);
	encodeDefMap.each(function(dataDimsRaw, coordDim) {
		var dataDims = normalizeToArray(dataDimsRaw).slice();
		if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
			encodeDefMap.set(coordDim, false);
			return;
		}
		var validDataDims = encodeDefMap.set(coordDim, []);
		each(dataDims, function(resultDimIdxOrName, idx) {
			var resultDimIdx$1 = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
			if (resultDimIdx$1 != null && resultDimIdx$1 < dimCount) {
				validDataDims[idx] = resultDimIdx$1;
				applyDim(getResultItem(resultDimIdx$1), coordDim, idx);
			}
		});
	});
	var availDimIdx = 0;
	each(sysDims, function(sysDimItemRaw) {
		var coordDim;
		var sysDimItemDimsDef;
		var sysDimItemOtherDims;
		var sysDimItem;
		if (isString(sysDimItemRaw)) {
			coordDim = sysDimItemRaw;
			sysDimItem = {};
		} else {
			sysDimItem = sysDimItemRaw;
			coordDim = sysDimItem.name;
			var ordinalMeta = sysDimItem.ordinalMeta;
			sysDimItem.ordinalMeta = null;
			sysDimItem = extend({}, sysDimItem);
			sysDimItem.ordinalMeta = ordinalMeta;
			sysDimItemDimsDef = sysDimItem.dimsDef;
			sysDimItemOtherDims = sysDimItem.otherDims;
			sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
		}
		var dataDims = encodeDefMap.get(coordDim);
		if (dataDims === false) return;
		dataDims = normalizeToArray(dataDims);
		if (!dataDims.length) for (var i$2 = 0; i$2 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i$2++) {
			while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) availDimIdx++;
			availDimIdx < dimCount && dataDims.push(availDimIdx++);
		}
		each(dataDims, function(resultDimIdx$1, coordDimIndex) {
			var resultItem$1 = getResultItem(resultDimIdx$1);
			if (isUsingSourceDimensionsDef && sysDimItem.type != null) resultItem$1.type = sysDimItem.type;
			applyDim(defaults(resultItem$1, sysDimItem), coordDim, coordDimIndex);
			if (resultItem$1.name == null && sysDimItemDimsDef) {
				var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
				!isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = { name: sysDimItemDimsDefItem });
				resultItem$1.name = resultItem$1.displayName = sysDimItemDimsDefItem.name;
				resultItem$1.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
			}
			sysDimItemOtherDims && defaults(resultItem$1.otherDims, sysDimItemOtherDims);
		});
	});
	function applyDim(resultItem$1, coordDim, coordDimIndex) {
		if (VISUAL_DIMENSIONS.get(coordDim) != null) resultItem$1.otherDims[coordDim] = coordDimIndex;
		else {
			resultItem$1.coordDim = coordDim;
			resultItem$1.coordDimIndex = coordDimIndex;
			coordDimNameMap.set(coordDim, true);
		}
	}
	var generateCoord = opt.generateCoord;
	var generateCoordCount = opt.generateCoordCount;
	var fromZero = generateCoordCount != null;
	generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
	var extra = generateCoord || "value";
	function ifNoNameFillWithCoordName(resultItem$1) {
		if (resultItem$1.name == null) resultItem$1.name = resultItem$1.coordDim;
	}
	if (!omitUnusedDimensions) for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
		var resultItem = getResultItem(resultDimIdx);
		if (resultItem.coordDim == null) {
			resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
			resultItem.coordDimIndex = 0;
			if (!generateCoord || generateCoordCount <= 0) resultItem.isExtraCoord = true;
			generateCoordCount--;
		}
		ifNoNameFillWithCoordName(resultItem);
		if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) resultItem.type = "ordinal";
	}
	else {
		each(resultList, function(resultItem$1) {
			ifNoNameFillWithCoordName(resultItem$1);
		});
		resultList.sort(function(item0, item1) {
			return item0.storeDimIndex - item1.storeDimIndex;
		});
	}
	removeDuplication(resultList);
	return new SeriesDataSchema({
		source,
		dimensions: resultList,
		fullDimensionCount: dimCount,
		dimensionOmitted: omitUnusedDimensions
	});
}
function removeDuplication(result) {
	var duplicationMap = createHashMap();
	for (var i$1 = 0; i$1 < result.length; i$1++) {
		var dim = result[i$1];
		var dimOriginalName = dim.name;
		var count$1 = duplicationMap.get(dimOriginalName) || 0;
		if (count$1 > 0) dim.name = dimOriginalName + (count$1 - 1);
		count$1++;
		duplicationMap.set(dimOriginalName, count$1);
	}
}
function getDimCount(source, sysDims, dimsDef, optDimCount) {
	var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
	each(sysDims, function(sysDimItem) {
		var sysDimItemDimsDef;
		if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
	});
	return dimCount;
}
function genCoordDimName(name, map$2, fromZero) {
	if (fromZero || map$2.hasKey(name)) {
		var i$1 = 0;
		while (map$2.hasKey(name + i$1)) i$1++;
		name += i$1;
	}
	map$2.set(name, true);
	return name;
}

//#endregion
//#region node_modules/echarts/lib/model/referHelper.js
/**
* @class
* For example:
* {
*     coordSysName: 'cartesian2d',
*     coordSysDims: ['x', 'y', ...],
*     axisMap: HashMap({
*         x: xAxisModel,
*         y: yAxisModel
*     }),
*     categoryAxisMap: HashMap({
*         x: xAxisModel,
*         y: undefined
*     }),
*     // The index of the first category axis in `coordSysDims`.
*     // `null/undefined` means no category axis exists.
*     firstCategoryDimIndex: 1,
*     // To replace user specified encode.
* }
*/
var CoordSysInfo = function() {
	function CoordSysInfo$1(coordSysName) {
		this.coordSysDims = [];
		this.axisMap = createHashMap();
		this.categoryAxisMap = createHashMap();
		this.coordSysName = coordSysName;
	}
	return CoordSysInfo$1;
}();
function getCoordSysInfoBySeries(seriesModel) {
	var coordSysName = seriesModel.get("coordinateSystem");
	var result = new CoordSysInfo(coordSysName);
	var fetch = fetchers[coordSysName];
	if (fetch) {
		fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
		return result;
	}
}
var fetchers = {
	cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
		var xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
		var yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
		if (!xAxisModel) throw new Error("xAxis \"" + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("xAxisId"), 0) + "\" not found");
		if (!yAxisModel) throw new Error("yAxis \"" + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("yAxisId"), 0) + "\" not found");
		result.coordSysDims = ["x", "y"];
		axisMap.set("x", xAxisModel);
		axisMap.set("y", yAxisModel);
		if (isCategory(xAxisModel)) {
			categoryAxisMap.set("x", xAxisModel);
			result.firstCategoryDimIndex = 0;
		}
		if (isCategory(yAxisModel)) {
			categoryAxisMap.set("y", yAxisModel);
			result.firstCategoryDimIndex ??= 1;
		}
	},
	singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
		var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
		if (!singleAxisModel) throw new Error("singleAxis should be specified.");
		result.coordSysDims = ["single"];
		axisMap.set("single", singleAxisModel);
		if (isCategory(singleAxisModel)) {
			categoryAxisMap.set("single", singleAxisModel);
			result.firstCategoryDimIndex = 0;
		}
	},
	polar: function(seriesModel, result, axisMap, categoryAxisMap) {
		var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
		var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
		var angleAxisModel = polarModel.findAxisModel("angleAxis");
		if (!angleAxisModel) throw new Error("angleAxis option not found");
		if (!radiusAxisModel) throw new Error("radiusAxis option not found");
		result.coordSysDims = ["radius", "angle"];
		axisMap.set("radius", radiusAxisModel);
		axisMap.set("angle", angleAxisModel);
		if (isCategory(radiusAxisModel)) {
			categoryAxisMap.set("radius", radiusAxisModel);
			result.firstCategoryDimIndex = 0;
		}
		if (isCategory(angleAxisModel)) {
			categoryAxisMap.set("angle", angleAxisModel);
			result.firstCategoryDimIndex ??= 1;
		}
	},
	geo: function(seriesModel, result, axisMap, categoryAxisMap) {
		result.coordSysDims = ["lng", "lat"];
	},
	parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
		var ecModel = seriesModel.ecModel;
		var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
		var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
		each(parallelModel.parallelAxisIndex, function(axisIndex, index) {
			var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
			var axisDim = coordSysDims[index];
			axisMap.set(axisDim, axisModel);
			if (isCategory(axisModel)) {
				categoryAxisMap.set(axisDim, axisModel);
				if (result.firstCategoryDimIndex == null) result.firstCategoryDimIndex = index;
			}
		});
	},
	matrix: function(seriesModel, result, axisMap, categoryAxisMap) {
		var matrixModel = seriesModel.getReferringComponents("matrix", SINGLE_REFERRING).models[0];
		if (!matrixModel) throw new Error("matrix coordinate system should be specified.");
		result.coordSysDims = ["x", "y"];
		var xModel = matrixModel.getDimensionModel("x");
		var yModel = matrixModel.getDimensionModel("y");
		axisMap.set("x", xModel);
		axisMap.set("y", yModel);
		categoryAxisMap.set("x", xModel);
		categoryAxisMap.set("y", yModel);
	}
};
function isCategory(axisModel) {
	return axisModel.get("type") === "category";
}

//#endregion
//#region node_modules/echarts/lib/data/helper/dataStackHelper.js
/**
* Note that it is too complicated to support 3d stack by value
* (have to create two-dimension inverted index), so in 3d case
* we just support that stacked by index.
*
* @param seriesModel
* @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.
*        The input will be modified.
* @param opt
* @param opt.stackedCoordDimension Specify a coord dimension if needed.
* @param opt.byIndex=false
* @return calculationInfo
* {
*     stackedDimension: string
*     stackedByDimension: string
*     isStackedByIndex: boolean
*     stackedOverDimension: string
*     stackResultDimension: string
* }
*/
function enableDataStack(seriesModel, dimensionsInput, opt) {
	opt = opt || {};
	var byIndex = opt.byIndex;
	var stackedCoordDimension = opt.stackedCoordDimension;
	var dimensionDefineList;
	var schema;
	var store;
	if (isLegacyDimensionsInput(dimensionsInput)) dimensionDefineList = dimensionsInput;
	else {
		schema = dimensionsInput.schema;
		dimensionDefineList = schema.dimensions;
		store = dimensionsInput.store;
	}
	var mayStack = !!(seriesModel && seriesModel.get("stack"));
	var stackedByDimInfo;
	var stackedDimInfo;
	var stackResultDimension;
	var stackedOverDimension;
	each(dimensionDefineList, function(dimensionInfo, index) {
		if (isString(dimensionInfo)) dimensionDefineList[index] = dimensionInfo = { name: dimensionInfo };
		if (mayStack && !dimensionInfo.isExtraCoord) {
			if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) stackedByDimInfo = dimensionInfo;
			if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) stackedDimInfo = dimensionInfo;
		}
	});
	if (stackedDimInfo && !byIndex && !stackedByDimInfo) byIndex = true;
	if (stackedDimInfo) {
		stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
		stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
		if (stackedByDimInfo) stackedByDimInfo.createInvertedIndices = true;
		var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
		var stackedDimType = stackedDimInfo.type;
		var stackedDimCoordIndex_1 = 0;
		each(dimensionDefineList, function(dimensionInfo) {
			if (dimensionInfo.coordDim === stackedDimCoordDim_1) stackedDimCoordIndex_1++;
		});
		var stackedOverDimensionDefine = {
			name: stackResultDimension,
			coordDim: stackedDimCoordDim_1,
			coordDimIndex: stackedDimCoordIndex_1,
			type: stackedDimType,
			isExtraCoord: true,
			isCalculationCoord: true,
			storeDimIndex: dimensionDefineList.length
		};
		var stackResultDimensionDefine = {
			name: stackedOverDimension,
			coordDim: stackedOverDimension,
			coordDimIndex: stackedDimCoordIndex_1 + 1,
			type: stackedDimType,
			isExtraCoord: true,
			isCalculationCoord: true,
			storeDimIndex: dimensionDefineList.length + 1
		};
		if (schema) {
			if (store) {
				stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
				stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
			}
			schema.appendCalculationDimension(stackedOverDimensionDefine);
			schema.appendCalculationDimension(stackResultDimensionDefine);
		} else {
			dimensionDefineList.push(stackedOverDimensionDefine);
			dimensionDefineList.push(stackResultDimensionDefine);
		}
	}
	return {
		stackedDimension: stackedDimInfo && stackedDimInfo.name,
		stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
		isStackedByIndex: byIndex,
		stackedOverDimension,
		stackResultDimension
	};
}
function isLegacyDimensionsInput(dimensionsInput) {
	return !isSeriesDataSchema(dimensionsInput.schema);
}
function isDimensionStacked(data, stackedDim) {
	return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
}
function getStackedDimension(data, targetDim) {
	return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
}

//#endregion
//#region node_modules/echarts/lib/chart/helper/createSeriesData.js
function getCoordSysDimDefs(seriesModel, coordSysInfo) {
	var coordSysName = seriesModel.get("coordinateSystem");
	var registeredCoordSys = CoordinateSystem_default.get(coordSysName);
	var coordSysDimDefs;
	if (coordSysInfo && coordSysInfo.coordSysDims) coordSysDimDefs = map(coordSysInfo.coordSysDims, function(dim) {
		var dimInfo = { name: dim };
		var axisModel = coordSysInfo.axisMap.get(dim);
		if (axisModel) dimInfo.type = getDimensionTypeByAxis(axisModel.get("type"));
		return dimInfo;
	});
	if (!coordSysDimDefs) coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
	return coordSysDimDefs;
}
function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
	var firstCategoryDimIndex;
	var hasNameEncode;
	coordSysInfo && each(dimInfoList, function(dimInfo, dimIndex) {
		var coordDim = dimInfo.coordDim;
		var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
		if (categoryAxisModel) {
			if (firstCategoryDimIndex == null) firstCategoryDimIndex = dimIndex;
			dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
			if (createInvertedIndices) dimInfo.createInvertedIndices = true;
		}
		if (dimInfo.otherDims.itemName != null) hasNameEncode = true;
	});
	if (!hasNameEncode && firstCategoryDimIndex != null) dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
	return firstCategoryDimIndex;
}
/**
* Caution: there are side effects to `sourceManager` in this method.
* Should better only be called in `Series['getInitialData']`.
*/
function createSeriesData(sourceRaw, seriesModel, opt) {
	opt = opt || {};
	var sourceManager = seriesModel.getSourceManager();
	var source;
	var isOriginalSource = false;
	if (sourceRaw) {
		isOriginalSource = true;
		source = createSourceFromSeriesDataOption(sourceRaw);
	} else {
		source = sourceManager.getSource();
		isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
	}
	var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
	var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
	var useEncodeDefaulter = opt.useEncodeDefaulter;
	var encodeDefaulter = isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
	var createDimensionOptions = {
		coordDimensions: coordSysDimDefs,
		generateCoord: opt.generateCoord,
		encodeDefine: seriesModel.getEncode(),
		encodeDefaulter,
		canOmitUnusedDimensions: !isOriginalSource
	};
	var schema = prepareSeriesDataSchema(source, createDimensionOptions);
	var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
	var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
	var stackCalculationInfo = enableDataStack(seriesModel, {
		schema,
		store
	});
	var data = new SeriesData_default(schema, seriesModel);
	data.setCalculationInfo(stackCalculationInfo);
	var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
		return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
	} : null;
	data.hasItemOption = false;
	data.initData(isOriginalSource ? source : store, null, dimValueGetter);
	return data;
}
function isNeedCompleteOrdinalData(source) {
	if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
		var sampleItem = firstDataNotNull(source.data || []);
		return !isArray(getDataItemValue(sampleItem));
	}
}
function firstDataNotNull(arr) {
	var i$1 = 0;
	while (i$1 < arr.length && arr[i$1] == null) i$1++;
	return arr[i$1];
}
var createSeriesData_default = createSeriesData;

//#endregion
//#region node_modules/echarts/lib/scale/helper.js
function isValueNice(val) {
	var exp10 = Math.pow(10, quantityExponent(Math.abs(val)));
	var f = Math.abs(val / exp10);
	return f === 0 || f === 1 || f === 2 || f === 3 || f === 5;
}
function isIntervalOrLogScale(scale$3) {
	return scale$3.type === "interval" || scale$3.type === "log";
}
/**
* @param extent Both extent[0] and extent[1] should be valid number.
*               Should be extent[0] < extent[1].
* @param splitNumber splitNumber should be >= 1.
*/
function intervalScaleNiceTicks(extent, spanWithBreaks, splitNumber, minInterval, maxInterval) {
	var result = {};
	var interval = result.interval = nice(spanWithBreaks / splitNumber, true);
	if (minInterval != null && interval < minInterval) interval = result.interval = minInterval;
	if (maxInterval != null && interval > maxInterval) interval = result.interval = maxInterval;
	var precision = result.intervalPrecision = getIntervalPrecision(interval);
	fixExtent(result.niceTickExtent = [round(Math.ceil(extent[0] / interval) * interval, precision), round(Math.floor(extent[1] / interval) * interval, precision)], extent);
	return result;
}
function increaseInterval(interval) {
	var exp10 = Math.pow(10, quantityExponent(interval));
	var f = interval / exp10;
	if (!f) f = 1;
	else if (f === 2) f = 3;
	else if (f === 3) f = 5;
	else f *= 2;
	return round(f * exp10);
}
/**
* @return interval precision
*/
function getIntervalPrecision(interval) {
	return getPrecision(interval) + 2;
}
function clamp(niceTickExtent, idx, extent) {
	niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
}
function fixExtent(niceTickExtent, extent) {
	!isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
	!isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
	clamp(niceTickExtent, 0, extent);
	clamp(niceTickExtent, 1, extent);
	if (niceTickExtent[0] > niceTickExtent[1]) niceTickExtent[0] = niceTickExtent[1];
}
function contain$1(val, extent) {
	return val >= extent[0] && val <= extent[1];
}
var ScaleCalculator = function() {
	function ScaleCalculator$1() {
		this.normalize = normalize$2;
		this.scale = scale;
	}
	ScaleCalculator$1.prototype.updateMethods = function(brkCtx) {
		if (brkCtx.hasBreaks()) {
			this.normalize = bind(brkCtx.normalize, brkCtx);
			this.scale = bind(brkCtx.scale, brkCtx);
		} else {
			this.normalize = normalize$2;
			this.scale = scale;
		}
	};
	return ScaleCalculator$1;
}();
function normalize$2(val, extent) {
	if (extent[1] === extent[0]) return .5;
	return (val - extent[0]) / (extent[1] - extent[0]);
}
function scale(val, extent) {
	return val * (extent[1] - extent[0]) + extent[0];
}
function logTransform(base$1, extent, noClampNegative) {
	var loggedBase = Math.log(base$1);
	return [Math.log(noClampNegative ? extent[0] : Math.max(0, extent[0])) / loggedBase, Math.log(noClampNegative ? extent[1] : Math.max(0, extent[1])) / loggedBase];
}

//#endregion
//#region node_modules/echarts/lib/scale/Scale.js
var Scale = function() {
	function Scale$1(setting) {
		this._calculator = new ScaleCalculator();
		this._setting = setting || {};
		this._extent = [Infinity, -Infinity];
		var scaleBreakHelper = getScaleBreakHelper();
		if (scaleBreakHelper) {
			this._brkCtx = scaleBreakHelper.createScaleBreakContext();
			this._brkCtx.update(this._extent);
		}
	}
	Scale$1.prototype.getSetting = function(name) {
		return this._setting[name];
	};
	/**
	* [CAVEAT]: It should not be overridden!
	*/
	Scale$1.prototype._innerUnionExtent = function(other) {
		var extent = this._extent;
		this._innerSetExtent(other[0] < extent[0] ? other[0] : extent[0], other[1] > extent[1] ? other[1] : extent[1]);
	};
	/**
	* Set extent from data
	*/
	Scale$1.prototype.unionExtentFromData = function(data, dim) {
		this._innerUnionExtent(data.getApproximateExtent(dim));
	};
	/**
	* Get a new slice of extent.
	* Extent is always in increase order.
	*/
	Scale$1.prototype.getExtent = function() {
		return this._extent.slice();
	};
	Scale$1.prototype.setExtent = function(start$1, end$1) {
		this._innerSetExtent(start$1, end$1);
	};
	/**
	* [CAVEAT]: It should not be overridden!
	*/
	Scale$1.prototype._innerSetExtent = function(start$1, end$1) {
		var thisExtent = this._extent;
		if (!isNaN(start$1)) thisExtent[0] = start$1;
		if (!isNaN(end$1)) thisExtent[1] = end$1;
		this._brkCtx && this._brkCtx.update(thisExtent);
	};
	/**
	* Prerequisite: Scale#parse is ready.
	*/
	Scale$1.prototype.setBreaksFromOption = function(breakOptionList) {
		var scaleBreakHelper = getScaleBreakHelper();
		if (scaleBreakHelper) this._innerSetBreak(scaleBreakHelper.parseAxisBreakOption(breakOptionList, bind(this.parse, this)));
	};
	/**
	* [CAVEAT]: It should not be overridden!
	*/
	Scale$1.prototype._innerSetBreak = function(parsed) {
		if (this._brkCtx) {
			this._brkCtx.setBreaks(parsed);
			this._calculator.updateMethods(this._brkCtx);
			this._brkCtx.update(this._extent);
		}
	};
	/**
	* [CAVEAT]: It should not be overridden!
	*/
	Scale$1.prototype._innerGetBreaks = function() {
		return this._brkCtx ? this._brkCtx.breaks : [];
	};
	/**
	* Do not expose the internal `_breaks` unless necessary.
	*/
	Scale$1.prototype.hasBreaks = function() {
		return this._brkCtx ? this._brkCtx.hasBreaks() : false;
	};
	Scale$1.prototype._getExtentSpanWithBreaks = function() {
		return this._brkCtx && this._brkCtx.hasBreaks() ? this._brkCtx.getExtentSpan() : this._extent[1] - this._extent[0];
	};
	/**
	* If value is in extent range
	*/
	Scale$1.prototype.isInExtentRange = function(value) {
		return this._extent[0] <= value && this._extent[1] >= value;
	};
	/**
	* When axis extent depends on data and no data exists,
	* axis ticks should not be drawn, which is named 'blank'.
	*/
	Scale$1.prototype.isBlank = function() {
		return this._isBlank;
	};
	/**
	* When axis extent depends on data and no data exists,
	* axis ticks should not be drawn, which is named 'blank'.
	*/
	Scale$1.prototype.setBlank = function(isBlank) {
		this._isBlank = isBlank;
	};
	return Scale$1;
}();
enableClassManagement(Scale);
var Scale_default = Scale;

//#endregion
//#region node_modules/echarts/lib/data/OrdinalMeta.js
var uidBase = 0;
var OrdinalMeta = function() {
	/**
	* PENDING - Regarding forcibly converting to string:
	*  In the early days, the underlying hash map impl used JS plain object and converted the key to
	*  string; later in https://github.com/ecomfe/zrender/pull/966 it was changed to a JS Map (in supported
	*  platforms), which does not require string keys. But consider any input that `scale/Ordinal['parse']`
	*  is involved, a number input represents an `OrdinalNumber` (i.e., an index), and affect the query
	*  behavior:
	*    - If forcbily converting to string:
	*      pros: users can use numeric string (such as, '123') to query the raw data (123), tho it's probably
	*      still confusing.
	*      cons: NaN/null/undefined in data will be equals to 'NaN'/'null'/'undefined', if simply using
	*      `val + ''` to convert them, like currently `getName` does.
	*    - Otherwise:
	*      pros: see NaN/null/undefined case above.
	*      cons: users cannot query the raw data (123) any more.
	*  There are two inconsistent behaviors in the current impl:
	*    - Force conversion is applied on the case `xAxis{data: ['aaa', 'bbb', ...]}`,
	*      but no conversion applied to the case `xAxis{data: [{value: 'aaa'}, ...]}` and
	*      the case `dataset: {source: [['aaa', 123], ['bbb', 234], ...]}`.
	*    - behaves differently according to whether JS Map is supported (the polyfill is simply using JS
	*      plain object) (tho it seems rare platform that do not support it).
	*  Since there's no sufficient good solution to offset cost of the breaking change, we preserve the
	*  current behavior, until real issues is reported.
	*/
	function OrdinalMeta$1(opt) {
		this.categories = opt.categories || [];
		this._needCollect = opt.needCollect;
		this._deduplication = opt.deduplication;
		this.uid = ++uidBase;
		this._onCollect = opt.onCollect;
	}
	OrdinalMeta$1.createByAxisModel = function(axisModel) {
		var option = axisModel.option;
		var data = option.data;
		var categories = data && map(data, getName);
		return new OrdinalMeta$1({
			categories,
			needCollect: !categories,
			deduplication: option.dedplication !== false
		});
	};
	OrdinalMeta$1.prototype.getOrdinal = function(category) {
		return this._getOrCreateMap().get(category);
	};
	/**
	* @return The ordinal. If not found, return NaN.
	*/
	OrdinalMeta$1.prototype.parseAndCollect = function(category) {
		var index;
		var needCollect = this._needCollect;
		if (!isString(category) && !needCollect) return category;
		if (needCollect && !this._deduplication) {
			index = this.categories.length;
			this.categories[index] = category;
			this._onCollect && this._onCollect(category, index);
			return index;
		}
		var map$2 = this._getOrCreateMap();
		index = map$2.get(category);
		if (index == null) if (needCollect) {
			index = this.categories.length;
			this.categories[index] = category;
			map$2.set(category, index);
			this._onCollect && this._onCollect(category, index);
		} else index = NaN;
		return index;
	};
	OrdinalMeta$1.prototype._getOrCreateMap = function() {
		return this._map || (this._map = createHashMap(this.categories));
	};
	return OrdinalMeta$1;
}();
function getName(obj) {
	if (isObject(obj) && obj.value != null) return obj.value;
	else return obj + "";
}
var OrdinalMeta_default = OrdinalMeta;

//#endregion
//#region node_modules/echarts/lib/scale/Ordinal.js
var OrdinalScale = function(_super) {
	__extends(OrdinalScale$1, _super);
	function OrdinalScale$1(setting) {
		var _this = _super.call(this, setting) || this;
		_this.type = "ordinal";
		var ordinalMeta = _this.getSetting("ordinalMeta");
		if (!ordinalMeta) ordinalMeta = new OrdinalMeta_default({});
		if (isArray(ordinalMeta)) ordinalMeta = new OrdinalMeta_default({ categories: map(ordinalMeta, function(item) {
			return isObject(item) ? item.value : item;
		}) });
		_this._ordinalMeta = ordinalMeta;
		_this._extent = _this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
		return _this;
	}
	OrdinalScale$1.prototype.parse = function(val) {
		if (val == null) return NaN;
		return isString(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
	};
	OrdinalScale$1.prototype.contain = function(val) {
		return contain$1(val, this._extent) && val >= 0 && val < this._ordinalMeta.categories.length;
	};
	/**
	* Normalize given rank or name to linear [0, 1]
	* @param val raw ordinal number.
	* @return normalized value in [0, 1].
	*/
	OrdinalScale$1.prototype.normalize = function(val) {
		val = this._getTickNumber(val);
		return this._calculator.normalize(val, this._extent);
	};
	/**
	* @param val normalized value in [0, 1].
	* @return raw ordinal number.
	*/
	OrdinalScale$1.prototype.scale = function(val) {
		val = Math.round(this._calculator.scale(val, this._extent));
		return this.getRawOrdinalNumber(val);
	};
	OrdinalScale$1.prototype.getTicks = function() {
		var ticks = [];
		var extent = this._extent;
		var rank = extent[0];
		while (rank <= extent[1]) {
			ticks.push({ value: rank });
			rank++;
		}
		return ticks;
	};
	OrdinalScale$1.prototype.getMinorTicks = function(splitNumber) {};
	/**
	* @see `Ordinal['_ordinalNumbersByTick']`
	*/
	OrdinalScale$1.prototype.setSortInfo = function(info) {
		if (info == null) {
			this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
			return;
		}
		var infoOrdinalNumbers = info.ordinalNumbers;
		var ordinalsByTick = this._ordinalNumbersByTick = [];
		var ticksByOrdinal = this._ticksByOrdinalNumber = [];
		var tickNum = 0;
		var allCategoryLen = this._ordinalMeta.categories.length;
		for (var len$1 = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len$1; ++tickNum) {
			var ordinalNumber = infoOrdinalNumbers[tickNum];
			ordinalsByTick[tickNum] = ordinalNumber;
			ticksByOrdinal[ordinalNumber] = tickNum;
		}
		var unusedOrdinal = 0;
		for (; tickNum < allCategoryLen; ++tickNum) {
			while (ticksByOrdinal[unusedOrdinal] != null) unusedOrdinal++;
			ordinalsByTick.push(unusedOrdinal);
			ticksByOrdinal[unusedOrdinal] = tickNum;
		}
	};
	OrdinalScale$1.prototype._getTickNumber = function(ordinal) {
		var ticksByOrdinalNumber = this._ticksByOrdinalNumber;
		return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
	};
	/**
	* @usage
	* ```js
	* const ordinalNumber = ordinalScale.getRawOrdinalNumber(tickVal);
	*
	* // case0
	* const rawOrdinalValue = axisModel.getCategories()[ordinalNumber];
	* // case1
	* const rawOrdinalValue = this._ordinalMeta.categories[ordinalNumber];
	* // case2
	* const coord = axis.dataToCoord(ordinalNumber);
	* ```
	*
	* @param {OrdinalNumber} tickNumber index of display
	*/
	OrdinalScale$1.prototype.getRawOrdinalNumber = function(tickNumber) {
		var ordinalNumbersByTick = this._ordinalNumbersByTick;
		return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
	};
	/**
	* Get item on tick
	*/
	OrdinalScale$1.prototype.getLabel = function(tick) {
		if (!this.isBlank()) {
			var ordinalNumber = this.getRawOrdinalNumber(tick.value);
			var cateogry = this._ordinalMeta.categories[ordinalNumber];
			return cateogry == null ? "" : cateogry + "";
		}
	};
	OrdinalScale$1.prototype.count = function() {
		return this._extent[1] - this._extent[0] + 1;
	};
	/**
	* @override
	* If value is in extent range
	*/
	OrdinalScale$1.prototype.isInExtentRange = function(value) {
		value = this._getTickNumber(value);
		return this._extent[0] <= value && this._extent[1] >= value;
	};
	OrdinalScale$1.prototype.getOrdinalMeta = function() {
		return this._ordinalMeta;
	};
	OrdinalScale$1.prototype.calcNiceTicks = function() {};
	OrdinalScale$1.prototype.calcNiceExtent = function() {};
	OrdinalScale$1.type = "ordinal";
	return OrdinalScale$1;
}(Scale_default);
Scale_default.registerClass(OrdinalScale);
var Ordinal_default = OrdinalScale;

//#endregion
//#region node_modules/echarts/lib/scale/Interval.js
var roundNumber = round;
var IntervalScale = function(_super) {
	__extends(IntervalScale$1, _super);
	function IntervalScale$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "interval";
		_this._interval = 0;
		_this._intervalPrecision = 2;
		return _this;
	}
	IntervalScale$1.prototype.parse = function(val) {
		return val == null || val === "" ? NaN : Number(val);
	};
	IntervalScale$1.prototype.contain = function(val) {
		return contain$1(val, this._extent);
	};
	IntervalScale$1.prototype.normalize = function(val) {
		return this._calculator.normalize(val, this._extent);
	};
	IntervalScale$1.prototype.scale = function(val) {
		return this._calculator.scale(val, this._extent);
	};
	IntervalScale$1.prototype.getInterval = function() {
		return this._interval;
	};
	IntervalScale$1.prototype.setInterval = function(interval) {
		this._interval = interval;
		this._niceExtent = this._extent.slice();
		this._intervalPrecision = getIntervalPrecision(interval);
	};
	/**
	* @override
	*/
	IntervalScale$1.prototype.getTicks = function(opt) {
		opt = opt || {};
		var interval = this._interval;
		var extent = this._extent;
		var niceTickExtent = this._niceExtent;
		var intervalPrecision = this._intervalPrecision;
		var scaleBreakHelper = getScaleBreakHelper();
		var ticks = [];
		if (!interval) return ticks;
		if (opt.breakTicks === "only_break" && scaleBreakHelper) {
			scaleBreakHelper.addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);
			return ticks;
		}
		var safeLimit = 1e4;
		if (extent[0] < niceTickExtent[0]) if (opt.expandToNicedExtent) ticks.push({ value: roundNumber(niceTickExtent[0] - interval, intervalPrecision) });
		else ticks.push({ value: extent[0] });
		var estimateNiceMultiple = function(tickVal, targetTick) {
			return Math.round((targetTick - tickVal) / interval);
		};
		var tick = niceTickExtent[0];
		while (tick <= niceTickExtent[1]) {
			ticks.push({ value: tick });
			tick = roundNumber(tick + interval, intervalPrecision);
			if (this._brkCtx) {
				var moreMultiple = this._brkCtx.calcNiceTickMultiple(tick, estimateNiceMultiple);
				if (moreMultiple >= 0) tick = roundNumber(tick + moreMultiple * interval, intervalPrecision);
			}
			if (ticks.length > 0 && tick === ticks[ticks.length - 1].value) break;
			if (ticks.length > safeLimit) return [];
		}
		var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
		if (extent[1] > lastNiceTick) if (opt.expandToNicedExtent) ticks.push({ value: roundNumber(lastNiceTick + interval, intervalPrecision) });
		else ticks.push({ value: extent[1] });
		if (scaleBreakHelper) scaleBreakHelper.pruneTicksByBreak(opt.pruneByBreak, ticks, this._brkCtx.breaks, function(item) {
			return item.value;
		}, this._interval, this._extent);
		if (opt.breakTicks !== "none" && scaleBreakHelper) scaleBreakHelper.addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);
		return ticks;
	};
	IntervalScale$1.prototype.getMinorTicks = function(splitNumber) {
		var ticks = this.getTicks({ expandToNicedExtent: true });
		var minorTicks = [];
		var extent = this.getExtent();
		for (var i$1 = 1; i$1 < ticks.length; i$1++) {
			var nextTick = ticks[i$1];
			var prevTick = ticks[i$1 - 1];
			if (prevTick["break"] || nextTick["break"]) continue;
			var count$1 = 0;
			var minorTicksGroup = [];
			var minorInterval = (nextTick.value - prevTick.value) / splitNumber;
			var minorIntervalPrecision = getIntervalPrecision(minorInterval);
			while (count$1 < splitNumber - 1) {
				var minorTick = roundNumber(prevTick.value + (count$1 + 1) * minorInterval, minorIntervalPrecision);
				if (minorTick > extent[0] && minorTick < extent[1]) minorTicksGroup.push(minorTick);
				count$1++;
			}
			var scaleBreakHelper = getScaleBreakHelper();
			scaleBreakHelper && scaleBreakHelper.pruneTicksByBreak("auto", minorTicksGroup, this._getNonTransBreaks(), function(value) {
				return value;
			}, this._interval, extent);
			minorTicks.push(minorTicksGroup);
		}
		return minorTicks;
	};
	IntervalScale$1.prototype._getNonTransBreaks = function() {
		return this._brkCtx ? this._brkCtx.breaks : [];
	};
	/**
	* @param opt.precision If 'auto', use nice presision.
	* @param opt.pad returns 1.50 but not 1.5 if precision is 2.
	*/
	IntervalScale$1.prototype.getLabel = function(data, opt) {
		if (data == null) return "";
		var precision = opt && opt.precision;
		if (precision == null) precision = getPrecision(data.value) || 0;
		else if (precision === "auto") precision = this._intervalPrecision;
		var dataNum = roundNumber(data.value, precision, true);
		return addCommas(dataNum);
	};
	/**
	* FIXME: refactor - disallow override, use composition instead.
	*
	* The override of `calcNiceTicks` should ensure these members are provided:
	*  this._intervalPrecision
	*  this._interval
	*
	* @param splitNumber By default `5`.
	*/
	IntervalScale$1.prototype.calcNiceTicks = function(splitNumber, minInterval, maxInterval) {
		splitNumber = splitNumber || 5;
		var extent = this._extent.slice();
		var span = this._getExtentSpanWithBreaks();
		if (!isFinite(span)) return;
		if (span < 0) {
			span = -span;
			extent.reverse();
			this._innerSetExtent(extent[0], extent[1]);
			extent = this._extent.slice();
		}
		var result = intervalScaleNiceTicks(extent, span, splitNumber, minInterval, maxInterval);
		this._intervalPrecision = result.intervalPrecision;
		this._interval = result.interval;
		this._niceExtent = result.niceTickExtent;
	};
	IntervalScale$1.prototype.calcNiceExtent = function(opt) {
		var extent = this._extent.slice();
		if (extent[0] === extent[1]) if (extent[0] !== 0) {
			var expandSize = Math.abs(extent[0]);
			if (!opt.fixMax) {
				extent[1] += expandSize / 2;
				extent[0] -= expandSize / 2;
			} else extent[0] -= expandSize / 2;
		} else extent[1] = 1;
		var span = extent[1] - extent[0];
		if (!isFinite(span)) {
			extent[0] = 0;
			extent[1] = 1;
		}
		this._innerSetExtent(extent[0], extent[1]);
		extent = this._extent.slice();
		this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
		var interval = this._interval;
		var intervalPrecition = this._intervalPrecision;
		if (!opt.fixMin) extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval, intervalPrecition);
		if (!opt.fixMax) extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval, intervalPrecition);
		this._innerSetExtent(extent[0], extent[1]);
	};
	IntervalScale$1.prototype.setNiceExtent = function(min$2, max$2) {
		this._niceExtent = [min$2, max$2];
	};
	IntervalScale$1.type = "interval";
	return IntervalScale$1;
}(Scale_default);
Scale_default.registerClass(IntervalScale);
var Interval_default = IntervalScale;

//#endregion
//#region node_modules/echarts/lib/util/vendor.js
var supportFloat32Array = typeof Float32Array !== "undefined";
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
	if (isArray(arg)) return supportFloat32Array ? new Float32Array(arg) : arg;
	return new Float32ArrayCtor(arg);
}

//#endregion
//#region node_modules/echarts/lib/layout/barGrid.js
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId$1(seriesModel) {
	return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
}
function getAxisKey$1(axis) {
	return axis.dim + axis.index;
}
/**
* @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
*/
function getLayoutOnAxis(opt) {
	var params = [];
	var baseAxis = opt.axis;
	var axisKey = "axis0";
	if (baseAxis.type !== "category") return;
	var bandWidth = baseAxis.getBandWidth();
	for (var i$1 = 0; i$1 < opt.count || 0; i$1++) params.push(defaults({
		bandWidth,
		axisKey,
		stackId: STACK_PREFIX + i$1
	}, opt));
	var widthAndOffsets = doCalBarWidthAndOffset(params);
	var result = [];
	for (var i$1 = 0; i$1 < opt.count; i$1++) {
		var item = widthAndOffsets[axisKey][STACK_PREFIX + i$1];
		item.offsetCenter = item.offset + item.width / 2;
		result.push(item);
	}
	return result;
}
function prepareLayoutBarSeries(seriesType$1, ecModel) {
	var seriesModels = [];
	ecModel.eachSeriesByType(seriesType$1, function(seriesModel) {
		if (isOnCartesian(seriesModel)) seriesModels.push(seriesModel);
	});
	return seriesModels;
}
/**
* Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent
* values.
* This works for time axes, value axes, and log axes.
* For a single time axis, return value is in the form like
* {'x_0': [1000000]}.
* The value of 1000000 is in milliseconds.
*/
function getValueAxesMinGaps(barSeries) {
	/**
	* Map from axis.index to values.
	* For a single time axis, axisValues is in the form like
	* {'x_0': [1495555200000, 1495641600000, 1495728000000]}.
	* Items in axisValues[x], e.g. 1495555200000, are time values of all
	* series.
	*/
	var axisValues = {};
	each(barSeries, function(seriesModel) {
		var baseAxis = seriesModel.coordinateSystem.getBaseAxis();
		if (baseAxis.type !== "time" && baseAxis.type !== "value") return;
		var data = seriesModel.getData();
		var key$2 = baseAxis.dim + "_" + baseAxis.index;
		var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
		var store = data.getStore();
		for (var i$1 = 0, cnt = store.count(); i$1 < cnt; ++i$1) {
			var value = store.get(dimIdx, i$1);
			if (!axisValues[key$2]) axisValues[key$2] = [value];
			else axisValues[key$2].push(value);
		}
	});
	var axisMinGaps = {};
	for (var key$1 in axisValues) if (axisValues.hasOwnProperty(key$1)) {
		var valuesInAxis = axisValues[key$1];
		if (valuesInAxis) {
			valuesInAxis.sort(function(a, b) {
				return a - b;
			});
			var min$2 = null;
			for (var j = 1; j < valuesInAxis.length; ++j) {
				var delta = valuesInAxis[j] - valuesInAxis[j - 1];
				if (delta > 0) min$2 = min$2 === null ? delta : Math.min(min$2, delta);
			}
			axisMinGaps[key$1] = min$2;
		}
	}
	return axisMinGaps;
}
function makeColumnLayout(barSeries) {
	var axisMinGaps = getValueAxesMinGaps(barSeries);
	var seriesInfoList = [];
	each(barSeries, function(seriesModel) {
		var baseAxis = seriesModel.coordinateSystem.getBaseAxis();
		var axisExtent = baseAxis.getExtent();
		var bandWidth;
		if (baseAxis.type === "category") bandWidth = baseAxis.getBandWidth();
		else if (baseAxis.type === "value" || baseAxis.type === "time") {
			var minGap = axisMinGaps[baseAxis.dim + "_" + baseAxis.index];
			var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
			var scale$3 = baseAxis.scale.getExtent();
			var scaleSpan = Math.abs(scale$3[1] - scale$3[0]);
			bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
		} else {
			var data = seriesModel.getData();
			bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
		}
		var barWidth = parsePercent$1(seriesModel.get("barWidth"), bandWidth);
		var barMaxWidth = parsePercent$1(seriesModel.get("barMaxWidth"), bandWidth);
		var barMinWidth = parsePercent$1(seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? .5 : 1), bandWidth);
		var barGap = seriesModel.get("barGap");
		var barCategoryGap = seriesModel.get("barCategoryGap");
		var defaultBarGap = seriesModel.get("defaultBarGap");
		seriesInfoList.push({
			bandWidth,
			barWidth,
			barMaxWidth,
			barMinWidth,
			barGap,
			barCategoryGap,
			defaultBarGap,
			axisKey: getAxisKey$1(baseAxis),
			stackId: getSeriesStackId$1(seriesModel)
		});
	});
	return doCalBarWidthAndOffset(seriesInfoList);
}
function doCalBarWidthAndOffset(seriesInfoList) {
	var columnsMap = {};
	each(seriesInfoList, function(seriesInfo, idx) {
		var axisKey = seriesInfo.axisKey;
		var bandWidth = seriesInfo.bandWidth;
		var columnsOnAxis = columnsMap[axisKey] || {
			bandWidth,
			remainedWidth: bandWidth,
			autoWidthCount: 0,
			categoryGap: null,
			gap: seriesInfo.defaultBarGap || 0,
			stacks: {}
		};
		var stacks = columnsOnAxis.stacks;
		columnsMap[axisKey] = columnsOnAxis;
		var stackId = seriesInfo.stackId;
		if (!stacks[stackId]) columnsOnAxis.autoWidthCount++;
		stacks[stackId] = stacks[stackId] || {
			width: 0,
			maxWidth: 0
		};
		var barWidth = seriesInfo.barWidth;
		if (barWidth && !stacks[stackId].width) {
			stacks[stackId].width = barWidth;
			barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
			columnsOnAxis.remainedWidth -= barWidth;
		}
		var barMaxWidth = seriesInfo.barMaxWidth;
		barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
		var barMinWidth = seriesInfo.barMinWidth;
		barMinWidth && (stacks[stackId].minWidth = barMinWidth);
		var barGap = seriesInfo.barGap;
		barGap != null && (columnsOnAxis.gap = barGap);
		var barCategoryGap = seriesInfo.barCategoryGap;
		barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
	});
	var result = {};
	each(columnsMap, function(columnsOnAxis, coordSysName) {
		result[coordSysName] = {};
		var stacks = columnsOnAxis.stacks;
		var bandWidth = columnsOnAxis.bandWidth;
		var categoryGapPercent = columnsOnAxis.categoryGap;
		if (categoryGapPercent == null) {
			var columnCount = keys(stacks).length;
			categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
		}
		var categoryGap = parsePercent$1(categoryGapPercent, bandWidth);
		var barGapPercent = parsePercent$1(columnsOnAxis.gap, 1);
		var remainedWidth = columnsOnAxis.remainedWidth;
		var autoWidthCount = columnsOnAxis.autoWidthCount;
		var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
		autoWidth = Math.max(autoWidth, 0);
		each(stacks, function(column) {
			var maxWidth = column.maxWidth;
			var minWidth = column.minWidth;
			if (!column.width) {
				var finalWidth = autoWidth;
				if (maxWidth && maxWidth < finalWidth) finalWidth = Math.min(maxWidth, remainedWidth);
				if (minWidth && minWidth > finalWidth) finalWidth = minWidth;
				if (finalWidth !== autoWidth) {
					column.width = finalWidth;
					remainedWidth -= finalWidth + barGapPercent * finalWidth;
					autoWidthCount--;
				}
			} else {
				var finalWidth = column.width;
				if (maxWidth) finalWidth = Math.min(finalWidth, maxWidth);
				if (minWidth) finalWidth = Math.max(finalWidth, minWidth);
				column.width = finalWidth;
				remainedWidth -= finalWidth + barGapPercent * finalWidth;
				autoWidthCount--;
			}
		});
		autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
		autoWidth = Math.max(autoWidth, 0);
		var widthSum = 0;
		var lastColumn;
		each(stacks, function(column, idx) {
			if (!column.width) column.width = autoWidth;
			lastColumn = column;
			widthSum += column.width * (1 + barGapPercent);
		});
		if (lastColumn) widthSum -= lastColumn.width * barGapPercent;
		var offset = -widthSum / 2;
		each(stacks, function(column, stackId) {
			result[coordSysName][stackId] = result[coordSysName][stackId] || {
				bandWidth,
				offset,
				width: column.width
			};
			offset += column.width * (1 + barGapPercent);
		});
	});
	return result;
}
function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
	if (barWidthAndOffset && axis) {
		var result = barWidthAndOffset[getAxisKey$1(axis)];
		if (result != null && seriesModel != null) return result[getSeriesStackId$1(seriesModel)];
		return result;
	}
}
function layout$1(seriesType$1, ecModel) {
	var seriesModels = prepareLayoutBarSeries(seriesType$1, ecModel);
	var barWidthAndOffset = makeColumnLayout(seriesModels);
	each(seriesModels, function(seriesModel) {
		var data = seriesModel.getData();
		var baseAxis = seriesModel.coordinateSystem.getBaseAxis();
		var stackId = getSeriesStackId$1(seriesModel);
		var columnLayoutInfo = barWidthAndOffset[getAxisKey$1(baseAxis)][stackId];
		var columnOffset = columnLayoutInfo.offset;
		var columnWidth = columnLayoutInfo.width;
		data.setLayout({
			bandWidth: columnLayoutInfo.bandWidth,
			offset: columnOffset,
			size: columnWidth
		});
	});
}
function createProgressiveLayout(seriesType$1) {
	return {
		seriesType: seriesType$1,
		plan: createRenderPlanner(),
		reset: function(seriesModel) {
			if (!isOnCartesian(seriesModel)) return;
			var data = seriesModel.getData();
			var cartesian = seriesModel.coordinateSystem;
			var baseAxis = cartesian.getBaseAxis();
			var valueAxis$1 = cartesian.getOtherAxis(baseAxis);
			var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis$1.dim));
			var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
			var drawBackground = seriesModel.get("showBackground", true);
			var valueDim = data.mapDimension(valueAxis$1.dim);
			var stackResultDim = data.getCalculationInfo("stackResultDimension");
			var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo("stackedOnSeries");
			var isValueAxisH = valueAxis$1.isHorizontal();
			var valueAxisStart = getValueAxisStart(baseAxis, valueAxis$1);
			var isLarge = isInLargeMode(seriesModel);
			var barMinHeight = seriesModel.get("barMinHeight") || 0;
			var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);
			var columnWidth = data.getLayout("size");
			var columnOffset = data.getLayout("offset");
			return { progress: function(params, data$1) {
				var count$1 = params.count;
				var largePoints = isLarge && createFloat32Array(count$1 * 3);
				var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count$1 * 3);
				var largeDataIndices = isLarge && createFloat32Array(count$1);
				var coordLayout = cartesian.master.getRect();
				var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
				var dataIndex;
				var store = data$1.getStore();
				var idxOffset = 0;
				while ((dataIndex = params.next()) != null) {
					var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
					var baseValue = store.get(baseDimIdx, dataIndex);
					var baseCoord = valueAxisStart;
					var stackStartValue = void 0;
					if (stacked) stackStartValue = +value - store.get(valueDimIdx, dataIndex);
					var x = void 0;
					var y = void 0;
					var width = void 0;
					var height = void 0;
					if (isValueAxisH) {
						var coord = cartesian.dataToPoint([value, baseValue]);
						if (stacked) {
							var startCoord = cartesian.dataToPoint([stackStartValue, baseValue]);
							baseCoord = startCoord[0];
						}
						x = baseCoord;
						y = coord[1] + columnOffset;
						width = coord[0] - baseCoord;
						height = columnWidth;
						if (Math.abs(width) < barMinHeight) width = (width < 0 ? -1 : 1) * barMinHeight;
					} else {
						var coord = cartesian.dataToPoint([baseValue, value]);
						if (stacked) {
							var startCoord = cartesian.dataToPoint([baseValue, stackStartValue]);
							baseCoord = startCoord[1];
						}
						x = coord[0] + columnOffset;
						y = baseCoord;
						width = columnWidth;
						height = coord[1] - baseCoord;
						if (Math.abs(height) < barMinHeight) height = (height <= 0 ? -1 : 1) * barMinHeight;
					}
					if (!isLarge) data$1.setItemLayout(dataIndex, {
						x,
						y,
						width,
						height
					});
					else {
						largePoints[idxOffset] = x;
						largePoints[idxOffset + 1] = y;
						largePoints[idxOffset + 2] = isValueAxisH ? width : height;
						if (largeBackgroundPoints) {
							largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;
							largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;
							largeBackgroundPoints[idxOffset + 2] = bgSize;
						}
						largeDataIndices[dataIndex] = dataIndex;
					}
					idxOffset += 3;
				}
				if (isLarge) data$1.setLayout({
					largePoints,
					largeDataIndices,
					largeBackgroundPoints,
					valueAxisHorizontal: isValueAxisH
				});
			} };
		}
	};
}
function isOnCartesian(seriesModel) {
	return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(seriesModel) {
	return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
}
function getValueAxisStart(baseAxis, valueAxis$1) {
	var startValue = valueAxis$1.model.get("startValue");
	if (!startValue) startValue = 0;
	return valueAxis$1.toGlobalCoord(valueAxis$1.dataToCoord(valueAxis$1.type === "log" ? startValue > 0 ? startValue : 1 : startValue));
}

//#endregion
//#region node_modules/echarts/lib/scale/Time.js
var bisect = function(a, x, lo, hi) {
	while (lo < hi) {
		var mid = lo + hi >>> 1;
		if (a[mid][1] < x) lo = mid + 1;
		else hi = mid;
	}
	return lo;
};
var TimeScale = function(_super) {
	__extends(TimeScale$1, _super);
	function TimeScale$1(settings) {
		var _this = _super.call(this, settings) || this;
		_this.type = "time";
		return _this;
	}
	/**
	* Get label is mainly for other components like dataZoom, tooltip.
	*/
	TimeScale$1.prototype.getLabel = function(tick) {
		var useUTC = this.getSetting("useUTC");
		return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
	};
	TimeScale$1.prototype.getFormattedLabel = function(tick, idx, labelFormatter) {
		var isUTC = this.getSetting("useUTC");
		return leveledFormat(tick, idx, labelFormatter, this.getSetting("locale"), isUTC);
	};
	/**
	* @override
	*/
	TimeScale$1.prototype.getTicks = function(opt) {
		opt = opt || {};
		var interval = this._interval;
		var extent = this._extent;
		var scaleBreakHelper = getScaleBreakHelper();
		var ticks = [];
		if (!interval) return ticks;
		var useUTC = this.getSetting("useUTC");
		if (scaleBreakHelper && opt.breakTicks === "only_break") {
			getScaleBreakHelper().addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);
			return ticks;
		}
		var extent0Unit = getUnitFromValue(extent[1], useUTC);
		ticks.push({
			value: extent[0],
			time: {
				level: 0,
				upperTimeUnit: extent0Unit,
				lowerTimeUnit: extent0Unit
			}
		});
		var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent, this._getExtentSpanWithBreaks(), this._brkCtx);
		ticks = ticks.concat(innerTicks);
		var extent1Unit = getUnitFromValue(extent[1], useUTC);
		ticks.push({
			value: extent[1],
			time: {
				level: 0,
				upperTimeUnit: extent1Unit,
				lowerTimeUnit: extent1Unit
			}
		});
		var isUTC = this.getSetting("useUTC");
		var upperUnitIndex = primaryTimeUnits.length - 1;
		var maxLevel = 0;
		each(ticks, function(tick) {
			upperUnitIndex = Math.min(upperUnitIndex, indexOf(primaryTimeUnits, tick.time.upperTimeUnit));
			maxLevel = Math.max(maxLevel, tick.time.level);
		});
		if (scaleBreakHelper) getScaleBreakHelper().pruneTicksByBreak(opt.pruneByBreak, ticks, this._brkCtx.breaks, function(item) {
			return item.value;
		}, this._approxInterval, this._extent);
		if (scaleBreakHelper && opt.breakTicks !== "none") getScaleBreakHelper().addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent, function(trimmedBrk) {
			var lowerBrkUnitIndex = Math.max(indexOf(primaryTimeUnits, getUnitFromValue(trimmedBrk.vmin, isUTC)), indexOf(primaryTimeUnits, getUnitFromValue(trimmedBrk.vmax, isUTC)));
			var upperBrkUnitIndex = 0;
			for (var unitIdx = 0; unitIdx < primaryTimeUnits.length; unitIdx++) if (!isPrimaryUnitValueAndGreaterSame(primaryTimeUnits[unitIdx], trimmedBrk.vmin, trimmedBrk.vmax, isUTC)) {
				upperBrkUnitIndex = unitIdx;
				break;
			}
			var upperIdx = Math.min(upperBrkUnitIndex, upperUnitIndex);
			return {
				level: maxLevel,
				lowerTimeUnit: primaryTimeUnits[Math.max(upperIdx, lowerBrkUnitIndex)],
				upperTimeUnit: primaryTimeUnits[upperIdx]
			};
		});
		return ticks;
	};
	TimeScale$1.prototype.calcNiceExtent = function(opt) {
		var extent = this.getExtent();
		if (extent[0] === extent[1]) {
			extent[0] -= ONE_DAY;
			extent[1] += ONE_DAY;
		}
		if (extent[1] === -Infinity && extent[0] === Infinity) {
			var d = /* @__PURE__ */ new Date();
			extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
			extent[0] = extent[1] - ONE_DAY;
		}
		this._innerSetExtent(extent[0], extent[1]);
		this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
	};
	TimeScale$1.prototype.calcNiceTicks = function(approxTickNum, minInterval, maxInterval) {
		approxTickNum = approxTickNum || 10;
		this._approxInterval = this._getExtentSpanWithBreaks() / approxTickNum;
		if (minInterval != null && this._approxInterval < minInterval) this._approxInterval = minInterval;
		if (maxInterval != null && this._approxInterval > maxInterval) this._approxInterval = maxInterval;
		var scaleIntervalsLen = scaleIntervals.length;
		var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
		this._interval = scaleIntervals[idx][1];
		this._intervalPrecision = getIntervalPrecision(this._interval);
		this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
	};
	TimeScale$1.prototype.parse = function(val) {
		return isNumber(val) ? val : +parseDate(val);
	};
	TimeScale$1.prototype.contain = function(val) {
		return contain$1(val, this._extent);
	};
	TimeScale$1.prototype.normalize = function(val) {
		return this._calculator.normalize(val, this._extent);
	};
	TimeScale$1.prototype.scale = function(val) {
		return this._calculator.scale(val, this._extent);
	};
	TimeScale$1.type = "time";
	return TimeScale$1;
}(Interval_default);
/**
* This implementation was originally copied from "d3.js"
* <https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/time/scale.js>
* with some modifications made for this program.
* See the license statement at the head of this file.
*/
var scaleIntervals = [
	["second", ONE_SECOND],
	["minute", ONE_MINUTE],
	["hour", ONE_HOUR],
	["quarter-day", ONE_HOUR * 6],
	["half-day", ONE_HOUR * 12],
	["day", ONE_DAY * 1.2],
	["half-week", ONE_DAY * 3.5],
	["week", ONE_DAY * 7],
	["month", ONE_DAY * 31],
	["quarter", ONE_DAY * 95],
	["half-year", ONE_YEAR / 2],
	["year", ONE_YEAR]
];
function isPrimaryUnitValueAndGreaterSame(unit, valueA, valueB, isUTC) {
	return roundTime(new Date(valueA), unit, isUTC).getTime() === roundTime(new Date(valueB), unit, isUTC).getTime();
}
function getDateInterval(approxInterval, daysInMonth) {
	approxInterval /= ONE_DAY;
	return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
}
function getMonthInterval(approxInterval) {
	var APPROX_ONE_MONTH = 30 * ONE_DAY;
	approxInterval /= APPROX_ONE_MONTH;
	return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
}
function getHourInterval(approxInterval) {
	approxInterval /= ONE_HOUR;
	return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
	approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
	return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
}
function getMillisecondsInterval(approxInterval) {
	return nice(approxInterval, true);
}
function getFirstTimestampOfUnit(timestamp, unitName, isUTC) {
	var upperUnitIdx = Math.max(0, indexOf(primaryTimeUnits, unitName) - 1);
	return roundTime(new Date(timestamp), primaryTimeUnits[upperUnitIdx], isUTC).getTime();
}
function createEstimateNiceMultiple(setMethodName, dateMethodInterval) {
	var tmpDate = /* @__PURE__ */ new Date(0);
	tmpDate[setMethodName](1);
	var tmpTime = tmpDate.getTime();
	tmpDate[setMethodName](1 + dateMethodInterval);
	var approxTimeInterval = tmpDate.getTime() - tmpTime;
	return function(tickVal, targetValue) {
		return Math.max(0, Math.round((targetValue - tickVal) / approxTimeInterval));
	};
}
function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent, extentSpanWithBreaks, brkCtx) {
	var safeLimit = 1e4;
	var unitNames = timeUnits;
	var iter = 0;
	function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out$1) {
		var estimateNiceMultiple = createEstimateNiceMultiple(setMethodName, interval);
		var dateTime = minTimestamp;
		var date = new Date(dateTime);
		while (dateTime < maxTimestamp && dateTime <= extent[1]) {
			out$1.push({ value: dateTime });
			if (iter++ > safeLimit) {
				warn("Exceed safe limit in time scale.");
				break;
			}
			date[setMethodName](date[getMethodName]() + interval);
			dateTime = date.getTime();
			if (brkCtx) {
				var moreMultiple = brkCtx.calcNiceTickMultiple(dateTime, estimateNiceMultiple);
				if (moreMultiple > 0) {
					date[setMethodName](date[getMethodName]() + moreMultiple * interval);
					dateTime = date.getTime();
				}
			}
		}
		out$1.push({
			value: dateTime,
			notAdd: true
		});
	}
	function addLevelTicks(unitName, lastLevelTicks, levelTicks$1) {
		var newAddedTicks = [];
		var isFirstLevel = !lastLevelTicks.length;
		if (isPrimaryUnitValueAndGreaterSame(getPrimaryTimeUnit(unitName), extent[0], extent[1], isUTC)) return;
		if (isFirstLevel) lastLevelTicks = [{ value: getFirstTimestampOfUnit(extent[0], unitName, isUTC) }, { value: extent[1] }];
		for (var i$2 = 0; i$2 < lastLevelTicks.length - 1; i$2++) {
			var startTick = lastLevelTicks[i$2].value;
			var endTick = lastLevelTicks[i$2 + 1].value;
			if (startTick === endTick) continue;
			var interval = void 0;
			var getterName = void 0;
			var setterName = void 0;
			var isDate = false;
			switch (unitName) {
				case "year":
					interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
					getterName = fullYearGetterName(isUTC);
					setterName = fullYearSetterName(isUTC);
					break;
				case "half-year":
				case "quarter":
				case "month":
					interval = getMonthInterval(approxInterval);
					getterName = monthGetterName(isUTC);
					setterName = monthSetterName(isUTC);
					break;
				case "week":
				case "half-week":
				case "day":
					interval = getDateInterval(approxInterval, 31);
					getterName = dateGetterName(isUTC);
					setterName = dateSetterName(isUTC);
					isDate = true;
					break;
				case "half-day":
				case "quarter-day":
				case "hour":
					interval = getHourInterval(approxInterval);
					getterName = hoursGetterName(isUTC);
					setterName = hoursSetterName(isUTC);
					break;
				case "minute":
					interval = getMinutesAndSecondsInterval(approxInterval, true);
					getterName = minutesGetterName(isUTC);
					setterName = minutesSetterName(isUTC);
					break;
				case "second":
					interval = getMinutesAndSecondsInterval(approxInterval, false);
					getterName = secondsGetterName(isUTC);
					setterName = secondsSetterName(isUTC);
					break;
				case "millisecond":
					interval = getMillisecondsInterval(approxInterval);
					getterName = millisecondsGetterName(isUTC);
					setterName = millisecondsSetterName(isUTC);
					break;
			}
			if (endTick >= extent[0] && startTick <= extent[1]) addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);
			if (unitName === "year" && levelTicks$1.length > 1 && i$2 === 0) levelTicks$1.unshift({ value: levelTicks$1[0].value - interval });
		}
		for (var i$2 = 0; i$2 < newAddedTicks.length; i$2++) levelTicks$1.push(newAddedTicks[i$2]);
	}
	var levelsTicks = [];
	var currentLevelTicks = [];
	var tickCount = 0;
	var lastLevelTickCount = 0;
	for (var i$1 = 0; i$1 < unitNames.length; ++i$1) {
		var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i$1]);
		if (!isPrimaryTimeUnit(unitNames[i$1])) continue;
		addLevelTicks(unitNames[i$1], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
		if (primaryTimeUnit !== (unitNames[i$1 + 1] ? getPrimaryTimeUnit(unitNames[i$1 + 1]) : null)) {
			if (currentLevelTicks.length) {
				lastLevelTickCount = tickCount;
				currentLevelTicks.sort(function(a, b) {
					return a.value - b.value;
				});
				var levelTicksRemoveDuplicated = [];
				for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
					var tickValue = currentLevelTicks[i_1].value;
					if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
						levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
						if (tickValue >= extent[0] && tickValue <= extent[1]) tickCount++;
					}
				}
				var targetTickNum = extentSpanWithBreaks / approxInterval;
				if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) break;
				levelsTicks.push(levelTicksRemoveDuplicated);
				if (tickCount > targetTickNum || bottomUnitName === unitNames[i$1]) break;
			}
			currentLevelTicks = [];
		}
	}
	var levelsTicksInExtent = filter(map(levelsTicks, function(levelTicks$1) {
		return filter(levelTicks$1, function(tick) {
			return tick.value >= extent[0] && tick.value <= extent[1] && !tick.notAdd;
		});
	}), function(levelTicks$1) {
		return levelTicks$1.length > 0;
	});
	var ticks = [];
	var maxLevel = levelsTicksInExtent.length - 1;
	for (var i$1 = 0; i$1 < levelsTicksInExtent.length; ++i$1) {
		var levelTicks = levelsTicksInExtent[i$1];
		for (var k$1 = 0; k$1 < levelTicks.length; ++k$1) {
			var unit = getUnitFromValue(levelTicks[k$1].value, isUTC);
			ticks.push({
				value: levelTicks[k$1].value,
				time: {
					level: maxLevel - i$1,
					upperTimeUnit: unit,
					lowerTimeUnit: unit
				}
			});
		}
	}
	ticks.sort(function(a, b) {
		return a.value - b.value;
	});
	var result = [];
	for (var i$1 = 0; i$1 < ticks.length; ++i$1) if (i$1 === 0 || ticks[i$1].value !== ticks[i$1 - 1].value) result.push(ticks[i$1]);
	return result;
}
Scale_default.registerClass(TimeScale);
var Time_default = TimeScale;

//#endregion
//#region node_modules/echarts/lib/scale/Log.js
var fixRound = round;
var mathFloor$1 = Math.floor;
var mathCeil$1 = Math.ceil;
var mathPow$1 = Math.pow;
var mathLog = Math.log;
var LogScale = function(_super) {
	__extends(LogScale$1, _super);
	function LogScale$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "log";
		_this.base = 10;
		_this._originalScale = new Interval_default();
		return _this;
	}
	/**
	* @param Whether expand the ticks to niced extent.
	*/
	LogScale$1.prototype.getTicks = function(opt) {
		opt = opt || {};
		var extent = this._extent.slice();
		var originalExtent = this._originalScale.getExtent();
		var ticks = _super.prototype.getTicks.call(this, opt);
		var base$1 = this.base;
		var originalBreaks = this._originalScale._innerGetBreaks();
		var scaleBreakHelper = getScaleBreakHelper();
		return map(ticks, function(tick) {
			var val = tick.value;
			var roundingCriterion = null;
			var powVal = mathPow$1(base$1, val);
			if (val === extent[0] && this._fixMin) roundingCriterion = originalExtent[0];
			else if (val === extent[1] && this._fixMax) roundingCriterion = originalExtent[1];
			var vBreak;
			if (scaleBreakHelper) {
				var transformed = scaleBreakHelper.getTicksLogTransformBreak(tick, base$1, originalBreaks, fixRoundingError);
				vBreak = transformed.vBreak;
				if (roundingCriterion == null) roundingCriterion = transformed.brkRoundingCriterion;
			}
			if (roundingCriterion != null) powVal = fixRoundingError(powVal, roundingCriterion);
			return {
				value: powVal,
				"break": vBreak
			};
		}, this);
	};
	LogScale$1.prototype._getNonTransBreaks = function() {
		return this._originalScale._innerGetBreaks();
	};
	LogScale$1.prototype.setExtent = function(start$1, end$1) {
		this._originalScale.setExtent(start$1, end$1);
		var loggedExtent = logTransform(this.base, [start$1, end$1]);
		_super.prototype.setExtent.call(this, loggedExtent[0], loggedExtent[1]);
	};
	/**
	* @return {number} end
	*/
	LogScale$1.prototype.getExtent = function() {
		var base$1 = this.base;
		var extent = _super.prototype.getExtent.call(this);
		extent[0] = mathPow$1(base$1, extent[0]);
		extent[1] = mathPow$1(base$1, extent[1]);
		var originalExtent = this._originalScale.getExtent();
		this._fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
		this._fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
		return extent;
	};
	LogScale$1.prototype.unionExtentFromData = function(data, dim) {
		this._originalScale.unionExtentFromData(data, dim);
		var loggedOther = logTransform(this.base, data.getApproximateExtent(dim), true);
		this._innerUnionExtent(loggedOther);
	};
	/**
	* Update interval and extent of intervals for nice ticks
	* @param approxTickNum default 10 Given approx tick number
	*/
	LogScale$1.prototype.calcNiceTicks = function(approxTickNum) {
		approxTickNum = approxTickNum || 10;
		var extent = this._extent.slice();
		var span = this._getExtentSpanWithBreaks();
		if (!isFinite(span) || span <= 0) return;
		var interval = quantity(span);
		if (approxTickNum / span * interval <= .5) interval *= 10;
		while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) interval *= 10;
		var niceExtent = [fixRound(mathCeil$1(extent[0] / interval) * interval), fixRound(mathFloor$1(extent[1] / interval) * interval)];
		this._interval = interval;
		this._intervalPrecision = getIntervalPrecision(interval);
		this._niceExtent = niceExtent;
	};
	LogScale$1.prototype.calcNiceExtent = function(opt) {
		_super.prototype.calcNiceExtent.call(this, opt);
		this._fixMin = opt.fixMin;
		this._fixMax = opt.fixMax;
	};
	LogScale$1.prototype.contain = function(val) {
		val = mathLog(val) / mathLog(this.base);
		return _super.prototype.contain.call(this, val);
	};
	LogScale$1.prototype.normalize = function(val) {
		val = mathLog(val) / mathLog(this.base);
		return _super.prototype.normalize.call(this, val);
	};
	LogScale$1.prototype.scale = function(val) {
		val = _super.prototype.scale.call(this, val);
		return mathPow$1(this.base, val);
	};
	LogScale$1.prototype.setBreaksFromOption = function(breakOptionList) {
		var scaleBreakHelper = getScaleBreakHelper();
		if (!scaleBreakHelper) return;
		var _a$1 = scaleBreakHelper.logarithmicParseBreaksFromOption(breakOptionList, this.base, bind(this.parse, this)), parsedOriginal = _a$1.parsedOriginal, parsedLogged = _a$1.parsedLogged;
		this._originalScale._innerSetBreak(parsedOriginal);
		this._innerSetBreak(parsedLogged);
	};
	LogScale$1.type = "log";
	return LogScale$1;
}(Interval_default);
function fixRoundingError(val, originalVal) {
	return fixRound(val, getPrecision(originalVal));
}
Scale_default.registerClass(LogScale);
var Log_default = LogScale;

//#endregion
//#region node_modules/echarts/lib/coord/scaleRawExtentInfo.js
var ScaleRawExtentInfo = function() {
	function ScaleRawExtentInfo$1(scale$3, model, originalExtent) {
		this._prepareParams(scale$3, model, originalExtent);
	}
	/**
	* Parameters depending on outside (like model, user callback)
	* are prepared and fixed here.
	*/
	ScaleRawExtentInfo$1.prototype._prepareParams = function(scale$3, model, dataExtent) {
		if (dataExtent[1] < dataExtent[0]) dataExtent = [NaN, NaN];
		this._dataMin = dataExtent[0];
		this._dataMax = dataExtent[1];
		var isOrdinal = this._isOrdinal = scale$3.type === "ordinal";
		this._needCrossZero = scale$3.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
		var axisMinValue = model.get("min", true);
		if (axisMinValue == null) axisMinValue = model.get("startValue", true);
		var modelMinRaw = this._modelMinRaw = axisMinValue;
		if (isFunction(modelMinRaw)) this._modelMinNum = parseAxisModelMinMax(scale$3, modelMinRaw({
			min: dataExtent[0],
			max: dataExtent[1]
		}));
		else if (modelMinRaw !== "dataMin") this._modelMinNum = parseAxisModelMinMax(scale$3, modelMinRaw);
		var modelMaxRaw = this._modelMaxRaw = model.get("max", true);
		if (isFunction(modelMaxRaw)) this._modelMaxNum = parseAxisModelMinMax(scale$3, modelMaxRaw({
			min: dataExtent[0],
			max: dataExtent[1]
		}));
		else if (modelMaxRaw !== "dataMax") this._modelMaxNum = parseAxisModelMinMax(scale$3, modelMaxRaw);
		if (isOrdinal) this._axisDataLen = model.getCategories().length;
		else {
			var boundaryGap = model.get("boundaryGap");
			var boundaryGapArr = isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
			if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
				console.warn("Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., \"20%\". Currently, boundaryGap is set to be 0.");
				this._boundaryGapInner = [0, 0];
			} else this._boundaryGapInner = [parsePercent(boundaryGapArr[0], 1), parsePercent(boundaryGapArr[1], 1)];
		}
	};
	/**
	* Calculate extent by prepared parameters.
	* This method has no external dependency and can be called duplicatedly,
	* getting the same result.
	* If parameters changed, should call this method to recalcuate.
	*/
	ScaleRawExtentInfo$1.prototype.calculate = function() {
		var isOrdinal = this._isOrdinal;
		var dataMin = this._dataMin;
		var dataMax = this._dataMax;
		var axisDataLen = this._axisDataLen;
		var boundaryGapInner = this._boundaryGapInner;
		var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
		var min$2 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
		var max$2 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
		var minFixed = min$2 != null;
		var maxFixed = max$2 != null;
		if (min$2 == null) min$2 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
		if (max$2 == null) max$2 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
		(min$2 == null || !isFinite(min$2)) && (min$2 = NaN);
		(max$2 == null || !isFinite(max$2)) && (max$2 = NaN);
		var isBlank = eqNaN(min$2) || eqNaN(max$2) || isOrdinal && !axisDataLen;
		if (this._needCrossZero) {
			if (min$2 > 0 && max$2 > 0 && !minFixed) min$2 = 0;
			if (min$2 < 0 && max$2 < 0 && !maxFixed) max$2 = 0;
		}
		var determinedMin = this._determinedMin;
		var determinedMax = this._determinedMax;
		if (determinedMin != null) {
			min$2 = determinedMin;
			minFixed = true;
		}
		if (determinedMax != null) {
			max$2 = determinedMax;
			maxFixed = true;
		}
		return {
			min: min$2,
			max: max$2,
			minFixed,
			maxFixed,
			isBlank
		};
	};
	ScaleRawExtentInfo$1.prototype.modifyDataMinMax = function(minMaxName, val) {
		assert(!this.frozen);
		this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
	};
	ScaleRawExtentInfo$1.prototype.setDeterminedMinMax = function(minMaxName, val) {
		var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
		assert(!this.frozen && this[attr] == null);
		this[attr] = val;
	};
	ScaleRawExtentInfo$1.prototype.freeze = function() {
		this.frozen = true;
	};
	return ScaleRawExtentInfo$1;
}();
var DETERMINED_MIN_MAX_ATTR = {
	min: "_determinedMin",
	max: "_determinedMax"
};
var DATA_MIN_MAX_ATTR = {
	min: "_dataMin",
	max: "_dataMax"
};
/**
* Get scale min max and related info only depends on model settings.
* This method can be called after coordinate system created.
* For example, in data processing stage.
*
* Scale extent info probably be required multiple times during a workflow.
* For example:
* (1) `dataZoom` depends it to get the axis extent in "100%" state.
* (2) `processor/extentCalculator` depends it to make sure whether axis extent is specified.
* (3) `coordSys.update` use it to finally decide the scale extent.
* But the callback of `min`/`max` should not be called multiple times.
* The code below should not be implemented repeatedly either.
* So we cache the result in the scale instance, which will be recreated at the beginning
* of the workflow (because `scale` instance will be recreated each round of the workflow).
*/
function ensureScaleRawExtentInfo(scale$3, model, originalExtent) {
	var rawExtentInfo = scale$3.rawExtentInfo;
	if (rawExtentInfo) return rawExtentInfo;
	rawExtentInfo = new ScaleRawExtentInfo(scale$3, model, originalExtent);
	scale$3.rawExtentInfo = rawExtentInfo;
	return rawExtentInfo;
}
function parseAxisModelMinMax(scale$3, minMax) {
	return minMax == null ? null : eqNaN(minMax) ? NaN : scale$3.parse(minMax);
}

//#endregion
//#region node_modules/echarts/lib/coord/axisHelper.js
/**
* Get axis scale extent before niced.
* Item of returned array can only be number (including Infinity and NaN).
*
* Caution:
* Precondition of calling this method:
* The scale extent has been initialized using series data extent via
* `scale.setExtent` or `scale.unionExtentFromData`;
*/
function getScaleExtent(scale$3, model) {
	var scaleType = scale$3.type;
	var rawExtentResult = ensureScaleRawExtentInfo(scale$3, model, scale$3.getExtent()).calculate();
	scale$3.setBlank(rawExtentResult.isBlank);
	var min$2 = rawExtentResult.min;
	var max$2 = rawExtentResult.max;
	var ecModel = model.ecModel;
	if (ecModel && scaleType === "time") {
		var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
		var isBaseAxisAndHasBarSeries_1 = false;
		each(barSeriesModels, function(seriesModel) {
			isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
		});
		if (isBaseAxisAndHasBarSeries_1) {
			var barWidthAndOffset = makeColumnLayout(barSeriesModels);
			var adjustedScale = adjustScaleForOverflow(min$2, max$2, model, barWidthAndOffset);
			min$2 = adjustedScale.min;
			max$2 = adjustedScale.max;
		}
	}
	return {
		extent: [min$2, max$2],
		fixMin: rawExtentResult.minFixed,
		fixMax: rawExtentResult.maxFixed
	};
}
function adjustScaleForOverflow(min$2, max$2, model, barWidthAndOffset) {
	var axisExtent = model.axis.getExtent();
	var axisLength = Math.abs(axisExtent[1] - axisExtent[0]);
	var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
	if (barsOnCurrentAxis === void 0) return {
		min: min$2,
		max: max$2
	};
	var minOverflow = Infinity;
	each(barsOnCurrentAxis, function(item) {
		minOverflow = Math.min(item.offset, minOverflow);
	});
	var maxOverflow = -Infinity;
	each(barsOnCurrentAxis, function(item) {
		maxOverflow = Math.max(item.offset + item.width, maxOverflow);
	});
	minOverflow = Math.abs(minOverflow);
	maxOverflow = Math.abs(maxOverflow);
	var totalOverFlow = minOverflow + maxOverflow;
	var oldRange = max$2 - min$2;
	var overflowBuffer = oldRange / (1 - (minOverflow + maxOverflow) / axisLength) - oldRange;
	max$2 += overflowBuffer * (maxOverflow / totalOverFlow);
	min$2 -= overflowBuffer * (minOverflow / totalOverFlow);
	return {
		min: min$2,
		max: max$2
	};
}
function niceScaleExtent(scale$3, inModel) {
	var model = inModel;
	var extentInfo = getScaleExtent(scale$3, model);
	var extent = extentInfo.extent;
	var splitNumber = model.get("splitNumber");
	if (scale$3 instanceof Log_default) scale$3.base = model.get("logBase");
	var scaleType = scale$3.type;
	var interval = model.get("interval");
	var isIntervalOrTime = scaleType === "interval" || scaleType === "time";
	scale$3.setBreaksFromOption(retrieveAxisBreaksOption(model));
	scale$3.setExtent(extent[0], extent[1]);
	scale$3.calcNiceExtent({
		splitNumber,
		fixMin: extentInfo.fixMin,
		fixMax: extentInfo.fixMax,
		minInterval: isIntervalOrTime ? model.get("minInterval") : null,
		maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
	});
	if (interval != null) scale$3.setInterval && scale$3.setInterval(interval);
}
/**
* @param axisType Default retrieve from model.type
*/
function createScaleByModel$1(model, axisType) {
	axisType = axisType || model.get("type");
	if (axisType) switch (axisType) {
		case "category": return new Ordinal_default({
			ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
			extent: [Infinity, -Infinity]
		});
		case "time": return new Time_default({
			locale: model.ecModel.getLocaleModel(),
			useUTC: model.ecModel.get("useUTC")
		});
		default: return new ((Scale_default.getClass(axisType)) || Interval_default)();
	}
}
/**
* Check if the axis cross 0
*/
function ifAxisCrossZero(axis) {
	var dataExtent = axis.scale.getExtent();
	var min$2 = dataExtent[0];
	var max$2 = dataExtent[1];
	return !(min$2 > 0 && max$2 > 0 || min$2 < 0 && max$2 < 0);
}
/**
* @param axis
* @return Label formatter function.
*         param: {number} tickValue,
*         param: {number} idx, the index in all ticks.
*                         If category axis, this param is not required.
*         return: {string} label string.
*/
function makeLabelFormatter(axis) {
	var labelFormatter = axis.getLabelModel().get("formatter");
	if (axis.type === "time") {
		var parsed_1 = parseTimeAxisLabelFormatter(labelFormatter);
		return function(tick, idx) {
			return axis.scale.getFormattedLabel(tick, idx, parsed_1);
		};
	} else if (isString(labelFormatter)) return function(tick) {
		var label = axis.scale.getLabel(tick);
		return labelFormatter.replace("{value}", label != null ? label : "");
	};
	else if (isFunction(labelFormatter)) {
		if (axis.type === "category") return function(tick, idx) {
			return labelFormatter(getAxisRawValue(axis, tick), tick.value - axis.scale.getExtent()[0], null);
		};
		var scaleBreakHelper_1 = getScaleBreakHelper();
		return function(tick, idx) {
			var extra = null;
			if (scaleBreakHelper_1) extra = scaleBreakHelper_1.makeAxisLabelFormatterParamBreak(extra, tick["break"]);
			return labelFormatter(getAxisRawValue(axis, tick), idx, extra);
		};
	} else return function(tick) {
		return axis.scale.getLabel(tick);
	};
}
function getAxisRawValue(axis, tick) {
	return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
}
/**
* @param model axisLabelModel or axisTickModel
* @return {number|String} Can be null|'auto'|number|function
*/
function getOptionCategoryInterval(model) {
	var interval = model.get("interval");
	return interval == null ? "auto" : interval;
}
/**
* Set `categoryInterval` as 0 implicitly indicates that
* show all labels regardless of overlap.
* @param {Object} axis axisModel.axis
*/
function shouldShowAllLabels(axis) {
	return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(data, axisDim) {
	var dataDimMap = {};
	each(data.mapDimensionsAll(axisDim), function(dataDim) {
		dataDimMap[getStackedDimension(data, dataDim)] = true;
	});
	return keys(dataDimMap);
}
function unionAxisExtentFromData(dataExtent, data, axisDim) {
	if (data) each(getDataDimensionsOnAxis(data, axisDim), function(dim) {
		var seriesExtent = data.getApproximateExtent(dim);
		seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
		seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
	});
}
function isNameLocationCenter(nameLocation) {
	return nameLocation === "middle" || nameLocation === "center";
}
function shouldAxisShow(axisModel) {
	return axisModel.getShallow("show");
}
function retrieveAxisBreaksOption(model) {
	var option = model.get("breaks", true);
	if (option != null) {
		if (!getScaleBreakHelper()) {
			error("Must `import {AxisBreak} from \"echarts/features.js\"; use(AxisBreak);` first if using breaks option.");
			return;
		}
		if (!isSupportAxisBreak(model.axis)) {
			error("Axis '" + model.axis.dim + "'-'" + model.axis.type + "' does not support break.");
			return;
		}
		return option;
	}
}
function isSupportAxisBreak(axis) {
	return (axis.dim === "x" || axis.dim === "y" || axis.dim === "z" || axis.dim === "single") && axis.type !== "category";
}

//#endregion
//#region node_modules/echarts/lib/coord/axisModelCommonMixin.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var AxisModelCommonMixin = function() {
	function AxisModelCommonMixin$1() {}
	AxisModelCommonMixin$1.prototype.getNeedCrossZero = function() {
		return !this.option.scale;
	};
	/**
	* Should be implemented by each axis model if necessary.
	* @return coordinate system model
	*/
	AxisModelCommonMixin$1.prototype.getCoordSysModel = function() {};
	return AxisModelCommonMixin$1;
}();

//#endregion
//#region node_modules/echarts/lib/export/api/helper.js
var helper_exports = /* @__PURE__ */ __export({
	createDimensions: () => createDimensions,
	createList: () => createList$2,
	createScale: () => createScale,
	createSymbol: () => createSymbol,
	createTextStyle: () => createTextStyle$1,
	dataStack: () => dataStack,
	enableHoverEmphasis: () => enableHoverEmphasis,
	getECData: () => getECData,
	getLayoutRect: () => getLayoutRect,
	mixinAxisModelCommonMethods: () => mixinAxisModelCommonMethods
});
/**
* Create a multi dimension List structure from seriesModel.
*/
function createList$2(seriesModel) {
	return createSeriesData_default(null, seriesModel);
}
var dataStack = {
	isDimensionStacked,
	enableDataStack,
	getStackedDimension
};
/**
* Create scale
* @param {Array.<number>} dataExtent
* @param {Object|module:echarts/Model} option If `optoin.type`
*        is secified, it can only be `'value'` currently.
*/
function createScale(dataExtent, option) {
	var axisModel = option;
	if (!(option instanceof Model_default)) axisModel = new Model_default(option);
	var scale$3 = createScaleByModel$1(axisModel);
	scale$3.setExtent(dataExtent[0], dataExtent[1]);
	niceScaleExtent(scale$3, axisModel);
	return scale$3;
}
/**
* Mixin common methods to axis model,
*
* Include methods
* `getFormattedLabels() => Array.<string>`
* `getCategories() => Array.<string>`
* `getMin(origin: boolean) => number`
* `getMax(origin: boolean) => number`
* `getNeedCrossZero() => boolean`
*/
function mixinAxisModelCommonMethods(Model$1) {
	mixin(Model$1, AxisModelCommonMixin);
}
function createTextStyle$1(textStyleModel, opts) {
	opts = opts || {};
	return createTextStyle(textStyleModel, null, null, opts.state !== "normal");
}

//#endregion
//#region node_modules/zrender/lib/contain/polygon.js
var EPSILON = 1e-8;
function isAroundEqual(a, b) {
	return Math.abs(a - b) < EPSILON;
}
function contain(points$3, x, y) {
	var w = 0;
	var p = points$3[0];
	if (!p) return false;
	for (var i$1 = 1; i$1 < points$3.length; i$1++) {
		var p2 = points$3[i$1];
		w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
		p = p2;
	}
	var p0 = points$3[0];
	if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
	return w !== 0;
}

//#endregion
//#region node_modules/echarts/lib/coord/geo/Region.js
var TMP_TRANSFORM = [];
function transformPoints(points$3, transform) {
	for (var p = 0; p < points$3.length; p++) applyTransform(points$3[p], points$3[p], transform);
}
function updateBBoxFromPoints(points$3, min$2, max$2, projection) {
	for (var i$1 = 0; i$1 < points$3.length; i$1++) {
		var p = points$3[i$1];
		if (projection) p = projection.project(p);
		if (p && isFinite(p[0]) && isFinite(p[1])) {
			min(min$2, min$2, p);
			max(max$2, max$2, p);
		}
	}
}
function centroid$1(points$3) {
	var signedArea = 0;
	var cx = 0;
	var cy = 0;
	var len$1 = points$3.length;
	var x0 = points$3[len$1 - 1][0];
	var y0 = points$3[len$1 - 1][1];
	for (var i$1 = 0; i$1 < len$1; i$1++) {
		var x1 = points$3[i$1][0];
		var y1 = points$3[i$1][1];
		var a = x0 * y1 - x1 * y0;
		signedArea += a;
		cx += (x0 + x1) * a;
		cy += (y0 + y1) * a;
		x0 = x1;
		y0 = y1;
	}
	return signedArea ? [
		cx / signedArea / 3,
		cy / signedArea / 3,
		signedArea
	] : [points$3[0][0] || 0, points$3[0][1] || 0];
}
var Region = function() {
	function Region$1(name) {
		this.name = name;
	}
	Region$1.prototype.setCenter = function(center$2) {
		this._center = center$2;
	};
	/**
	* Get center point in data unit. That is,
	* for GeoJSONRegion, the unit is lat/lng,
	* for GeoSVGRegion, the unit is SVG local coord.
	*/
	Region$1.prototype.getCenter = function() {
		var center$2 = this._center;
		if (!center$2) center$2 = this._center = this.calcCenter();
		return center$2;
	};
	return Region$1;
}();
var GeoJSONPolygonGeometry = function() {
	function GeoJSONPolygonGeometry$1(exterior, interiors) {
		this.type = "polygon";
		this.exterior = exterior;
		this.interiors = interiors;
	}
	return GeoJSONPolygonGeometry$1;
}();
var GeoJSONLineStringGeometry = function() {
	function GeoJSONLineStringGeometry$1(points$3) {
		this.type = "linestring";
		this.points = points$3;
	}
	return GeoJSONLineStringGeometry$1;
}();
var GeoJSONRegion = function(_super) {
	__extends(GeoJSONRegion$1, _super);
	function GeoJSONRegion$1(name, geometries, cp) {
		var _this = _super.call(this, name) || this;
		_this.type = "geoJSON";
		_this.geometries = geometries;
		_this._center = cp && [cp[0], cp[1]];
		return _this;
	}
	GeoJSONRegion$1.prototype.calcCenter = function() {
		var geometries = this.geometries;
		var largestGeo;
		var largestGeoSize = 0;
		for (var i$1 = 0; i$1 < geometries.length; i$1++) {
			var geo = geometries[i$1];
			var exterior = geo.exterior;
			var size = exterior && exterior.length;
			if (size > largestGeoSize) {
				largestGeo = geo;
				largestGeoSize = size;
			}
		}
		if (largestGeo) return centroid$1(largestGeo.exterior);
		var rect = this.getBoundingRect();
		return [rect.x + rect.width / 2, rect.y + rect.height / 2];
	};
	GeoJSONRegion$1.prototype.getBoundingRect = function(projection) {
		var rect = this._rect;
		if (rect && !projection) return rect;
		var min$2 = [Infinity, Infinity];
		var max$2 = [-Infinity, -Infinity];
		var geometries = this.geometries;
		each(geometries, function(geo) {
			if (geo.type === "polygon") updateBBoxFromPoints(geo.exterior, min$2, max$2, projection);
			else each(geo.points, function(points$3) {
				updateBBoxFromPoints(points$3, min$2, max$2, projection);
			});
		});
		if (!(isFinite(min$2[0]) && isFinite(min$2[1]) && isFinite(max$2[0]) && isFinite(max$2[1]))) min$2[0] = min$2[1] = max$2[0] = max$2[1] = 0;
		rect = new BoundingRect_default(min$2[0], min$2[1], max$2[0] - min$2[0], max$2[1] - min$2[1]);
		if (!projection) this._rect = rect;
		return rect;
	};
	GeoJSONRegion$1.prototype.contain = function(coord) {
		var rect = this.getBoundingRect();
		var geometries = this.geometries;
		if (!rect.contain(coord[0], coord[1])) return false;
		loopGeo: for (var i$1 = 0, len$1 = geometries.length; i$1 < len$1; i$1++) {
			var geo = geometries[i$1];
			if (geo.type !== "polygon") continue;
			var exterior = geo.exterior;
			var interiors = geo.interiors;
			if (contain(exterior, coord[0], coord[1])) {
				for (var k$1 = 0; k$1 < (interiors ? interiors.length : 0); k$1++) if (contain(interiors[k$1], coord[0], coord[1])) continue loopGeo;
				return true;
			}
		}
		return false;
	};
	/**
	* Transform the raw coords to target bounding.
	* @param x
	* @param y
	* @param width
	* @param height
	*/
	GeoJSONRegion$1.prototype.transformTo = function(x, y, width, height) {
		var rect = this.getBoundingRect();
		var aspect = rect.width / rect.height;
		if (!width) width = aspect * height;
		else if (!height) height = width / aspect;
		var target = new BoundingRect_default(x, y, width, height);
		var transform = rect.calculateTransform(target);
		var geometries = this.geometries;
		for (var i$1 = 0; i$1 < geometries.length; i$1++) {
			var geo = geometries[i$1];
			if (geo.type === "polygon") {
				transformPoints(geo.exterior, transform);
				each(geo.interiors, function(interior) {
					transformPoints(interior, transform);
				});
			} else each(geo.points, function(points$3) {
				transformPoints(points$3, transform);
			});
		}
		rect = this._rect;
		rect.copy(target);
		this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
	};
	GeoJSONRegion$1.prototype.cloneShallow = function(name) {
		name ??= this.name;
		var newRegion = new GeoJSONRegion$1(name, this.geometries, this._center);
		newRegion._rect = this._rect;
		newRegion.transformTo = null;
		return newRegion;
	};
	return GeoJSONRegion$1;
}(Region);
var GeoSVGRegion = function(_super) {
	__extends(GeoSVGRegion$1, _super);
	function GeoSVGRegion$1(name, elOnlyForCalculate) {
		var _this = _super.call(this, name) || this;
		_this.type = "geoSVG";
		_this._elOnlyForCalculate = elOnlyForCalculate;
		return _this;
	}
	GeoSVGRegion$1.prototype.calcCenter = function() {
		var el = this._elOnlyForCalculate;
		var rect = el.getBoundingRect();
		var center$2 = [rect.x + rect.width / 2, rect.y + rect.height / 2];
		var mat = identity(TMP_TRANSFORM);
		var target = el;
		while (target && !target.isGeoSVGGraphicRoot) {
			mul(mat, target.getLocalTransform(), mat);
			target = target.parent;
		}
		invert(mat, mat);
		applyTransform(center$2, center$2, mat);
		return center$2;
	};
	return GeoSVGRegion$1;
}(Region);

//#endregion
//#region node_modules/echarts/lib/coord/geo/parseGeoJson.js
function decode(json) {
	if (!json.UTF8Encoding) return json;
	var jsonCompressed = json;
	var encodeScale = jsonCompressed.UTF8Scale;
	if (encodeScale == null) encodeScale = 1024;
	var features$1 = jsonCompressed.features;
	each(features$1, function(feature) {
		var geometry = feature.geometry;
		var encodeOffsets = geometry.encodeOffsets;
		var coordinates = geometry.coordinates;
		if (!encodeOffsets) return;
		switch (geometry.type) {
			case "LineString":
				geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
				break;
			case "Polygon":
				decodeRings(coordinates, encodeOffsets, encodeScale);
				break;
			case "MultiLineString":
				decodeRings(coordinates, encodeOffsets, encodeScale);
				break;
			case "MultiPolygon": each(coordinates, function(rings, idx) {
				return decodeRings(rings, encodeOffsets[idx], encodeScale);
			});
		}
	});
	jsonCompressed.UTF8Encoding = false;
	return jsonCompressed;
}
function decodeRings(rings, encodeOffsets, encodeScale) {
	for (var c = 0; c < rings.length; c++) rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);
}
function decodeRing(coordinate, encodeOffsets, encodeScale) {
	var result = [];
	var prevX = encodeOffsets[0];
	var prevY = encodeOffsets[1];
	for (var i$1 = 0; i$1 < coordinate.length; i$1 += 2) {
		var x = coordinate.charCodeAt(i$1) - 64;
		var y = coordinate.charCodeAt(i$1 + 1) - 64;
		x = x >> 1 ^ -(x & 1);
		y = y >> 1 ^ -(y & 1);
		x += prevX;
		y += prevY;
		prevX = x;
		prevY = y;
		result.push([x / encodeScale, y / encodeScale]);
	}
	return result;
}
function parseGeoJSON(geoJson, nameProperty) {
	geoJson = decode(geoJson);
	return map(filter(geoJson.features, function(featureObj) {
		return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
	}), function(featureObj) {
		var properties = featureObj.properties;
		var geo = featureObj.geometry;
		var geometries = [];
		switch (geo.type) {
			case "Polygon":
				var coordinates = geo.coordinates;
				geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
				break;
			case "MultiPolygon":
				each(geo.coordinates, function(item) {
					if (item[0]) geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
				});
				break;
			case "LineString":
				geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
				break;
			case "MultiLineString": geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
		}
		var region = new GeoJSONRegion(properties[nameProperty || "name"], geometries, properties.cp);
		region.properties = properties;
		return region;
	});
}

//#endregion
//#region node_modules/echarts/lib/export/api/number.js
var number_exports = /* @__PURE__ */ __export({
	MAX_SAFE_INTEGER: () => MAX_SAFE_INTEGER,
	asc: () => asc$1,
	getPercentWithPrecision: () => getPercentWithPrecision,
	getPixelPrecision: () => getPixelPrecision,
	getPrecision: () => getPrecision,
	getPrecisionSafe: () => getPrecisionSafe,
	isNumeric: () => isNumeric,
	isRadianAroundZero: () => isRadianAroundZero,
	linearMap: () => linearMap$2,
	nice: () => nice,
	numericToNumber: () => numericToNumber,
	parseDate: () => parseDate,
	parsePercent: () => parsePercent$1,
	quantile: () => quantile,
	quantity: () => quantity,
	quantityExponent: () => quantityExponent,
	reformIntervals: () => reformIntervals,
	remRadian: () => remRadian,
	round: () => round
});

//#endregion
//#region node_modules/echarts/lib/export/api/time.js
var time_exports = /* @__PURE__ */ __export({
	format: () => format,
	parse: () => parseDate,
	roundTime: () => roundTime
});

//#endregion
//#region node_modules/echarts/lib/export/api/graphic.js
var graphic_exports = /* @__PURE__ */ __export({
	Arc: () => Arc_default,
	BezierCurve: () => BezierCurve_default,
	BoundingRect: () => BoundingRect_default,
	Circle: () => Circle_default,
	CompoundPath: () => CompoundPath_default,
	Ellipse: () => Ellipse_default,
	Group: () => Group_default,
	Image: () => Image_default,
	IncrementalDisplayable: () => IncrementalDisplayable_default,
	Line: () => Line_default,
	LinearGradient: () => LinearGradient_default,
	Polygon: () => Polygon_default,
	Polyline: () => Polyline_default,
	RadialGradient: () => RadialGradient_default,
	Rect: () => Rect_default,
	Ring: () => Ring_default,
	Sector: () => Sector_default,
	Text: () => Text_default,
	clipPointsByRect: () => clipPointsByRect,
	clipRectByRect: () => clipRectByRect,
	createIcon: () => createIcon,
	extendPath: () => extendPath,
	extendShape: () => extendShape,
	getShapeClass: () => getShapeClass,
	getTransform: () => getTransform$1,
	initProps: () => initProps,
	makeImage: () => makeImage,
	makePath: () => makePath,
	mergePath: () => mergePath,
	registerShape: () => registerShape,
	resizePath: () => resizePath,
	updateProps: () => updateProps
});

//#endregion
//#region node_modules/echarts/lib/export/api/format.js
var format_exports = /* @__PURE__ */ __export({
	addCommas: () => addCommas,
	capitalFirst: () => capitalFirst,
	encodeHTML: () => encodeHTML,
	formatTime: () => formatTime,
	formatTpl: () => formatTpl,
	getTextRect: () => getTextRect,
	getTooltipMarker: () => getTooltipMarker,
	normalizeCssArray: () => normalizeCssArray,
	toCamelCase: () => toCamelCase,
	truncateText: () => truncateText
});

//#endregion
//#region node_modules/echarts/lib/export/api/util.js
var util_exports = /* @__PURE__ */ __export({
	bind: () => bind,
	clone: () => clone,
	curry: () => curry,
	defaults: () => defaults,
	each: () => each,
	extend: () => extend,
	filter: () => filter,
	indexOf: () => indexOf,
	inherits: () => inherits,
	isArray: () => isArray,
	isFunction: () => isFunction,
	isObject: () => isObject,
	isString: () => isString,
	map: () => map,
	merge: () => merge,
	reduce: () => reduce
});

//#endregion
//#region node_modules/echarts/lib/coord/axisTickLabelBuilder.js
var modelInner = makeInner();
var axisInner = makeInner();
var AxisTickLabelComputingKind = {
	estimate: 1,
	determine: 2
};
function createAxisLabelsComputingContext(kind) {
	return {
		out: { noPxChangeTryDetermine: [] },
		kind
	};
}
function tickValuesToNumbers(axis, values) {
	var nums = map(values, function(val) {
		return axis.scale.parse(val);
	});
	if (axis.type === "time" && nums.length > 0) {
		nums.sort();
		nums.unshift(nums[0]);
		nums.push(nums[nums.length - 1]);
	}
	return nums;
}
function createAxisLabels(axis, ctx) {
	var custom = axis.getLabelModel().get("customValues");
	if (custom) {
		var labelFormatter_1 = makeLabelFormatter(axis);
		var extent_1 = axis.scale.getExtent();
		var tickNumbers = tickValuesToNumbers(axis, custom);
		var ticks = filter(tickNumbers, function(val) {
			return val >= extent_1[0] && val <= extent_1[1];
		});
		return { labels: map(ticks, function(numval) {
			var tick = { value: numval };
			return {
				formattedLabel: labelFormatter_1(tick),
				rawLabel: axis.scale.getLabel(tick),
				tickValue: numval,
				time: void 0,
				"break": void 0
			};
		}) };
	}
	return axis.type === "category" ? makeCategoryLabels(axis, ctx) : makeRealNumberLabels(axis);
}
/**
* @param tickModel For example, can be axisTick, splitLine, splitArea.
*/
function createAxisTicks(axis, tickModel, opt) {
	var custom = axis.getTickModel().get("customValues");
	if (custom) {
		var extent_2 = axis.scale.getExtent();
		var tickNumbers = tickValuesToNumbers(axis, custom);
		return { ticks: filter(tickNumbers, function(val) {
			return val >= extent_2[0] && val <= extent_2[1];
		}) };
	}
	return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : { ticks: map(axis.scale.getTicks(opt), function(tick) {
		return tick.value;
	}) };
}
function makeCategoryLabels(axis, ctx) {
	var labelModel = axis.getLabelModel();
	var result = makeCategoryLabelsActually(axis, labelModel, ctx);
	return !labelModel.get("show") || axis.scale.isBlank() ? { labels: [] } : result;
}
function makeCategoryLabelsActually(axis, labelModel, ctx) {
	var labelsCache = ensureCategoryLabelCache(axis);
	var optionLabelInterval = getOptionCategoryInterval(labelModel);
	var isEstimate = ctx.kind === AxisTickLabelComputingKind.estimate;
	if (!isEstimate) {
		var result_1 = axisCacheGet(labelsCache, optionLabelInterval);
		if (result_1) return result_1;
	}
	var labels;
	var numericLabelInterval;
	if (isFunction(optionLabelInterval)) labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
	else {
		numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis, ctx) : optionLabelInterval;
		labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
	}
	var result = {
		labels,
		labelCategoryInterval: numericLabelInterval
	};
	if (!isEstimate) axisCacheSet(labelsCache, optionLabelInterval, result);
	else ctx.out.noPxChangeTryDetermine.push(function() {
		axisCacheSet(labelsCache, optionLabelInterval, result);
		return true;
	});
	return result;
}
function makeCategoryTicks(axis, tickModel) {
	var ticksCache = ensureCategoryTickCache(axis);
	var optionTickInterval = getOptionCategoryInterval(tickModel);
	var result = axisCacheGet(ticksCache, optionTickInterval);
	if (result) return result;
	var ticks;
	var tickCategoryInterval;
	if (!tickModel.get("show") || axis.scale.isBlank()) ticks = [];
	if (isFunction(optionTickInterval)) ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
	else if (optionTickInterval === "auto") {
		var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel(), createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine));
		tickCategoryInterval = labelsResult.labelCategoryInterval;
		ticks = map(labelsResult.labels, function(labelItem) {
			return labelItem.tickValue;
		});
	} else {
		tickCategoryInterval = optionTickInterval;
		ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
	}
	return axisCacheSet(ticksCache, optionTickInterval, {
		ticks,
		tickCategoryInterval
	});
}
function makeRealNumberLabels(axis) {
	var ticks = axis.scale.getTicks();
	var labelFormatter = makeLabelFormatter(axis);
	return { labels: map(ticks, function(tick, idx) {
		return {
			formattedLabel: labelFormatter(tick, idx),
			rawLabel: axis.scale.getLabel(tick),
			tickValue: tick.value,
			time: tick.time,
			"break": tick["break"]
		};
	}) };
}
var ensureCategoryTickCache = initAxisCacheMethod("axisTick");
var ensureCategoryLabelCache = initAxisCacheMethod("axisLabel");
/**
* PENDING: refactor to JS Map? Because key can be a function or more complicated object, and
* cache size always is small, and currently no JS Map object key polyfill, we use a simple
* array cache instead of plain object hash.
*/
function initAxisCacheMethod(prop) {
	return function ensureCache(axis) {
		return axisInner(axis)[prop] || (axisInner(axis)[prop] = { list: [] });
	};
}
function axisCacheGet(cache, key$1) {
	for (var i$1 = 0; i$1 < cache.list.length; i$1++) if (cache.list[i$1].key === key$1) return cache.list[i$1].value;
}
function axisCacheSet(cache, key$1, value) {
	cache.list.push({
		key: key$1,
		value
	});
	return value;
}
function makeAutoCategoryInterval(axis, ctx) {
	if (ctx.kind === AxisTickLabelComputingKind.estimate) {
		var result_2 = axis.calculateCategoryInterval(ctx);
		ctx.out.noPxChangeTryDetermine.push(function() {
			axisInner(axis).autoInterval = result_2;
			return true;
		});
		return result_2;
	}
	var result = axisInner(axis).autoInterval;
	return result != null ? result : axisInner(axis).autoInterval = axis.calculateCategoryInterval(ctx);
}
/**
* Calculate interval for category axis ticks and labels.
* Use a stretegy to try to avoid overlapping.
* To get precise result, at least one of `getRotate` and `isHorizontal`
* should be implemented in axis.
*/
function calculateCategoryInterval(axis, ctx) {
	var kind = ctx.kind;
	var params = fetchAutoCategoryIntervalCalculationParams(axis);
	var labelFormatter = makeLabelFormatter(axis);
	var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
	var ordinalScale = axis.scale;
	var ordinalExtent = ordinalScale.getExtent();
	var tickCount = ordinalScale.count();
	if (ordinalExtent[1] - ordinalExtent[0] < 1) return 0;
	var step = 1;
	var maxCount = 40;
	if (tickCount > maxCount) step = Math.max(1, Math.floor(tickCount / maxCount));
	var tickValue = ordinalExtent[0];
	var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
	var unitW = Math.abs(unitSpan * Math.cos(rotation));
	var unitH = Math.abs(unitSpan * Math.sin(rotation));
	var maxW = 0;
	var maxH = 0;
	for (; tickValue <= ordinalExtent[1]; tickValue += step) {
		var width = 0;
		var height = 0;
		var rect = getBoundingRect(labelFormatter({ value: tickValue }), params.font, "center", "top");
		width = rect.width * 1.3;
		height = rect.height * 1.3;
		maxW = Math.max(maxW, width, 7);
		maxH = Math.max(maxH, height, 7);
	}
	var dw = maxW / unitW;
	var dh = maxH / unitH;
	isNaN(dw) && (dw = Infinity);
	isNaN(dh) && (dh = Infinity);
	var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
	if (kind === AxisTickLabelComputingKind.estimate) {
		ctx.out.noPxChangeTryDetermine.push(bind(calculateCategoryIntervalTryDetermine, null, axis, interval, tickCount));
		return interval;
	}
	var lastInterval = calculateCategoryIntervalDealCache(axis, interval, tickCount);
	return lastInterval != null ? lastInterval : interval;
}
function calculateCategoryIntervalTryDetermine(axis, interval, tickCount) {
	return calculateCategoryIntervalDealCache(axis, interval, tickCount) == null;
}
function calculateCategoryIntervalDealCache(axis, interval, tickCount) {
	var cache = modelInner(axis.model);
	var axisExtent = axis.getExtent();
	var lastAutoInterval = cache.lastAutoInterval;
	var lastTickCount = cache.lastTickCount;
	if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) return lastAutoInterval;
	else {
		cache.lastTickCount = tickCount;
		cache.lastAutoInterval = interval;
		cache.axisExtent0 = axisExtent[0];
		cache.axisExtent1 = axisExtent[1];
	}
}
function fetchAutoCategoryIntervalCalculationParams(axis) {
	var labelModel = axis.getLabelModel();
	return {
		axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
		labelRotate: labelModel.get("rotate") || 0,
		font: labelModel.getFont()
	};
}
function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
	var labelFormatter = makeLabelFormatter(axis);
	var ordinalScale = axis.scale;
	var ordinalExtent = ordinalScale.getExtent();
	var labelModel = axis.getLabelModel();
	var result = [];
	var step = Math.max((categoryInterval || 0) + 1, 1);
	var startTick = ordinalExtent[0];
	var tickCount = ordinalScale.count();
	if (startTick !== 0 && step > 1 && tickCount / step > 2) startTick = Math.round(Math.ceil(startTick / step) * step);
	var showAllLabel = shouldShowAllLabels(axis);
	var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
	var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
	if (includeMinLabel && startTick !== ordinalExtent[0]) addItem(ordinalExtent[0]);
	var tickValue = startTick;
	for (; tickValue <= ordinalExtent[1]; tickValue += step) addItem(tickValue);
	if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) addItem(ordinalExtent[1]);
	function addItem(tickValue$1) {
		var tickObj = { value: tickValue$1 };
		result.push(onlyTick ? tickValue$1 : {
			formattedLabel: labelFormatter(tickObj),
			rawLabel: ordinalScale.getLabel(tickObj),
			tickValue: tickValue$1,
			time: void 0,
			"break": void 0
		});
	}
	return result;
}
function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
	var ordinalScale = axis.scale;
	var labelFormatter = makeLabelFormatter(axis);
	var result = [];
	each(ordinalScale.getTicks(), function(tick) {
		var rawLabel = ordinalScale.getLabel(tick);
		var tickValue = tick.value;
		if (categoryInterval(tick.value, rawLabel)) result.push(onlyTick ? tickValue : {
			formattedLabel: labelFormatter(tick),
			rawLabel,
			tickValue,
			time: void 0,
			"break": void 0
		});
	});
	return result;
}

//#endregion
//#region node_modules/echarts/lib/coord/Axis.js
var NORMALIZED_EXTENT = [0, 1];
/**
* Base class of Axis.
*
* Lifetime: recreate for each main process.
* [NOTICE]: Some caches is stored on the axis instance (see `axisTickLabelBuilder.ts`)
*  which is based on this lifetime.
*/
var Axis = function() {
	function Axis$1(dim, scale$3, extent) {
		this.onBand = false;
		this.inverse = false;
		this.dim = dim;
		this.scale = scale$3;
		this._extent = extent || [0, 0];
	}
	/**
	* If axis extent contain given coord
	*/
	Axis$1.prototype.contain = function(coord) {
		var extent = this._extent;
		var min$2 = Math.min(extent[0], extent[1]);
		var max$2 = Math.max(extent[0], extent[1]);
		return coord >= min$2 && coord <= max$2;
	};
	/**
	* If axis extent contain given data
	*/
	Axis$1.prototype.containData = function(data) {
		return this.scale.contain(this.scale.parse(data));
	};
	/**
	* Get coord extent.
	*/
	Axis$1.prototype.getExtent = function() {
		return this._extent.slice();
	};
	/**
	* Get precision used for formatting
	*/
	Axis$1.prototype.getPixelPrecision = function(dataExtent) {
		return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
	};
	/**
	* Set coord extent
	*/
	Axis$1.prototype.setExtent = function(start$1, end$1) {
		var extent = this._extent;
		extent[0] = start$1;
		extent[1] = end$1;
	};
	/**
	* Convert data to coord. Data is the rank if it has an ordinal scale
	*/
	Axis$1.prototype.dataToCoord = function(data, clamp$1) {
		var extent = this._extent;
		var scale$3 = this.scale;
		data = scale$3.normalize(scale$3.parse(data));
		if (this.onBand && scale$3.type === "ordinal") {
			extent = extent.slice();
			fixExtentWithBands(extent, scale$3.count());
		}
		return linearMap$2(data, NORMALIZED_EXTENT, extent, clamp$1);
	};
	/**
	* Convert coord to data. Data is the rank if it has an ordinal scale
	*/
	Axis$1.prototype.coordToData = function(coord, clamp$1) {
		var extent = this._extent;
		var scale$3 = this.scale;
		if (this.onBand && scale$3.type === "ordinal") {
			extent = extent.slice();
			fixExtentWithBands(extent, scale$3.count());
		}
		var t = linearMap$2(coord, extent, NORMALIZED_EXTENT, clamp$1);
		return this.scale.scale(t);
	};
	/**
	* Convert pixel point to data in axis
	*/
	Axis$1.prototype.pointToData = function(point, clamp$1) {};
	/**
	* Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
	* `axis.getTicksCoords` considers `onBand`, which is used by
	* `boundaryGap:true` of category axis and splitLine and splitArea.
	* @param opt.tickModel default: axis.model.getModel('axisTick')
	* @param opt.clamp If `true`, the first and the last
	*        tick must be at the axis end points. Otherwise, clip ticks
	*        that outside the axis extent.
	*/
	Axis$1.prototype.getTicksCoords = function(opt) {
		opt = opt || {};
		var tickModel = opt.tickModel || this.getTickModel();
		var ticks = createAxisTicks(this, tickModel, {
			breakTicks: opt.breakTicks,
			pruneByBreak: opt.pruneByBreak
		}).ticks;
		var ticksCoords = map(ticks, function(tickVal) {
			return {
				coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
				tickValue: tickVal
			};
		}, this);
		var alignWithLabel = tickModel.get("alignWithLabel");
		fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
		return ticksCoords;
	};
	Axis$1.prototype.getMinorTicksCoords = function() {
		if (this.scale.type === "ordinal") return [];
		var splitNumber = this.model.getModel("minorTick").get("splitNumber");
		if (!(splitNumber > 0 && splitNumber < 100)) splitNumber = 5;
		return map(this.scale.getMinorTicks(splitNumber), function(minorTicksGroup) {
			return map(minorTicksGroup, function(minorTick) {
				return {
					coord: this.dataToCoord(minorTick),
					tickValue: minorTick
				};
			}, this);
		}, this);
	};
	Axis$1.prototype.getViewLabels = function(ctx) {
		ctx = ctx || createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine);
		return createAxisLabels(this, ctx).labels;
	};
	Axis$1.prototype.getLabelModel = function() {
		return this.model.getModel("axisLabel");
	};
	/**
	* Notice here we only get the default tick model. For splitLine
	* or splitArea, we should pass the splitLineModel or splitAreaModel
	* manually when calling `getTicksCoords`.
	* In GL, this method may be overridden to:
	* `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
	*/
	Axis$1.prototype.getTickModel = function() {
		return this.model.getModel("axisTick");
	};
	/**
	* Get width of band
	*/
	Axis$1.prototype.getBandWidth = function() {
		var axisExtent = this._extent;
		var dataExtent = this.scale.getExtent();
		var len$1 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
		len$1 === 0 && (len$1 = 1);
		var size = Math.abs(axisExtent[1] - axisExtent[0]);
		return Math.abs(size) / len$1;
	};
	/**
	* Only be called in category axis.
	* Can be overridden, consider other axes like in 3D.
	* @return Auto interval for cateogry axis tick and label
	*/
	Axis$1.prototype.calculateCategoryInterval = function(ctx) {
		ctx = ctx || createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine);
		return calculateCategoryInterval(this, ctx);
	};
	return Axis$1;
}();
function fixExtentWithBands(extent, nTick) {
	var margin = (extent[1] - extent[0]) / nTick / 2;
	extent[0] += margin;
	extent[1] -= margin;
}
function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp$1) {
	var ticksLen = ticksCoords.length;
	if (!axis.onBand || alignWithLabel || !ticksLen) return;
	var axisExtent = axis.getExtent();
	var last;
	var diffSize;
	if (ticksLen === 1) {
		ticksCoords[0].coord = axisExtent[0];
		ticksCoords[0].onBand = true;
		last = ticksCoords[1] = {
			coord: axisExtent[1],
			tickValue: ticksCoords[0].tickValue,
			onBand: true
		};
	} else {
		var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
		var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
		each(ticksCoords, function(ticksItem) {
			ticksItem.coord -= shift_1 / 2;
			ticksItem.onBand = true;
		});
		var dataExtent = axis.scale.getExtent();
		diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
		last = {
			coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize,
			tickValue: dataExtent[1] + 1,
			onBand: true
		};
		ticksCoords.push(last);
	}
	var inverse = axisExtent[0] > axisExtent[1];
	if (littleThan$1(ticksCoords[0].coord, axisExtent[0])) clamp$1 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
	if (clamp$1 && littleThan$1(axisExtent[0], ticksCoords[0].coord)) ticksCoords.unshift({
		coord: axisExtent[0],
		onBand: true
	});
	if (littleThan$1(axisExtent[1], last.coord)) clamp$1 ? last.coord = axisExtent[1] : ticksCoords.pop();
	if (clamp$1 && littleThan$1(last.coord, axisExtent[1])) ticksCoords.push({
		coord: axisExtent[1],
		onBand: true
	});
	function littleThan$1(a, b) {
		a = round(a);
		b = round(b);
		return inverse ? a > b : a < b;
	}
}
var Axis_default = Axis;

//#endregion
//#region node_modules/echarts/lib/export/api.js
function extendComponentModel(proto) {
	var Model$1 = Component_default.extend(proto);
	Component_default.registerClass(Model$1);
	return Model$1;
}
function extendComponentView(proto) {
	var View$1 = Component_default$1.extend(proto);
	Component_default$1.registerClass(View$1);
	return View$1;
}
function extendSeriesModel(proto) {
	var Model$1 = Series_default.extend(proto);
	Series_default.registerClass(Model$1);
	return Model$1;
}
function extendChartView(proto) {
	var View$1 = Chart_default.extend(proto);
	Chart_default.registerClass(View$1);
	return View$1;
}

//#endregion
//#region node_modules/echarts/lib/label/labelGuideHelper.js
var PI2$2 = Math.PI * 2;
var CMD$1 = PathProxy_default.CMD;
var DEFAULT_SEARCH_SPACE = [
	"top",
	"right",
	"bottom",
	"left"
];
function getCandidateAnchor(pos, distance$1, rect, outPt, outDir) {
	var width = rect.width;
	var height = rect.height;
	switch (pos) {
		case "top":
			outPt.set(rect.x + width / 2, rect.y - distance$1);
			outDir.set(0, -1);
			break;
		case "bottom":
			outPt.set(rect.x + width / 2, rect.y + height + distance$1);
			outDir.set(0, 1);
			break;
		case "left":
			outPt.set(rect.x - distance$1, rect.y + height / 2);
			outDir.set(-1, 0);
			break;
		case "right":
			outPt.set(rect.x + width + distance$1, rect.y + height / 2);
			outDir.set(1, 0);
			break;
	}
}
function projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out$1) {
	x -= cx;
	y -= cy;
	var d = Math.sqrt(x * x + y * y);
	x /= d;
	y /= d;
	var ox = x * r + cx;
	var oy = y * r + cy;
	if (Math.abs(startAngle - endAngle) % PI2$2 < 1e-4) {
		out$1[0] = ox;
		out$1[1] = oy;
		return d - r;
	}
	if (anticlockwise) {
		var tmp = startAngle;
		startAngle = normalizeRadian(endAngle);
		endAngle = normalizeRadian(tmp);
	} else {
		startAngle = normalizeRadian(startAngle);
		endAngle = normalizeRadian(endAngle);
	}
	if (startAngle > endAngle) endAngle += PI2$2;
	var angle = Math.atan2(y, x);
	if (angle < 0) angle += PI2$2;
	if (angle >= startAngle && angle <= endAngle || angle + PI2$2 >= startAngle && angle + PI2$2 <= endAngle) {
		out$1[0] = ox;
		out$1[1] = oy;
		return d - r;
	}
	var x1 = r * Math.cos(startAngle) + cx;
	var y1 = r * Math.sin(startAngle) + cy;
	var x2 = r * Math.cos(endAngle) + cx;
	var y2 = r * Math.sin(endAngle) + cy;
	var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);
	var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);
	if (d1 < d2) {
		out$1[0] = x1;
		out$1[1] = y1;
		return Math.sqrt(d1);
	} else {
		out$1[0] = x2;
		out$1[1] = y2;
		return Math.sqrt(d2);
	}
}
function projectPointToLine(x1, y1, x2, y2, x, y, out$1, limitToEnds) {
	var dx = x - x1;
	var dy = y - y1;
	var dx1 = x2 - x1;
	var dy1 = y2 - y1;
	var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
	dx1 /= lineLen;
	dy1 /= lineLen;
	var t = (dx * dx1 + dy * dy1) / lineLen;
	if (limitToEnds) t = Math.min(Math.max(t, 0), 1);
	t *= lineLen;
	var ox = out$1[0] = x1 + t * dx1;
	var oy = out$1[1] = y1 + t * dy1;
	return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
}
function projectPointToRect(x1, y1, width, height, x, y, out$1) {
	if (width < 0) {
		x1 = x1 + width;
		width = -width;
	}
	if (height < 0) {
		y1 = y1 + height;
		height = -height;
	}
	var x2 = x1 + width;
	var y2 = y1 + height;
	var ox = out$1[0] = Math.min(Math.max(x, x1), x2);
	var oy = out$1[1] = Math.min(Math.max(y, y1), y2);
	return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
}
var tmpPt = [];
function nearestPointOnRect(pt, rect, out$1) {
	var dist$2 = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);
	out$1.set(tmpPt[0], tmpPt[1]);
	return dist$2;
}
/**
* Calculate min distance corresponding point.
* This method won't evaluate if point is in the path.
*/
function nearestPointOnPath(pt, path, out$1) {
	var xi = 0;
	var yi = 0;
	var x0 = 0;
	var y0 = 0;
	var x1;
	var y1;
	var minDist = Infinity;
	var data = path.data;
	var x = pt.x;
	var y = pt.y;
	for (var i$1 = 0; i$1 < data.length;) {
		var cmd = data[i$1++];
		if (i$1 === 1) {
			xi = data[i$1];
			yi = data[i$1 + 1];
			x0 = xi;
			y0 = yi;
		}
		var d = minDist;
		switch (cmd) {
			case CMD$1.M:
				x0 = data[i$1++];
				y0 = data[i$1++];
				xi = x0;
				yi = y0;
				break;
			case CMD$1.L:
				d = projectPointToLine(xi, yi, data[i$1], data[i$1 + 1], x, y, tmpPt, true);
				xi = data[i$1++];
				yi = data[i$1++];
				break;
			case CMD$1.C:
				d = cubicProjectPoint(xi, yi, data[i$1++], data[i$1++], data[i$1++], data[i$1++], data[i$1], data[i$1 + 1], x, y, tmpPt);
				xi = data[i$1++];
				yi = data[i$1++];
				break;
			case CMD$1.Q:
				d = quadraticProjectPoint(xi, yi, data[i$1++], data[i$1++], data[i$1], data[i$1 + 1], x, y, tmpPt);
				xi = data[i$1++];
				yi = data[i$1++];
				break;
			case CMD$1.A:
				var cx = data[i$1++];
				var cy = data[i$1++];
				var rx = data[i$1++];
				var ry = data[i$1++];
				var theta = data[i$1++];
				var dTheta = data[i$1++];
				i$1 += 1;
				var anticlockwise = !!(1 - data[i$1++]);
				x1 = Math.cos(theta) * rx + cx;
				y1 = Math.sin(theta) * ry + cy;
				if (i$1 <= 1) {
					x0 = x1;
					y0 = y1;
				}
				var _x = (x - cx) * ry / rx + cx;
				d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);
				xi = Math.cos(theta + dTheta) * rx + cx;
				yi = Math.sin(theta + dTheta) * ry + cy;
				break;
			case CMD$1.R:
				x0 = xi = data[i$1++];
				y0 = yi = data[i$1++];
				var width = data[i$1++];
				var height = data[i$1++];
				d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);
				break;
			case CMD$1.Z:
				d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);
				xi = x0;
				yi = y0;
				break;
		}
		if (d < minDist) {
			minDist = d;
			out$1.set(tmpPt[0], tmpPt[1]);
		}
	}
	return minDist;
}
var pt0 = new Point_default();
var pt1 = new Point_default();
var pt2 = new Point_default();
var dir = new Point_default();
var dir2 = new Point_default();
/**
* Calculate a proper guide line based on the label position and graphic element definition
* @param label
* @param labelRect
* @param target
* @param targetRect
*/
function updateLabelLinePoints(target, labelLineModel) {
	if (!target) return;
	var labelLine = target.getTextGuideLine();
	var label = target.getTextContent();
	if (!(label && labelLine)) return;
	var labelGuideConfig = target.textGuideLineConfig || {};
	var points$3 = [
		[0, 0],
		[0, 0],
		[0, 0]
	];
	var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;
	var labelRect = label.getBoundingRect().clone();
	labelRect.applyTransform(label.getComputedTransform());
	var minDist = Infinity;
	var anchorPoint = labelGuideConfig.anchor;
	var targetTransform = target.getComputedTransform();
	var targetInversedTransform = targetTransform && invert([], targetTransform);
	var len$1 = labelLineModel.get("length2") || 0;
	if (anchorPoint) pt2.copy(anchorPoint);
	for (var i$1 = 0; i$1 < searchSpace.length; i$1++) {
		var candidate = searchSpace[i$1];
		getCandidateAnchor(candidate, 0, labelRect, pt0, dir);
		Point_default.scaleAndAdd(pt1, pt0, dir, len$1);
		pt1.transform(targetInversedTransform);
		var boundingRect = target.getBoundingRect();
		var dist$2 = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path_default ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);
		if (dist$2 < minDist) {
			minDist = dist$2;
			pt1.transform(targetTransform);
			pt2.transform(targetTransform);
			pt2.toArray(points$3[0]);
			pt1.toArray(points$3[1]);
			pt0.toArray(points$3[2]);
		}
	}
	limitTurnAngle(points$3, labelLineModel.get("minTurnAngle"));
	labelLine.setShape({ points: points$3 });
}
var tmpArr = [];
var tmpProjPoint = new Point_default();
/**
* Reduce the line segment attached to the label to limit the turn angle between two segments.
* @param linePoints
* @param minTurnAngle Radian of minimum turn angle. 0 - 180
*/
function limitTurnAngle(linePoints, minTurnAngle) {
	if (!(minTurnAngle <= 180 && minTurnAngle > 0)) return;
	minTurnAngle = minTurnAngle / 180 * Math.PI;
	pt0.fromArray(linePoints[0]);
	pt1.fromArray(linePoints[1]);
	pt2.fromArray(linePoints[2]);
	Point_default.sub(dir, pt0, pt1);
	Point_default.sub(dir2, pt2, pt1);
	var len1 = dir.len();
	var len2 = dir2.len();
	if (len1 < .001 || len2 < .001) return;
	dir.scale(1 / len1);
	dir2.scale(1 / len2);
	var angleCos = dir.dot(dir2);
	if (Math.cos(minTurnAngle) < angleCos) {
		var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
		tmpProjPoint.fromArray(tmpArr);
		tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));
		var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
		if (isNaN(t)) return;
		if (t < 0) Point_default.copy(tmpProjPoint, pt1);
		else if (t > 1) Point_default.copy(tmpProjPoint, pt2);
		tmpProjPoint.toArray(linePoints[1]);
	}
}
/**
* Limit the angle of line and the surface
* @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite
*/
function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
	if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) return;
	maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
	pt0.fromArray(linePoints[0]);
	pt1.fromArray(linePoints[1]);
	pt2.fromArray(linePoints[2]);
	Point_default.sub(dir, pt1, pt0);
	Point_default.sub(dir2, pt2, pt1);
	var len1 = dir.len();
	var len2 = dir2.len();
	if (len1 < .001 || len2 < .001) return;
	dir.scale(1 / len1);
	dir2.scale(1 / len2);
	if (dir.dot(surfaceNormal) < Math.cos(maxSurfaceAngle)) {
		var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
		tmpProjPoint.fromArray(tmpArr);
		var HALF_PI = Math.PI / 2;
		var newAngle = HALF_PI + Math.acos(dir2.dot(surfaceNormal)) - maxSurfaceAngle;
		if (newAngle >= HALF_PI) Point_default.copy(tmpProjPoint, pt2);
		else {
			tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));
			var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
			if (isNaN(t)) return;
			if (t < 0) Point_default.copy(tmpProjPoint, pt1);
			else if (t > 1) Point_default.copy(tmpProjPoint, pt2);
		}
		tmpProjPoint.toArray(linePoints[1]);
	}
}
function setLabelLineState(labelLine, ignore, stateName, stateModel) {
	var isNormal = stateName === "normal";
	var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
	stateObj.ignore = ignore;
	var smooth = stateModel.get("smooth");
	if (smooth && smooth === true) smooth = .3;
	stateObj.shape = stateObj.shape || {};
	if (smooth > 0) stateObj.shape.smooth = smooth;
	var styleObj = stateModel.getModel("lineStyle").getLineStyle();
	isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
}
function buildLabelLinePath(path, shape) {
	var smooth = shape.smooth;
	var points$3 = shape.points;
	if (!points$3) return;
	path.moveTo(points$3[0][0], points$3[0][1]);
	if (smooth > 0 && points$3.length >= 3) {
		var len1 = dist$1(points$3[0], points$3[1]);
		var len2 = dist$1(points$3[1], points$3[2]);
		if (!len1 || !len2) {
			path.lineTo(points$3[1][0], points$3[1][1]);
			path.lineTo(points$3[2][0], points$3[2][1]);
			return;
		}
		var moveLen = Math.min(len1, len2) * smooth;
		var midPoint0 = lerp([], points$3[1], points$3[0], moveLen / len1);
		var midPoint2 = lerp([], points$3[1], points$3[2], moveLen / len2);
		var midPoint1 = lerp([], midPoint0, midPoint2, .5);
		path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
		path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points$3[2][0], points$3[2][1]);
	} else for (var i$1 = 1; i$1 < points$3.length; i$1++) path.lineTo(points$3[i$1][0], points$3[i$1][1]);
}
/**
* Create a label line if necessary and set it's style.
*/
function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
	var labelLine = targetEl.getTextGuideLine();
	var label = targetEl.getTextContent();
	if (!label) {
		if (labelLine) targetEl.removeTextGuideLine();
		return;
	}
	var normalModel = statesModels.normal;
	var showNormal = normalModel.get("show");
	var labelIgnoreNormal = label.ignore;
	for (var i$1 = 0; i$1 < DISPLAY_STATES.length; i$1++) {
		var stateName = DISPLAY_STATES[i$1];
		var stateModel = statesModels[stateName];
		var isNormal = stateName === "normal";
		if (stateModel) {
			var stateShow = stateModel.get("show");
			if ((isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal)) || !retrieve2(stateShow, showNormal)) {
				var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];
				if (stateObj) stateObj.ignore = true;
				if (!!labelLine) setLabelLineState(labelLine, true, stateName, stateModel);
				continue;
			}
			if (!labelLine) {
				labelLine = new Polyline_default();
				targetEl.setTextGuideLine(labelLine);
				if (!isNormal && (labelIgnoreNormal || !showNormal)) setLabelLineState(labelLine, true, "normal", statesModels.normal);
				if (targetEl.stateProxy) labelLine.stateProxy = targetEl.stateProxy;
			}
			setLabelLineState(labelLine, false, stateName, stateModel);
		}
	}
	if (labelLine) {
		defaults(labelLine.style, defaultStyle);
		labelLine.style.fill = null;
		var showAbove = normalModel.get("showAbove");
		var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
		labelLineConfig.showAbove = showAbove || false;
		labelLine.buildPath = buildLabelLinePath;
	}
}
function getLabelLineStatesModels(itemModel, labelLineName) {
	labelLineName = labelLineName || "labelLine";
	var statesModels = { normal: itemModel.getModel(labelLineName) };
	for (var i$1 = 0; i$1 < SPECIAL_STATES.length; i$1++) {
		var stateName = SPECIAL_STATES[i$1];
		statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
	}
	return statesModels;
}

//#endregion
//#region node_modules/echarts/lib/label/labelLayoutHelper.js
var LABEL_LAYOUT_BASE_PROPS = [
	"label",
	"labelLine",
	"layoutOption",
	"priority",
	"defaultAttr",
	"marginForce",
	"minMarginForce",
	"marginDefault",
	"suggestIgnore"
];
var LABEL_LAYOUT_DIRTY_BIT_OTHERS = 1;
var LABEL_LAYOUT_DIRTY_BIT_OBB = 2;
var LABEL_LAYOUT_DIRTY_ALL = LABEL_LAYOUT_DIRTY_BIT_OTHERS | LABEL_LAYOUT_DIRTY_BIT_OBB;
function setLabelLayoutDirty(labelGeometry, dirtyOrClear, dirtyBits) {
	dirtyBits = dirtyBits || LABEL_LAYOUT_DIRTY_ALL;
	dirtyOrClear ? labelGeometry.dirty |= dirtyBits : labelGeometry.dirty &= ~dirtyBits;
}
function isLabelLayoutDirty(labelGeometry, dirtyBits) {
	dirtyBits = dirtyBits || LABEL_LAYOUT_DIRTY_ALL;
	return labelGeometry.dirty == null || !!(labelGeometry.dirty & dirtyBits);
}
/**
* [CAUTION]
*  - No auto dirty propagation mechanism yet. If the transform of the raw label or any of its ancestors is
*    changed, must sync the changes to the props of `LabelGeometry` by:
*    either explicitly call:
*      `setLabelLayoutDirty(labelLayout, true); ensureLabelLayoutWithGeometry(labelLayout);`
*    or call (if only translation is performed):
*      `labelLayoutApplyTranslation(labelLayout);`
*  - `label.ignore` is not necessarily falsy, and not considered in computing `LabelGeometry`,
*    since it might be modified by some overlap resolving handling.
*  - To duplicate or make a variation:
*    use `newLabelLayoutWithGeometry`.
*
* The result can also be the input of this method.
* @return `NullUndefined` if and only if `labelLayout` is `NullUndefined`.
*/
function ensureLabelLayoutWithGeometry(labelLayout$1) {
	if (!labelLayout$1) return;
	if (isLabelLayoutDirty(labelLayout$1)) computeLabelGeometry(labelLayout$1, labelLayout$1.label, labelLayout$1);
	return labelLayout$1;
}
/**
* The props in `out` will be filled if existing, or created.
*/
function computeLabelGeometry(out$1, label, opt) {
	var rawTransform = label.getComputedTransform();
	out$1.transform = ensureCopyTransform(out$1.transform, rawTransform);
	var outLocalRect = out$1.localRect = ensureCopyRect(out$1.localRect, label.getBoundingRect());
	var labelStyleExt = label.style;
	var margin = labelStyleExt.margin;
	var marginForce = opt && opt.marginForce;
	var minMarginForce = opt && opt.minMarginForce;
	var marginDefault = opt && opt.marginDefault;
	var marginType = labelStyleExt.__marginType;
	if (marginType == null && marginDefault) {
		margin = marginDefault;
		marginType = LabelMarginType.textMargin;
	}
	for (var i$1 = 0; i$1 < 4; i$1++) _tmpLabelMargin[i$1] = marginType === LabelMarginType.minMargin && minMarginForce && minMarginForce[i$1] != null ? minMarginForce[i$1] : marginForce && marginForce[i$1] != null ? marginForce[i$1] : margin ? margin[i$1] : 0;
	if (marginType === LabelMarginType.textMargin) expandOrShrinkRect(outLocalRect, _tmpLabelMargin, false, false);
	var outGlobalRect = out$1.rect = ensureCopyRect(out$1.rect, outLocalRect);
	if (rawTransform) outGlobalRect.applyTransform(rawTransform);
	if (marginType === LabelMarginType.minMargin) expandOrShrinkRect(outGlobalRect, _tmpLabelMargin, false, false);
	out$1.axisAligned = isBoundingRectAxisAligned(rawTransform);
	(out$1.label = out$1.label || {}).ignore = label.ignore;
	setLabelLayoutDirty(out$1, false);
	setLabelLayoutDirty(out$1, true, LABEL_LAYOUT_DIRTY_BIT_OBB);
	return out$1;
}
var _tmpLabelMargin = [
	0,
	0,
	0,
	0
];
/**
* The props in `out` will be filled if existing, or created.
*/
function computeLabelGeometry2(out$1, rawLocalRect, rawTransform) {
	out$1.transform = ensureCopyTransform(out$1.transform, rawTransform);
	out$1.localRect = ensureCopyRect(out$1.localRect, rawLocalRect);
	out$1.rect = ensureCopyRect(out$1.rect, rawLocalRect);
	if (rawTransform) out$1.rect.applyTransform(rawTransform);
	out$1.axisAligned = isBoundingRectAxisAligned(rawTransform);
	out$1.obb = void 0;
	(out$1.label = out$1.label || {}).ignore = false;
	return out$1;
}
/**
* This is a shortcut of
*   ```js
*   labelLayout.label.x = newX;
*   labelLayout.label.y = newY;
*   setLabelLayoutDirty(labelLayout, true);
*   ensureLabelLayoutWithGeometry(labelLayout);
*   ```
* and provide better performance in this common case.
*/
function labelLayoutApplyTranslation(labelLayout$1, offset) {
	if (!labelLayout$1) return;
	labelLayout$1.label.x += offset.x;
	labelLayout$1.label.y += offset.y;
	labelLayout$1.label.markRedraw();
	var transform = labelLayout$1.transform;
	if (transform) {
		transform[4] += offset.x;
		transform[5] += offset.y;
	}
	var globalRect = labelLayout$1.rect;
	if (globalRect) {
		globalRect.x += offset.x;
		globalRect.y += offset.y;
	}
	var obb = labelLayout$1.obb;
	if (obb) obb.fromBoundingRect(labelLayout$1.localRect, transform);
}
/**
* To duplicate or make a variation of a label layout.
* Copy the only relevant properties to avoid the conflict or wrongly reuse of the props of `LabelLayoutWithGeometry`.
*/
function newLabelLayoutWithGeometry(newBaseWithDefaults, source) {
	for (var i$1 = 0; i$1 < LABEL_LAYOUT_BASE_PROPS.length; i$1++) {
		var prop = LABEL_LAYOUT_BASE_PROPS[i$1];
		if (newBaseWithDefaults[prop] == null) newBaseWithDefaults[prop] = source[prop];
	}
	return ensureLabelLayoutWithGeometry(newBaseWithDefaults);
}
/**
* Create obb if no one, can cache it.
*/
function ensureOBB(labelGeometry) {
	var obb = labelGeometry.obb;
	if (!obb || isLabelLayoutDirty(labelGeometry, LABEL_LAYOUT_DIRTY_BIT_OBB)) {
		labelGeometry.obb = obb = obb || new OrientedBoundingRect_default();
		obb.fromBoundingRect(labelGeometry.localRect, labelGeometry.transform);
		setLabelLayoutDirty(labelGeometry, false, LABEL_LAYOUT_DIRTY_BIT_OBB);
	}
	return obb;
}
/**
* Adjust labels on x/y direction to avoid overlap.
*
* PENDING: the current implementation is based on the global bounding rect rather than the local rect,
*  which may be not preferable in some edge cases when the label has rotation, but works for most cases,
*  since rotation is unnecessary when there is sufficient space, while squeezing is applied regardless
*  of overlapping when there is no enough space.
*
* NOTICE:
*  - The input `list` and its content will be modified (sort, label.x/y, rect).
*  - The caller should sync the modifications to the other parts by
*    `setLabelLayoutDirty` and `ensureLabelLayoutWithGeometry` if needed.
*
* @return adjusted
*/
function shiftLayoutOnXY(list, xyDimIdx, minBound, maxBound, balanceShift) {
	var len$1 = list.length;
	var xyDim = XY[xyDimIdx];
	var sizeDim = WH[xyDimIdx];
	if (len$1 < 2) return false;
	list.sort(function(a, b) {
		return a.rect[xyDim] - b.rect[xyDim];
	});
	var lastPos = 0;
	var delta;
	var adjusted = false;
	var totalShifts = 0;
	for (var i$1 = 0; i$1 < len$1; i$1++) {
		var item = list[i$1];
		var rect = item.rect;
		delta = rect[xyDim] - lastPos;
		if (delta < 0) {
			rect[xyDim] -= delta;
			item.label[xyDim] -= delta;
			adjusted = true;
		}
		var shift = Math.max(-delta, 0);
		totalShifts += shift;
		lastPos = rect[xyDim] + rect[sizeDim];
	}
	if (totalShifts > 0 && balanceShift) shiftList(-totalShifts / len$1, 0, len$1);
	var first = list[0];
	var last = list[len$1 - 1];
	var minGap;
	var maxGap;
	updateMinMaxGap();
	minGap < 0 && squeezeGaps(-minGap, .8);
	maxGap < 0 && squeezeGaps(maxGap, .8);
	updateMinMaxGap();
	takeBoundsGap(minGap, maxGap, 1);
	takeBoundsGap(maxGap, minGap, -1);
	updateMinMaxGap();
	if (minGap < 0) squeezeWhenBailout(-minGap);
	if (maxGap < 0) squeezeWhenBailout(maxGap);
	function updateMinMaxGap() {
		minGap = first.rect[xyDim] - minBound;
		maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];
	}
	function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
		if (gapThisBound < 0) {
			var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
			if (moveFromMaxGap > 0) {
				shiftList(moveFromMaxGap * moveDir, 0, len$1);
				var remained = moveFromMaxGap + gapThisBound;
				if (remained < 0) squeezeGaps(-remained * moveDir, 1);
			} else squeezeGaps(-gapThisBound * moveDir, 1);
		}
	}
	function shiftList(delta$1, start$1, end$1) {
		if (delta$1 !== 0) adjusted = true;
		for (var i$2 = start$1; i$2 < end$1; i$2++) {
			var item$1 = list[i$2];
			var rect$1 = item$1.rect;
			rect$1[xyDim] += delta$1;
			item$1.label[xyDim] += delta$1;
		}
	}
	function squeezeGaps(delta$1, maxSqeezePercent) {
		var gaps = [];
		var totalGaps = 0;
		for (var i$2 = 1; i$2 < len$1; i$2++) {
			var prevItemRect = list[i$2 - 1].rect;
			var gap = Math.max(list[i$2].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
			gaps.push(gap);
			totalGaps += gap;
		}
		if (!totalGaps) return;
		var squeezePercent = Math.min(Math.abs(delta$1) / totalGaps, maxSqeezePercent);
		if (delta$1 > 0) for (var i$2 = 0; i$2 < len$1 - 1; i$2++) {
			var movement = gaps[i$2] * squeezePercent;
			shiftList(movement, 0, i$2 + 1);
		}
		else for (var i$2 = len$1 - 1; i$2 > 0; i$2--) {
			var movement = gaps[i$2 - 1] * squeezePercent;
			shiftList(-movement, i$2, len$1);
		}
	}
	/**
	* Squeeze to allow overlap if there is no more space available.
	* Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.
	*/
	function squeezeWhenBailout(delta$1) {
		var dir$1 = delta$1 < 0 ? -1 : 1;
		delta$1 = Math.abs(delta$1);
		var moveForEachLabel = Math.ceil(delta$1 / (len$1 - 1));
		for (var i$2 = 0; i$2 < len$1 - 1; i$2++) {
			if (dir$1 > 0) shiftList(moveForEachLabel, 0, i$2 + 1);
			else shiftList(-moveForEachLabel, len$1 - i$2 - 1, len$1);
			delta$1 -= moveForEachLabel;
			if (delta$1 <= 0) return;
		}
	}
	return adjusted;
}
/**
* @see `SavedLabelAttr` in `LabelManager.ts`
* @see `hideOverlap`
*/
function restoreIgnore(labelList) {
	for (var i$1 = 0; i$1 < labelList.length; i$1++) {
		var labelItem = labelList[i$1];
		var defaultAttr = labelItem.defaultAttr;
		var labelLine = labelItem.labelLine;
		labelItem.label.attr("ignore", defaultAttr.ignore);
		labelLine && labelLine.attr("ignore", defaultAttr.labelGuideIgnore);
	}
}
/**
* [NOTICE - restore]:
*  'series:layoutlabels' may be triggered during some shortcut passes, such as zooming in series.graph/geo
*  (`updateLabelLayout`), where the modified `Element` props should be restorable from `defaultAttr`.
*  @see `SavedLabelAttr` in `LabelManager.ts`
*  `restoreIgnore` can be called to perform the restore, if needed.
*
* [NOTICE - state]:
*  Regarding Element's states, this method is only designed for the normal state.
*  PENDING: although currently this method is effectively called in other states in `updateLabelLayout` case,
*      the bad case is not noticeable in the zooming scenario.
*/
function hideOverlap(labelList) {
	var displayedLabels = [];
	labelList.sort(function(a, b) {
		return (b.suggestIgnore ? 1 : 0) - (a.suggestIgnore ? 1 : 0) || b.priority - a.priority;
	});
	function hideEl(el) {
		if (!el.ignore) {
			var emphasisState = el.ensureState("emphasis");
			if (emphasisState.ignore == null) emphasisState.ignore = false;
		}
		el.ignore = true;
	}
	for (var i$1 = 0; i$1 < labelList.length; i$1++) {
		var labelItem = ensureLabelLayoutWithGeometry(labelList[i$1]);
		if (labelItem.label.ignore) continue;
		var label = labelItem.label;
		var labelLine = labelItem.labelLine;
		var overlapped = false;
		for (var j = 0; j < displayedLabels.length; j++) if (labelIntersect(labelItem, displayedLabels[j], null, { touchThreshold: .05 })) {
			overlapped = true;
			break;
		}
		if (overlapped) {
			hideEl(label);
			labelLine && hideEl(labelLine);
		} else displayedLabels.push(labelItem);
	}
}
/**
* Enable fast check for performance; use obb if inevitable.
* If `mtv` is used, `targetLayoutInfo` can be moved based on the values filled into `mtv`.
*
* This method is based only on the current `Element` states (regardless of other states).
* Typically this method (and the entire layout process) is performed in normal state.
*/
function labelIntersect(baseLayoutInfo, targetLayoutInfo, mtv, intersectOpt) {
	if (!baseLayoutInfo || !targetLayoutInfo) return false;
	if (baseLayoutInfo.label && baseLayoutInfo.label.ignore || targetLayoutInfo.label && targetLayoutInfo.label.ignore) return false;
	if (!baseLayoutInfo.rect.intersect(targetLayoutInfo.rect, mtv, intersectOpt)) return false;
	if (baseLayoutInfo.axisAligned && targetLayoutInfo.axisAligned) return true;
	return ensureOBB(baseLayoutInfo).intersect(ensureOBB(targetLayoutInfo), mtv, intersectOpt);
}

//#endregion
//#region node_modules/echarts/lib/label/LabelManager.js
function cloneArr(points$3) {
	if (points$3) {
		var newPoints = [];
		for (var i$1 = 0; i$1 < points$3.length; i$1++) newPoints.push(points$3[i$1].slice());
		return newPoints;
	}
}
function prepareLayoutCallbackParams(labelItem, hostEl) {
	var label = labelItem.label;
	var labelLine = hostEl && hostEl.getTextGuideLine();
	return {
		dataIndex: labelItem.dataIndex,
		dataType: labelItem.dataType,
		seriesIndex: labelItem.seriesModel.seriesIndex,
		text: labelItem.label.style.text,
		rect: labelItem.hostRect,
		labelRect: labelItem.rect,
		align: label.style.align,
		verticalAlign: label.style.verticalAlign,
		labelLinePoints: cloneArr(labelLine && labelLine.shape.points)
	};
}
var LABEL_OPTION_TO_STYLE_KEYS = [
	"align",
	"verticalAlign",
	"width",
	"height",
	"fontSize"
];
var dummyTransformable = new Transformable_default();
var labelLayoutInnerStore = makeInner();
var labelLineAnimationStore = makeInner();
function extendWithKeys(target, source, keys$1) {
	for (var i$1 = 0; i$1 < keys$1.length; i$1++) {
		var key$1 = keys$1[i$1];
		if (source[key$1] != null) target[key$1] = source[key$1];
	}
}
var LABEL_LAYOUT_PROPS = [
	"x",
	"y",
	"rotation"
];
var LabelManager = function() {
	function LabelManager$1() {
		this._labelList = [];
		this._chartViewList = [];
	}
	LabelManager$1.prototype.clearLabels = function() {
		this._labelList = [];
		this._chartViewList = [];
	};
	/**
	* Add label to manager
	*/
	LabelManager$1.prototype._addLabel = function(dataIndex, dataType, seriesModel, label, layoutOptionOrCb) {
		var labelStyle = label.style;
		var textConfig = label.__hostTarget.textConfig || {};
		var labelTransform = label.getComputedTransform();
		var labelRect = label.getBoundingRect().plain();
		BoundingRect_default.applyTransform(labelRect, labelRect, labelTransform);
		if (labelTransform) dummyTransformable.setLocalTransform(labelTransform);
		else {
			dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;
			dummyTransformable.scaleX = dummyTransformable.scaleY = 1;
		}
		dummyTransformable.rotation = normalizeRadian(dummyTransformable.rotation);
		var host = label.__hostTarget;
		var hostRect;
		if (host) {
			hostRect = host.getBoundingRect().plain();
			var transform = host.getComputedTransform();
			BoundingRect_default.applyTransform(hostRect, hostRect, transform);
		}
		var labelGuide = hostRect && host.getTextGuideLine();
		this._labelList.push({
			label,
			labelLine: labelGuide,
			seriesModel,
			dataIndex,
			dataType,
			layoutOptionOrCb,
			layoutOption: null,
			rect: labelRect,
			hostRect,
			priority: hostRect ? hostRect.width * hostRect.height : 0,
			defaultAttr: {
				ignore: label.ignore,
				labelGuideIgnore: labelGuide && labelGuide.ignore,
				x: dummyTransformable.x,
				y: dummyTransformable.y,
				scaleX: dummyTransformable.scaleX,
				scaleY: dummyTransformable.scaleY,
				rotation: dummyTransformable.rotation,
				style: {
					x: labelStyle.x,
					y: labelStyle.y,
					align: labelStyle.align,
					verticalAlign: labelStyle.verticalAlign,
					width: labelStyle.width,
					height: labelStyle.height,
					fontSize: labelStyle.fontSize
				},
				cursor: label.cursor,
				attachedPos: textConfig.position,
				attachedRot: textConfig.rotation
			}
		});
	};
	LabelManager$1.prototype.addLabelsOfSeries = function(chartView) {
		var _this = this;
		this._chartViewList.push(chartView);
		var seriesModel = chartView.__model;
		var layoutOption = seriesModel.get("labelLayout");
		/**
		* Ignore layouting if it's not specified anything.
		*/
		if (!(isFunction(layoutOption) || keys(layoutOption).length)) return;
		chartView.group.traverse(function(child) {
			if (child.ignore) return true;
			var textEl = child.getTextContent();
			var ecData = getECData(child);
			if (textEl && !textEl.disableLabelLayout) _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);
		});
	};
	LabelManager$1.prototype.updateLayoutConfig = function(api) {
		var width = api.getWidth();
		var height = api.getHeight();
		function createDragHandler(el, labelLineModel) {
			return function() {
				updateLabelLinePoints(el, labelLineModel);
			};
		}
		for (var i$1 = 0; i$1 < this._labelList.length; i$1++) {
			var labelItem = this._labelList[i$1];
			var label = labelItem.label;
			var hostEl = label.__hostTarget;
			var defaultLabelAttr = labelItem.defaultAttr;
			var layoutOption = void 0;
			if (isFunction(labelItem.layoutOptionOrCb)) layoutOption = labelItem.layoutOptionOrCb(prepareLayoutCallbackParams(labelItem, hostEl));
			else layoutOption = labelItem.layoutOptionOrCb;
			layoutOption = layoutOption || {};
			labelItem.layoutOption = layoutOption;
			var degreeToRadian = Math.PI / 180;
			if (hostEl) hostEl.setTextConfig({
				local: false,
				position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,
				rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,
				offset: [layoutOption.dx || 0, layoutOption.dy || 0]
			});
			var needsUpdateLabelLine = false;
			if (layoutOption.x != null) {
				label.x = parsePercent$1(layoutOption.x, width);
				label.setStyle("x", 0);
				needsUpdateLabelLine = true;
			} else {
				label.x = defaultLabelAttr.x;
				label.setStyle("x", defaultLabelAttr.style.x);
			}
			if (layoutOption.y != null) {
				label.y = parsePercent$1(layoutOption.y, height);
				label.setStyle("y", 0);
				needsUpdateLabelLine = true;
			} else {
				label.y = defaultLabelAttr.y;
				label.setStyle("y", defaultLabelAttr.style.y);
			}
			if (layoutOption.labelLinePoints) {
				var guideLine = hostEl.getTextGuideLine();
				if (guideLine) {
					guideLine.setShape({ points: layoutOption.labelLinePoints });
					needsUpdateLabelLine = false;
				}
			}
			var labelLayoutStore = labelLayoutInnerStore(label);
			labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;
			label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;
			label.scaleX = defaultLabelAttr.scaleX;
			label.scaleY = defaultLabelAttr.scaleY;
			for (var k$1 = 0; k$1 < LABEL_OPTION_TO_STYLE_KEYS.length; k$1++) {
				var key$1 = LABEL_OPTION_TO_STYLE_KEYS[k$1];
				label.setStyle(key$1, layoutOption[key$1] != null ? layoutOption[key$1] : defaultLabelAttr.style[key$1]);
			}
			if (layoutOption.draggable) {
				label.draggable = true;
				label.cursor = "move";
				if (hostEl) {
					var hostModel = labelItem.seriesModel;
					if (labelItem.dataIndex != null) hostModel = labelItem.seriesModel.getData(labelItem.dataType).getItemModel(labelItem.dataIndex);
					label.on("drag", createDragHandler(hostEl, hostModel.getModel("labelLine")));
				}
			} else {
				label.off("drag");
				label.cursor = defaultLabelAttr.cursor;
			}
		}
	};
	LabelManager$1.prototype.layout = function(api) {
		var width = api.getWidth();
		var height = api.getHeight();
		var labelList = [];
		each(this._labelList, function(inputItem) {
			if (!inputItem.defaultAttr.ignore) labelList.push(newLabelLayoutWithGeometry({}, inputItem));
		});
		var labelsNeedsAdjustOnX = filter(labelList, function(item) {
			return item.layoutOption.moveOverlap === "shiftX";
		});
		var labelsNeedsAdjustOnY = filter(labelList, function(item) {
			return item.layoutOption.moveOverlap === "shiftY";
		});
		shiftLayoutOnXY(labelsNeedsAdjustOnX, 0, 0, width);
		shiftLayoutOnXY(labelsNeedsAdjustOnY, 1, 0, height);
		var labelsNeedsHideOverlap = filter(labelList, function(item) {
			return item.layoutOption.hideOverlap;
		});
		restoreIgnore(labelsNeedsHideOverlap);
		hideOverlap(labelsNeedsHideOverlap);
	};
	/**
	* Process all labels. Not only labels with layoutOption.
	*/
	LabelManager$1.prototype.processLabelsOverall = function() {
		var _this = this;
		each(this._chartViewList, function(chartView) {
			var seriesModel = chartView.__model;
			var ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;
			var animationEnabled = seriesModel.isAnimationEnabled();
			chartView.group.traverse(function(child) {
				if (child.ignore && !child.forceLabelAnimation) return true;
				var needsUpdateLabelLine = !ignoreLabelLineUpdate;
				var label = child.getTextContent();
				if (!needsUpdateLabelLine && label) needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;
				if (needsUpdateLabelLine) _this._updateLabelLine(child, seriesModel);
				if (animationEnabled) _this._animateLabels(child, seriesModel);
			});
		});
	};
	LabelManager$1.prototype._updateLabelLine = function(el, seriesModel) {
		var textEl = el.getTextContent();
		var ecData = getECData(el);
		var dataIndex = ecData.dataIndex;
		if (textEl && dataIndex != null) {
			var data = seriesModel.getData(ecData.dataType);
			var itemModel = data.getItemModel(dataIndex);
			var defaultStyle = {};
			var visualStyle = data.getItemVisual(dataIndex, "style");
			if (visualStyle) defaultStyle.stroke = visualStyle[data.getVisual("drawType")];
			var labelLineModel = itemModel.getModel("labelLine");
			setLabelLineStyle(el, getLabelLineStatesModels(itemModel), defaultStyle);
			updateLabelLinePoints(el, labelLineModel);
		}
	};
	LabelManager$1.prototype._animateLabels = function(el, seriesModel) {
		var textEl = el.getTextContent();
		var guideLine = el.getTextGuideLine();
		if (textEl && (el.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !isElementRemoved(el))) {
			var layoutStore = labelLayoutInnerStore(textEl);
			var oldLayout = layoutStore.oldLayout;
			var ecData = getECData(el);
			var dataIndex = ecData.dataIndex;
			var newProps = {
				x: textEl.x,
				y: textEl.y,
				rotation: textEl.rotation
			};
			var data = seriesModel.getData(ecData.dataType);
			if (!oldLayout) {
				textEl.attr(newProps);
				if (!labelInner(textEl).valueAnimation) {
					var oldOpacity = retrieve2(textEl.style.opacity, 1);
					textEl.style.opacity = 0;
					initProps(textEl, { style: { opacity: oldOpacity } }, seriesModel, dataIndex);
				}
			} else {
				textEl.attr(oldLayout);
				var prevStates = el.prevStates;
				if (prevStates) {
					if (indexOf(prevStates, "select") >= 0) textEl.attr(layoutStore.oldLayoutSelect);
					if (indexOf(prevStates, "emphasis") >= 0) textEl.attr(layoutStore.oldLayoutEmphasis);
				}
				updateProps(textEl, newProps, seriesModel, dataIndex);
			}
			layoutStore.oldLayout = newProps;
			if (textEl.states.select) {
				var layoutSelect = layoutStore.oldLayoutSelect = {};
				extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);
				extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);
			}
			if (textEl.states.emphasis) {
				var layoutEmphasis = layoutStore.oldLayoutEmphasis = {};
				extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);
				extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);
			}
			animateLabelValue(textEl, dataIndex, data, seriesModel, seriesModel);
		}
		if (guideLine && !guideLine.ignore && !guideLine.invisible) {
			var layoutStore = labelLineAnimationStore(guideLine);
			var oldLayout = layoutStore.oldLayout;
			var newLayout = { points: guideLine.shape.points };
			if (!oldLayout) {
				guideLine.setShape(newLayout);
				guideLine.style.strokePercent = 0;
				initProps(guideLine, { style: { strokePercent: 1 } }, seriesModel);
			} else {
				guideLine.attr({ shape: oldLayout });
				updateProps(guideLine, { shape: newLayout }, seriesModel);
			}
			layoutStore.oldLayout = newLayout;
		}
	};
	return LabelManager$1;
}();
var LabelManager_default = LabelManager;

//#endregion
//#region node_modules/echarts/lib/label/installLabelLayout.js
var getLabelManager = makeInner();
function installLabelLayout(registers) {
	registers.registerUpdateLifecycle("series:beforeupdate", function(ecModel, api, params) {
		var labelManager = getLabelManager(api).labelManager;
		if (!labelManager) labelManager = getLabelManager(api).labelManager = new LabelManager_default();
		labelManager.clearLabels();
	});
	registers.registerUpdateLifecycle("series:layoutlabels", function(ecModel, api, params) {
		var labelManager = getLabelManager(api).labelManager;
		params.updatedSeries.forEach(function(series) {
			labelManager.addLabelsOfSeries(api.getViewOfSeriesModel(series));
		});
		labelManager.updateLayoutConfig(api);
		labelManager.layout(api);
		labelManager.processLabelsOverall();
	});
}

//#endregion
//#region node_modules/zrender/lib/svg/SVGPathRebuilder.js
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI$4 = Math.PI;
var PI2$1 = Math.PI * 2;
var degree = 180 / PI$4;
var SVGPathRebuilder = function() {
	function SVGPathRebuilder$1() {}
	SVGPathRebuilder$1.prototype.reset = function(precision) {
		this._start = true;
		this._d = [];
		this._str = "";
		this._p = Math.pow(10, precision || 4);
	};
	SVGPathRebuilder$1.prototype.moveTo = function(x, y) {
		this._add("M", x, y);
	};
	SVGPathRebuilder$1.prototype.lineTo = function(x, y) {
		this._add("L", x, y);
	};
	SVGPathRebuilder$1.prototype.bezierCurveTo = function(x, y, x2, y2, x3, y3) {
		this._add("C", x, y, x2, y2, x3, y3);
	};
	SVGPathRebuilder$1.prototype.quadraticCurveTo = function(x, y, x2, y2) {
		this._add("Q", x, y, x2, y2);
	};
	SVGPathRebuilder$1.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
		this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);
	};
	SVGPathRebuilder$1.prototype.ellipse = function(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {
		var dTheta = endAngle - startAngle;
		var clockwise = !anticlockwise;
		var dThetaPositive = Math.abs(dTheta);
		var isCircle = isAroundZero(dThetaPositive - PI2$1) || (clockwise ? dTheta >= PI2$1 : -dTheta >= PI2$1);
		var unifiedTheta = dTheta > 0 ? dTheta % PI2$1 : dTheta % PI2$1 + PI2$1;
		var large = false;
		if (isCircle) large = true;
		else if (isAroundZero(dThetaPositive)) large = false;
		else large = unifiedTheta >= PI$4 === !!clockwise;
		var x0 = cx + rx * mathCos(startAngle);
		var y0 = cy + ry * mathSin(startAngle);
		if (this._start) this._add("M", x0, y0);
		var xRot = Math.round(psi * degree);
		if (isCircle) {
			var p = 1 / this._p;
			var dTheta_1 = (clockwise ? 1 : -1) * (PI2$1 - p);
			this._add("A", rx, ry, xRot, 1, +clockwise, cx + rx * mathCos(startAngle + dTheta_1), cy + ry * mathSin(startAngle + dTheta_1));
			if (p > .01) this._add("A", rx, ry, xRot, 0, +clockwise, x0, y0);
		} else {
			var x = cx + rx * mathCos(endAngle);
			var y = cy + ry * mathSin(endAngle);
			this._add("A", rx, ry, xRot, +large, +clockwise, x, y);
		}
	};
	SVGPathRebuilder$1.prototype.rect = function(x, y, w, h) {
		this._add("M", x, y);
		this._add("l", w, 0);
		this._add("l", 0, h);
		this._add("l", -w, 0);
		this._add("Z");
	};
	SVGPathRebuilder$1.prototype.closePath = function() {
		if (this._d.length > 0) this._add("Z");
	};
	SVGPathRebuilder$1.prototype._add = function(cmd, a, b, c, d, e$1, f, g, h) {
		var vals = [];
		var p = this._p;
		for (var i$1 = 1; i$1 < arguments.length; i$1++) {
			var val = arguments[i$1];
			if (isNaN(val)) {
				this._invalid = true;
				return;
			}
			vals.push(Math.round(val * p) / p);
		}
		this._d.push(cmd + vals.join(" "));
		this._start = cmd === "Z";
	};
	SVGPathRebuilder$1.prototype.generateStr = function() {
		this._str = this._invalid ? "" : this._d.join("");
		this._d = [];
	};
	SVGPathRebuilder$1.prototype.getStr = function() {
		return this._str;
	};
	return SVGPathRebuilder$1;
}();
var SVGPathRebuilder_default = SVGPathRebuilder;

//#endregion
//#region node_modules/zrender/lib/svg/mapStyleToAttrs.js
var NONE = "none";
var mathRound = Math.round;
function pathHasFill(style) {
	var fill = style.fill;
	return fill != null && fill !== NONE;
}
function pathHasStroke(style) {
	var stroke = style.stroke;
	return stroke != null && stroke !== NONE;
}
var strokeProps = [
	"lineCap",
	"miterLimit",
	"lineJoin"
];
var svgStrokeProps = map(strokeProps, function(prop) {
	return "stroke-" + prop.toLowerCase();
});
function mapStyleToAttrs(updateAttr$1, style, el, forceUpdate) {
	var opacity = style.opacity == null ? 1 : style.opacity;
	if (el instanceof Image_default) {
		updateAttr$1("opacity", opacity);
		return;
	}
	if (pathHasFill(style)) {
		var fill = normalizeColor(style.fill);
		updateAttr$1("fill", fill.color);
		var fillOpacity = style.fillOpacity != null ? style.fillOpacity * fill.opacity * opacity : fill.opacity * opacity;
		if (forceUpdate || fillOpacity < 1) updateAttr$1("fill-opacity", fillOpacity);
	} else updateAttr$1("fill", NONE);
	if (pathHasStroke(style)) {
		var stroke = normalizeColor(style.stroke);
		updateAttr$1("stroke", stroke.color);
		var strokeScale = style.strokeNoScale ? el.getLineScale() : 1;
		var strokeWidth = strokeScale ? (style.lineWidth || 0) / strokeScale : 0;
		var strokeOpacity = style.strokeOpacity != null ? style.strokeOpacity * stroke.opacity * opacity : stroke.opacity * opacity;
		var strokeFirst = style.strokeFirst;
		if (forceUpdate || strokeWidth !== 1) updateAttr$1("stroke-width", strokeWidth);
		if (forceUpdate || strokeFirst) updateAttr$1("paint-order", strokeFirst ? "stroke" : "fill");
		if (forceUpdate || strokeOpacity < 1) updateAttr$1("stroke-opacity", strokeOpacity);
		if (style.lineDash) {
			var _a$1 = getLineDash(el), lineDash = _a$1[0], lineDashOffset = _a$1[1];
			if (lineDash) {
				lineDashOffset = mathRound(lineDashOffset || 0);
				updateAttr$1("stroke-dasharray", lineDash.join(","));
				if (lineDashOffset || forceUpdate) updateAttr$1("stroke-dashoffset", lineDashOffset);
			}
		} else if (forceUpdate) updateAttr$1("stroke-dasharray", NONE);
		for (var i$1 = 0; i$1 < strokeProps.length; i$1++) {
			var propName = strokeProps[i$1];
			if (forceUpdate || style[propName] !== DEFAULT_PATH_STYLE[propName]) {
				var val = style[propName] || DEFAULT_PATH_STYLE[propName];
				val && updateAttr$1(svgStrokeProps[i$1], val);
			}
		}
	} else if (forceUpdate) updateAttr$1("stroke", NONE);
}

//#endregion
//#region node_modules/zrender/lib/svg/core.js
var SVGNS = "http://www.w3.org/2000/svg";
var XLINKNS = "http://www.w3.org/1999/xlink";
var XMLNS = "http://www.w3.org/2000/xmlns/";
var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
var META_DATA_PREFIX = "ecmeta_";
function createElement(name) {
	return document.createElementNS(SVGNS, name);
}
function createVNode(tag, key$1, attrs, children, text) {
	return {
		tag,
		attrs: attrs || {},
		children,
		text,
		key: key$1
	};
}
function createElementOpen(name, attrs) {
	var attrsStr = [];
	if (attrs) for (var key$1 in attrs) {
		var val = attrs[key$1];
		var part = key$1;
		if (val === false) continue;
		else if (val !== true && val != null) part += "=\"" + val + "\"";
		attrsStr.push(part);
	}
	return "<" + name + " " + attrsStr.join(" ") + ">";
}
function createElementClose(name) {
	return "</" + name + ">";
}
function vNodeToString(el, opts) {
	opts = opts || {};
	var S = opts.newline ? "\n" : "";
	function convertElToString(el$1) {
		var children = el$1.children, tag = el$1.tag, attrs = el$1.attrs, text = el$1.text;
		return createElementOpen(tag, attrs) + (tag !== "style" ? encodeHTML(text) : text || "") + (children ? "" + S + map(children, function(child) {
			return convertElToString(child);
		}).join(S) + S : "") + createElementClose(tag);
	}
	return convertElToString(el);
}
function getCssString(selectorNodes, animationNodes, opts) {
	opts = opts || {};
	var S = opts.newline ? "\n" : "";
	var bracketBegin = " {" + S;
	var bracketEnd = S + "}";
	var selectors = map(keys(selectorNodes), function(className) {
		return className + bracketBegin + map(keys(selectorNodes[className]), function(attrName) {
			return attrName + ":" + selectorNodes[className][attrName] + ";";
		}).join(S) + bracketEnd;
	}).join(S);
	var animations = map(keys(animationNodes), function(animationName) {
		return "@keyframes " + animationName + bracketBegin + map(keys(animationNodes[animationName]), function(percent) {
			return percent + bracketBegin + map(keys(animationNodes[animationName][percent]), function(attrName) {
				var val = animationNodes[animationName][percent][attrName];
				if (attrName === "d") val = "path(\"" + val + "\")";
				return attrName + ":" + val + ";";
			}).join(S) + bracketEnd;
		}).join(S) + bracketEnd;
	}).join(S);
	if (!selectors && !animations) return "";
	return [
		"<![CDATA[",
		selectors,
		animations,
		"]]>"
	].join(S);
}
function createBrushScope(zrId) {
	return {
		zrId,
		shadowCache: {},
		patternCache: {},
		gradientCache: {},
		clipPathCache: {},
		defs: {},
		cssNodes: {},
		cssAnims: {},
		cssStyleCache: {},
		cssAnimIdx: 0,
		shadowIdx: 0,
		gradientIdx: 0,
		patternIdx: 0,
		clipPathIdx: 0
	};
}
function createSVGVNode(width, height, children, useViewBox) {
	return createVNode("svg", "root", {
		"width": width,
		"height": height,
		"xmlns": SVGNS,
		"xmlns:xlink": XLINKNS,
		"version": "1.1",
		"baseProfile": "full",
		"viewBox": useViewBox ? "0 0 " + width + " " + height : false
	}, children);
}

//#endregion
//#region node_modules/zrender/lib/svg/cssClassId.js
var cssClassIdx = 0;
function getClassId() {
	return cssClassIdx++;
}

//#endregion
//#region node_modules/zrender/lib/svg/cssAnimation.js
var EASING_MAP = {
	cubicIn: "0.32,0,0.67,0",
	cubicOut: "0.33,1,0.68,1",
	cubicInOut: "0.65,0,0.35,1",
	quadraticIn: "0.11,0,0.5,0",
	quadraticOut: "0.5,1,0.89,1",
	quadraticInOut: "0.45,0,0.55,1",
	quarticIn: "0.5,0,0.75,0",
	quarticOut: "0.25,1,0.5,1",
	quarticInOut: "0.76,0,0.24,1",
	quinticIn: "0.64,0,0.78,0",
	quinticOut: "0.22,1,0.36,1",
	quinticInOut: "0.83,0,0.17,1",
	sinusoidalIn: "0.12,0,0.39,0",
	sinusoidalOut: "0.61,1,0.88,1",
	sinusoidalInOut: "0.37,0,0.63,1",
	exponentialIn: "0.7,0,0.84,0",
	exponentialOut: "0.16,1,0.3,1",
	exponentialInOut: "0.87,0,0.13,1",
	circularIn: "0.55,0,1,0.45",
	circularOut: "0,0.55,0.45,1",
	circularInOut: "0.85,0,0.15,1"
};
var transformOriginKey = "transform-origin";
function buildPathString(el, kfShape, path) {
	var shape = extend({}, el.shape);
	extend(shape, kfShape);
	el.buildPath(path, shape);
	var svgPathBuilder = new SVGPathRebuilder_default();
	svgPathBuilder.reset(getPathPrecision(el));
	path.rebuildPath(svgPathBuilder, 1);
	svgPathBuilder.generateStr();
	return svgPathBuilder.getStr();
}
function setTransformOrigin(target, transform) {
	var originX = transform.originX, originY = transform.originY;
	if (originX || originY) target[transformOriginKey] = originX + "px " + originY + "px";
}
var ANIMATE_STYLE_MAP = {
	fill: "fill",
	opacity: "opacity",
	lineWidth: "stroke-width",
	lineDashOffset: "stroke-dashoffset"
};
function addAnimation(cssAnim, scope) {
	var animationName = scope.zrId + "-ani-" + scope.cssAnimIdx++;
	scope.cssAnims[animationName] = cssAnim;
	return animationName;
}
function createCompoundPathCSSAnimation(el, attrs, scope) {
	var paths = el.shape.paths;
	var composedAnim = {};
	var cssAnimationCfg;
	var cssAnimationName;
	each(paths, function(path) {
		var subScope = createBrushScope(scope.zrId);
		subScope.animation = true;
		createCSSAnimation(path, {}, subScope, true);
		var cssAnims = subScope.cssAnims;
		var cssNodes = subScope.cssNodes;
		var animNames = keys(cssAnims);
		var len$1 = animNames.length;
		if (!len$1) return;
		cssAnimationName = animNames[len$1 - 1];
		var lastAnim = cssAnims[cssAnimationName];
		for (var percent in lastAnim) {
			var kf = lastAnim[percent];
			composedAnim[percent] = composedAnim[percent] || { d: "" };
			composedAnim[percent].d += kf.d || "";
		}
		for (var className in cssNodes) {
			var val = cssNodes[className].animation;
			if (val.indexOf(cssAnimationName) >= 0) cssAnimationCfg = val;
		}
	});
	if (!cssAnimationCfg) return;
	attrs.d = false;
	var animationName = addAnimation(composedAnim, scope);
	return cssAnimationCfg.replace(cssAnimationName, animationName);
}
function getEasingFunc(easing) {
	return isString(easing) ? EASING_MAP[easing] ? "cubic-bezier(" + EASING_MAP[easing] + ")" : createCubicEasingFunc(easing) ? easing : "" : "";
}
function createCSSAnimation(el, attrs, scope, onlyShape) {
	var animators = el.animators;
	var len$1 = animators.length;
	var cssAnimations = [];
	if (el instanceof CompoundPath_default) {
		var animationCfg = createCompoundPathCSSAnimation(el, attrs, scope);
		if (animationCfg) cssAnimations.push(animationCfg);
		else if (!len$1) return;
	} else if (!len$1) return;
	var groupAnimators = {};
	for (var i$1 = 0; i$1 < len$1; i$1++) {
		var animator = animators[i$1];
		var cfgArr = [animator.getMaxTime() / 1e3 + "s"];
		var easing = getEasingFunc(animator.getClip().easing);
		var delay = animator.getDelay();
		if (easing) cfgArr.push(easing);
		else cfgArr.push("linear");
		if (delay) cfgArr.push(delay / 1e3 + "s");
		if (animator.getLoop()) cfgArr.push("infinite");
		var cfg = cfgArr.join(" ");
		groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []];
		groupAnimators[cfg][1].push(animator);
	}
	function createSingleCSSAnimation(groupAnimator) {
		var animators$1 = groupAnimator[1];
		var len$2 = animators$1.length;
		var transformKfs = {};
		var shapeKfs = {};
		var finalKfs = {};
		var animationTimingFunctionAttrName = "animation-timing-function";
		function saveAnimatorTrackToCssKfs(animator$2, cssKfs, toCssAttrName) {
			var tracks = animator$2.getTracks();
			var maxTime = animator$2.getMaxTime();
			for (var k$1 = 0; k$1 < tracks.length; k$1++) {
				var track = tracks[k$1];
				if (track.needsAnimate()) {
					var kfs = track.keyframes;
					var attrName = track.propName;
					toCssAttrName && (attrName = toCssAttrName(attrName));
					if (attrName) for (var i$3 = 0; i$3 < kfs.length; i$3++) {
						var kf = kfs[i$3];
						var percent$1 = Math.round(kf.time / maxTime * 100) + "%";
						var kfEasing = getEasingFunc(kf.easing);
						var rawValue = kf.rawValue;
						if (isString(rawValue) || isNumber(rawValue)) {
							cssKfs[percent$1] = cssKfs[percent$1] || {};
							cssKfs[percent$1][attrName] = kf.rawValue;
							if (kfEasing) cssKfs[percent$1][animationTimingFunctionAttrName] = kfEasing;
						}
					}
				}
			}
		}
		for (var i$2 = 0; i$2 < len$2; i$2++) {
			var animator$1 = animators$1[i$2];
			var targetProp = animator$1.targetName;
			if (!targetProp) !onlyShape && saveAnimatorTrackToCssKfs(animator$1, transformKfs);
			else if (targetProp === "shape") saveAnimatorTrackToCssKfs(animator$1, shapeKfs);
		}
		for (var percent in transformKfs) {
			var transform = {};
			copyTransform(transform, el);
			extend(transform, transformKfs[percent]);
			var str = getSRTTransformString(transform);
			var timingFunction = transformKfs[percent][animationTimingFunctionAttrName];
			finalKfs[percent] = str ? { transform: str } : {};
			setTransformOrigin(finalKfs[percent], transform);
			if (timingFunction) finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
		}
		var path;
		var canAnimateShape = true;
		for (var percent in shapeKfs) {
			finalKfs[percent] = finalKfs[percent] || {};
			var isFirst = !path;
			var timingFunction = shapeKfs[percent][animationTimingFunctionAttrName];
			if (isFirst) path = new PathProxy_default();
			var len_1 = path.len();
			path.reset();
			finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path);
			var newLen = path.len();
			if (!isFirst && len_1 !== newLen) {
				canAnimateShape = false;
				break;
			}
			if (timingFunction) finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
		}
		if (!canAnimateShape) for (var percent in finalKfs) delete finalKfs[percent].d;
		if (!onlyShape) for (var i$2 = 0; i$2 < len$2; i$2++) {
			var animator$1 = animators$1[i$2];
			var targetProp = animator$1.targetName;
			if (targetProp === "style") saveAnimatorTrackToCssKfs(animator$1, finalKfs, function(propName) {
				return ANIMATE_STYLE_MAP[propName];
			});
		}
		var percents = keys(finalKfs);
		var allTransformOriginSame = true;
		var transformOrigin;
		for (var i$2 = 1; i$2 < percents.length; i$2++) {
			var p0 = percents[i$2 - 1];
			var p1 = percents[i$2];
			if (finalKfs[p0][transformOriginKey] !== finalKfs[p1][transformOriginKey]) {
				allTransformOriginSame = false;
				break;
			}
			transformOrigin = finalKfs[p0][transformOriginKey];
		}
		if (allTransformOriginSame && transformOrigin) {
			for (var percent in finalKfs) if (finalKfs[percent][transformOriginKey]) delete finalKfs[percent][transformOriginKey];
			attrs[transformOriginKey] = transformOrigin;
		}
		if (filter(percents, function(percent$1) {
			return keys(finalKfs[percent$1]).length > 0;
		}).length) return addAnimation(finalKfs, scope) + " " + groupAnimator[0] + " both";
	}
	for (var key$1 in groupAnimators) {
		var animationCfg = createSingleCSSAnimation(groupAnimators[key$1]);
		if (animationCfg) cssAnimations.push(animationCfg);
	}
	if (cssAnimations.length) {
		var className = scope.zrId + "-cls-" + getClassId();
		scope.cssNodes["." + className] = { animation: cssAnimations.join(",") };
		attrs["class"] = className;
	}
}

//#endregion
//#region node_modules/zrender/lib/svg/cssEmphasis.js
function createCSSEmphasis(el, attrs, scope) {
	if (!el.ignore) if (el.isSilent()) {
		var style = { "pointer-events": "none" };
		setClassAttribute(style, attrs, scope, true);
	} else {
		var emphasisStyle = el.states.emphasis && el.states.emphasis.style ? el.states.emphasis.style : {};
		var fill = emphasisStyle.fill;
		if (!fill) {
			var normalFill = el.style && el.style.fill;
			var selectFill = el.states.select && el.states.select.style && el.states.select.style.fill;
			var fromFill = el.currentStates.indexOf("select") >= 0 ? selectFill || normalFill : normalFill;
			if (fromFill) fill = liftColor(fromFill);
		}
		var lineWidth = emphasisStyle.lineWidth;
		if (lineWidth) {
			var scaleX = !emphasisStyle.strokeNoScale && el.transform ? el.transform[0] : 1;
			lineWidth = lineWidth / scaleX;
		}
		var style = { cursor: "pointer" };
		if (fill) style.fill = fill;
		if (emphasisStyle.stroke) style.stroke = emphasisStyle.stroke;
		if (lineWidth) style["stroke-width"] = lineWidth;
		setClassAttribute(style, attrs, scope, true);
	}
}
function setClassAttribute(style, attrs, scope, withHover) {
	var styleKey = JSON.stringify(style);
	var className = scope.cssStyleCache[styleKey];
	if (!className) {
		className = scope.zrId + "-cls-" + getClassId();
		scope.cssStyleCache[styleKey] = className;
		scope.cssNodes["." + className + (withHover ? ":hover" : "")] = style;
	}
	attrs["class"] = attrs["class"] ? attrs["class"] + " " + className : className;
}

//#endregion
//#region node_modules/zrender/lib/svg/graphic.js
var round$3 = Math.round;
function isImageLike(val) {
	return val && isString(val.src);
}
function isCanvasLike(val) {
	return val && isFunction(val.toDataURL);
}
function setStyleAttrs(attrs, style, el, scope) {
	mapStyleToAttrs(function(key$1, val) {
		var isFillStroke = key$1 === "fill" || key$1 === "stroke";
		if (isFillStroke && isGradient(val)) setGradient(style, attrs, key$1, scope);
		else if (isFillStroke && isPattern(val)) setPattern(el, attrs, key$1, scope);
		else attrs[key$1] = val;
		if (isFillStroke && scope.ssr && val === "none") attrs["pointer-events"] = "visible";
	}, style, el, false);
	setShadow(el, attrs, scope);
}
function setMetaData(attrs, el) {
	var metaData = getElementSSRData(el);
	if (metaData) {
		metaData.each(function(val, key$1) {
			val != null && (attrs[(META_DATA_PREFIX + key$1).toLowerCase()] = val + "");
		});
		if (el.isSilent()) attrs[META_DATA_PREFIX + "silent"] = "true";
	}
}
function noRotateScale(m$1) {
	return isAroundZero(m$1[0] - 1) && isAroundZero(m$1[1]) && isAroundZero(m$1[2]) && isAroundZero(m$1[3] - 1);
}
function noTranslate(m$1) {
	return isAroundZero(m$1[4]) && isAroundZero(m$1[5]);
}
function setTransform(attrs, m$1, compress) {
	if (m$1 && !(noTranslate(m$1) && noRotateScale(m$1))) {
		var mul$2 = compress ? 10 : 1e4;
		attrs.transform = noRotateScale(m$1) ? "translate(" + round$3(m$1[4] * mul$2) / mul$2 + " " + round$3(m$1[5] * mul$2) / mul$2 + ")" : getMatrixStr(m$1);
	}
}
function convertPolyShape(shape, attrs, mul$2) {
	var points$3 = shape.points;
	var strArr = [];
	for (var i$1 = 0; i$1 < points$3.length; i$1++) {
		strArr.push(round$3(points$3[i$1][0] * mul$2) / mul$2);
		strArr.push(round$3(points$3[i$1][1] * mul$2) / mul$2);
	}
	attrs.points = strArr.join(" ");
}
function validatePolyShape(shape) {
	return !shape.smooth;
}
function createAttrsConvert(desc) {
	var normalizedDesc = map(desc, function(item) {
		return typeof item === "string" ? [item, item] : item;
	});
	return function(shape, attrs, mul$2) {
		for (var i$1 = 0; i$1 < normalizedDesc.length; i$1++) {
			var item = normalizedDesc[i$1];
			var val = shape[item[0]];
			if (val != null) attrs[item[1]] = round$3(val * mul$2) / mul$2;
		}
	};
}
var builtinShapesDef = {
	circle: [createAttrsConvert([
		"cx",
		"cy",
		"r"
	])],
	polyline: [convertPolyShape, validatePolyShape],
	polygon: [convertPolyShape, validatePolyShape]
};
function hasShapeAnimation(el) {
	var animators = el.animators;
	for (var i$1 = 0; i$1 < animators.length; i$1++) if (animators[i$1].targetName === "shape") return true;
	return false;
}
function brushSVGPath(el, scope) {
	var style = el.style;
	var shape = el.shape;
	var builtinShpDef = builtinShapesDef[el.type];
	var attrs = {};
	var needsAnimate = scope.animation;
	var svgElType = "path";
	var strokePercent = el.style.strokePercent;
	var precision = scope.compress && getPathPrecision(el) || 4;
	if (builtinShpDef && !scope.willUpdate && !(builtinShpDef[1] && !builtinShpDef[1](shape)) && !(needsAnimate && hasShapeAnimation(el)) && !(strokePercent < 1)) {
		svgElType = el.type;
		var mul$2 = Math.pow(10, precision);
		builtinShpDef[0](shape, attrs, mul$2);
	} else {
		var needBuildPath = !el.path || el.shapeChanged();
		if (!el.path) el.createPathProxy();
		var path = el.path;
		if (needBuildPath) {
			path.beginPath();
			el.buildPath(path, el.shape);
			el.pathUpdated();
		}
		var pathVersion = path.getVersion();
		var elExt = el;
		var svgPathBuilder = elExt.__svgPathBuilder;
		if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || strokePercent !== elExt.__svgPathStrokePercent) {
			if (!svgPathBuilder) svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder_default();
			svgPathBuilder.reset(precision);
			path.rebuildPath(svgPathBuilder, strokePercent);
			svgPathBuilder.generateStr();
			elExt.__svgPathVersion = pathVersion;
			elExt.__svgPathStrokePercent = strokePercent;
		}
		attrs.d = svgPathBuilder.getStr();
	}
	setTransform(attrs, el.transform);
	setStyleAttrs(attrs, style, el, scope);
	setMetaData(attrs, el);
	scope.animation && createCSSAnimation(el, attrs, scope);
	scope.emphasis && createCSSEmphasis(el, attrs, scope);
	return createVNode(svgElType, el.id + "", attrs);
}
function brushSVGImage(el, scope) {
	var style = el.style;
	var image = style.image;
	if (image && !isString(image)) {
		if (isImageLike(image)) image = image.src;
		else if (isCanvasLike(image)) image = image.toDataURL();
	}
	if (!image) return;
	var x = style.x || 0;
	var y = style.y || 0;
	var dw = style.width;
	var dh = style.height;
	var attrs = {
		href: image,
		width: dw,
		height: dh
	};
	if (x) attrs.x = x;
	if (y) attrs.y = y;
	setTransform(attrs, el.transform);
	setStyleAttrs(attrs, style, el, scope);
	setMetaData(attrs, el);
	scope.animation && createCSSAnimation(el, attrs, scope);
	return createVNode("image", el.id + "", attrs);
}
function brushSVGTSpan(el, scope) {
	var style = el.style;
	var text = style.text;
	text != null && (text += "");
	if (!text || isNaN(style.x) || isNaN(style.y)) return;
	var font = style.font || DEFAULT_FONT;
	var x = style.x || 0;
	var y = adjustTextY(style.y || 0, getLineHeight(font), style.textBaseline);
	var textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] || style.textAlign;
	var attrs = {
		"dominant-baseline": "central",
		"text-anchor": textAlign
	};
	if (hasSeparateFont(style)) {
		var separatedFontStr = "";
		var fontStyle = style.fontStyle;
		var fontSize = parseFontSize(style.fontSize);
		if (!parseFloat(fontSize)) return;
		var fontFamily = style.fontFamily || DEFAULT_FONT_FAMILY;
		var fontWeight = style.fontWeight;
		separatedFontStr += "font-size:" + fontSize + ";font-family:" + fontFamily + ";";
		if (fontStyle && fontStyle !== "normal") separatedFontStr += "font-style:" + fontStyle + ";";
		if (fontWeight && fontWeight !== "normal") separatedFontStr += "font-weight:" + fontWeight + ";";
		attrs.style = separatedFontStr;
	} else attrs.style = "font: " + font;
	if (text.match(/\s/)) attrs["xml:space"] = "preserve";
	if (x) attrs.x = x;
	if (y) attrs.y = y;
	setTransform(attrs, el.transform);
	setStyleAttrs(attrs, style, el, scope);
	setMetaData(attrs, el);
	scope.animation && createCSSAnimation(el, attrs, scope);
	return createVNode("text", el.id + "", attrs, void 0, text);
}
function brush$1(el, scope) {
	if (el instanceof Path_default) return brushSVGPath(el, scope);
	else if (el instanceof Image_default) return brushSVGImage(el, scope);
	else if (el instanceof TSpan_default) return brushSVGTSpan(el, scope);
}
function setShadow(el, attrs, scope) {
	var style = el.style;
	if (hasShadow(style)) {
		var shadowKey = getShadowKey(el);
		var shadowCache = scope.shadowCache;
		var shadowId = shadowCache[shadowKey];
		if (!shadowId) {
			var globalScale = el.getGlobalScale();
			var scaleX = globalScale[0];
			var scaleY = globalScale[1];
			if (!scaleX || !scaleY) return;
			var offsetX = style.shadowOffsetX || 0;
			var offsetY = style.shadowOffsetY || 0;
			var blur_1 = style.shadowBlur;
			var _a$1 = normalizeColor(style.shadowColor), opacity = _a$1.opacity, color$2 = _a$1.color;
			var stdDx = blur_1 / 2 / scaleX;
			var stdDy = blur_1 / 2 / scaleY;
			var stdDeviation = stdDx + " " + stdDy;
			shadowId = scope.zrId + "-s" + scope.shadowIdx++;
			scope.defs[shadowId] = createVNode("filter", shadowId, {
				"id": shadowId,
				"x": "-100%",
				"y": "-100%",
				"width": "300%",
				"height": "300%"
			}, [createVNode("feDropShadow", "", {
				"dx": offsetX / scaleX,
				"dy": offsetY / scaleY,
				"stdDeviation": stdDeviation,
				"flood-color": color$2,
				"flood-opacity": opacity
			})]);
			shadowCache[shadowKey] = shadowId;
		}
		attrs.filter = getIdURL(shadowId);
	}
}
function setGradient(style, attrs, target, scope) {
	var val = style[target];
	var gradientTag;
	var gradientAttrs = { "gradientUnits": val.global ? "userSpaceOnUse" : "objectBoundingBox" };
	if (isLinearGradient(val)) {
		gradientTag = "linearGradient";
		gradientAttrs.x1 = val.x;
		gradientAttrs.y1 = val.y;
		gradientAttrs.x2 = val.x2;
		gradientAttrs.y2 = val.y2;
	} else if (isRadialGradient(val)) {
		gradientTag = "radialGradient";
		gradientAttrs.cx = retrieve2(val.x, .5);
		gradientAttrs.cy = retrieve2(val.y, .5);
		gradientAttrs.r = retrieve2(val.r, .5);
	} else {
		logError("Illegal gradient type.");
		return;
	}
	var colors = val.colorStops;
	var colorStops = [];
	for (var i$1 = 0, len$1 = colors.length; i$1 < len$1; ++i$1) {
		var offset = round4(colors[i$1].offset) * 100 + "%";
		var stopColor = colors[i$1].color;
		var _a$1 = normalizeColor(stopColor), color$2 = _a$1.color, opacity = _a$1.opacity;
		var stopsAttrs = { "offset": offset };
		stopsAttrs["stop-color"] = color$2;
		if (opacity < 1) stopsAttrs["stop-opacity"] = opacity;
		colorStops.push(createVNode("stop", i$1 + "", stopsAttrs));
	}
	var gradientKey = vNodeToString(createVNode(gradientTag, "", gradientAttrs, colorStops));
	var gradientCache = scope.gradientCache;
	var gradientId = gradientCache[gradientKey];
	if (!gradientId) {
		gradientId = scope.zrId + "-g" + scope.gradientIdx++;
		gradientCache[gradientKey] = gradientId;
		gradientAttrs.id = gradientId;
		scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops);
	}
	attrs[target] = getIdURL(gradientId);
}
function setPattern(el, attrs, target, scope) {
	var val = el.style[target];
	var boundingRect = el.getBoundingRect();
	var patternAttrs = {};
	var repeat = val.repeat;
	var noRepeat = repeat === "no-repeat";
	var repeatX = repeat === "repeat-x";
	var repeatY = repeat === "repeat-y";
	var child;
	if (isImagePattern(val)) {
		var imageWidth_1 = val.imageWidth;
		var imageHeight_1 = val.imageHeight;
		var imageSrc = void 0;
		var patternImage = val.image;
		if (isString(patternImage)) imageSrc = patternImage;
		else if (isImageLike(patternImage)) imageSrc = patternImage.src;
		else if (isCanvasLike(patternImage)) imageSrc = patternImage.toDataURL();
		if (typeof Image === "undefined") {
			var errMsg = "Image width/height must been given explictly in svg-ssr renderer.";
			assert(imageWidth_1, errMsg);
			assert(imageHeight_1, errMsg);
		} else if (imageWidth_1 == null || imageHeight_1 == null) {
			var setSizeToVNode_1 = function(vNode, img) {
				if (vNode) {
					var svgEl = vNode.elm;
					var width = imageWidth_1 || img.width;
					var height = imageHeight_1 || img.height;
					if (vNode.tag === "pattern") {
						if (repeatX) {
							height = 1;
							width /= boundingRect.width;
						} else if (repeatY) {
							width = 1;
							height /= boundingRect.height;
						}
					}
					vNode.attrs.width = width;
					vNode.attrs.height = height;
					if (svgEl) {
						svgEl.setAttribute("width", width);
						svgEl.setAttribute("height", height);
					}
				}
			};
			var createdImage = createOrUpdateImage(imageSrc, null, el, function(img) {
				noRepeat || setSizeToVNode_1(patternVNode, img);
				setSizeToVNode_1(child, img);
			});
			if (createdImage && createdImage.width && createdImage.height) {
				imageWidth_1 = imageWidth_1 || createdImage.width;
				imageHeight_1 = imageHeight_1 || createdImage.height;
			}
		}
		child = createVNode("image", "img", {
			href: imageSrc,
			width: imageWidth_1,
			height: imageHeight_1
		});
		patternAttrs.width = imageWidth_1;
		patternAttrs.height = imageHeight_1;
	} else if (val.svgElement) {
		child = clone(val.svgElement);
		patternAttrs.width = val.svgWidth;
		patternAttrs.height = val.svgHeight;
	}
	if (!child) return;
	var patternWidth;
	var patternHeight;
	if (noRepeat) patternWidth = patternHeight = 1;
	else if (repeatX) {
		patternHeight = 1;
		patternWidth = patternAttrs.width / boundingRect.width;
	} else if (repeatY) {
		patternWidth = 1;
		patternHeight = patternAttrs.height / boundingRect.height;
	} else patternAttrs.patternUnits = "userSpaceOnUse";
	if (patternWidth != null && !isNaN(patternWidth)) patternAttrs.width = patternWidth;
	if (patternHeight != null && !isNaN(patternHeight)) patternAttrs.height = patternHeight;
	var patternTransform = getSRTTransformString(val);
	patternTransform && (patternAttrs.patternTransform = patternTransform);
	var patternVNode = createVNode("pattern", "", patternAttrs, [child]);
	var patternKey = vNodeToString(patternVNode);
	var patternCache = scope.patternCache;
	var patternId = patternCache[patternKey];
	if (!patternId) {
		patternId = scope.zrId + "-p" + scope.patternIdx++;
		patternCache[patternKey] = patternId;
		patternAttrs.id = patternId;
		patternVNode = scope.defs[patternId] = createVNode("pattern", patternId, patternAttrs, [child]);
	}
	attrs[target] = getIdURL(patternId);
}
function setClipPath(clipPath, attrs, scope) {
	var clipPathCache = scope.clipPathCache, defs = scope.defs;
	var clipPathId = clipPathCache[clipPath.id];
	if (!clipPathId) {
		clipPathId = scope.zrId + "-c" + scope.clipPathIdx++;
		var clipPathAttrs = { id: clipPathId };
		clipPathCache[clipPath.id] = clipPathId;
		defs[clipPathId] = createVNode("clipPath", clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)]);
	}
	attrs["clip-path"] = getIdURL(clipPathId);
}

//#endregion
//#region node_modules/zrender/lib/svg/domapi.js
function createTextNode(text) {
	return document.createTextNode(text);
}
function insertBefore(parentNode$1, newNode, referenceNode) {
	parentNode$1.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
	node.removeChild(child);
}
function appendChild(node, child) {
	node.appendChild(child);
}
function parentNode(node) {
	return node.parentNode;
}
function nextSibling(node) {
	return node.nextSibling;
}
function setTextContent(node, text) {
	node.textContent = text;
}

//#endregion
//#region node_modules/zrender/lib/svg/patch.js
var colonChar = 58;
var xChar = 120;
var emptyNode = createVNode("", "");
function isUndef(s) {
	return s === void 0;
}
function isDef(s) {
	return s !== void 0;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
	var map$2 = {};
	for (var i$1 = beginIdx; i$1 <= endIdx; ++i$1) {
		var key$1 = children[i$1].key;
		if (key$1 !== void 0) {
			if (map$2[key$1] != null) console.error("Duplicate key " + key$1);
			map$2[key$1] = i$1;
		}
	}
	return map$2;
}
function sameVnode(vnode1, vnode2) {
	var isSameKey = vnode1.key === vnode2.key;
	return vnode1.tag === vnode2.tag && isSameKey;
}
function createElm(vnode) {
	var i$1;
	var children = vnode.children;
	var tag = vnode.tag;
	if (isDef(tag)) {
		var elm = vnode.elm = createElement(tag);
		updateAttrs(emptyNode, vnode);
		if (isArray(children)) for (i$1 = 0; i$1 < children.length; ++i$1) {
			var ch = children[i$1];
			if (ch != null) appendChild(elm, createElm(ch));
		}
		else if (isDef(vnode.text) && !isObject(vnode.text)) appendChild(elm, createTextNode(vnode.text));
	} else vnode.elm = createTextNode(vnode.text);
	return vnode.elm;
}
function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
	for (; startIdx <= endIdx; ++startIdx) {
		var ch = vnodes[startIdx];
		if (ch != null) insertBefore(parentElm, createElm(ch), before);
	}
}
function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	for (; startIdx <= endIdx; ++startIdx) {
		var ch = vnodes[startIdx];
		if (ch != null) if (isDef(ch.tag)) {
			var parent_1 = parentNode(ch.elm);
			removeChild(parent_1, ch.elm);
		} else removeChild(parentElm, ch.elm);
	}
}
function updateAttrs(oldVnode, vnode) {
	var key$1;
	var elm = vnode.elm;
	var oldAttrs = oldVnode && oldVnode.attrs || {};
	var attrs = vnode.attrs || {};
	if (oldAttrs === attrs) return;
	for (key$1 in attrs) {
		var cur = attrs[key$1];
		if (oldAttrs[key$1] !== cur) if (cur === true) elm.setAttribute(key$1, "");
		else if (cur === false) elm.removeAttribute(key$1);
		else if (key$1 === "style") elm.style.cssText = cur;
		else if (key$1.charCodeAt(0) !== xChar) elm.setAttribute(key$1, cur);
		else if (key$1 === "xmlns:xlink" || key$1 === "xmlns") elm.setAttributeNS(XMLNS, key$1, cur);
		else if (key$1.charCodeAt(3) === colonChar) elm.setAttributeNS(XML_NAMESPACE, key$1, cur);
		else if (key$1.charCodeAt(5) === colonChar) elm.setAttributeNS(XLINKNS, key$1, cur);
		else elm.setAttribute(key$1, cur);
	}
	for (key$1 in oldAttrs) if (!(key$1 in attrs)) elm.removeAttribute(key$1);
}
function updateChildren(parentElm, oldCh, newCh) {
	var oldStartIdx = 0;
	var newStartIdx = 0;
	var oldEndIdx = oldCh.length - 1;
	var oldStartVnode = oldCh[0];
	var oldEndVnode = oldCh[oldEndIdx];
	var newEndIdx = newCh.length - 1;
	var newStartVnode = newCh[0];
	var newEndVnode = newCh[newEndIdx];
	var oldKeyToIdx;
	var idxInOld;
	var elmToMove;
	var before;
	while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) if (oldStartVnode == null) oldStartVnode = oldCh[++oldStartIdx];
	else if (oldEndVnode == null) oldEndVnode = oldCh[--oldEndIdx];
	else if (newStartVnode == null) newStartVnode = newCh[++newStartIdx];
	else if (newEndVnode == null) newEndVnode = newCh[--newEndIdx];
	else if (sameVnode(oldStartVnode, newStartVnode)) {
		patchVnode(oldStartVnode, newStartVnode);
		oldStartVnode = oldCh[++oldStartIdx];
		newStartVnode = newCh[++newStartIdx];
	} else if (sameVnode(oldEndVnode, newEndVnode)) {
		patchVnode(oldEndVnode, newEndVnode);
		oldEndVnode = oldCh[--oldEndIdx];
		newEndVnode = newCh[--newEndIdx];
	} else if (sameVnode(oldStartVnode, newEndVnode)) {
		patchVnode(oldStartVnode, newEndVnode);
		insertBefore(parentElm, oldStartVnode.elm, nextSibling(oldEndVnode.elm));
		oldStartVnode = oldCh[++oldStartIdx];
		newEndVnode = newCh[--newEndIdx];
	} else if (sameVnode(oldEndVnode, newStartVnode)) {
		patchVnode(oldEndVnode, newStartVnode);
		insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
		oldEndVnode = oldCh[--oldEndIdx];
		newStartVnode = newCh[++newStartIdx];
	} else {
		if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
		idxInOld = oldKeyToIdx[newStartVnode.key];
		if (isUndef(idxInOld)) insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
		else {
			elmToMove = oldCh[idxInOld];
			if (elmToMove.tag !== newStartVnode.tag) insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
			else {
				patchVnode(elmToMove, newStartVnode);
				oldCh[idxInOld] = void 0;
				insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
			}
		}
		newStartVnode = newCh[++newStartIdx];
	}
	if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) if (oldStartIdx > oldEndIdx) {
		before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
		addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
	} else removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
}
function patchVnode(oldVnode, vnode) {
	var elm = vnode.elm = oldVnode.elm;
	var oldCh = oldVnode.children;
	var ch = vnode.children;
	if (oldVnode === vnode) return;
	updateAttrs(oldVnode, vnode);
	if (isUndef(vnode.text)) {
		if (isDef(oldCh) && isDef(ch)) {
			if (oldCh !== ch) updateChildren(elm, oldCh, ch);
		} else if (isDef(ch)) {
			if (isDef(oldVnode.text)) setTextContent(elm, "");
			addVnodes(elm, null, ch, 0, ch.length - 1);
		} else if (isDef(oldCh)) removeVnodes(elm, oldCh, 0, oldCh.length - 1);
		else if (isDef(oldVnode.text)) setTextContent(elm, "");
	} else if (oldVnode.text !== vnode.text) {
		if (isDef(oldCh)) removeVnodes(elm, oldCh, 0, oldCh.length - 1);
		setTextContent(elm, vnode.text);
	}
}
function patch(oldVnode, vnode) {
	if (sameVnode(oldVnode, vnode)) patchVnode(oldVnode, vnode);
	else {
		var elm = oldVnode.elm;
		var parent_2 = parentNode(elm);
		createElm(vnode);
		if (parent_2 !== null) {
			insertBefore(parent_2, vnode.elm, nextSibling(elm));
			removeVnodes(parent_2, [oldVnode], 0, 0);
		}
	}
	return vnode;
}

//#endregion
//#region node_modules/zrender/lib/svg/Painter.js
var svgId = 0;
var SVGPainter = function() {
	function SVGPainter$1(root, storage$1, opts) {
		this.type = "svg";
		this.refreshHover = createMethodNotSupport("refreshHover");
		this.configLayer = createMethodNotSupport("configLayer");
		this.storage = storage$1;
		this._opts = opts = extend({}, opts);
		this.root = root;
		this._id = "zr" + svgId++;
		this._oldVNode = createSVGVNode(opts.width, opts.height);
		if (root && !opts.ssr) {
			var viewport = this._viewport = document.createElement("div");
			viewport.style.cssText = "position:relative;overflow:hidden";
			var svgDom = this._svgDom = this._oldVNode.elm = createElement("svg");
			updateAttrs(null, this._oldVNode);
			viewport.appendChild(svgDom);
			root.appendChild(viewport);
		}
		this.resize(opts.width, opts.height);
	}
	SVGPainter$1.prototype.getType = function() {
		return this.type;
	};
	SVGPainter$1.prototype.getViewportRoot = function() {
		return this._viewport;
	};
	SVGPainter$1.prototype.getViewportRootOffset = function() {
		var viewportRoot = this.getViewportRoot();
		if (viewportRoot) return {
			offsetLeft: viewportRoot.offsetLeft || 0,
			offsetTop: viewportRoot.offsetTop || 0
		};
	};
	SVGPainter$1.prototype.getSvgDom = function() {
		return this._svgDom;
	};
	SVGPainter$1.prototype.refresh = function() {
		if (this.root) {
			var vnode = this.renderToVNode({ willUpdate: true });
			vnode.attrs.style = "position:absolute;left:0;top:0;user-select:none";
			patch(this._oldVNode, vnode);
			this._oldVNode = vnode;
		}
	};
	SVGPainter$1.prototype.renderOneToVNode = function(el) {
		return brush$1(el, createBrushScope(this._id));
	};
	SVGPainter$1.prototype.renderToVNode = function(opts) {
		opts = opts || {};
		var list = this.storage.getDisplayList(true);
		var width = this._width;
		var height = this._height;
		var scope = createBrushScope(this._id);
		scope.animation = opts.animation;
		scope.willUpdate = opts.willUpdate;
		scope.compress = opts.compress;
		scope.emphasis = opts.emphasis;
		scope.ssr = this._opts.ssr;
		var children = [];
		var bgVNode = this._bgVNode = createBackgroundVNode(width, height, this._backgroundColor, scope);
		bgVNode && children.push(bgVNode);
		var mainVNode = !opts.compress ? this._mainVNode = createVNode("g", "main", {}, []) : null;
		this._paintList(list, scope, mainVNode ? mainVNode.children : children);
		mainVNode && children.push(mainVNode);
		var defs = map(keys(scope.defs), function(id) {
			return scope.defs[id];
		});
		if (defs.length) children.push(createVNode("defs", "defs", {}, defs));
		if (opts.animation) {
			var animationCssStr = getCssString(scope.cssNodes, scope.cssAnims, { newline: true });
			if (animationCssStr) {
				var styleNode = createVNode("style", "stl", {}, [], animationCssStr);
				children.push(styleNode);
			}
		}
		return createSVGVNode(width, height, children, opts.useViewBox);
	};
	SVGPainter$1.prototype.renderToString = function(opts) {
		opts = opts || {};
		return vNodeToString(this.renderToVNode({
			animation: retrieve2(opts.cssAnimation, true),
			emphasis: retrieve2(opts.cssEmphasis, true),
			willUpdate: false,
			compress: true,
			useViewBox: retrieve2(opts.useViewBox, true)
		}), { newline: true });
	};
	SVGPainter$1.prototype.setBackgroundColor = function(backgroundColor$1) {
		this._backgroundColor = backgroundColor$1;
	};
	SVGPainter$1.prototype.getSvgRoot = function() {
		return this._mainVNode && this._mainVNode.elm;
	};
	SVGPainter$1.prototype._paintList = function(list, scope, out$1) {
		var listLen = list.length;
		var clipPathsGroupsStack = [];
		var clipPathsGroupsStackDepth = 0;
		var currentClipPathGroup;
		var prevClipPaths;
		var clipGroupNodeIdx = 0;
		for (var i$1 = 0; i$1 < listLen; i$1++) {
			var displayable = list[i$1];
			if (!displayable.invisible) {
				var clipPaths = displayable.__clipPaths;
				var len$1 = clipPaths && clipPaths.length || 0;
				var prevLen = prevClipPaths && prevClipPaths.length || 0;
				var lca = void 0;
				for (lca = Math.max(len$1 - 1, prevLen - 1); lca >= 0; lca--) if (clipPaths && prevClipPaths && clipPaths[lca] === prevClipPaths[lca]) break;
				for (var i_1 = prevLen - 1; i_1 > lca; i_1--) {
					clipPathsGroupsStackDepth--;
					currentClipPathGroup = clipPathsGroupsStack[clipPathsGroupsStackDepth - 1];
				}
				for (var i_2 = lca + 1; i_2 < len$1; i_2++) {
					var groupAttrs = {};
					setClipPath(clipPaths[i_2], groupAttrs, scope);
					var g = createVNode("g", "clip-g-" + clipGroupNodeIdx++, groupAttrs, []);
					(currentClipPathGroup ? currentClipPathGroup.children : out$1).push(g);
					clipPathsGroupsStack[clipPathsGroupsStackDepth++] = g;
					currentClipPathGroup = g;
				}
				prevClipPaths = clipPaths;
				var ret = brush$1(displayable, scope);
				if (ret) (currentClipPathGroup ? currentClipPathGroup.children : out$1).push(ret);
			}
		}
	};
	SVGPainter$1.prototype.resize = function(width, height) {
		var opts = this._opts;
		var root = this.root;
		var viewport = this._viewport;
		width != null && (opts.width = width);
		height != null && (opts.height = height);
		if (root && viewport) {
			viewport.style.display = "none";
			width = getSize$1(root, 0, opts);
			height = getSize$1(root, 1, opts);
			viewport.style.display = "";
		}
		if (this._width !== width || this._height !== height) {
			this._width = width;
			this._height = height;
			if (viewport) {
				var viewportStyle = viewport.style;
				viewportStyle.width = width + "px";
				viewportStyle.height = height + "px";
			}
			if (!isPattern(this._backgroundColor)) {
				var svgDom = this._svgDom;
				if (svgDom) {
					svgDom.setAttribute("width", width);
					svgDom.setAttribute("height", height);
				}
				var bgEl = this._bgVNode && this._bgVNode.elm;
				if (bgEl) {
					bgEl.setAttribute("width", width);
					bgEl.setAttribute("height", height);
				}
			} else this.refresh();
		}
	};
	SVGPainter$1.prototype.getWidth = function() {
		return this._width;
	};
	SVGPainter$1.prototype.getHeight = function() {
		return this._height;
	};
	SVGPainter$1.prototype.dispose = function() {
		if (this.root) this.root.innerHTML = "";
		this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
	};
	SVGPainter$1.prototype.clear = function() {
		if (this._svgDom) this._svgDom.innerHTML = null;
		this._oldVNode = null;
	};
	SVGPainter$1.prototype.toDataURL = function(base64) {
		var str = this.renderToString();
		var prefix = "data:image/svg+xml;";
		if (base64) {
			str = encodeBase64(str);
			return str && prefix + "base64," + str;
		}
		return prefix + "charset=UTF-8," + encodeURIComponent(str);
	};
	return SVGPainter$1;
}();
function createMethodNotSupport(method) {
	return function() {
		logError("In SVG mode painter not support method \"" + method + "\"");
	};
}
function createBackgroundVNode(width, height, backgroundColor$1, scope) {
	var bgVNode;
	if (backgroundColor$1 && backgroundColor$1 !== "none") {
		bgVNode = createVNode("rect", "bg", {
			width,
			height,
			x: "0",
			y: "0"
		});
		if (isGradient(backgroundColor$1)) setGradient({ fill: backgroundColor$1 }, bgVNode.attrs, "fill", scope);
		else if (isPattern(backgroundColor$1)) setPattern({
			style: { fill: backgroundColor$1 },
			dirty: noop,
			getBoundingRect: function() {
				return {
					width,
					height
				};
			}
		}, bgVNode.attrs, "fill", scope);
		else {
			var _a$1 = normalizeColor(backgroundColor$1), color$2 = _a$1.color, opacity = _a$1.opacity;
			bgVNode.attrs.fill = color$2;
			opacity < 1 && (bgVNode.attrs["fill-opacity"] = opacity);
		}
	}
	return bgVNode;
}
var Painter_default$1 = SVGPainter;

//#endregion
//#region node_modules/echarts/lib/renderer/installSVGRenderer.js
function install(registers) {
	registers.registerPainter("svg", Painter_default$1);
}

//#endregion
//#region node_modules/zrender/lib/canvas/Layer.js
function createDom(id, painter, dpr$1) {
	var newDom = platformApi.createCanvas();
	var width = painter.getWidth();
	var height = painter.getHeight();
	var newDomStyle = newDom.style;
	if (newDomStyle) {
		newDomStyle.position = "absolute";
		newDomStyle.left = "0";
		newDomStyle.top = "0";
		newDomStyle.width = width + "px";
		newDomStyle.height = height + "px";
		newDom.setAttribute("data-zr-dom-id", id);
	}
	newDom.width = width * dpr$1;
	newDom.height = height * dpr$1;
	return newDom;
}
var Layer = function(_super) {
	__extends$1(Layer$1, _super);
	function Layer$1(id, painter, dpr$1) {
		var _this = _super.call(this) || this;
		_this.motionBlur = false;
		_this.lastFrameAlpha = .7;
		_this.dpr = 1;
		_this.virtual = false;
		_this.config = {};
		_this.incremental = false;
		_this.zlevel = 0;
		_this.maxRepaintRectCount = 5;
		_this.__dirty = true;
		_this.__firstTimePaint = true;
		_this.__used = false;
		_this.__drawIndex = 0;
		_this.__startIndex = 0;
		_this.__endIndex = 0;
		_this.__prevStartIndex = null;
		_this.__prevEndIndex = null;
		var dom;
		dpr$1 = dpr$1 || devicePixelRatio;
		if (typeof id === "string") dom = createDom(id, painter, dpr$1);
		else if (isObject(id)) {
			dom = id;
			id = dom.id;
		}
		_this.id = id;
		_this.dom = dom;
		var domStyle = dom.style;
		if (domStyle) {
			disableUserSelect(dom);
			dom.onselectstart = function() {
				return false;
			};
			domStyle.padding = "0";
			domStyle.margin = "0";
			domStyle.borderWidth = "0";
		}
		_this.painter = painter;
		_this.dpr = dpr$1;
		return _this;
	}
	Layer$1.prototype.getElementCount = function() {
		return this.__endIndex - this.__startIndex;
	};
	Layer$1.prototype.afterBrush = function() {
		this.__prevStartIndex = this.__startIndex;
		this.__prevEndIndex = this.__endIndex;
	};
	Layer$1.prototype.initContext = function() {
		this.ctx = this.dom.getContext("2d");
		this.ctx.dpr = this.dpr;
	};
	Layer$1.prototype.setUnpainted = function() {
		this.__firstTimePaint = true;
	};
	Layer$1.prototype.createBackBuffer = function() {
		var dpr$1 = this.dpr;
		this.domBack = createDom("back-" + this.id, this.painter, dpr$1);
		this.ctxBack = this.domBack.getContext("2d");
		if (dpr$1 !== 1) this.ctxBack.scale(dpr$1, dpr$1);
	};
	Layer$1.prototype.createRepaintRects = function(displayList, prevList, viewWidth, viewHeight) {
		if (this.__firstTimePaint) {
			this.__firstTimePaint = false;
			return null;
		}
		var mergedRepaintRects = [];
		var maxRepaintRectCount = this.maxRepaintRectCount;
		var full = false;
		var pendingRect = new BoundingRect_default(0, 0, 0, 0);
		function addRectToMergePool(rect) {
			if (!rect.isFinite() || rect.isZero()) return;
			if (mergedRepaintRects.length === 0) {
				var boundingRect = new BoundingRect_default(0, 0, 0, 0);
				boundingRect.copy(rect);
				mergedRepaintRects.push(boundingRect);
			} else {
				var isMerged = false;
				var minDeltaArea = Infinity;
				var bestRectToMergeIdx = 0;
				for (var i$2 = 0; i$2 < mergedRepaintRects.length; ++i$2) {
					var mergedRect = mergedRepaintRects[i$2];
					if (mergedRect.intersect(rect)) {
						var pendingRect_1 = new BoundingRect_default(0, 0, 0, 0);
						pendingRect_1.copy(mergedRect);
						pendingRect_1.union(rect);
						mergedRepaintRects[i$2] = pendingRect_1;
						isMerged = true;
						break;
					} else if (full) {
						pendingRect.copy(rect);
						pendingRect.union(mergedRect);
						var aArea = rect.width * rect.height;
						var bArea = mergedRect.width * mergedRect.height;
						var deltaArea = pendingRect.width * pendingRect.height - aArea - bArea;
						if (deltaArea < minDeltaArea) {
							minDeltaArea = deltaArea;
							bestRectToMergeIdx = i$2;
						}
					}
				}
				if (full) {
					mergedRepaintRects[bestRectToMergeIdx].union(rect);
					isMerged = true;
				}
				if (!isMerged) {
					var boundingRect = new BoundingRect_default(0, 0, 0, 0);
					boundingRect.copy(rect);
					mergedRepaintRects.push(boundingRect);
				}
				if (!full) full = mergedRepaintRects.length >= maxRepaintRectCount;
			}
		}
		for (var i$1 = this.__startIndex; i$1 < this.__endIndex; ++i$1) {
			var el = displayList[i$1];
			if (el) {
				var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
				var prevRect = el.__isRendered && (el.__dirty & REDRAW_BIT || !shouldPaint) ? el.getPrevPaintRect() : null;
				if (prevRect) addRectToMergePool(prevRect);
				var curRect = shouldPaint && (el.__dirty & REDRAW_BIT || !el.__isRendered) ? el.getPaintRect() : null;
				if (curRect) addRectToMergePool(curRect);
			}
		}
		for (var i$1 = this.__prevStartIndex; i$1 < this.__prevEndIndex; ++i$1) {
			var el = prevList[i$1];
			var shouldPaint = el && el.shouldBePainted(viewWidth, viewHeight, true, true);
			if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
				var prevRect = el.getPrevPaintRect();
				if (prevRect) addRectToMergePool(prevRect);
			}
		}
		var hasIntersections;
		do {
			hasIntersections = false;
			for (var i$1 = 0; i$1 < mergedRepaintRects.length;) {
				if (mergedRepaintRects[i$1].isZero()) {
					mergedRepaintRects.splice(i$1, 1);
					continue;
				}
				for (var j = i$1 + 1; j < mergedRepaintRects.length;) if (mergedRepaintRects[i$1].intersect(mergedRepaintRects[j])) {
					hasIntersections = true;
					mergedRepaintRects[i$1].union(mergedRepaintRects[j]);
					mergedRepaintRects.splice(j, 1);
				} else j++;
				i$1++;
			}
		} while (hasIntersections);
		this._paintRects = mergedRepaintRects;
		return mergedRepaintRects;
	};
	Layer$1.prototype.debugGetPaintRects = function() {
		return (this._paintRects || []).slice();
	};
	Layer$1.prototype.resize = function(width, height) {
		var dpr$1 = this.dpr;
		var dom = this.dom;
		var domStyle = dom.style;
		var domBack = this.domBack;
		if (domStyle) {
			domStyle.width = width + "px";
			domStyle.height = height + "px";
		}
		dom.width = width * dpr$1;
		dom.height = height * dpr$1;
		if (domBack) {
			domBack.width = width * dpr$1;
			domBack.height = height * dpr$1;
			if (dpr$1 !== 1) this.ctxBack.scale(dpr$1, dpr$1);
		}
	};
	Layer$1.prototype.clear = function(clearAll, clearColor, repaintRects) {
		var dom = this.dom;
		var ctx = this.ctx;
		var width = dom.width;
		var height = dom.height;
		clearColor = clearColor || this.clearColor;
		var haveMotionBLur = this.motionBlur && !clearAll;
		var lastFrameAlpha = this.lastFrameAlpha;
		var dpr$1 = this.dpr;
		var self$1 = this;
		if (haveMotionBLur) {
			if (!this.domBack) this.createBackBuffer();
			this.ctxBack.globalCompositeOperation = "copy";
			this.ctxBack.drawImage(dom, 0, 0, width / dpr$1, height / dpr$1);
		}
		var domBack = this.domBack;
		function doClear(x, y, width$1, height$1) {
			ctx.clearRect(x, y, width$1, height$1);
			if (clearColor && clearColor !== "transparent") {
				var clearColorGradientOrPattern = void 0;
				if (isGradientObject(clearColor)) {
					clearColorGradientOrPattern = (clearColor.global || clearColor.__width === width$1 && clearColor.__height === height$1) && clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
						x: 0,
						y: 0,
						width: width$1,
						height: height$1
					});
					clearColor.__canvasGradient = clearColorGradientOrPattern;
					clearColor.__width = width$1;
					clearColor.__height = height$1;
				} else if (isImagePatternObject(clearColor)) {
					clearColor.scaleX = clearColor.scaleX || dpr$1;
					clearColor.scaleY = clearColor.scaleY || dpr$1;
					clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, { dirty: function() {
						self$1.setUnpainted();
						self$1.painter.refresh();
					} });
				}
				ctx.save();
				ctx.fillStyle = clearColorGradientOrPattern || clearColor;
				ctx.fillRect(x, y, width$1, height$1);
				ctx.restore();
			}
			if (haveMotionBLur) {
				ctx.save();
				ctx.globalAlpha = lastFrameAlpha;
				ctx.drawImage(domBack, x, y, width$1, height$1);
				ctx.restore();
			}
		}
		if (!repaintRects || haveMotionBLur) doClear(0, 0, width, height);
		else if (repaintRects.length) each(repaintRects, function(rect) {
			doClear(rect.x * dpr$1, rect.y * dpr$1, rect.width * dpr$1, rect.height * dpr$1);
		});
	};
	return Layer$1;
}(Eventful_default);
var Layer_default = Layer;

//#endregion
//#region node_modules/zrender/lib/canvas/Painter.js
var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = .01;
var INCREMENTAL_INC = .001;
function isLayerValid(layer) {
	if (!layer) return false;
	if (layer.__builtin__) return true;
	if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") return false;
	return true;
}
function createRoot(width, height) {
	var domRoot = document.createElement("div");
	domRoot.style.cssText = [
		"position:relative",
		"width:" + width + "px",
		"height:" + height + "px",
		"padding:0",
		"margin:0",
		"border-width:0"
	].join(";") + ";";
	return domRoot;
}
var CanvasPainter = function() {
	function CanvasPainter$1(root, storage$1, opts, id) {
		this.type = "canvas";
		this._zlevelList = [];
		this._prevDisplayList = [];
		this._layers = {};
		this._layerConfig = {};
		this._needsManuallyCompositing = false;
		this.type = "canvas";
		var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
		this._opts = opts = extend({}, opts || {});
		this.dpr = opts.devicePixelRatio || devicePixelRatio;
		this._singleCanvas = singleCanvas;
		this.root = root;
		if (root.style) {
			disableUserSelect(root);
			root.innerHTML = "";
		}
		this.storage = storage$1;
		var zlevelList = this._zlevelList;
		this._prevDisplayList = [];
		var layers = this._layers;
		if (!singleCanvas) {
			this._width = getSize$1(root, 0, opts);
			this._height = getSize$1(root, 1, opts);
			var domRoot = this._domRoot = createRoot(this._width, this._height);
			root.appendChild(domRoot);
		} else {
			var rootCanvas = root;
			var width = rootCanvas.width;
			var height = rootCanvas.height;
			if (opts.width != null) width = opts.width;
			if (opts.height != null) height = opts.height;
			this.dpr = opts.devicePixelRatio || 1;
			rootCanvas.width = width * this.dpr;
			rootCanvas.height = height * this.dpr;
			this._width = width;
			this._height = height;
			var mainLayer = new Layer_default(rootCanvas, this, this.dpr);
			mainLayer.__builtin__ = true;
			mainLayer.initContext();
			layers[CANVAS_ZLEVEL] = mainLayer;
			mainLayer.zlevel = CANVAS_ZLEVEL;
			zlevelList.push(CANVAS_ZLEVEL);
			this._domRoot = root;
		}
	}
	CanvasPainter$1.prototype.getType = function() {
		return "canvas";
	};
	CanvasPainter$1.prototype.isSingleCanvas = function() {
		return this._singleCanvas;
	};
	CanvasPainter$1.prototype.getViewportRoot = function() {
		return this._domRoot;
	};
	CanvasPainter$1.prototype.getViewportRootOffset = function() {
		var viewportRoot = this.getViewportRoot();
		if (viewportRoot) return {
			offsetLeft: viewportRoot.offsetLeft || 0,
			offsetTop: viewportRoot.offsetTop || 0
		};
	};
	CanvasPainter$1.prototype.refresh = function(paintAll) {
		var list = this.storage.getDisplayList(true);
		var prevList = this._prevDisplayList;
		var zlevelList = this._zlevelList;
		this._redrawId = Math.random();
		this._paintList(list, prevList, paintAll, this._redrawId);
		for (var i$1 = 0; i$1 < zlevelList.length; i$1++) {
			var z = zlevelList[i$1];
			var layer = this._layers[z];
			if (!layer.__builtin__ && layer.refresh) {
				var clearColor = i$1 === 0 ? this._backgroundColor : null;
				layer.refresh(clearColor);
			}
		}
		if (this._opts.useDirtyRect) this._prevDisplayList = list.slice();
		return this;
	};
	CanvasPainter$1.prototype.refreshHover = function() {
		this._paintHoverList(this.storage.getDisplayList(false));
	};
	CanvasPainter$1.prototype._paintHoverList = function(list) {
		var len$1 = list.length;
		var hoverLayer = this._hoverlayer;
		hoverLayer && hoverLayer.clear();
		if (!len$1) return;
		var scope = {
			inHover: true,
			viewWidth: this._width,
			viewHeight: this._height
		};
		var ctx;
		for (var i$1 = 0; i$1 < len$1; i$1++) {
			var el = list[i$1];
			if (el.__inHover) {
				if (!hoverLayer) hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
				if (!ctx) {
					ctx = hoverLayer.ctx;
					ctx.save();
				}
				brush(ctx, el, scope, i$1 === len$1 - 1);
			}
		}
		if (ctx) ctx.restore();
	};
	CanvasPainter$1.prototype.getHoverLayer = function() {
		return this.getLayer(HOVER_LAYER_ZLEVEL);
	};
	CanvasPainter$1.prototype.paintOne = function(ctx, el) {
		brushSingle(ctx, el);
	};
	CanvasPainter$1.prototype._paintList = function(list, prevList, paintAll, redrawId) {
		if (this._redrawId !== redrawId) return;
		paintAll = paintAll || false;
		this._updateLayerStatus(list);
		var _a$1 = this._doPaintList(list, prevList, paintAll), finished = _a$1.finished, needsRefreshHover = _a$1.needsRefreshHover;
		if (this._needsManuallyCompositing) this._compositeManually();
		if (needsRefreshHover) this._paintHoverList(list);
		if (!finished) {
			var self_1 = this;
			requestAnimationFrame_default(function() {
				self_1._paintList(list, prevList, paintAll, redrawId);
			});
		} else this.eachLayer(function(layer) {
			layer.afterBrush && layer.afterBrush();
		});
	};
	CanvasPainter$1.prototype._compositeManually = function() {
		var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
		var width = this._domRoot.width;
		var height = this._domRoot.height;
		ctx.clearRect(0, 0, width, height);
		this.eachBuiltinLayer(function(layer) {
			if (layer.virtual) ctx.drawImage(layer.dom, 0, 0, width, height);
		});
	};
	CanvasPainter$1.prototype._doPaintList = function(list, prevList, paintAll) {
		var _this = this;
		var layerList = [];
		var useDirtyRect = this._opts.useDirtyRect;
		for (var zi = 0; zi < this._zlevelList.length; zi++) {
			var zlevel = this._zlevelList[zi];
			var layer = this._layers[zlevel];
			if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) layerList.push(layer);
		}
		var finished = true;
		var needsRefreshHover = false;
		var _loop_1 = function(k$2) {
			var layer$1 = layerList[k$2];
			var ctx = layer$1.ctx;
			var repaintRects = useDirtyRect && layer$1.createRepaintRects(list, prevList, this_1._width, this_1._height);
			var start$1 = paintAll ? layer$1.__startIndex : layer$1.__drawIndex;
			var useTimer = !paintAll && layer$1.incremental && Date.now;
			var startTime = useTimer && Date.now();
			var clearColor = layer$1.zlevel === this_1._zlevelList[0] ? this_1._backgroundColor : null;
			if (layer$1.__startIndex === layer$1.__endIndex) layer$1.clear(false, clearColor, repaintRects);
			else if (start$1 === layer$1.__startIndex) {
				var firstEl = list[start$1];
				if (!firstEl.incremental || !firstEl.notClear || paintAll) layer$1.clear(false, clearColor, repaintRects);
			}
			if (start$1 === -1) {
				console.error("For some unknown reason. drawIndex is -1");
				start$1 = layer$1.__startIndex;
			}
			var i$1;
			var repaint = function(repaintRect) {
				var scope = {
					inHover: false,
					allClipped: false,
					prevEl: null,
					viewWidth: _this._width,
					viewHeight: _this._height
				};
				for (i$1 = start$1; i$1 < layer$1.__endIndex; i$1++) {
					var el = list[i$1];
					if (el.__inHover) needsRefreshHover = true;
					_this._doPaintEl(el, layer$1, useDirtyRect, repaintRect, scope, i$1 === layer$1.__endIndex - 1);
					if (useTimer) {
						if (Date.now() - startTime > 15) break;
					}
				}
				if (scope.prevElClipPaths) ctx.restore();
			};
			if (repaintRects) if (repaintRects.length === 0) i$1 = layer$1.__endIndex;
			else {
				var dpr$1 = this_1.dpr;
				for (var r = 0; r < repaintRects.length; ++r) {
					var rect = repaintRects[r];
					ctx.save();
					ctx.beginPath();
					ctx.rect(rect.x * dpr$1, rect.y * dpr$1, rect.width * dpr$1, rect.height * dpr$1);
					ctx.clip();
					repaint(rect);
					ctx.restore();
				}
			}
			else {
				ctx.save();
				repaint();
				ctx.restore();
			}
			layer$1.__drawIndex = i$1;
			if (layer$1.__drawIndex < layer$1.__endIndex) finished = false;
		};
		var this_1 = this;
		for (var k$1 = 0; k$1 < layerList.length; k$1++) _loop_1(k$1);
		if (env_default.wxa) each(this._layers, function(layer$1) {
			if (layer$1 && layer$1.ctx && layer$1.ctx.draw) layer$1.ctx.draw();
		});
		return {
			finished,
			needsRefreshHover
		};
	};
	CanvasPainter$1.prototype._doPaintEl = function(el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
		var ctx = currentLayer.ctx;
		if (useDirtyRect) {
			var paintRect = el.getPaintRect();
			if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
				brush(ctx, el, scope, isLast);
				el.setPrevPaintRect(paintRect);
			}
		} else brush(ctx, el, scope, isLast);
	};
	CanvasPainter$1.prototype.getLayer = function(zlevel, virtual) {
		if (this._singleCanvas && !this._needsManuallyCompositing) zlevel = CANVAS_ZLEVEL;
		var layer = this._layers[zlevel];
		if (!layer) {
			layer = new Layer_default("zr_" + zlevel, this, this.dpr);
			layer.zlevel = zlevel;
			layer.__builtin__ = true;
			if (this._layerConfig[zlevel]) merge(layer, this._layerConfig[zlevel], true);
			else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
			if (virtual) layer.virtual = virtual;
			this.insertLayer(zlevel, layer);
			layer.initContext();
		}
		return layer;
	};
	CanvasPainter$1.prototype.insertLayer = function(zlevel, layer) {
		var layersMap = this._layers;
		var zlevelList = this._zlevelList;
		var len$1 = zlevelList.length;
		var domRoot = this._domRoot;
		var prevLayer = null;
		var i$1 = -1;
		if (layersMap[zlevel]) {
			logError("ZLevel " + zlevel + " has been used already");
			return;
		}
		if (!isLayerValid(layer)) {
			logError("Layer of zlevel " + zlevel + " is not valid");
			return;
		}
		if (len$1 > 0 && zlevel > zlevelList[0]) {
			for (i$1 = 0; i$1 < len$1 - 1; i$1++) if (zlevelList[i$1] < zlevel && zlevelList[i$1 + 1] > zlevel) break;
			prevLayer = layersMap[zlevelList[i$1]];
		}
		zlevelList.splice(i$1 + 1, 0, zlevel);
		layersMap[zlevel] = layer;
		if (!layer.virtual) if (prevLayer) {
			var prevDom = prevLayer.dom;
			if (prevDom.nextSibling) domRoot.insertBefore(layer.dom, prevDom.nextSibling);
			else domRoot.appendChild(layer.dom);
		} else if (domRoot.firstChild) domRoot.insertBefore(layer.dom, domRoot.firstChild);
		else domRoot.appendChild(layer.dom);
		layer.painter || (layer.painter = this);
	};
	CanvasPainter$1.prototype.eachLayer = function(cb, context) {
		var zlevelList = this._zlevelList;
		for (var i$1 = 0; i$1 < zlevelList.length; i$1++) {
			var z = zlevelList[i$1];
			cb.call(context, this._layers[z], z);
		}
	};
	CanvasPainter$1.prototype.eachBuiltinLayer = function(cb, context) {
		var zlevelList = this._zlevelList;
		for (var i$1 = 0; i$1 < zlevelList.length; i$1++) {
			var z = zlevelList[i$1];
			var layer = this._layers[z];
			if (layer.__builtin__) cb.call(context, layer, z);
		}
	};
	CanvasPainter$1.prototype.eachOtherLayer = function(cb, context) {
		var zlevelList = this._zlevelList;
		for (var i$1 = 0; i$1 < zlevelList.length; i$1++) {
			var z = zlevelList[i$1];
			var layer = this._layers[z];
			if (!layer.__builtin__) cb.call(context, layer, z);
		}
	};
	CanvasPainter$1.prototype.getLayers = function() {
		return this._layers;
	};
	CanvasPainter$1.prototype._updateLayerStatus = function(list) {
		this.eachBuiltinLayer(function(layer$1, z) {
			layer$1.__dirty = layer$1.__used = false;
		});
		function updatePrevLayer(idx) {
			if (prevLayer) {
				if (prevLayer.__endIndex !== idx) prevLayer.__dirty = true;
				prevLayer.__endIndex = idx;
			}
		}
		if (this._singleCanvas) for (var i_1 = 1; i_1 < list.length; i_1++) {
			var el = list[i_1];
			if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {
				this._needsManuallyCompositing = true;
				break;
			}
		}
		var prevLayer = null;
		var incrementalLayerCount = 0;
		var prevZlevel;
		var i$1;
		for (i$1 = 0; i$1 < list.length; i$1++) {
			var el = list[i$1];
			var zlevel = el.zlevel;
			var layer = void 0;
			if (prevZlevel !== zlevel) {
				prevZlevel = zlevel;
				incrementalLayerCount = 0;
			}
			if (el.incremental) {
				layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
				layer.incremental = true;
				incrementalLayerCount = 1;
			} else layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
			if (!layer.__builtin__) logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
			if (layer !== prevLayer) {
				layer.__used = true;
				if (layer.__startIndex !== i$1) layer.__dirty = true;
				layer.__startIndex = i$1;
				if (!layer.incremental) layer.__drawIndex = i$1;
				else layer.__drawIndex = -1;
				updatePrevLayer(i$1);
				prevLayer = layer;
			}
			if (el.__dirty & REDRAW_BIT && !el.__inHover) {
				layer.__dirty = true;
				if (layer.incremental && layer.__drawIndex < 0) layer.__drawIndex = i$1;
			}
		}
		updatePrevLayer(i$1);
		this.eachBuiltinLayer(function(layer$1, z) {
			if (!layer$1.__used && layer$1.getElementCount() > 0) {
				layer$1.__dirty = true;
				layer$1.__startIndex = layer$1.__endIndex = layer$1.__drawIndex = 0;
			}
			if (layer$1.__dirty && layer$1.__drawIndex < 0) layer$1.__drawIndex = layer$1.__startIndex;
		});
	};
	CanvasPainter$1.prototype.clear = function() {
		this.eachBuiltinLayer(this._clearLayer);
		return this;
	};
	CanvasPainter$1.prototype._clearLayer = function(layer) {
		layer.clear();
	};
	CanvasPainter$1.prototype.setBackgroundColor = function(backgroundColor$1) {
		this._backgroundColor = backgroundColor$1;
		each(this._layers, function(layer) {
			layer.setUnpainted();
		});
	};
	CanvasPainter$1.prototype.configLayer = function(zlevel, config) {
		if (config) {
			var layerConfig = this._layerConfig;
			if (!layerConfig[zlevel]) layerConfig[zlevel] = config;
			else merge(layerConfig[zlevel], config, true);
			for (var i$1 = 0; i$1 < this._zlevelList.length; i$1++) {
				var _zlevel = this._zlevelList[i$1];
				if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
					var layer = this._layers[_zlevel];
					merge(layer, layerConfig[zlevel], true);
				}
			}
		}
	};
	CanvasPainter$1.prototype.delLayer = function(zlevel) {
		var layers = this._layers;
		var zlevelList = this._zlevelList;
		var layer = layers[zlevel];
		if (!layer) return;
		layer.dom.parentNode.removeChild(layer.dom);
		delete layers[zlevel];
		zlevelList.splice(indexOf(zlevelList, zlevel), 1);
	};
	CanvasPainter$1.prototype.resize = function(width, height) {
		if (!this._domRoot.style) {
			if (width == null || height == null) return;
			this._width = width;
			this._height = height;
			this.getLayer(CANVAS_ZLEVEL).resize(width, height);
		} else {
			var domRoot = this._domRoot;
			domRoot.style.display = "none";
			var opts = this._opts;
			var root = this.root;
			width != null && (opts.width = width);
			height != null && (opts.height = height);
			width = getSize$1(root, 0, opts);
			height = getSize$1(root, 1, opts);
			domRoot.style.display = "";
			if (this._width !== width || height !== this._height) {
				domRoot.style.width = width + "px";
				domRoot.style.height = height + "px";
				for (var id in this._layers) if (this._layers.hasOwnProperty(id)) this._layers[id].resize(width, height);
				this.refresh(true);
			}
			this._width = width;
			this._height = height;
		}
		return this;
	};
	CanvasPainter$1.prototype.clearLayer = function(zlevel) {
		var layer = this._layers[zlevel];
		if (layer) layer.clear();
	};
	CanvasPainter$1.prototype.dispose = function() {
		this.root.innerHTML = "";
		this.root = this.storage = this._domRoot = this._layers = null;
	};
	CanvasPainter$1.prototype.getRenderedCanvas = function(opts) {
		opts = opts || {};
		if (this._singleCanvas && !this._compositeManually) return this._layers[CANVAS_ZLEVEL].dom;
		var imageLayer = new Layer_default("image", this, opts.pixelRatio || this.dpr);
		imageLayer.initContext();
		imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
		var ctx = imageLayer.ctx;
		if (opts.pixelRatio <= this.dpr) {
			this.refresh();
			var width_1 = imageLayer.dom.width;
			var height_1 = imageLayer.dom.height;
			this.eachLayer(function(layer) {
				if (layer.__builtin__) ctx.drawImage(layer.dom, 0, 0, width_1, height_1);
				else if (layer.renderToCanvas) {
					ctx.save();
					layer.renderToCanvas(ctx);
					ctx.restore();
				}
			});
		} else {
			var scope = {
				inHover: false,
				viewWidth: this._width,
				viewHeight: this._height
			};
			var displayList = this.storage.getDisplayList(true);
			for (var i$1 = 0, len$1 = displayList.length; i$1 < len$1; i$1++) {
				var el = displayList[i$1];
				brush(ctx, el, scope, i$1 === len$1 - 1);
			}
		}
		return imageLayer.dom;
	};
	CanvasPainter$1.prototype.getWidth = function() {
		return this._width;
	};
	CanvasPainter$1.prototype.getHeight = function() {
		return this._height;
	};
	return CanvasPainter$1;
}();
var Painter_default = CanvasPainter;

//#endregion
//#region node_modules/echarts/lib/renderer/installCanvasRenderer.js
function install$1(registers) {
	registers.registerPainter("canvas", Painter_default);
}

//#endregion
//#region node_modules/echarts/lib/chart/line/LineSeries.js
var LineSeriesModel = function(_super) {
	__extends(LineSeriesModel$1, _super);
	function LineSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = LineSeriesModel$1.type;
		_this.hasSymbolVisual = true;
		return _this;
	}
	LineSeriesModel$1.prototype.getInitialData = function(option) {
		var coordSys = option.coordinateSystem;
		if (coordSys !== "polar" && coordSys !== "cartesian2d") throw new Error("Line not support coordinateSystem besides cartesian and polar");
		return createSeriesData_default(null, this, { useEncodeDefaulter: true });
	};
	LineSeriesModel$1.prototype.getLegendIcon = function(opt) {
		var group = new Group_default();
		var line = createSymbol("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
		group.add(line);
		line.setStyle(opt.lineStyle);
		var visualType = this.getData().getVisual("symbol");
		var visualRotate = this.getData().getVisual("symbolRotate");
		var symbolType = visualType === "none" ? "circle" : visualType;
		var size = opt.itemHeight * .8;
		var symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
		group.add(symbol);
		symbol.setStyle(opt.itemStyle);
		symbol.rotation = (opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0) * Math.PI / 180;
		symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
		if (symbolType.indexOf("empty") > -1) {
			symbol.style.stroke = symbol.style.fill;
			symbol.style.fill = tokens_default.color.neutral00;
			symbol.style.lineWidth = 2;
		}
		return group;
	};
	LineSeriesModel$1.type = "series.line";
	LineSeriesModel$1.dependencies = ["grid", "polar"];
	LineSeriesModel$1.defaultOption = {
		z: 3,
		coordinateSystem: "cartesian2d",
		legendHoverLink: true,
		clip: true,
		label: { position: "top" },
		endLabel: {
			show: false,
			valueAnimation: true,
			distance: 8
		},
		lineStyle: {
			width: 2,
			type: "solid"
		},
		emphasis: { scale: true },
		step: false,
		smooth: false,
		smoothMonotone: null,
		symbol: "emptyCircle",
		symbolSize: 6,
		symbolRotate: null,
		showSymbol: true,
		showAllSymbol: "auto",
		connectNulls: false,
		sampling: "none",
		animationEasing: "linear",
		progressive: 0,
		hoverLayerThreshold: Infinity,
		universalTransition: { divideShape: "clone" },
		triggerLineEvent: false
	};
	return LineSeriesModel$1;
}(Series_default);
var LineSeries_default = LineSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/helper/labelHelper.js
/**
* @return label string. Not null/undefined
*/
function getDefaultLabel(data, dataIndex) {
	var labelDims = data.mapDimensionsAll("defaultedLabel");
	var len$1 = labelDims.length;
	if (len$1 === 1) {
		var rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
		return rawVal != null ? rawVal + "" : null;
	} else if (len$1) {
		var vals = [];
		for (var i$1 = 0; i$1 < labelDims.length; i$1++) vals.push(retrieveRawValue(data, dataIndex, labelDims[i$1]));
		return vals.join(" ");
	}
}
function getDefaultInterpolatedLabel(data, interpolatedValue) {
	var labelDims = data.mapDimensionsAll("defaultedLabel");
	if (!isArray(interpolatedValue)) return interpolatedValue + "";
	var vals = [];
	for (var i$1 = 0; i$1 < labelDims.length; i$1++) {
		var dimIndex = data.getDimensionIndex(labelDims[i$1]);
		if (dimIndex >= 0) vals.push(interpolatedValue[dimIndex]);
	}
	return vals.join(" ");
}

//#endregion
//#region node_modules/echarts/lib/chart/helper/Symbol.js
var Symbol$1 = function(_super) {
	__extends(Symbol$2, _super);
	function Symbol$2(data, idx, seriesScope, opts) {
		var _this = _super.call(this) || this;
		_this.updateData(data, idx, seriesScope, opts);
		return _this;
	}
	Symbol$2.prototype._createSymbol = function(symbolType, data, idx, symbolSize, z2, keepAspect) {
		this.removeAll();
		var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
		symbolPath.attr({
			z2: retrieve2(z2, 100),
			culling: true,
			scaleX: symbolSize[0] / 2,
			scaleY: symbolSize[1] / 2
		});
		symbolPath.drift = driftSymbol;
		this._symbolType = symbolType;
		this.add(symbolPath);
	};
	/**
	* Stop animation
	* @param {boolean} toLastFrame
	*/
	Symbol$2.prototype.stopSymbolAnimation = function(toLastFrame) {
		this.childAt(0).stopAnimation(null, toLastFrame);
	};
	Symbol$2.prototype.getSymbolType = function() {
		return this._symbolType;
	};
	/**
	* FIXME:
	* Caution: This method breaks the encapsulation of this module,
	* but it indeed brings convenience. So do not use the method
	* unless you detailedly know all the implements of `Symbol`,
	* especially animation.
	*
	* Get symbol path element.
	*/
	Symbol$2.prototype.getSymbolPath = function() {
		return this.childAt(0);
	};
	/**
	* Highlight symbol
	*/
	Symbol$2.prototype.highlight = function() {
		enterEmphasis(this.childAt(0));
	};
	/**
	* Downplay symbol
	*/
	Symbol$2.prototype.downplay = function() {
		leaveEmphasis(this.childAt(0));
	};
	/**
	* @param {number} zlevel
	* @param {number} z
	*/
	Symbol$2.prototype.setZ = function(zlevel, z) {
		var symbolPath = this.childAt(0);
		symbolPath.zlevel = zlevel;
		symbolPath.z = z;
	};
	Symbol$2.prototype.setDraggable = function(draggable, hasCursorOption) {
		var symbolPath = this.childAt(0);
		symbolPath.draggable = draggable;
		symbolPath.cursor = !hasCursorOption && draggable ? "move" : symbolPath.cursor;
	};
	/**
	* Update symbol properties
	*/
	Symbol$2.prototype.updateData = function(data, idx, seriesScope, opts) {
		this.silent = false;
		var symbolType = data.getItemVisual(idx, "symbol") || "circle";
		var seriesModel = data.hostModel;
		var symbolSize = Symbol$2.getSymbolSize(data, idx);
		var z2 = Symbol$2.getSymbolZ2(data, idx);
		var isInit = symbolType !== this._symbolType;
		var disableAnimation = opts && opts.disableAnimation;
		if (isInit) {
			var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
			this._createSymbol(symbolType, data, idx, symbolSize, z2, keepAspect);
		} else {
			var symbolPath = this.childAt(0);
			symbolPath.silent = false;
			var target = {
				scaleX: symbolSize[0] / 2,
				scaleY: symbolSize[1] / 2
			};
			disableAnimation ? symbolPath.attr(target) : updateProps(symbolPath, target, seriesModel, idx);
			saveOldStyle(symbolPath);
		}
		this._updateCommon(data, idx, symbolSize, seriesScope, opts);
		if (isInit) {
			var symbolPath = this.childAt(0);
			if (!disableAnimation) {
				var target = {
					scaleX: this._sizeX,
					scaleY: this._sizeY,
					style: { opacity: symbolPath.style.opacity }
				};
				symbolPath.scaleX = symbolPath.scaleY = 0;
				symbolPath.style.opacity = 0;
				initProps(symbolPath, target, seriesModel, idx);
			}
		}
		if (disableAnimation) this.childAt(0).stopAnimation("leave");
	};
	Symbol$2.prototype._updateCommon = function(data, idx, symbolSize, seriesScope, opts) {
		var symbolPath = this.childAt(0);
		var seriesModel = data.hostModel;
		var emphasisItemStyle;
		var blurItemStyle;
		var selectItemStyle;
		var focus;
		var blurScope;
		var emphasisDisabled;
		var labelStatesModels;
		var hoverScale;
		var cursorStyle;
		if (seriesScope) {
			emphasisItemStyle = seriesScope.emphasisItemStyle;
			blurItemStyle = seriesScope.blurItemStyle;
			selectItemStyle = seriesScope.selectItemStyle;
			focus = seriesScope.focus;
			blurScope = seriesScope.blurScope;
			labelStatesModels = seriesScope.labelStatesModels;
			hoverScale = seriesScope.hoverScale;
			cursorStyle = seriesScope.cursorStyle;
			emphasisDisabled = seriesScope.emphasisDisabled;
		}
		if (!seriesScope || data.hasItemOption) {
			var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
			var emphasisModel = itemModel.getModel("emphasis");
			emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
			selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
			blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
			focus = emphasisModel.get("focus");
			blurScope = emphasisModel.get("blurScope");
			emphasisDisabled = emphasisModel.get("disabled");
			labelStatesModels = getLabelStatesModels(itemModel);
			hoverScale = emphasisModel.getShallow("scale");
			cursorStyle = itemModel.getShallow("cursor");
		}
		var symbolRotate = data.getItemVisual(idx, "symbolRotate");
		symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
		var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
		if (symbolOffset) {
			symbolPath.x = symbolOffset[0];
			symbolPath.y = symbolOffset[1];
		}
		cursorStyle && symbolPath.attr("cursor", cursorStyle);
		var symbolStyle = data.getItemVisual(idx, "style");
		var visualColor = symbolStyle.fill;
		if (symbolPath instanceof Image_default) {
			var pathStyle = symbolPath.style;
			symbolPath.useStyle(extend({
				image: pathStyle.image,
				x: pathStyle.x,
				y: pathStyle.y,
				width: pathStyle.width,
				height: pathStyle.height
			}, symbolStyle));
		} else {
			if (symbolPath.__isEmptyBrush) symbolPath.useStyle(extend({}, symbolStyle));
			else symbolPath.useStyle(symbolStyle);
			symbolPath.style.decal = null;
			symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
			symbolPath.style.strokeNoScale = true;
		}
		var liftZ = data.getItemVisual(idx, "liftZ");
		var z2Origin = this._z2;
		if (liftZ != null) {
			if (z2Origin == null) {
				this._z2 = symbolPath.z2;
				symbolPath.z2 += liftZ;
			}
		} else if (z2Origin != null) {
			symbolPath.z2 = z2Origin;
			this._z2 = null;
		}
		var useNameLabel = opts && opts.useNameLabel;
		setLabelStyle(symbolPath, labelStatesModels, {
			labelFetcher: seriesModel,
			labelDataIndex: idx,
			defaultText: getLabelDefaultText,
			inheritColor: visualColor,
			defaultOpacity: symbolStyle.opacity
		});
		function getLabelDefaultText(idx$1) {
			return useNameLabel ? data.getName(idx$1) : getDefaultLabel(data, idx$1);
		}
		this._sizeX = symbolSize[0] / 2;
		this._sizeY = symbolSize[1] / 2;
		var emphasisState = symbolPath.ensureState("emphasis");
		emphasisState.style = emphasisItemStyle;
		symbolPath.ensureState("select").style = selectItemStyle;
		symbolPath.ensureState("blur").style = blurItemStyle;
		var scaleRatio = hoverScale == null || hoverScale === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(hoverScale) && hoverScale > 0 ? +hoverScale : 1;
		emphasisState.scaleX = this._sizeX * scaleRatio;
		emphasisState.scaleY = this._sizeY * scaleRatio;
		this.setSymbolScale(1);
		toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
	};
	Symbol$2.prototype.setSymbolScale = function(scale$3) {
		this.scaleX = this.scaleY = scale$3;
	};
	Symbol$2.prototype.fadeOut = function(cb, seriesModel, opt) {
		var symbolPath = this.childAt(0);
		var dataIndex = getECData(this).dataIndex;
		var animationOpt = opt && opt.animation;
		this.silent = symbolPath.silent = true;
		if (opt && opt.fadeLabel) {
			var textContent = symbolPath.getTextContent();
			if (textContent) removeElement(textContent, { style: { opacity: 0 } }, seriesModel, {
				dataIndex,
				removeOpt: animationOpt,
				cb: function() {
					symbolPath.removeTextContent();
				}
			});
		} else symbolPath.removeTextContent();
		removeElement(symbolPath, {
			style: { opacity: 0 },
			scaleX: 0,
			scaleY: 0
		}, seriesModel, {
			dataIndex,
			cb,
			removeOpt: animationOpt
		});
	};
	Symbol$2.getSymbolSize = function(data, idx) {
		return normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
	};
	Symbol$2.getSymbolZ2 = function(data, idx) {
		return data.getItemVisual(idx, "z2");
	};
	return Symbol$2;
}(Group_default);
function driftSymbol(dx, dy) {
	this.parent.drift(dx, dy);
}
var Symbol_default = Symbol$1;

//#endregion
//#region node_modules/echarts/lib/chart/helper/SymbolDraw.js
function symbolNeedsDraw$1(data, point, idx, opt) {
	return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
}
function normalizeUpdateOpt(opt) {
	if (opt != null && !isObject(opt)) opt = { isIgnore: opt };
	return opt || {};
}
function makeSeriesScope$2(data) {
	var seriesModel = data.hostModel;
	var emphasisModel = seriesModel.getModel("emphasis");
	return {
		emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
		blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
		selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
		focus: emphasisModel.get("focus"),
		blurScope: emphasisModel.get("blurScope"),
		emphasisDisabled: emphasisModel.get("disabled"),
		hoverScale: emphasisModel.get("scale"),
		labelStatesModels: getLabelStatesModels(seriesModel),
		cursorStyle: seriesModel.get("cursor")
	};
}
var SymbolDraw = function() {
	function SymbolDraw$1(SymbolCtor) {
		this.group = new Group_default();
		this._SymbolCtor = SymbolCtor || Symbol_default;
	}
	/**
	* Update symbols draw by new data
	*/
	SymbolDraw$1.prototype.updateData = function(data, opt) {
		this._progressiveEls = null;
		opt = normalizeUpdateOpt(opt);
		var group = this.group;
		var seriesModel = data.hostModel;
		var oldData = this._data;
		var SymbolCtor = this._SymbolCtor;
		var disableAnimation = opt.disableAnimation;
		var seriesScope = makeSeriesScope$2(data);
		var symbolUpdateOpt = { disableAnimation };
		var getSymbolPoint = opt.getSymbolPoint || function(idx) {
			return data.getItemLayout(idx);
		};
		if (!oldData) group.removeAll();
		data.diff(oldData).add(function(newIdx) {
			var point = getSymbolPoint(newIdx);
			if (symbolNeedsDraw$1(data, point, newIdx, opt)) {
				var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
				symbolEl.setPosition(point);
				data.setItemGraphicEl(newIdx, symbolEl);
				group.add(symbolEl);
			}
		}).update(function(newIdx, oldIdx) {
			var symbolEl = oldData.getItemGraphicEl(oldIdx);
			var point = getSymbolPoint(newIdx);
			if (!symbolNeedsDraw$1(data, point, newIdx, opt)) {
				group.remove(symbolEl);
				return;
			}
			var newSymbolType = data.getItemVisual(newIdx, "symbol") || "circle";
			var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
			if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
				group.remove(symbolEl);
				symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
				symbolEl.setPosition(point);
			} else {
				symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
				var target = {
					x: point[0],
					y: point[1]
				};
				disableAnimation ? symbolEl.attr(target) : updateProps(symbolEl, target, seriesModel);
			}
			group.add(symbolEl);
			data.setItemGraphicEl(newIdx, symbolEl);
		}).remove(function(oldIdx) {
			var el = oldData.getItemGraphicEl(oldIdx);
			el && el.fadeOut(function() {
				group.remove(el);
			}, seriesModel);
		}).execute();
		this._getSymbolPoint = getSymbolPoint;
		this._data = data;
	};
	SymbolDraw$1.prototype.updateLayout = function() {
		var _this = this;
		var data = this._data;
		if (data) data.eachItemGraphicEl(function(el, idx) {
			var point = _this._getSymbolPoint(idx);
			el.setPosition(point);
			el.markRedraw();
		});
	};
	SymbolDraw$1.prototype.incrementalPrepareUpdate = function(data) {
		this._seriesScope = makeSeriesScope$2(data);
		this._data = null;
		this.group.removeAll();
	};
	/**
	* Update symbols draw by new data
	*/
	SymbolDraw$1.prototype.incrementalUpdate = function(taskParams, data, opt) {
		this._progressiveEls = [];
		opt = normalizeUpdateOpt(opt);
		function updateIncrementalAndHover(el$1) {
			if (!el$1.isGroup) {
				el$1.incremental = true;
				el$1.ensureState("emphasis").hoverLayer = true;
			}
		}
		for (var idx = taskParams.start; idx < taskParams.end; idx++) {
			var point = data.getItemLayout(idx);
			if (symbolNeedsDraw$1(data, point, idx, opt)) {
				var el = new this._SymbolCtor(data, idx, this._seriesScope);
				el.traverse(updateIncrementalAndHover);
				el.setPosition(point);
				this.group.add(el);
				data.setItemGraphicEl(idx, el);
				this._progressiveEls.push(el);
			}
		}
	};
	SymbolDraw$1.prototype.eachRendered = function(cb) {
		traverseElements(this._progressiveEls || this.group, cb);
	};
	SymbolDraw$1.prototype.remove = function(enableAnimation) {
		var group = this.group;
		var data = this._data;
		if (data && enableAnimation) data.eachItemGraphicEl(function(el) {
			el.fadeOut(function() {
				group.remove(el);
			}, data.hostModel);
		});
		else group.removeAll();
	};
	return SymbolDraw$1;
}();
var SymbolDraw_default = SymbolDraw;

//#endregion
//#region node_modules/echarts/lib/chart/line/helper.js
function prepareDataCoordInfo(coordSys, data, valueOrigin) {
	var baseAxis = coordSys.getBaseAxis();
	var valueAxis$1 = coordSys.getOtherAxis(baseAxis);
	var valueStart = getValueStart(valueAxis$1, valueOrigin);
	var baseAxisDim = baseAxis.dim;
	var valueAxisDim = valueAxis$1.dim;
	var valueDim = data.mapDimension(valueAxisDim);
	var baseDim = data.mapDimension(baseAxisDim);
	var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
	var dims = map(coordSys.dimensions, function(coordDim) {
		return data.mapDimension(coordDim);
	});
	var stacked = false;
	var stackResultDim = data.getCalculationInfo("stackResultDimension");
	if (isDimensionStacked(data, dims[0])) {
		stacked = true;
		dims[0] = stackResultDim;
	}
	if (isDimensionStacked(data, dims[1])) {
		stacked = true;
		dims[1] = stackResultDim;
	}
	return {
		dataDimsForPoint: dims,
		valueStart,
		valueAxisDim,
		baseAxisDim,
		stacked: !!stacked,
		valueDim,
		baseDim,
		baseDataOffset,
		stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
	};
}
function getValueStart(valueAxis$1, valueOrigin) {
	var valueStart = 0;
	var extent = valueAxis$1.scale.getExtent();
	if (valueOrigin === "start") valueStart = extent[0];
	else if (valueOrigin === "end") valueStart = extent[1];
	else if (isNumber(valueOrigin) && !isNaN(valueOrigin)) valueStart = valueOrigin;
	else if (extent[0] > 0) valueStart = extent[0];
	else if (extent[1] < 0) valueStart = extent[1];
	return valueStart;
}
function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
	var value = NaN;
	if (dataCoordInfo.stacked) value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
	if (isNaN(value)) value = dataCoordInfo.valueStart;
	var baseDataOffset = dataCoordInfo.baseDataOffset;
	var stackedData = [];
	stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
	stackedData[1 - baseDataOffset] = value;
	return coordSys.dataToPoint(stackedData);
}

//#endregion
//#region node_modules/echarts/lib/chart/line/lineAnimationDiff.js
function diffData(oldData, newData) {
	var diffResult = [];
	newData.diff(oldData).add(function(idx) {
		diffResult.push({
			cmd: "+",
			idx
		});
	}).update(function(newIdx, oldIdx) {
		diffResult.push({
			cmd: "=",
			idx: oldIdx,
			idx1: newIdx
		});
	}).remove(function(idx) {
		diffResult.push({
			cmd: "-",
			idx
		});
	}).execute();
	return diffResult;
}
function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
	var diff = diffData(oldData, newData);
	var currPoints = [];
	var nextPoints = [];
	var currStackedPoints = [];
	var nextStackedPoints = [];
	var status = [];
	var sortedIndices = [];
	var rawIndices = [];
	var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
	var oldPoints = oldData.getLayout("points") || [];
	var newPoints = newData.getLayout("points") || [];
	for (var i$1 = 0; i$1 < diff.length; i$1++) {
		var diffItem = diff[i$1];
		var pointAdded = true;
		var oldIdx2 = void 0;
		var newIdx2 = void 0;
		switch (diffItem.cmd) {
			case "=":
				oldIdx2 = diffItem.idx * 2;
				newIdx2 = diffItem.idx1 * 2;
				var currentX = oldPoints[oldIdx2];
				var currentY = oldPoints[oldIdx2 + 1];
				var nextX = newPoints[newIdx2];
				var nextY = newPoints[newIdx2 + 1];
				if (isNaN(currentX) || isNaN(currentY)) {
					currentX = nextX;
					currentY = nextY;
				}
				currPoints.push(currentX, currentY);
				nextPoints.push(nextX, nextY);
				currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
				nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
				rawIndices.push(newData.getRawIndex(diffItem.idx1));
				break;
			case "+":
				var newIdx = diffItem.idx;
				var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
				var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
				newIdx2 = newIdx * 2;
				currPoints.push(oldPt[0], oldPt[1]);
				nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
				var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
				currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
				nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
				rawIndices.push(newData.getRawIndex(newIdx));
				break;
			case "-": pointAdded = false;
		}
		if (pointAdded) {
			status.push(diffItem);
			sortedIndices.push(sortedIndices.length);
		}
	}
	sortedIndices.sort(function(a, b) {
		return rawIndices[a] - rawIndices[b];
	});
	var len$1 = currPoints.length;
	var sortedCurrPoints = createFloat32Array(len$1);
	var sortedNextPoints = createFloat32Array(len$1);
	var sortedCurrStackedPoints = createFloat32Array(len$1);
	var sortedNextStackedPoints = createFloat32Array(len$1);
	var sortedStatus = [];
	for (var i$1 = 0; i$1 < sortedIndices.length; i$1++) {
		var idx = sortedIndices[i$1];
		var i2 = i$1 * 2;
		var idx2 = idx * 2;
		sortedCurrPoints[i2] = currPoints[idx2];
		sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
		sortedNextPoints[i2] = nextPoints[idx2];
		sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
		sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
		sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
		sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
		sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
		sortedStatus[i$1] = status[idx];
	}
	return {
		current: sortedCurrPoints,
		next: sortedNextPoints,
		stackedOnCurrent: sortedCurrStackedPoints,
		stackedOnNext: sortedNextStackedPoints,
		status: sortedStatus
	};
}

//#endregion
//#region node_modules/echarts/lib/chart/line/poly.js
var mathMin$6 = Math.min;
var mathMax$6 = Math.max;
function isPointNull$1(x, y) {
	return isNaN(x) || isNaN(y);
}
/**
* Draw smoothed line in non-monotone, in may cause undesired curve in extreme
* situations. This should be used when points are non-monotone neither in x or
* y dimension.
*/
function drawSegment(ctx, points$3, start$1, segLen, allLen, dir$1, smooth, smoothMonotone, connectNulls) {
	var prevX;
	var prevY;
	var cpx0;
	var cpy0;
	var cpx1;
	var cpy1;
	var idx = start$1;
	var k$1 = 0;
	for (; k$1 < segLen; k$1++) {
		var x = points$3[idx * 2];
		var y = points$3[idx * 2 + 1];
		if (idx >= allLen || idx < 0) break;
		if (isPointNull$1(x, y)) {
			if (connectNulls) {
				idx += dir$1;
				continue;
			}
			break;
		}
		if (idx === start$1) {
			ctx[dir$1 > 0 ? "moveTo" : "lineTo"](x, y);
			cpx0 = x;
			cpy0 = y;
		} else {
			var dx = x - prevX;
			var dy = y - prevY;
			if (dx * dx + dy * dy < .5) {
				idx += dir$1;
				continue;
			}
			if (smooth > 0) {
				var nextIdx = idx + dir$1;
				var nextX = points$3[nextIdx * 2];
				var nextY = points$3[nextIdx * 2 + 1];
				while (nextX === x && nextY === y && k$1 < segLen) {
					k$1++;
					nextIdx += dir$1;
					idx += dir$1;
					nextX = points$3[nextIdx * 2];
					nextY = points$3[nextIdx * 2 + 1];
					x = points$3[idx * 2];
					y = points$3[idx * 2 + 1];
					dx = x - prevX;
					dy = y - prevY;
				}
				var tmpK = k$1 + 1;
				if (connectNulls) while (isPointNull$1(nextX, nextY) && tmpK < segLen) {
					tmpK++;
					nextIdx += dir$1;
					nextX = points$3[nextIdx * 2];
					nextY = points$3[nextIdx * 2 + 1];
				}
				var ratioNextSeg = .5;
				var vx = 0;
				var vy = 0;
				var nextCpx0 = void 0;
				var nextCpy0 = void 0;
				if (tmpK >= segLen || isPointNull$1(nextX, nextY)) {
					cpx1 = x;
					cpy1 = y;
				} else {
					vx = nextX - prevX;
					vy = nextY - prevY;
					var dx0 = x - prevX;
					var dx1 = nextX - x;
					var dy0 = y - prevY;
					var dy1 = nextY - y;
					var lenPrevSeg = void 0;
					var lenNextSeg = void 0;
					if (smoothMonotone === "x") {
						lenPrevSeg = Math.abs(dx0);
						lenNextSeg = Math.abs(dx1);
						var dir_1 = vx > 0 ? 1 : -1;
						cpx1 = x - dir_1 * lenPrevSeg * smooth;
						cpy1 = y;
						nextCpx0 = x + dir_1 * lenNextSeg * smooth;
						nextCpy0 = y;
					} else if (smoothMonotone === "y") {
						lenPrevSeg = Math.abs(dy0);
						lenNextSeg = Math.abs(dy1);
						var dir_2 = vy > 0 ? 1 : -1;
						cpx1 = x;
						cpy1 = y - dir_2 * lenPrevSeg * smooth;
						nextCpx0 = x;
						nextCpy0 = y + dir_2 * lenNextSeg * smooth;
					} else {
						lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
						lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
						ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
						cpx1 = x - vx * smooth * (1 - ratioNextSeg);
						cpy1 = y - vy * smooth * (1 - ratioNextSeg);
						nextCpx0 = x + vx * smooth * ratioNextSeg;
						nextCpy0 = y + vy * smooth * ratioNextSeg;
						nextCpx0 = mathMin$6(nextCpx0, mathMax$6(nextX, x));
						nextCpy0 = mathMin$6(nextCpy0, mathMax$6(nextY, y));
						nextCpx0 = mathMax$6(nextCpx0, mathMin$6(nextX, x));
						nextCpy0 = mathMax$6(nextCpy0, mathMin$6(nextY, y));
						vx = nextCpx0 - x;
						vy = nextCpy0 - y;
						cpx1 = x - vx * lenPrevSeg / lenNextSeg;
						cpy1 = y - vy * lenPrevSeg / lenNextSeg;
						cpx1 = mathMin$6(cpx1, mathMax$6(prevX, x));
						cpy1 = mathMin$6(cpy1, mathMax$6(prevY, y));
						cpx1 = mathMax$6(cpx1, mathMin$6(prevX, x));
						cpy1 = mathMax$6(cpy1, mathMin$6(prevY, y));
						vx = x - cpx1;
						vy = y - cpy1;
						nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;
						nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
					}
				}
				ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);
				cpx0 = nextCpx0;
				cpy0 = nextCpy0;
			} else ctx.lineTo(x, y);
		}
		prevX = x;
		prevY = y;
		idx += dir$1;
	}
	return k$1;
}
var ECPolylineShape = function() {
	function ECPolylineShape$1() {
		this.smooth = 0;
		this.smoothConstraint = true;
	}
	return ECPolylineShape$1;
}();
var ECPolyline = function(_super) {
	__extends(ECPolyline$1, _super);
	function ECPolyline$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this.type = "ec-polyline";
		return _this;
	}
	ECPolyline$1.prototype.getDefaultStyle = function() {
		return {
			stroke: tokens_default.color.neutral99,
			fill: null
		};
	};
	ECPolyline$1.prototype.getDefaultShape = function() {
		return new ECPolylineShape();
	};
	ECPolyline$1.prototype.buildPath = function(ctx, shape) {
		var points$3 = shape.points;
		var i$1 = 0;
		var len$1 = points$3.length / 2;
		if (shape.connectNulls) {
			for (; len$1 > 0; len$1--) if (!isPointNull$1(points$3[len$1 * 2 - 2], points$3[len$1 * 2 - 1])) break;
			for (; i$1 < len$1; i$1++) if (!isPointNull$1(points$3[i$1 * 2], points$3[i$1 * 2 + 1])) break;
		}
		while (i$1 < len$1) i$1 += drawSegment(ctx, points$3, i$1, len$1, len$1, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
	};
	ECPolyline$1.prototype.getPointOn = function(xOrY, dim) {
		if (!this.path) {
			this.createPathProxy();
			this.buildPath(this.path, this.shape);
		}
		var data = this.path.data;
		var CMD$5 = PathProxy_default.CMD;
		var x0;
		var y0;
		var isDimX = dim === "x";
		var roots$1 = [];
		for (var i$1 = 0; i$1 < data.length;) {
			var cmd = data[i$1++];
			var x = void 0;
			var y = void 0;
			var x2 = void 0;
			var y2 = void 0;
			var x3 = void 0;
			var y3 = void 0;
			var t = void 0;
			switch (cmd) {
				case CMD$5.M:
					x0 = data[i$1++];
					y0 = data[i$1++];
					break;
				case CMD$5.L:
					x = data[i$1++];
					y = data[i$1++];
					t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);
					if (t <= 1 && t >= 0) {
						var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;
						return isDimX ? [xOrY, val] : [val, xOrY];
					}
					x0 = x;
					y0 = y;
					break;
				case CMD$5.C:
					x = data[i$1++];
					y = data[i$1++];
					x2 = data[i$1++];
					y2 = data[i$1++];
					x3 = data[i$1++];
					y3 = data[i$1++];
					var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots$1) : cubicRootAt(y0, y, y2, y3, xOrY, roots$1);
					if (nRoot > 0) for (var i_1 = 0; i_1 < nRoot; i_1++) {
						var t_1 = roots$1[i_1];
						if (t_1 <= 1 && t_1 >= 0) {
							var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);
							return isDimX ? [xOrY, val] : [val, xOrY];
						}
					}
					x0 = x3;
					y0 = y3;
					break;
			}
		}
	};
	return ECPolyline$1;
}(Path_default);
var ECPolygonShape = function(_super) {
	__extends(ECPolygonShape$1, _super);
	function ECPolygonShape$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	return ECPolygonShape$1;
}(ECPolylineShape);
var ECPolygon = function(_super) {
	__extends(ECPolygon$1, _super);
	function ECPolygon$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this.type = "ec-polygon";
		return _this;
	}
	ECPolygon$1.prototype.getDefaultShape = function() {
		return new ECPolygonShape();
	};
	ECPolygon$1.prototype.buildPath = function(ctx, shape) {
		var points$3 = shape.points;
		var stackedOnPoints = shape.stackedOnPoints;
		var i$1 = 0;
		var len$1 = points$3.length / 2;
		var smoothMonotone = shape.smoothMonotone;
		if (shape.connectNulls) {
			for (; len$1 > 0; len$1--) if (!isPointNull$1(points$3[len$1 * 2 - 2], points$3[len$1 * 2 - 1])) break;
			for (; i$1 < len$1; i$1++) if (!isPointNull$1(points$3[i$1 * 2], points$3[i$1 * 2 + 1])) break;
		}
		while (i$1 < len$1) {
			var k$1 = drawSegment(ctx, points$3, i$1, len$1, len$1, 1, shape.smooth, smoothMonotone, shape.connectNulls);
			drawSegment(ctx, stackedOnPoints, i$1 + k$1 - 1, k$1, len$1, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
			i$1 += k$1 + 1;
			ctx.closePath();
		}
	};
	return ECPolygon$1;
}(Path_default);

//#endregion
//#region node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js
function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
	var rect = cartesian.getArea();
	var x = rect.x;
	var y = rect.y;
	var width = rect.width;
	var height = rect.height;
	var lineWidth = seriesModel.get(["lineStyle", "width"]) || 0;
	x -= lineWidth / 2;
	y -= lineWidth / 2;
	width += lineWidth;
	height += lineWidth;
	width = Math.ceil(width);
	if (x !== Math.floor(x)) {
		x = Math.floor(x);
		width++;
	}
	var clipPath = new Rect_default({ shape: {
		x,
		y,
		width,
		height
	} });
	if (hasAnimation) {
		var baseAxis = cartesian.getBaseAxis();
		var isHorizontal = baseAxis.isHorizontal();
		var isAxisInversed = baseAxis.inverse;
		if (isHorizontal) {
			if (isAxisInversed) clipPath.shape.x += width;
			clipPath.shape.width = 0;
		} else {
			if (!isAxisInversed) clipPath.shape.y += height;
			clipPath.shape.height = 0;
		}
		var duringCb = isFunction(during) ? function(percent) {
			during(percent, clipPath);
		} : null;
		initProps(clipPath, { shape: {
			width,
			height,
			x,
			y
		} }, seriesModel, null, done, duringCb);
	}
	return clipPath;
}
function createPolarClipPath(polar, hasAnimation, seriesModel) {
	var sectorArea = polar.getArea();
	var r0 = round(sectorArea.r0, 1);
	var r = round(sectorArea.r, 1);
	var clipPath = new Sector_default({ shape: {
		cx: round(polar.cx, 1),
		cy: round(polar.cy, 1),
		r0,
		r,
		startAngle: sectorArea.startAngle,
		endAngle: sectorArea.endAngle,
		clockwise: sectorArea.clockwise
	} });
	if (hasAnimation) {
		if (polar.getBaseAxis().dim === "angle") clipPath.shape.endAngle = sectorArea.startAngle;
		else clipPath.shape.r = r0;
		initProps(clipPath, { shape: {
			endAngle: sectorArea.endAngle,
			r
		} }, seriesModel);
	}
	return clipPath;
}
function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
	if (!coordSys) return null;
	else if (coordSys.type === "polar") return createPolarClipPath(coordSys, hasAnimation, seriesModel);
	else if (coordSys.type === "cartesian2d") return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
	return null;
}

//#endregion
//#region node_modules/echarts/lib/coord/CoordinateSystem.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function isCoordinateSystemType(coordSys, type) {
	return coordSys.type === type;
}

//#endregion
//#region node_modules/echarts/lib/chart/line/LineView.js
function isPointsSame(points1, points2) {
	if (points1.length !== points2.length) return;
	for (var i$1 = 0; i$1 < points1.length; i$1++) if (points1[i$1] !== points2[i$1]) return;
	return true;
}
function bboxFromPoints(points$3) {
	var minX = Infinity;
	var minY = Infinity;
	var maxX = -Infinity;
	var maxY = -Infinity;
	for (var i$1 = 0; i$1 < points$3.length;) {
		var x = points$3[i$1++];
		var y = points$3[i$1++];
		if (!isNaN(x)) {
			minX = Math.min(x, minX);
			maxX = Math.max(x, maxX);
		}
		if (!isNaN(y)) {
			minY = Math.min(y, minY);
			maxY = Math.max(y, maxY);
		}
	}
	return [[minX, minY], [maxX, maxY]];
}
function getBoundingDiff(points1, points2) {
	var _a$1 = bboxFromPoints(points1), min1 = _a$1[0], max1 = _a$1[1];
	var _b$1 = bboxFromPoints(points2), min2$1 = _b$1[0], max2$1 = _b$1[1];
	return Math.max(Math.abs(min1[0] - min2$1[0]), Math.abs(min1[1] - min2$1[1]), Math.abs(max1[0] - max2$1[0]), Math.abs(max1[1] - max2$1[1]));
}
function getSmooth(smooth) {
	return isNumber(smooth) ? smooth : smooth ? .5 : 0;
}
function getStackedOnPoints(coordSys, data, dataCoordInfo) {
	if (!dataCoordInfo.valueDim) return [];
	var len$1 = data.count();
	var points$3 = createFloat32Array(len$1 * 2);
	for (var idx = 0; idx < len$1; idx++) {
		var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
		points$3[idx * 2] = pt[0];
		points$3[idx * 2 + 1] = pt[1];
	}
	return points$3;
}
/**
* Filter the null data and extend data for step considering `stepTurnAt`
*
* @param points data to convert, that may containing null
* @param basePoints base data to reference, used only for areaStyle points
* @param coordSys coordinate system
* @param stepTurnAt 'start' | 'end' | 'middle' | true
* @param connectNulls whether to connect nulls
* @returns converted point positions
*/
function turnPointsIntoStep(points$3, basePoints, coordSys, stepTurnAt, connectNulls) {
	var baseAxis = coordSys.getBaseAxis();
	var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
	var stepPoints = [];
	var i$1 = 0;
	var stepPt = [];
	var pt = [];
	var nextPt = [];
	var filteredPoints = [];
	if (connectNulls) {
		for (i$1 = 0; i$1 < points$3.length; i$1 += 2) {
			/**
			* For areaStyle of stepped lines, `stackedOnPoints` should be
			* filtered the same as `points` so that the base axis values
			* should stay the same as the lines above. See #20021
			*/
			var reference = basePoints || points$3;
			if (!isNaN(reference[i$1]) && !isNaN(reference[i$1 + 1])) filteredPoints.push(points$3[i$1], points$3[i$1 + 1]);
		}
		points$3 = filteredPoints;
	}
	for (i$1 = 0; i$1 < points$3.length - 2; i$1 += 2) {
		nextPt[0] = points$3[i$1 + 2];
		nextPt[1] = points$3[i$1 + 3];
		pt[0] = points$3[i$1];
		pt[1] = points$3[i$1 + 1];
		stepPoints.push(pt[0], pt[1]);
		switch (stepTurnAt) {
			case "end":
				stepPt[baseIndex] = nextPt[baseIndex];
				stepPt[1 - baseIndex] = pt[1 - baseIndex];
				stepPoints.push(stepPt[0], stepPt[1]);
				break;
			case "middle":
				var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
				var stepPt2 = [];
				stepPt[baseIndex] = stepPt2[baseIndex] = middle;
				stepPt[1 - baseIndex] = pt[1 - baseIndex];
				stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
				stepPoints.push(stepPt[0], stepPt[1]);
				stepPoints.push(stepPt2[0], stepPt2[1]);
				break;
			default:
				stepPt[baseIndex] = pt[baseIndex];
				stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
				stepPoints.push(stepPt[0], stepPt[1]);
		}
	}
	stepPoints.push(points$3[i$1++], points$3[i$1++]);
	return stepPoints;
}
/**
* Clip color stops to edge. Avoid creating too large gradients.
* Which may lead to blurry when GPU acceleration is enabled. See #15680
*
* The stops has been sorted from small to large.
*/
function clipColorStops(colorStops, maxSize) {
	var newColorStops = [];
	var len$1 = colorStops.length;
	var prevOutOfRangeColorStop;
	var prevInRangeColorStop;
	function lerpStop(stop0, stop1, clippedCoord) {
		var coord0 = stop0.coord;
		return {
			coord: clippedCoord,
			color: lerp$1((clippedCoord - coord0) / (stop1.coord - coord0), [stop0.color, stop1.color])
		};
	}
	for (var i$1 = 0; i$1 < len$1; i$1++) {
		var stop_1 = colorStops[i$1];
		var coord = stop_1.coord;
		if (coord < 0) prevOutOfRangeColorStop = stop_1;
		else if (coord > maxSize) {
			if (prevInRangeColorStop) newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));
			else if (prevOutOfRangeColorStop) newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));
			break;
		} else {
			if (prevOutOfRangeColorStop) {
				newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0));
				prevOutOfRangeColorStop = null;
			}
			newColorStops.push(stop_1);
			prevInRangeColorStop = stop_1;
		}
	}
	return newColorStops;
}
function getVisualGradient(data, coordSys, api) {
	var visualMetaList = data.getVisual("visualMeta");
	if (!visualMetaList || !visualMetaList.length || !data.count()) return;
	if (coordSys.type !== "cartesian2d") {
		console.warn("Visual map on line style is only supported on cartesian2d.");
		return;
	}
	var coordDim;
	var visualMeta;
	for (var i$1 = visualMetaList.length - 1; i$1 >= 0; i$1--) {
		var dimInfo = data.getDimensionInfo(visualMetaList[i$1].dimension);
		coordDim = dimInfo && dimInfo.coordDim;
		if (coordDim === "x" || coordDim === "y") {
			visualMeta = visualMetaList[i$1];
			break;
		}
	}
	if (!visualMeta) {
		console.warn("Visual map on line style only support x or y dimension.");
		return;
	}
	var axis = coordSys.getAxis(coordDim);
	var colorStops = map(visualMeta.stops, function(stop$1) {
		return {
			coord: axis.toGlobalCoord(axis.dataToCoord(stop$1.value)),
			color: stop$1.color
		};
	});
	var stopLen = colorStops.length;
	var outerColors = visualMeta.outerColors.slice();
	if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
		colorStops.reverse();
		outerColors.reverse();
	}
	var colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api.getWidth() : api.getHeight());
	var inRangeStopLen = colorStopsInRange.length;
	if (!inRangeStopLen && stopLen) return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
	var tinyExtent = 10;
	var minCoord = colorStopsInRange[0].coord - tinyExtent;
	var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
	var coordSpan = maxCoord - minCoord;
	if (coordSpan < .001) return "transparent";
	each(colorStopsInRange, function(stop$1) {
		stop$1.offset = (stop$1.coord - minCoord) / coordSpan;
	});
	colorStopsInRange.push({
		offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : .5,
		color: outerColors[1] || "transparent"
	});
	colorStopsInRange.unshift({
		offset: inRangeStopLen ? colorStopsInRange[0].offset : .5,
		color: outerColors[0] || "transparent"
	});
	var gradient = new LinearGradient_default(0, 0, 0, 0, colorStopsInRange, true);
	gradient[coordDim] = minCoord;
	gradient[coordDim + "2"] = maxCoord;
	return gradient;
}
function getIsIgnoreFunc(seriesModel, data, coordSys) {
	var showAllSymbol = seriesModel.get("showAllSymbol");
	var isAuto = showAllSymbol === "auto";
	if (showAllSymbol && !isAuto) return;
	var categoryAxis$1 = coordSys.getAxesByScale("ordinal")[0];
	if (!categoryAxis$1) return;
	if (isAuto && canShowAllSymbolForCategory(categoryAxis$1, data)) return;
	var categoryDataDim = data.mapDimension(categoryAxis$1.dim);
	var labelMap = {};
	each(categoryAxis$1.getViewLabels(), function(labelItem) {
		var ordinalNumber = categoryAxis$1.scale.getRawOrdinalNumber(labelItem.tickValue);
		labelMap[ordinalNumber] = 1;
	});
	return function(dataIndex) {
		return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
	};
}
function canShowAllSymbolForCategory(categoryAxis$1, data) {
	var axisExtent = categoryAxis$1.getExtent();
	var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis$1.scale.count();
	isNaN(availSize) && (availSize = 0);
	var dataLen = data.count();
	var step = Math.max(1, Math.round(dataLen / 5));
	for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) if (Symbol_default.getSymbolSize(data, dataIndex)[categoryAxis$1.isHorizontal() ? 1 : 0] * 1.5 > availSize) return false;
	return true;
}
function isPointNull(x, y) {
	return isNaN(x) || isNaN(y);
}
function getLastIndexNotNull(points$3) {
	var len$1 = points$3.length / 2;
	for (; len$1 > 0; len$1--) if (!isPointNull(points$3[len$1 * 2 - 2], points$3[len$1 * 2 - 1])) break;
	return len$1 - 1;
}
function getPointAtIndex(points$3, idx) {
	return [points$3[idx * 2], points$3[idx * 2 + 1]];
}
function getIndexRange(points$3, xOrY, dim) {
	var len$1 = points$3.length / 2;
	var dimIdx = dim === "x" ? 0 : 1;
	var a;
	var b;
	var prevIndex = 0;
	var nextIndex = -1;
	for (var i$1 = 0; i$1 < len$1; i$1++) {
		b = points$3[i$1 * 2 + dimIdx];
		if (isNaN(b) || isNaN(points$3[i$1 * 2 + 1 - dimIdx])) continue;
		if (i$1 === 0) {
			a = b;
			continue;
		}
		if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
			nextIndex = i$1;
			break;
		}
		prevIndex = i$1;
		a = b;
	}
	return {
		range: [prevIndex, nextIndex],
		t: (xOrY - a) / (b - a)
	};
}
function anyStateShowEndLabel(seriesModel) {
	if (seriesModel.get(["endLabel", "show"])) return true;
	for (var i$1 = 0; i$1 < SPECIAL_STATES.length; i$1++) if (seriesModel.get([
		SPECIAL_STATES[i$1],
		"endLabel",
		"show"
	])) return true;
	return false;
}
function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
	if (isCoordinateSystemType(coordSys, "cartesian2d")) {
		var endLabelModel_1 = seriesModel.getModel("endLabel");
		var valueAnimation_1 = endLabelModel_1.get("valueAnimation");
		var data_1 = seriesModel.getData();
		var labelAnimationRecord_1 = { lastFrameIndex: 0 };
		var during = anyStateShowEndLabel(seriesModel) ? function(percent, clipRect) {
			lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
		} : null;
		var isHorizontal = coordSys.getBaseAxis().isHorizontal();
		var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function() {
			var endLabel = lineView._endLabel;
			if (endLabel && hasAnimation) {
				if (labelAnimationRecord_1.originalX != null) endLabel.attr({
					x: labelAnimationRecord_1.originalX,
					y: labelAnimationRecord_1.originalY
				});
			}
		}, during);
		if (!seriesModel.get("clip", true)) {
			var rectShape = clipPath.shape;
			var expandSize = Math.max(rectShape.width, rectShape.height);
			if (isHorizontal) {
				rectShape.y -= expandSize;
				rectShape.height += expandSize * 2;
			} else {
				rectShape.x -= expandSize;
				rectShape.width += expandSize * 2;
			}
		}
		if (during) during(1, clipPath);
		return clipPath;
	} else {
		if (seriesModel.get(["endLabel", "show"])) console.warn("endLabel is not supported for lines in polar systems.");
		return createPolarClipPath(coordSys, hasAnimation, seriesModel);
	}
}
function getEndLabelStateSpecified(endLabelModel, coordSys) {
	var baseAxis = coordSys.getBaseAxis();
	var isHorizontal = baseAxis.isHorizontal();
	var isBaseInversed = baseAxis.inverse;
	var align = isHorizontal ? isBaseInversed ? "right" : "left" : "center";
	var verticalAlign = isHorizontal ? "middle" : isBaseInversed ? "top" : "bottom";
	return { normal: {
		align: endLabelModel.get("align") || align,
		verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
	} };
}
var LineView = function(_super) {
	__extends(LineView$1, _super);
	function LineView$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	LineView$1.prototype.init = function() {
		var lineGroup = new Group_default();
		var symbolDraw = new SymbolDraw_default();
		this.group.add(symbolDraw.group);
		this._symbolDraw = symbolDraw;
		this._lineGroup = lineGroup;
		this._changePolyState = bind(this._changePolyState, this);
	};
	LineView$1.prototype.render = function(seriesModel, ecModel, api) {
		var coordSys = seriesModel.coordinateSystem;
		var group = this.group;
		var data = seriesModel.getData();
		var lineStyleModel = seriesModel.getModel("lineStyle");
		var areaStyleModel = seriesModel.getModel("areaStyle");
		var points$3 = data.getLayout("points") || [];
		var isCoordSysPolar = coordSys.type === "polar";
		var prevCoordSys = this._coordSys;
		var symbolDraw = this._symbolDraw;
		var polyline = this._polyline;
		var polygon = this._polygon;
		var lineGroup = this._lineGroup;
		var hasAnimation = !ecModel.ssr && seriesModel.get("animation");
		var isAreaChart = !areaStyleModel.isEmpty();
		var valueOrigin = areaStyleModel.get("origin");
		var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
		var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
		var showSymbol = seriesModel.get("showSymbol");
		var connectNulls = seriesModel.get("connectNulls");
		var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
		var oldData = this._data;
		oldData && oldData.eachItemGraphicEl(function(el, idx) {
			if (el.__temp) {
				group.remove(el);
				oldData.setItemGraphicEl(idx, null);
			}
		});
		if (!showSymbol) symbolDraw.remove();
		group.add(lineGroup);
		var step = !isCoordSysPolar ? seriesModel.get("step") : false;
		var clipShapeForSymbol;
		if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
			clipShapeForSymbol = coordSys.getArea();
			if (clipShapeForSymbol.width != null) {
				clipShapeForSymbol.x -= .1;
				clipShapeForSymbol.y -= .1;
				clipShapeForSymbol.width += .2;
				clipShapeForSymbol.height += .2;
			} else if (clipShapeForSymbol.r0) {
				clipShapeForSymbol.r0 -= .5;
				clipShapeForSymbol.r += .5;
			}
		}
		this._clipShapeForSymbol = clipShapeForSymbol;
		var visualColor = getVisualGradient(data, coordSys, api) || data.getVisual("style")[data.getVisual("drawType")];
		if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
			showSymbol && symbolDraw.updateData(data, {
				isIgnore: isIgnoreFunc,
				clipShape: clipShapeForSymbol,
				disableAnimation: true,
				getSymbolPoint: function(idx) {
					return [points$3[idx * 2], points$3[idx * 2 + 1]];
				}
			});
			hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
			if (step) {
				if (stackedOnPoints) stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points$3, coordSys, step, connectNulls);
				points$3 = turnPointsIntoStep(points$3, null, coordSys, step, connectNulls);
			}
			polyline = this._newPolyline(points$3);
			if (isAreaChart) polygon = this._newPolygon(points$3, stackedOnPoints);
			else if (polygon) {
				lineGroup.remove(polygon);
				polygon = this._polygon = null;
			}
			if (!isCoordSysPolar) this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
			lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
		} else {
			if (isAreaChart && !polygon) polygon = this._newPolygon(points$3, stackedOnPoints);
			else if (polygon && !isAreaChart) {
				lineGroup.remove(polygon);
				polygon = this._polygon = null;
			}
			if (!isCoordSysPolar) this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
			var oldClipPath = lineGroup.getClipPath();
			if (oldClipPath) {
				var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
				initProps(oldClipPath, { shape: newClipPath.shape }, seriesModel);
			} else lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
			showSymbol && symbolDraw.updateData(data, {
				isIgnore: isIgnoreFunc,
				clipShape: clipShapeForSymbol,
				disableAnimation: true,
				getSymbolPoint: function(idx) {
					return [points$3[idx * 2], points$3[idx * 2 + 1]];
				}
			});
			if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points$3)) if (hasAnimation) this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls);
			else {
				if (step) {
					if (stackedOnPoints) stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points$3, coordSys, step, connectNulls);
					points$3 = turnPointsIntoStep(points$3, null, coordSys, step, connectNulls);
				}
				polyline.setShape({ points: points$3 });
				polygon && polygon.setShape({
					points: points$3,
					stackedOnPoints
				});
			}
		}
		var emphasisModel = seriesModel.getModel("emphasis");
		var focus = emphasisModel.get("focus");
		var blurScope = emphasisModel.get("blurScope");
		var emphasisDisabled = emphasisModel.get("disabled");
		polyline.useStyle(defaults(lineStyleModel.getLineStyle(), {
			fill: "none",
			stroke: visualColor,
			lineJoin: "bevel"
		}));
		setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
		if (polyline.style.lineWidth > 0 && seriesModel.get([
			"emphasis",
			"lineStyle",
			"width"
		]) === "bolder") {
			var emphasisLineStyle = polyline.getState("emphasis").style;
			emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
		}
		getECData(polyline).seriesIndex = seriesModel.seriesIndex;
		toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
		var smooth = getSmooth(seriesModel.get("smooth"));
		var smoothMonotone = seriesModel.get("smoothMonotone");
		polyline.setShape({
			smooth,
			smoothMonotone,
			connectNulls
		});
		if (polygon) {
			var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
			var stackedOnSmooth = 0;
			polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
				fill: visualColor,
				opacity: .7,
				lineJoin: "bevel",
				decal: data.getVisual("style").decal
			}));
			if (stackedOnSeries) stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
			polygon.setShape({
				smooth,
				stackedOnSmooth,
				smoothMonotone,
				connectNulls
			});
			setStatesStylesFromModel(polygon, seriesModel, "areaStyle");
			getECData(polygon).seriesIndex = seriesModel.seriesIndex;
			toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled);
		}
		var changePolyState = this._changePolyState;
		data.eachItemGraphicEl(function(el) {
			el && (el.onHoverStateChange = changePolyState);
		});
		this._polyline.onHoverStateChange = changePolyState;
		this._data = data;
		this._coordSys = coordSys;
		this._stackedOnPoints = stackedOnPoints;
		this._points = points$3;
		this._step = step;
		this._valueOrigin = valueOrigin;
		if (seriesModel.get("triggerLineEvent")) {
			this.packEventData(seriesModel, polyline);
			polygon && this.packEventData(seriesModel, polygon);
		}
	};
	LineView$1.prototype.packEventData = function(seriesModel, el) {
		getECData(el).eventData = {
			componentType: "series",
			componentSubType: "line",
			componentIndex: seriesModel.componentIndex,
			seriesIndex: seriesModel.seriesIndex,
			seriesName: seriesModel.name,
			seriesType: "line"
		};
	};
	LineView$1.prototype.highlight = function(seriesModel, ecModel, api, payload) {
		var data = seriesModel.getData();
		var dataIndex = queryDataIndex(data, payload);
		this._changePolyState("emphasis");
		if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
			var points$3 = data.getLayout("points");
			var symbol = data.getItemGraphicEl(dataIndex);
			if (!symbol) {
				var x = points$3[dataIndex * 2];
				var y = points$3[dataIndex * 2 + 1];
				if (isNaN(x) || isNaN(y)) return;
				if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) return;
				var zlevel = seriesModel.get("zlevel") || 0;
				var z = seriesModel.get("z") || 0;
				symbol = new Symbol_default(data, dataIndex);
				symbol.x = x;
				symbol.y = y;
				symbol.setZ(zlevel, z);
				var symbolLabel = symbol.getSymbolPath().getTextContent();
				if (symbolLabel) {
					symbolLabel.zlevel = zlevel;
					symbolLabel.z = z;
					symbolLabel.z2 = this._polyline.z2 + 1;
				}
				symbol.__temp = true;
				data.setItemGraphicEl(dataIndex, symbol);
				symbol.stopSymbolAnimation(true);
				this.group.add(symbol);
			}
			symbol.highlight();
		} else Chart_default.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
	};
	LineView$1.prototype.downplay = function(seriesModel, ecModel, api, payload) {
		var data = seriesModel.getData();
		var dataIndex = queryDataIndex(data, payload);
		this._changePolyState("normal");
		if (dataIndex != null && dataIndex >= 0) {
			var symbol = data.getItemGraphicEl(dataIndex);
			if (symbol) if (symbol.__temp) {
				data.setItemGraphicEl(dataIndex, null);
				this.group.remove(symbol);
			} else symbol.downplay();
		} else Chart_default.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
	};
	LineView$1.prototype._changePolyState = function(toState) {
		var polygon = this._polygon;
		setStatesFlag(this._polyline, toState);
		polygon && setStatesFlag(polygon, toState);
	};
	LineView$1.prototype._newPolyline = function(points$3) {
		var polyline = this._polyline;
		if (polyline) this._lineGroup.remove(polyline);
		polyline = new ECPolyline({
			shape: { points: points$3 },
			segmentIgnoreThreshold: 2,
			z2: 10
		});
		this._lineGroup.add(polyline);
		this._polyline = polyline;
		return polyline;
	};
	LineView$1.prototype._newPolygon = function(points$3, stackedOnPoints) {
		var polygon = this._polygon;
		if (polygon) this._lineGroup.remove(polygon);
		polygon = new ECPolygon({
			shape: {
				points: points$3,
				stackedOnPoints
			},
			segmentIgnoreThreshold: 2
		});
		this._lineGroup.add(polygon);
		this._polygon = polygon;
		return polygon;
	};
	LineView$1.prototype._initSymbolLabelAnimation = function(data, coordSys, clipShape) {
		var isHorizontalOrRadial;
		var isCoordSysPolar;
		var baseAxis = coordSys.getBaseAxis();
		var isAxisInverse = baseAxis.inverse;
		if (coordSys.type === "cartesian2d") {
			isHorizontalOrRadial = baseAxis.isHorizontal();
			isCoordSysPolar = false;
		} else if (coordSys.type === "polar") {
			isHorizontalOrRadial = baseAxis.dim === "angle";
			isCoordSysPolar = true;
		}
		var seriesModel = data.hostModel;
		var seriesDuration = seriesModel.get("animationDuration");
		if (isFunction(seriesDuration)) seriesDuration = seriesDuration(null);
		var seriesDelay = seriesModel.get("animationDelay") || 0;
		var seriesDelayValue = isFunction(seriesDelay) ? seriesDelay(null) : seriesDelay;
		data.eachItemGraphicEl(function(symbol, idx) {
			var el = symbol;
			if (el) {
				var point = [symbol.x, symbol.y];
				var start$1 = void 0;
				var end$1 = void 0;
				var current = void 0;
				if (clipShape) if (isCoordSysPolar) {
					var polarClip = clipShape;
					var coord = coordSys.pointToCoord(point);
					if (isHorizontalOrRadial) {
						start$1 = polarClip.startAngle;
						end$1 = polarClip.endAngle;
						current = -coord[1] / 180 * Math.PI;
					} else {
						start$1 = polarClip.r0;
						end$1 = polarClip.r;
						current = coord[0];
					}
				} else {
					var gridClip = clipShape;
					if (isHorizontalOrRadial) {
						start$1 = gridClip.x;
						end$1 = gridClip.x + gridClip.width;
						current = symbol.x;
					} else {
						start$1 = gridClip.y + gridClip.height;
						end$1 = gridClip.y;
						current = symbol.y;
					}
				}
				var ratio = end$1 === start$1 ? 0 : (current - start$1) / (end$1 - start$1);
				if (isAxisInverse) ratio = 1 - ratio;
				var delay = isFunction(seriesDelay) ? seriesDelay(idx) : seriesDuration * ratio + seriesDelayValue;
				var symbolPath = el.getSymbolPath();
				var text = symbolPath.getTextContent();
				el.attr({
					scaleX: 0,
					scaleY: 0
				});
				el.animateTo({
					scaleX: 1,
					scaleY: 1
				}, {
					duration: 200,
					setToFinal: true,
					delay
				});
				if (text) text.animateFrom({ style: { opacity: 0 } }, {
					duration: 300,
					delay
				});
				symbolPath.disableLabelAnimation = true;
			}
		});
	};
	LineView$1.prototype._initOrUpdateEndLabel = function(seriesModel, coordSys, inheritColor) {
		var endLabelModel = seriesModel.getModel("endLabel");
		if (anyStateShowEndLabel(seriesModel)) {
			var data_2 = seriesModel.getData();
			var polyline = this._polyline;
			var points$3 = data_2.getLayout("points");
			if (!points$3) {
				polyline.removeTextContent();
				this._endLabel = null;
				return;
			}
			var endLabel = this._endLabel;
			if (!endLabel) {
				endLabel = this._endLabel = new Text_default({ z2: 200 });
				endLabel.ignoreClip = true;
				polyline.setTextContent(this._endLabel);
				polyline.disableLabelAnimation = true;
			}
			var dataIndex = getLastIndexNotNull(points$3);
			if (dataIndex >= 0) {
				setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
					inheritColor,
					labelFetcher: seriesModel,
					labelDataIndex: dataIndex,
					defaultText: function(dataIndex$1, opt, interpolatedValue) {
						return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex$1);
					},
					enableTextSetter: true
				}, getEndLabelStateSpecified(endLabelModel, coordSys));
				polyline.textConfig.position = null;
			}
		} else if (this._endLabel) {
			this._polyline.removeTextContent();
			this._endLabel = null;
		}
	};
	LineView$1.prototype._endLabelOnDuring = function(percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
		var endLabel = this._endLabel;
		var polyline = this._polyline;
		if (endLabel) {
			if (percent < 1 && animationRecord.originalX == null) {
				animationRecord.originalX = endLabel.x;
				animationRecord.originalY = endLabel.y;
			}
			var points$3 = data.getLayout("points");
			var seriesModel = data.hostModel;
			var connectNulls = seriesModel.get("connectNulls");
			var precision = endLabelModel.get("precision");
			var distance$1 = endLabelModel.get("distance") || 0;
			var baseAxis = coordSys.getBaseAxis();
			var isHorizontal = baseAxis.isHorizontal();
			var isBaseInversed = baseAxis.inverse;
			var clipShape = clipRect.shape;
			var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
			var distanceX = (isHorizontal ? distance$1 : 0) * (isBaseInversed ? -1 : 1);
			var distanceY = (isHorizontal ? 0 : -distance$1) * (isBaseInversed ? -1 : 1);
			var dim = isHorizontal ? "x" : "y";
			var dataIndexRange = getIndexRange(points$3, xOrY, dim);
			var indices = dataIndexRange.range;
			var diff = indices[1] - indices[0];
			var value = void 0;
			if (diff >= 1) {
				if (diff > 1 && !connectNulls) {
					var pt = getPointAtIndex(points$3, indices[0]);
					endLabel.attr({
						x: pt[0] + distanceX,
						y: pt[1] + distanceY
					});
					valueAnimation && (value = seriesModel.getRawValue(indices[0]));
				} else {
					var pt = polyline.getPointOn(xOrY, dim);
					pt && endLabel.attr({
						x: pt[0] + distanceX,
						y: pt[1] + distanceY
					});
					var startValue = seriesModel.getRawValue(indices[0]);
					var endValue = seriesModel.getRawValue(indices[1]);
					valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
				}
				animationRecord.lastFrameIndex = indices[0];
			} else {
				var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
				var pt = getPointAtIndex(points$3, idx);
				valueAnimation && (value = seriesModel.getRawValue(idx));
				endLabel.attr({
					x: pt[0] + distanceX,
					y: pt[1] + distanceY
				});
			}
			if (valueAnimation) {
				var inner$24 = labelInner(endLabel);
				if (typeof inner$24.setLabelText === "function") inner$24.setLabelText(value);
			}
		}
	};
	/**
	* @private
	*/
	LineView$1.prototype._doUpdateAnimation = function(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {
		var polyline = this._polyline;
		var polygon = this._polygon;
		var seriesModel = data.hostModel;
		var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
		var current = diff.current;
		var stackedOnCurrent = diff.stackedOnCurrent;
		var next = diff.next;
		var stackedOnNext = diff.stackedOnNext;
		if (step) {
			stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, diff.current, coordSys, step, connectNulls);
			current = turnPointsIntoStep(diff.current, null, coordSys, step, connectNulls);
			stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, diff.next, coordSys, step, connectNulls);
			next = turnPointsIntoStep(diff.next, null, coordSys, step, connectNulls);
		}
		if (getBoundingDiff(current, next) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
			polyline.stopAnimation();
			polyline.setShape({ points: next });
			if (polygon) {
				polygon.stopAnimation();
				polygon.setShape({
					points: next,
					stackedOnPoints: stackedOnNext
				});
			}
			return;
		}
		polyline.shape.__points = diff.current;
		polyline.shape.points = current;
		var target = { shape: { points: next } };
		if (diff.current !== current) target.shape.__points = diff.next;
		polyline.stopAnimation();
		updateProps(polyline, target, seriesModel);
		if (polygon) {
			polygon.setShape({
				points: current,
				stackedOnPoints: stackedOnCurrent
			});
			polygon.stopAnimation();
			updateProps(polygon, { shape: { stackedOnPoints: stackedOnNext } }, seriesModel);
			if (polyline.shape.points !== polygon.shape.points) polygon.shape.points = polyline.shape.points;
		}
		var updatedDataInfo = [];
		var diffStatus = diff.status;
		for (var i$1 = 0; i$1 < diffStatus.length; i$1++) if (diffStatus[i$1].cmd === "=") {
			var el = data.getItemGraphicEl(diffStatus[i$1].idx1);
			if (el) updatedDataInfo.push({
				el,
				ptIdx: i$1
			});
		}
		if (polyline.animators && polyline.animators.length) polyline.animators[0].during(function() {
			polygon && polygon.dirtyShape();
			var points$3 = polyline.shape.__points;
			for (var i$2 = 0; i$2 < updatedDataInfo.length; i$2++) {
				var el$1 = updatedDataInfo[i$2].el;
				var offset = updatedDataInfo[i$2].ptIdx * 2;
				el$1.x = points$3[offset];
				el$1.y = points$3[offset + 1];
				el$1.markRedraw();
			}
		});
	};
	LineView$1.prototype.remove = function(ecModel) {
		var group = this.group;
		var oldData = this._data;
		this._lineGroup.removeAll();
		this._symbolDraw.remove(true);
		oldData && oldData.eachItemGraphicEl(function(el, idx) {
			if (el.__temp) {
				group.remove(el);
				oldData.setItemGraphicEl(idx, null);
			}
		});
		this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
	};
	LineView$1.type = "line";
	return LineView$1;
}(Chart_default);
var LineView_default = LineView;

//#endregion
//#region node_modules/echarts/lib/layout/points.js
function pointsLayout(seriesType$1, forceStoreInTypedArray) {
	return {
		seriesType: seriesType$1,
		plan: createRenderPlanner(),
		reset: function(seriesModel) {
			var data = seriesModel.getData();
			var coordSys = seriesModel.coordinateSystem;
			var pipelineContext = seriesModel.pipelineContext;
			var useTypedArray = forceStoreInTypedArray || pipelineContext.large;
			if (!coordSys) return;
			var dims = map(coordSys.dimensions, function(dim) {
				return data.mapDimension(dim);
			}).slice(0, 2);
			var dimLen = dims.length;
			var stackResultDim = data.getCalculationInfo("stackResultDimension");
			if (isDimensionStacked(data, dims[0])) dims[0] = stackResultDim;
			if (isDimensionStacked(data, dims[1])) dims[1] = stackResultDim;
			var store = data.getStore();
			var dimIdx0 = data.getDimensionIndex(dims[0]);
			var dimIdx1 = data.getDimensionIndex(dims[1]);
			return dimLen && { progress: function(params, data$1) {
				var segCount = params.end - params.start;
				var points$3 = useTypedArray && createFloat32Array(segCount * dimLen);
				var tmpIn = [];
				var tmpOut = [];
				for (var i$1 = params.start, offset = 0; i$1 < params.end; i$1++) {
					var point = void 0;
					if (dimLen === 1) {
						var x = store.get(dimIdx0, i$1);
						point = coordSys.dataToPoint(x, null, tmpOut);
					} else {
						tmpIn[0] = store.get(dimIdx0, i$1);
						tmpIn[1] = store.get(dimIdx1, i$1);
						point = coordSys.dataToPoint(tmpIn, null, tmpOut);
					}
					if (useTypedArray) {
						points$3[offset++] = point[0];
						points$3[offset++] = point[1];
					} else data$1.setItemLayout(i$1, point.slice());
				}
				useTypedArray && data$1.setLayout("points", points$3);
			} };
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/processor/dataSample.js
var samplers = {
	average: function(frame) {
		var sum$1 = 0;
		var count$1 = 0;
		for (var i$1 = 0; i$1 < frame.length; i$1++) if (!isNaN(frame[i$1])) {
			sum$1 += frame[i$1];
			count$1++;
		}
		return count$1 === 0 ? NaN : sum$1 / count$1;
	},
	sum: function(frame) {
		var sum$1 = 0;
		for (var i$1 = 0; i$1 < frame.length; i$1++) sum$1 += frame[i$1] || 0;
		return sum$1;
	},
	max: function(frame) {
		var max$2 = -Infinity;
		for (var i$1 = 0; i$1 < frame.length; i$1++) frame[i$1] > max$2 && (max$2 = frame[i$1]);
		return isFinite(max$2) ? max$2 : NaN;
	},
	min: function(frame) {
		var min$2 = Infinity;
		for (var i$1 = 0; i$1 < frame.length; i$1++) frame[i$1] < min$2 && (min$2 = frame[i$1]);
		return isFinite(min$2) ? min$2 : NaN;
	},
	nearest: function(frame) {
		return frame[0];
	}
};
var indexSampler = function(frame) {
	return Math.round(frame.length / 2);
};
function dataSample(seriesType$1) {
	return {
		seriesType: seriesType$1,
		reset: function(seriesModel, ecModel, api) {
			var data = seriesModel.getData();
			var sampling = seriesModel.get("sampling");
			var coordSys = seriesModel.coordinateSystem;
			var count$1 = data.count();
			if (count$1 > 10 && coordSys.type === "cartesian2d" && sampling) {
				var baseAxis = coordSys.getBaseAxis();
				var valueAxis$1 = coordSys.getOtherAxis(baseAxis);
				var extent = baseAxis.getExtent();
				var dpr$1 = api.getDevicePixelRatio();
				var size = Math.abs(extent[1] - extent[0]) * (dpr$1 || 1);
				var rate = Math.round(count$1 / size);
				if (isFinite(rate) && rate > 1) {
					if (sampling === "lttb") seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis$1.dim), 1 / rate));
					else if (sampling === "minmax") seriesModel.setData(data.minmaxDownSample(data.mapDimension(valueAxis$1.dim), 1 / rate));
					var sampler = void 0;
					if (isString(sampling)) sampler = samplers[sampling];
					else if (isFunction(sampling)) sampler = sampling;
					if (sampler) seriesModel.setData(data.downSample(data.mapDimension(valueAxis$1.dim), 1 / rate, sampler, indexSampler));
				}
			}
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/chart/line/install.js
function install$2(registers) {
	registers.registerChartView(LineView_default);
	registers.registerSeriesModel(LineSeries_default);
	registers.registerLayout(pointsLayout("line", true));
	registers.registerVisual({
		seriesType: "line",
		reset: function(seriesModel) {
			var data = seriesModel.getData();
			var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
			if (lineStyle && !lineStyle.stroke) lineStyle.stroke = data.getVisual("style").fill;
			data.setVisual("legendLineStyle", lineStyle);
		}
	});
	registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}

//#endregion
//#region node_modules/echarts/lib/chart/bar/BaseBarSeries.js
var BaseBarSeriesModel = function(_super) {
	__extends(BaseBarSeriesModel$1, _super);
	function BaseBarSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = BaseBarSeriesModel$1.type;
		return _this;
	}
	BaseBarSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		return createSeriesData_default(null, this, { useEncodeDefaulter: true });
	};
	BaseBarSeriesModel$1.prototype.getMarkerPosition = function(value, dims, startingAtTick) {
		var coordSys = this.coordinateSystem;
		if (coordSys && coordSys.clampData) {
			var clampData_1 = coordSys.clampData(value);
			var pt_1 = coordSys.dataToPoint(clampData_1);
			if (startingAtTick) each(coordSys.getAxes(), function(axis, idx) {
				if (axis.type === "category" && dims != null) {
					var tickCoords = axis.getTicksCoords();
					var alignTicksWithLabel = axis.getTickModel().get("alignWithLabel");
					var targetTickId = clampData_1[idx];
					var isEnd = dims[idx] === "x1" || dims[idx] === "y1";
					if (isEnd && !alignTicksWithLabel) targetTickId += 1;
					if (tickCoords.length < 2) return;
					else if (tickCoords.length === 2) {
						pt_1[idx] = axis.toGlobalCoord(axis.getExtent()[isEnd ? 1 : 0]);
						return;
					}
					var leftCoord = void 0;
					var coord = void 0;
					var stepTickValue = 1;
					for (var i$1 = 0; i$1 < tickCoords.length; i$1++) {
						var tickCoord = tickCoords[i$1].coord;
						var tickValue = i$1 === tickCoords.length - 1 ? tickCoords[i$1 - 1].tickValue + stepTickValue : tickCoords[i$1].tickValue;
						if (tickValue === targetTickId) {
							coord = tickCoord;
							break;
						} else if (tickValue < targetTickId) leftCoord = tickCoord;
						else if (leftCoord != null && tickValue > targetTickId) {
							coord = (tickCoord + leftCoord) / 2;
							break;
						}
						if (i$1 === 1) stepTickValue = tickValue - tickCoords[0].tickValue;
					}
					if (coord == null) {
						if (!leftCoord) coord = tickCoords[0].coord;
						else if (leftCoord) coord = tickCoords[tickCoords.length - 1].coord;
					}
					pt_1[idx] = axis.toGlobalCoord(coord);
				}
			});
			else {
				var data = this.getData();
				var offset = data.getLayout("offset");
				var size = data.getLayout("size");
				var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
				pt_1[offsetIndex] += offset + size / 2;
			}
			return pt_1;
		}
		return [NaN, NaN];
	};
	BaseBarSeriesModel$1.type = "series.__base_bar__";
	BaseBarSeriesModel$1.defaultOption = {
		z: 2,
		coordinateSystem: "cartesian2d",
		legendHoverLink: true,
		barMinHeight: 0,
		barMinAngle: 0,
		large: false,
		largeThreshold: 400,
		progressive: 3e3,
		progressiveChunkMode: "mod",
		defaultBarGap: "10%"
	};
	return BaseBarSeriesModel$1;
}(Series_default);
Series_default.registerClass(BaseBarSeriesModel);
var BaseBarSeries_default = BaseBarSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/bar/BarSeries.js
var BarSeriesModel = function(_super) {
	__extends(BarSeriesModel$1, _super);
	function BarSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = BarSeriesModel$1.type;
		return _this;
	}
	BarSeriesModel$1.prototype.getInitialData = function() {
		return createSeriesData_default(null, this, {
			useEncodeDefaulter: true,
			createInvertedIndices: !!this.get("realtimeSort", true) || null
		});
	};
	/**
	* @override
	*/
	BarSeriesModel$1.prototype.getProgressive = function() {
		return this.get("large") ? this.get("progressive") : false;
	};
	/**
	* @override
	*/
	BarSeriesModel$1.prototype.getProgressiveThreshold = function() {
		var progressiveThreshold = this.get("progressiveThreshold");
		var largeThreshold = this.get("largeThreshold");
		if (largeThreshold > progressiveThreshold) progressiveThreshold = largeThreshold;
		return progressiveThreshold;
	};
	BarSeriesModel$1.prototype.brushSelector = function(dataIndex, data, selectors) {
		return selectors.rect(data.getItemLayout(dataIndex));
	};
	BarSeriesModel$1.type = "series.bar";
	BarSeriesModel$1.dependencies = ["grid", "polar"];
	BarSeriesModel$1.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
		clip: true,
		roundCap: false,
		showBackground: false,
		backgroundStyle: {
			color: "rgba(180, 180, 180, 0.2)",
			borderColor: null,
			borderWidth: 0,
			borderType: "solid",
			borderRadius: 0,
			shadowBlur: 0,
			shadowColor: null,
			shadowOffsetX: 0,
			shadowOffsetY: 0,
			opacity: 1
		},
		select: { itemStyle: {
			borderColor: tokens_default.color.primary,
			borderWidth: 2
		} },
		realtimeSort: false
	});
	return BarSeriesModel$1;
}(BaseBarSeries_default);
var BarSeries_default = BarSeriesModel;

//#endregion
//#region node_modules/echarts/lib/util/shape/sausage.js
/**
* Sausage: similar to sector, but have half circle on both sides
*/
var SausageShape = function() {
	function SausageShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.r0 = 0;
		this.r = 0;
		this.startAngle = 0;
		this.endAngle = Math.PI * 2;
		this.clockwise = true;
	}
	return SausageShape$1;
}();
var SausagePath = function(_super) {
	__extends(SausagePath$1, _super);
	function SausagePath$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this.type = "sausage";
		return _this;
	}
	SausagePath$1.prototype.getDefaultShape = function() {
		return new SausageShape();
	};
	SausagePath$1.prototype.buildPath = function(ctx, shape) {
		var cx = shape.cx;
		var cy = shape.cy;
		var r0 = Math.max(shape.r0 || 0, 0);
		var r = Math.max(shape.r, 0);
		var dr = (r - r0) * .5;
		var rCenter = r0 + dr;
		var startAngle = shape.startAngle;
		var endAngle = shape.endAngle;
		var clockwise = shape.clockwise;
		var PI2$9 = Math.PI * 2;
		var lessThanCircle = clockwise ? endAngle - startAngle < PI2$9 : startAngle - endAngle < PI2$9;
		if (!lessThanCircle) startAngle = endAngle - (clockwise ? PI2$9 : -PI2$9);
		var unitStartX = Math.cos(startAngle);
		var unitStartY = Math.sin(startAngle);
		var unitEndX = Math.cos(endAngle);
		var unitEndY = Math.sin(endAngle);
		if (lessThanCircle) {
			ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
			ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);
		} else ctx.moveTo(unitStartX * r + cx, unitStartY * r + cy);
		ctx.arc(cx, cy, r, startAngle, endAngle, !clockwise);
		ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
		if (r0 !== 0) ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
	};
	return SausagePath$1;
}(Path_default);
var sausage_default = SausagePath;

//#endregion
//#region node_modules/echarts/lib/label/sectorLabel.js
function createSectorCalculateTextPosition(positionMapping, opts) {
	opts = opts || {};
	var isRoundCap = opts.isRoundCap;
	return function(out$1, opts$1, boundingRect) {
		var textPosition = opts$1.position;
		if (!textPosition || textPosition instanceof Array) return calculateTextPosition(out$1, opts$1, boundingRect);
		var mappedSectorPosition = positionMapping(textPosition);
		var distance$1 = opts$1.distance != null ? opts$1.distance : 5;
		var sector = this.shape;
		var cx = sector.cx;
		var cy = sector.cy;
		var r = sector.r;
		var r0 = sector.r0;
		var middleR = (r + r0) / 2;
		var startAngle = sector.startAngle;
		var endAngle = sector.endAngle;
		var middleAngle = (startAngle + endAngle) / 2;
		var extraDist = isRoundCap ? Math.abs(r - r0) / 2 : 0;
		var mathCos$5 = Math.cos;
		var mathSin$5 = Math.sin;
		var x = cx + r * mathCos$5(startAngle);
		var y = cy + r * mathSin$5(startAngle);
		var textAlign = "left";
		var textVerticalAlign = "top";
		switch (mappedSectorPosition) {
			case "startArc":
				x = cx + (r0 - distance$1) * mathCos$5(middleAngle);
				y = cy + (r0 - distance$1) * mathSin$5(middleAngle);
				textAlign = "center";
				textVerticalAlign = "top";
				break;
			case "insideStartArc":
				x = cx + (r0 + distance$1) * mathCos$5(middleAngle);
				y = cy + (r0 + distance$1) * mathSin$5(middleAngle);
				textAlign = "center";
				textVerticalAlign = "bottom";
				break;
			case "startAngle":
				x = cx + middleR * mathCos$5(startAngle) + adjustAngleDistanceX(startAngle, distance$1 + extraDist, false);
				y = cy + middleR * mathSin$5(startAngle) + adjustAngleDistanceY(startAngle, distance$1 + extraDist, false);
				textAlign = "right";
				textVerticalAlign = "middle";
				break;
			case "insideStartAngle":
				x = cx + middleR * mathCos$5(startAngle) + adjustAngleDistanceX(startAngle, -distance$1 + extraDist, false);
				y = cy + middleR * mathSin$5(startAngle) + adjustAngleDistanceY(startAngle, -distance$1 + extraDist, false);
				textAlign = "left";
				textVerticalAlign = "middle";
				break;
			case "middle":
				x = cx + middleR * mathCos$5(middleAngle);
				y = cy + middleR * mathSin$5(middleAngle);
				textAlign = "center";
				textVerticalAlign = "middle";
				break;
			case "endArc":
				x = cx + (r + distance$1) * mathCos$5(middleAngle);
				y = cy + (r + distance$1) * mathSin$5(middleAngle);
				textAlign = "center";
				textVerticalAlign = "bottom";
				break;
			case "insideEndArc":
				x = cx + (r - distance$1) * mathCos$5(middleAngle);
				y = cy + (r - distance$1) * mathSin$5(middleAngle);
				textAlign = "center";
				textVerticalAlign = "top";
				break;
			case "endAngle":
				x = cx + middleR * mathCos$5(endAngle) + adjustAngleDistanceX(endAngle, distance$1 + extraDist, true);
				y = cy + middleR * mathSin$5(endAngle) + adjustAngleDistanceY(endAngle, distance$1 + extraDist, true);
				textAlign = "left";
				textVerticalAlign = "middle";
				break;
			case "insideEndAngle":
				x = cx + middleR * mathCos$5(endAngle) + adjustAngleDistanceX(endAngle, -distance$1 + extraDist, true);
				y = cy + middleR * mathSin$5(endAngle) + adjustAngleDistanceY(endAngle, -distance$1 + extraDist, true);
				textAlign = "right";
				textVerticalAlign = "middle";
				break;
			default: return calculateTextPosition(out$1, opts$1, boundingRect);
		}
		out$1 = out$1 || {};
		out$1.x = x;
		out$1.y = y;
		out$1.align = textAlign;
		out$1.verticalAlign = textVerticalAlign;
		return out$1;
	};
}
function setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {
	if (isNumber(rotateType)) {
		sector.setTextConfig({ rotation: rotateType });
		return;
	} else if (isArray(textPosition)) {
		sector.setTextConfig({ rotation: 0 });
		return;
	}
	var shape = sector.shape;
	var startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
	var endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
	var middleAngle = (startAngle + endAngle) / 2;
	var anchorAngle;
	var mappedSectorPosition = positionMapping(textPosition);
	switch (mappedSectorPosition) {
		case "startArc":
		case "insideStartArc":
		case "middle":
		case "insideEndArc":
		case "endArc":
			anchorAngle = middleAngle;
			break;
		case "startAngle":
		case "insideStartAngle":
			anchorAngle = startAngle;
			break;
		case "endAngle":
		case "insideEndAngle":
			anchorAngle = endAngle;
			break;
		default:
			sector.setTextConfig({ rotation: 0 });
			return;
	}
	var rotate$1 = Math.PI * 1.5 - anchorAngle;
	/**
	* TODO: labels with rotate > Math.PI / 2 should be rotate another
	* half round flipped to increase readability. However, only middle
	* position supports this for now, because in other positions, the
	* anchor point is not at the center of the text, so the positions
	* after rotating is not as expected.
	*/
	if (mappedSectorPosition === "middle" && rotate$1 > Math.PI / 2 && rotate$1 < Math.PI * 1.5) rotate$1 -= Math.PI;
	sector.setTextConfig({ rotation: rotate$1 });
}
function adjustAngleDistanceX(angle, distance$1, isEnd) {
	return distance$1 * Math.sin(angle) * (isEnd ? -1 : 1);
}
function adjustAngleDistanceY(angle, distance$1, isEnd) {
	return distance$1 * Math.cos(angle) * (isEnd ? 1 : -1);
}

//#endregion
//#region node_modules/echarts/lib/chart/helper/sectorHelper.js
function getSectorCornerRadius(model, shape, zeroIfNull) {
	var cornerRadius = model.get("borderRadius");
	if (cornerRadius == null) return zeroIfNull ? { cornerRadius: 0 } : null;
	if (!isArray(cornerRadius)) cornerRadius = [
		cornerRadius,
		cornerRadius,
		cornerRadius,
		cornerRadius
	];
	var dr = Math.abs(shape.r || 0 - shape.r0 || 0);
	return { cornerRadius: map(cornerRadius, function(cr) {
		return parsePercent(cr, dr);
	}) };
}

//#endregion
//#region node_modules/echarts/lib/chart/bar/BarView.js
var mathMax$5 = Math.max;
var mathMin$5 = Math.min;
function getClipArea(coord, data) {
	var coordSysClipArea = coord.getArea && coord.getArea();
	if (isCoordinateSystemType(coord, "cartesian2d")) {
		var baseAxis = coord.getBaseAxis();
		if (baseAxis.type !== "category" || !baseAxis.onBand) {
			var expandWidth = data.getLayout("bandWidth");
			if (baseAxis.isHorizontal()) {
				coordSysClipArea.x -= expandWidth;
				coordSysClipArea.width += expandWidth * 2;
			} else {
				coordSysClipArea.y -= expandWidth;
				coordSysClipArea.height += expandWidth * 2;
			}
		}
	}
	return coordSysClipArea;
}
var BarView = function(_super) {
	__extends(BarView$1, _super);
	function BarView$1() {
		var _this = _super.call(this) || this;
		_this.type = BarView$1.type;
		_this._isFirstFrame = true;
		return _this;
	}
	BarView$1.prototype.render = function(seriesModel, ecModel, api, payload) {
		this._model = seriesModel;
		this._removeOnRenderedListener(api);
		this._updateDrawMode(seriesModel);
		var coordinateSystemType = seriesModel.get("coordinateSystem");
		if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
			this._progressiveEls = null;
			this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);
		} else warn("Only cartesian2d and polar supported for bar.");
	};
	BarView$1.prototype.incrementalPrepareRender = function(seriesModel) {
		this._clear();
		this._updateDrawMode(seriesModel);
		this._updateLargeClip(seriesModel);
	};
	BarView$1.prototype.incrementalRender = function(params, seriesModel) {
		this._progressiveEls = [];
		this._incrementalRenderLarge(params, seriesModel);
	};
	BarView$1.prototype.eachRendered = function(cb) {
		traverseElements(this._progressiveEls || this.group, cb);
	};
	BarView$1.prototype._updateDrawMode = function(seriesModel) {
		var isLargeDraw = seriesModel.pipelineContext.large;
		if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
			this._isLargeDraw = isLargeDraw;
			this._clear();
		}
	};
	BarView$1.prototype._renderNormal = function(seriesModel, ecModel, api, payload) {
		var group = this.group;
		var data = seriesModel.getData();
		var oldData = this._data;
		var coord = seriesModel.coordinateSystem;
		var baseAxis = coord.getBaseAxis();
		var isHorizontalOrRadial;
		if (coord.type === "cartesian2d") isHorizontalOrRadial = baseAxis.isHorizontal();
		else if (coord.type === "polar") isHorizontalOrRadial = baseAxis.dim === "angle";
		var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
		var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);
		if (realtimeSortCfg) this._enableRealtimeSort(realtimeSortCfg, data, api);
		var needsClip = seriesModel.get("clip", true) || realtimeSortCfg;
		var coordSysClipArea = getClipArea(coord, data);
		group.removeClipPath();
		var roundCap = seriesModel.get("roundCap", true);
		var drawBackground = seriesModel.get("showBackground", true);
		var backgroundModel = seriesModel.getModel("backgroundStyle");
		var barBorderRadius = backgroundModel.get("borderRadius") || 0;
		var bgEls = [];
		var oldBgEls = this._backgroundEls;
		var isInitSort = payload && payload.isInitSort;
		var isChangeOrder = payload && payload.type === "changeAxisOrder";
		function createBackground(dataIndex) {
			var bgLayout = getLayout[coord.type](data, dataIndex);
			if (!bgLayout) return null;
			var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
			bgEl.useStyle(backgroundModel.getItemStyle());
			if (coord.type === "cartesian2d") bgEl.setShape("r", barBorderRadius);
			else bgEl.setShape("cornerRadius", barBorderRadius);
			bgEls[dataIndex] = bgEl;
			return bgEl;
		}
		data.diff(oldData).add(function(dataIndex) {
			var itemModel = data.getItemModel(dataIndex);
			var layout$3 = getLayout[coord.type](data, dataIndex, itemModel);
			if (!layout$3) return;
			if (drawBackground) createBackground(dataIndex);
			if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout$3)) return;
			var isClipped = false;
			if (needsClip) isClipped = clip[coord.type](coordSysClipArea, layout$3);
			var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout$3, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
			if (realtimeSortCfg)
 /**
			* Force label animation because even if the element is
			* ignored because it's clipped, it may not be clipped after
			* changing order. Then, if not using forceLabelAnimation,
			* the label animation was never started, in which case,
			* the label will be the final value and doesn't have label
			* animation.
			*/
			el.forceLabelAnimation = true;
			updateStyle(el, data, dataIndex, itemModel, layout$3, seriesModel, isHorizontalOrRadial, coord.type === "polar");
			if (isInitSort) el.attr({ shape: layout$3 });
			else if (realtimeSortCfg) updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout$3, dataIndex, isHorizontalOrRadial, false, false);
			else initProps(el, { shape: layout$3 }, seriesModel, dataIndex);
			data.setItemGraphicEl(dataIndex, el);
			group.add(el);
			el.ignore = isClipped;
		}).update(function(newIndex, oldIndex) {
			var itemModel = data.getItemModel(newIndex);
			var layout$3 = getLayout[coord.type](data, newIndex, itemModel);
			if (!layout$3) return;
			if (drawBackground) {
				var bgEl = void 0;
				if (oldBgEls.length === 0) bgEl = createBackground(oldIndex);
				else {
					bgEl = oldBgEls[oldIndex];
					bgEl.useStyle(backgroundModel.getItemStyle());
					if (coord.type === "cartesian2d") bgEl.setShape("r", barBorderRadius);
					else bgEl.setShape("cornerRadius", barBorderRadius);
					bgEls[newIndex] = bgEl;
				}
				var bgLayout = getLayout[coord.type](data, newIndex);
				var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
				updateProps(bgEl, { shape }, animationModel, newIndex);
			}
			var el = oldData.getItemGraphicEl(oldIndex);
			if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout$3)) {
				group.remove(el);
				return;
			}
			var isClipped = false;
			if (needsClip) {
				isClipped = clip[coord.type](coordSysClipArea, layout$3);
				if (isClipped) group.remove(el);
			}
			if (el && (el.type === "sector" && roundCap || el.type === "sausage" && !roundCap)) {
				el && removeElementWithFadeOut(el, seriesModel, oldIndex);
				el = null;
			}
			if (!el) el = elementCreator[coord.type](seriesModel, data, newIndex, layout$3, isHorizontalOrRadial, animationModel, baseAxis.model, true, roundCap);
			else saveOldStyle(el);
			if (realtimeSortCfg) el.forceLabelAnimation = true;
			if (isChangeOrder) {
				var textEl = el.getTextContent();
				if (textEl) {
					var labelInnerStore = labelInner(textEl);
					if (labelInnerStore.prevValue != null)
 /**
					* Set preValue to be value so that no new label
					* should be started, otherwise, it will take a full
					* `animationDurationUpdate` time to finish the
					* animation, which is not expected.
					*/
					labelInnerStore.prevValue = labelInnerStore.value;
				}
			} else updateStyle(el, data, newIndex, itemModel, layout$3, seriesModel, isHorizontalOrRadial, coord.type === "polar");
			if (isInitSort) el.attr({ shape: layout$3 });
			else if (realtimeSortCfg) updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout$3, newIndex, isHorizontalOrRadial, true, isChangeOrder);
			else updateProps(el, { shape: layout$3 }, seriesModel, newIndex, null);
			data.setItemGraphicEl(newIndex, el);
			el.ignore = isClipped;
			group.add(el);
		}).remove(function(dataIndex) {
			var el = oldData.getItemGraphicEl(dataIndex);
			el && removeElementWithFadeOut(el, seriesModel, dataIndex);
		}).execute();
		var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group_default());
		bgGroup.removeAll();
		for (var i$1 = 0; i$1 < bgEls.length; ++i$1) bgGroup.add(bgEls[i$1]);
		group.add(bgGroup);
		this._backgroundEls = bgEls;
		this._data = data;
	};
	BarView$1.prototype._renderLarge = function(seriesModel, ecModel, api) {
		this._clear();
		createLarge$1(seriesModel, this.group);
		this._updateLargeClip(seriesModel);
	};
	BarView$1.prototype._incrementalRenderLarge = function(params, seriesModel) {
		this._removeBackground();
		createLarge$1(seriesModel, this.group, this._progressiveEls, true);
	};
	BarView$1.prototype._updateLargeClip = function(seriesModel) {
		var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
		var group = this.group;
		if (clipPath) group.setClipPath(clipPath);
		else group.removeClipPath();
	};
	BarView$1.prototype._enableRealtimeSort = function(realtimeSortCfg, data, api) {
		var _this = this;
		if (!data.count()) return;
		var baseAxis = realtimeSortCfg.baseAxis;
		if (this._isFirstFrame) {
			this._dispatchInitSort(data, realtimeSortCfg, api);
			this._isFirstFrame = false;
		} else {
			var orderMapping_1 = function(idx) {
				var el = data.getItemGraphicEl(idx);
				var shape = el && el.shape;
				return shape && Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || 0;
			};
			this._onRendered = function() {
				_this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);
			};
			api.getZr().on("rendered", this._onRendered);
		}
	};
	BarView$1.prototype._dataSort = function(data, baseAxis, orderMapping) {
		var info = [];
		data.each(data.mapDimension(baseAxis.dim), function(ordinalNumber, dataIdx) {
			var mappedValue = orderMapping(dataIdx);
			mappedValue = mappedValue == null ? NaN : mappedValue;
			info.push({
				dataIndex: dataIdx,
				mappedValue,
				ordinalNumber
			});
		});
		info.sort(function(a, b) {
			return b.mappedValue - a.mappedValue;
		});
		return { ordinalNumbers: map(info, function(item) {
			return item.ordinalNumber;
		}) };
	};
	BarView$1.prototype._isOrderChangedWithinSameData = function(data, orderMapping, baseAxis) {
		var scale$3 = baseAxis.scale;
		var ordinalDataDim = data.mapDimension(baseAxis.dim);
		var lastValue = Number.MAX_VALUE;
		for (var tickNum = 0, len$1 = scale$3.getOrdinalMeta().categories.length; tickNum < len$1; ++tickNum) {
			var rawIdx = data.rawIndexOf(ordinalDataDim, scale$3.getRawOrdinalNumber(tickNum));
			var value = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data.indexOfRawIndex(rawIdx));
			if (value > lastValue) return true;
			lastValue = value;
		}
		return false;
	};
	BarView$1.prototype._isOrderDifferentInView = function(orderInfo, baseAxis) {
		var scale$3 = baseAxis.scale;
		var extent = scale$3.getExtent();
		var tickNum = Math.max(0, extent[0]);
		var tickMax = Math.min(extent[1], scale$3.getOrdinalMeta().categories.length - 1);
		for (; tickNum <= tickMax; ++tickNum) if (orderInfo.ordinalNumbers[tickNum] !== scale$3.getRawOrdinalNumber(tickNum)) return true;
	};
	BarView$1.prototype._updateSortWithinSameData = function(data, orderMapping, baseAxis, api) {
		if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) return;
		var sortInfo = this._dataSort(data, baseAxis, orderMapping);
		if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
			this._removeOnRenderedListener(api);
			api.dispatchAction({
				type: "changeAxisOrder",
				componentType: baseAxis.dim + "Axis",
				axisId: baseAxis.index,
				sortInfo
			});
		}
	};
	BarView$1.prototype._dispatchInitSort = function(data, realtimeSortCfg, api) {
		var baseAxis = realtimeSortCfg.baseAxis;
		var sortResult = this._dataSort(data, baseAxis, function(dataIdx) {
			return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);
		});
		api.dispatchAction({
			type: "changeAxisOrder",
			componentType: baseAxis.dim + "Axis",
			isInitSort: true,
			axisId: baseAxis.index,
			sortInfo: sortResult
		});
	};
	BarView$1.prototype.remove = function(ecModel, api) {
		this._clear(this._model);
		this._removeOnRenderedListener(api);
	};
	BarView$1.prototype.dispose = function(ecModel, api) {
		this._removeOnRenderedListener(api);
	};
	BarView$1.prototype._removeOnRenderedListener = function(api) {
		if (this._onRendered) {
			api.getZr().off("rendered", this._onRendered);
			this._onRendered = null;
		}
	};
	BarView$1.prototype._clear = function(model) {
		var group = this.group;
		var data = this._data;
		if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
			this._removeBackground();
			this._backgroundEls = [];
			data.eachItemGraphicEl(function(el) {
				removeElementWithFadeOut(el, model, getECData(el).dataIndex);
			});
		} else group.removeAll();
		this._data = null;
		this._isFirstFrame = true;
	};
	BarView$1.prototype._removeBackground = function() {
		this.group.remove(this._backgroundGroup);
		this._backgroundGroup = null;
	};
	BarView$1.type = "bar";
	return BarView$1;
}(Chart_default);
var clip = {
	cartesian2d: function(coordSysBoundingRect, layout$3) {
		var signWidth = layout$3.width < 0 ? -1 : 1;
		var signHeight = layout$3.height < 0 ? -1 : 1;
		if (signWidth < 0) {
			layout$3.x += layout$3.width;
			layout$3.width = -layout$3.width;
		}
		if (signHeight < 0) {
			layout$3.y += layout$3.height;
			layout$3.height = -layout$3.height;
		}
		var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
		var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
		var x = mathMax$5(layout$3.x, coordSysBoundingRect.x);
		var x2 = mathMin$5(layout$3.x + layout$3.width, coordSysX2);
		var y = mathMax$5(layout$3.y, coordSysBoundingRect.y);
		var y2 = mathMin$5(layout$3.y + layout$3.height, coordSysY2);
		var xClipped = x2 < x;
		var yClipped = y2 < y;
		layout$3.x = xClipped && x > coordSysX2 ? x2 : x;
		layout$3.y = yClipped && y > coordSysY2 ? y2 : y;
		layout$3.width = xClipped ? 0 : x2 - x;
		layout$3.height = yClipped ? 0 : y2 - y;
		if (signWidth < 0) {
			layout$3.x += layout$3.width;
			layout$3.width = -layout$3.width;
		}
		if (signHeight < 0) {
			layout$3.y += layout$3.height;
			layout$3.height = -layout$3.height;
		}
		return xClipped || yClipped;
	},
	polar: function(coordSysClipArea, layout$3) {
		var signR = layout$3.r0 <= layout$3.r ? 1 : -1;
		if (signR < 0) {
			var tmp = layout$3.r;
			layout$3.r = layout$3.r0;
			layout$3.r0 = tmp;
		}
		var r = mathMin$5(layout$3.r, coordSysClipArea.r);
		var r0 = mathMax$5(layout$3.r0, coordSysClipArea.r0);
		layout$3.r = r;
		layout$3.r0 = r0;
		var clipped = r - r0 < 0;
		if (signR < 0) {
			var tmp = layout$3.r;
			layout$3.r = layout$3.r0;
			layout$3.r0 = tmp;
		}
		return clipped;
	}
};
var elementCreator = {
	cartesian2d: function(seriesModel, data, newIndex, layout$3, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
		var rect = new Rect_default({
			shape: extend({}, layout$3),
			z2: 1
		});
		rect.__dataIndex = newIndex;
		rect.name = "item";
		if (animationModel) {
			var rectShape = rect.shape;
			var animateProperty = isHorizontal ? "height" : "width";
			rectShape[animateProperty] = 0;
		}
		return rect;
	},
	polar: function(seriesModel, data, newIndex, layout$3, isRadial, animationModel, axisModel, isUpdate, roundCap) {
		var ShapeClass = !isRadial && roundCap ? sausage_default : Sector_default;
		var sector = new ShapeClass({
			shape: layout$3,
			z2: 1
		});
		sector.name = "item";
		sector.calculateTextPosition = createSectorCalculateTextPosition(createPolarPositionMapping(isRadial), { isRoundCap: ShapeClass === sausage_default });
		if (animationModel) {
			var sectorShape = sector.shape;
			var animateProperty = isRadial ? "r" : "endAngle";
			var animateTarget = {};
			sectorShape[animateProperty] = isRadial ? layout$3.r0 : layout$3.startAngle;
			animateTarget[animateProperty] = layout$3[animateProperty];
			(isUpdate ? updateProps : initProps)(sector, { shape: animateTarget }, animationModel);
		}
		return sector;
	}
};
function shouldRealtimeSort(seriesModel, coordSys) {
	var realtimeSortOption = seriesModel.get("realtimeSort", true);
	var baseAxis = coordSys.getBaseAxis();
	if (realtimeSortOption) {
		if (baseAxis.type !== "category") warn("`realtimeSort` will not work because this bar series is not based on a category axis.");
		if (coordSys.type !== "cartesian2d") warn("`realtimeSort` will not work because this bar series is not on cartesian2d.");
	}
	if (realtimeSortOption && baseAxis.type === "category" && coordSys.type === "cartesian2d") return {
		baseAxis,
		otherAxis: coordSys.getOtherAxis(baseAxis)
	};
}
function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout$3, newIndex, isHorizontal, isUpdate, isChangeOrder) {
	var seriesTarget;
	var axisTarget;
	if (isHorizontal) {
		axisTarget = {
			x: layout$3.x,
			width: layout$3.width
		};
		seriesTarget = {
			y: layout$3.y,
			height: layout$3.height
		};
	} else {
		axisTarget = {
			y: layout$3.y,
			height: layout$3.height
		};
		seriesTarget = {
			x: layout$3.x,
			width: layout$3.width
		};
	}
	if (!isChangeOrder) (isUpdate ? updateProps : initProps)(el, { shape: seriesTarget }, seriesAnimationModel, newIndex, null);
	var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
	(isUpdate ? updateProps : initProps)(el, { shape: axisTarget }, axisAnimationModel, newIndex);
}
function checkPropertiesNotValid(obj, props) {
	for (var i$1 = 0; i$1 < props.length; i$1++) if (!isFinite(obj[props[i$1]])) return true;
	return false;
}
var rectPropties = [
	"x",
	"y",
	"width",
	"height"
];
var polarPropties = [
	"cx",
	"cy",
	"r",
	"startAngle",
	"endAngle"
];
var isValidLayout = {
	cartesian2d: function(layout$3) {
		return !checkPropertiesNotValid(layout$3, rectPropties);
	},
	polar: function(layout$3) {
		return !checkPropertiesNotValid(layout$3, polarPropties);
	}
};
var getLayout = {
	cartesian2d: function(data, dataIndex, itemModel) {
		var layout$3 = data.getItemLayout(dataIndex);
		if (!layout$3) return null;
		var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout$3) : 0;
		var signX = layout$3.width > 0 ? 1 : -1;
		var signY = layout$3.height > 0 ? 1 : -1;
		return {
			x: layout$3.x + signX * fixedLineWidth / 2,
			y: layout$3.y + signY * fixedLineWidth / 2,
			width: layout$3.width - signX * fixedLineWidth,
			height: layout$3.height - signY * fixedLineWidth
		};
	},
	polar: function(data, dataIndex, itemModel) {
		var layout$3 = data.getItemLayout(dataIndex);
		return {
			cx: layout$3.cx,
			cy: layout$3.cy,
			r0: layout$3.r0,
			r: layout$3.r,
			startAngle: layout$3.startAngle,
			endAngle: layout$3.endAngle,
			clockwise: layout$3.clockwise
		};
	}
};
function isZeroOnPolar(layout$3) {
	return layout$3.startAngle != null && layout$3.endAngle != null && layout$3.startAngle === layout$3.endAngle;
}
function createPolarPositionMapping(isRadial) {
	return function(isRadial$1) {
		var arcOrAngle = isRadial$1 ? "Arc" : "Angle";
		return function(position$1) {
			switch (position$1) {
				case "start":
				case "insideStart":
				case "end":
				case "insideEnd": return position$1 + arcOrAngle;
				default: return position$1;
			}
		};
	}(isRadial);
}
function updateStyle(el, data, dataIndex, itemModel, layout$3, seriesModel, isHorizontalOrRadial, isPolar) {
	var style = data.getItemVisual(dataIndex, "style");
	if (!isPolar) {
		var borderRadius = itemModel.get(["itemStyle", "borderRadius"]) || 0;
		el.setShape("r", borderRadius);
	} else if (!seriesModel.get("roundCap")) {
		var sectorShape = el.shape;
		extend(sectorShape, getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true));
		el.setShape(sectorShape);
	}
	el.useStyle(style);
	var cursorStyle = itemModel.getShallow("cursor");
	cursorStyle && el.attr("cursor", cursorStyle);
	var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout$3.r >= layout$3.r0 ? "endArc" : "startArc" : layout$3.endAngle >= layout$3.startAngle ? "endAngle" : "startAngle" : isHorizontalOrRadial ? layout$3.height >= 0 ? "bottom" : "top" : layout$3.width >= 0 ? "right" : "left";
	var labelStatesModels = getLabelStatesModels(itemModel);
	setLabelStyle(el, labelStatesModels, {
		labelFetcher: seriesModel,
		labelDataIndex: dataIndex,
		defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
		inheritColor: style.fill,
		defaultOpacity: style.opacity,
		defaultOutsidePosition: labelPositionOutside
	});
	var label = el.getTextContent();
	if (isPolar && label) {
		var position$1 = itemModel.get(["label", "position"]);
		el.textConfig.inside = position$1 === "middle" ? true : null;
		setSectorTextRotation(el, position$1 === "outside" ? labelPositionOutside : position$1, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(["label", "rotate"]));
	}
	setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function(value) {
		return getDefaultInterpolatedLabel(data, value);
	});
	var emphasisModel = itemModel.getModel(["emphasis"]);
	toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
	setStatesStylesFromModel(el, itemModel);
	if (isZeroOnPolar(layout$3)) {
		el.style.fill = "none";
		el.style.stroke = "none";
		each(el.states, function(state) {
			if (state.style) state.style.fill = state.style.stroke = "none";
		});
	}
}
function getLineWidth(itemModel, rawLayout) {
	var borderColor = itemModel.get(["itemStyle", "borderColor"]);
	if (!borderColor || borderColor === "none") return 0;
	var lineWidth = itemModel.get(["itemStyle", "borderWidth"]) || 0;
	var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
	var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
	return Math.min(lineWidth, width, height);
}
var LagePathShape = function() {
	function LagePathShape$1() {}
	return LagePathShape$1;
}();
var LargePath = function(_super) {
	__extends(LargePath$1, _super);
	function LargePath$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this.type = "largeBar";
		return _this;
	}
	LargePath$1.prototype.getDefaultShape = function() {
		return new LagePathShape();
	};
	LargePath$1.prototype.buildPath = function(ctx, shape) {
		var points$3 = shape.points;
		var baseDimIdx = this.baseDimIdx;
		var valueDimIdx = 1 - this.baseDimIdx;
		var startPoint = [];
		var size = [];
		var barWidth = this.barWidth;
		for (var i$1 = 0; i$1 < points$3.length; i$1 += 3) {
			size[baseDimIdx] = barWidth;
			size[valueDimIdx] = points$3[i$1 + 2];
			startPoint[baseDimIdx] = points$3[i$1 + baseDimIdx];
			startPoint[valueDimIdx] = points$3[i$1 + valueDimIdx];
			ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);
		}
	};
	return LargePath$1;
}(Path_default);
function createLarge$1(seriesModel, group, progressiveEls, incremental) {
	var data = seriesModel.getData();
	var baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
	var largeDataIndices = data.getLayout("largeDataIndices");
	var barWidth = data.getLayout("size");
	var backgroundModel = seriesModel.getModel("backgroundStyle");
	var bgPoints = data.getLayout("largeBackgroundPoints");
	if (bgPoints) {
		var bgEl = new LargePath({
			shape: { points: bgPoints },
			incremental: !!incremental,
			silent: true,
			z2: 0
		});
		bgEl.baseDimIdx = baseDimIdx;
		bgEl.largeDataIndices = largeDataIndices;
		bgEl.barWidth = barWidth;
		bgEl.useStyle(backgroundModel.getItemStyle());
		group.add(bgEl);
		progressiveEls && progressiveEls.push(bgEl);
	}
	var el = new LargePath({
		shape: { points: data.getLayout("largePoints") },
		incremental: !!incremental,
		ignoreCoarsePointer: true,
		z2: 1
	});
	el.baseDimIdx = baseDimIdx;
	el.largeDataIndices = largeDataIndices;
	el.barWidth = barWidth;
	group.add(el);
	el.useStyle(data.getVisual("style"));
	el.style.stroke = null;
	getECData(el).seriesIndex = seriesModel.seriesIndex;
	if (!seriesModel.get("silent")) {
		el.on("mousedown", largePathUpdateDataIndex);
		el.on("mousemove", largePathUpdateDataIndex);
	}
	progressiveEls && progressiveEls.push(el);
}
var largePathUpdateDataIndex = throttle(function(event) {
	var largePath = this;
	var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
	getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
}, 30, false);
function largePathFindDataIndex(largePath, x, y) {
	var baseDimIdx = largePath.baseDimIdx;
	var valueDimIdx = 1 - baseDimIdx;
	var points$3 = largePath.shape.points;
	var largeDataIndices = largePath.largeDataIndices;
	var startPoint = [];
	var size = [];
	var barWidth = largePath.barWidth;
	for (var i$1 = 0, len$1 = points$3.length / 3; i$1 < len$1; i$1++) {
		var ii = i$1 * 3;
		size[baseDimIdx] = barWidth;
		size[valueDimIdx] = points$3[ii + 2];
		startPoint[baseDimIdx] = points$3[ii + baseDimIdx];
		startPoint[valueDimIdx] = points$3[ii + valueDimIdx];
		if (size[valueDimIdx] < 0) {
			startPoint[valueDimIdx] += size[valueDimIdx];
			size[valueDimIdx] = -size[valueDimIdx];
		}
		if (x >= startPoint[0] && x <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) return largeDataIndices[i$1];
	}
	return -1;
}
function createBackgroundShape(isHorizontalOrRadial, layout$3, coord) {
	if (isCoordinateSystemType(coord, "cartesian2d")) {
		var rectShape = layout$3;
		var coordLayout = coord.getArea();
		return {
			x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
			y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
			width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
			height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
		};
	} else {
		var coordLayout = coord.getArea();
		var sectorShape = layout$3;
		return {
			cx: coordLayout.cx,
			cy: coordLayout.cy,
			r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
			r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
			startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
			endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
		};
	}
}
function createBackgroundEl(coord, isHorizontalOrRadial, layout$3) {
	return new (coord.type === "polar" ? Sector_default : Rect_default)({
		shape: createBackgroundShape(isHorizontalOrRadial, layout$3, coord),
		silent: true,
		z2: 0
	});
}
var BarView_default = BarView;

//#endregion
//#region node_modules/echarts/lib/chart/bar/install.js
function install$3(registers) {
	registers.registerChartView(BarView_default);
	registers.registerSeriesModel(BarSeries_default);
	registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout$1, "bar"));
	registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar"));
	registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar"));
	/**
	* @payload
	* @property {string} [componentType=series]
	* @property {number} [dx]
	* @property {number} [dy]
	* @property {number} [zoom]
	* @property {number} [originX]
	* @property {number} [originY]
	*/
	registers.registerAction({
		type: "changeAxisOrder",
		event: "changeAxisOrder",
		update: "update"
	}, function(payload, ecModel) {
		var componentType = payload.componentType || "series";
		ecModel.eachComponent({
			mainType: componentType,
			query: payload
		}, function(componentModel) {
			if (payload.sortInfo) componentModel.axis.setCategorySortInfo(payload.sortInfo);
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/pie/pieLayout.js
var PI2 = Math.PI * 2;
var RADIAN$4 = Math.PI / 180;
function pieLayout(seriesType$1, ecModel, api) {
	ecModel.eachSeriesByType(seriesType$1, function(seriesModel) {
		var data = seriesModel.getData();
		var valueDim = data.mapDimension("value");
		var _a$1 = getCircleLayout(seriesModel, api), cx = _a$1.cx, cy = _a$1.cy, r = _a$1.r, r0 = _a$1.r0, viewRect$1 = _a$1.viewRect;
		var startAngle = -seriesModel.get("startAngle") * RADIAN$4;
		var endAngle = seriesModel.get("endAngle");
		var padAngle = seriesModel.get("padAngle") * RADIAN$4;
		endAngle = endAngle === "auto" ? startAngle - PI2 : -endAngle * RADIAN$4;
		var minAndPadAngle = seriesModel.get("minAngle") * RADIAN$4 + padAngle;
		var validDataCount = 0;
		data.each(valueDim, function(value) {
			!isNaN(value) && validDataCount++;
		});
		var sum$1 = data.getSum(valueDim);
		var unitRadian = Math.PI / (sum$1 || validDataCount) * 2;
		var clockwise = seriesModel.get("clockwise");
		var roseType = seriesModel.get("roseType");
		var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
		var extent = data.getDataExtent(valueDim);
		extent[0] = 0;
		var dir$1 = clockwise ? 1 : -1;
		var angles = [startAngle, endAngle];
		var halfPadAngle = dir$1 * padAngle / 2;
		normalizeArcAngles(angles, !clockwise);
		startAngle = angles[0], endAngle = angles[1];
		var layoutData = getSeriesLayoutData(seriesModel);
		layoutData.startAngle = startAngle;
		layoutData.endAngle = endAngle;
		layoutData.clockwise = clockwise;
		layoutData.cx = cx;
		layoutData.cy = cy;
		layoutData.r = r;
		layoutData.r0 = r0;
		var angleRange = Math.abs(endAngle - startAngle);
		var restAngle = angleRange;
		var valueSumLargerThanMinAngle = 0;
		var currentAngle = startAngle;
		data.setLayout({
			viewRect: viewRect$1,
			r
		});
		data.each(valueDim, function(value, idx) {
			var angle;
			if (isNaN(value)) {
				data.setItemLayout(idx, {
					angle: NaN,
					startAngle: NaN,
					endAngle: NaN,
					clockwise,
					cx,
					cy,
					r0,
					r: roseType ? NaN : r
				});
				return;
			}
			if (roseType !== "area") angle = sum$1 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
			else angle = angleRange / validDataCount;
			if (angle < minAndPadAngle) {
				angle = minAndPadAngle;
				restAngle -= minAndPadAngle;
			} else valueSumLargerThanMinAngle += value;
			var endAngle$1 = currentAngle + dir$1 * angle;
			var actualStartAngle = 0;
			var actualEndAngle = 0;
			if (padAngle > angle) {
				actualStartAngle = currentAngle + dir$1 * angle / 2;
				actualEndAngle = actualStartAngle;
			} else {
				actualStartAngle = currentAngle + halfPadAngle;
				actualEndAngle = endAngle$1 - halfPadAngle;
			}
			data.setItemLayout(idx, {
				angle,
				startAngle: actualStartAngle,
				endAngle: actualEndAngle,
				clockwise,
				cx,
				cy,
				r0,
				r: roseType ? linearMap$2(value, extent, [r0, r]) : r
			});
			currentAngle = endAngle$1;
		});
		if (restAngle < PI2 && validDataCount) if (restAngle <= .001) {
			var angle_1 = angleRange / validDataCount;
			data.each(valueDim, function(value, idx) {
				if (!isNaN(value)) {
					var layout$3 = data.getItemLayout(idx);
					layout$3.angle = angle_1;
					var actualStartAngle = 0;
					var actualEndAngle = 0;
					if (angle_1 < padAngle) {
						actualStartAngle = startAngle + dir$1 * (idx + 1 / 2) * angle_1;
						actualEndAngle = actualStartAngle;
					} else {
						actualStartAngle = startAngle + dir$1 * idx * angle_1 + halfPadAngle;
						actualEndAngle = startAngle + dir$1 * (idx + 1) * angle_1 - halfPadAngle;
					}
					layout$3.startAngle = actualStartAngle;
					layout$3.endAngle = actualEndAngle;
				}
			});
		} else {
			unitRadian = restAngle / valueSumLargerThanMinAngle;
			currentAngle = startAngle;
			data.each(valueDim, function(value, idx) {
				if (!isNaN(value)) {
					var layout$3 = data.getItemLayout(idx);
					var angle = layout$3.angle === minAndPadAngle ? minAndPadAngle : value * unitRadian;
					var actualStartAngle = 0;
					var actualEndAngle = 0;
					if (angle < padAngle) {
						actualStartAngle = currentAngle + dir$1 * angle / 2;
						actualEndAngle = actualStartAngle;
					} else {
						actualStartAngle = currentAngle + halfPadAngle;
						actualEndAngle = currentAngle + dir$1 * angle - halfPadAngle;
					}
					layout$3.startAngle = actualStartAngle;
					layout$3.endAngle = actualEndAngle;
					currentAngle += dir$1 * angle;
				}
			});
		}
	});
}
var getSeriesLayoutData = makeInner();

//#endregion
//#region node_modules/echarts/lib/processor/dataFilter.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function dataFilter$1(seriesType$1) {
	return {
		seriesType: seriesType$1,
		reset: function(seriesModel, ecModel) {
			var legendModels = ecModel.findComponents({ mainType: "legend" });
			if (!legendModels || !legendModels.length) return;
			var data = seriesModel.getData();
			data.filterSelf(function(idx) {
				var name = data.getName(idx);
				for (var i$1 = 0; i$1 < legendModels.length; i$1++) if (!legendModels[i$1].isSelected(name)) return false;
				return true;
			});
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/chart/pie/labelLayout.js
var RADIAN$3 = Math.PI / 180;
function adjustSingleSide(list, cx, cy, r, dir$1, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
	if (list.length < 2) return;
	function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
		var rB = semi.rB;
		var rB2 = rB * rB;
		for (var i$2 = 0; i$2 < semi.list.length; i$2++) {
			var item = semi.list[i$2];
			var dy = Math.abs(item.label.y - cy);
			var rA = r + item.len;
			var rA2 = rA * rA;
			var newX = cx + (Math.sqrt(Math.abs((1 - dy * dy / rB2) * rA2)) + item.len2) * dir$1;
			var deltaX = newX - item.label.x;
			constrainTextWidth(item, item.targetTextWidth - deltaX * dir$1, true);
			item.label.x = newX;
		}
	}
	function recalculateX(items) {
		var topSemi = {
			list: [],
			maxY: 0
		};
		var bottomSemi = {
			list: [],
			maxY: 0
		};
		for (var i$2 = 0; i$2 < items.length; i$2++) {
			if (items[i$2].labelAlignTo !== "none") continue;
			var item = items[i$2];
			var semi = item.label.y > cy ? bottomSemi : topSemi;
			var dy = Math.abs(item.label.y - cy);
			if (dy >= semi.maxY) {
				var dx$1 = item.label.x - cx - item.len2 * dir$1;
				var rA = r + item.len;
				semi.rB = Math.abs(dx$1) < rA ? Math.sqrt(dy * dy / (1 - dx$1 * dx$1 / rA / rA)) : rA;
				semi.maxY = dy;
			}
			semi.list.push(item);
		}
		recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
		recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
	}
	var len$1 = list.length;
	for (var i$1 = 0; i$1 < len$1; i$1++) if (list[i$1].position === "outer" && list[i$1].labelAlignTo === "labelLine") {
		var dx = list[i$1].label.x - farthestX;
		list[i$1].linePoints[1][0] += dx;
		list[i$1].label.x = farthestX;
	}
	if (shiftLayoutOnXY(list, 1, viewTop, viewTop + viewHeight)) recalculateX(list);
}
function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
	var leftList = [];
	var rightList = [];
	var leftmostX = Number.MAX_VALUE;
	var rightmostX = -Number.MAX_VALUE;
	for (var i$1 = 0; i$1 < labelLayoutList.length; i$1++) {
		var label = labelLayoutList[i$1].label;
		if (isPositionCenter(labelLayoutList[i$1])) continue;
		if (label.x < cx) {
			leftmostX = Math.min(leftmostX, label.x);
			leftList.push(labelLayoutList[i$1]);
		} else {
			rightmostX = Math.max(rightmostX, label.x);
			rightList.push(labelLayoutList[i$1]);
		}
	}
	for (var i$1 = 0; i$1 < labelLayoutList.length; i$1++) {
		var layout$3 = labelLayoutList[i$1];
		if (!isPositionCenter(layout$3) && layout$3.linePoints) {
			if (layout$3.labelStyleWidth != null) continue;
			var label = layout$3.label;
			var linePoints = layout$3.linePoints;
			var targetTextWidth = void 0;
			if (layout$3.labelAlignTo === "edge") if (label.x < cx) targetTextWidth = linePoints[2][0] - layout$3.labelDistance - viewLeft - layout$3.edgeDistance;
			else targetTextWidth = viewLeft + viewWidth - layout$3.edgeDistance - linePoints[2][0] - layout$3.labelDistance;
			else if (layout$3.labelAlignTo === "labelLine") if (label.x < cx) targetTextWidth = leftmostX - viewLeft - layout$3.bleedMargin;
			else targetTextWidth = viewLeft + viewWidth - rightmostX - layout$3.bleedMargin;
			else if (label.x < cx) targetTextWidth = label.x - viewLeft - layout$3.bleedMargin;
			else targetTextWidth = viewLeft + viewWidth - label.x - layout$3.bleedMargin;
			layout$3.targetTextWidth = targetTextWidth;
			constrainTextWidth(layout$3, targetTextWidth, false);
		}
	}
	adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
	adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
	for (var i$1 = 0; i$1 < labelLayoutList.length; i$1++) {
		var layout$3 = labelLayoutList[i$1];
		if (!isPositionCenter(layout$3) && layout$3.linePoints) {
			var label = layout$3.label;
			var linePoints = layout$3.linePoints;
			var isAlignToEdge = layout$3.labelAlignTo === "edge";
			var padding = label.style.padding;
			var paddingH = padding ? padding[1] + padding[3] : 0;
			var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
			var realTextWidth = layout$3.rect.width + extraPaddingH;
			var dist$2 = linePoints[1][0] - linePoints[2][0];
			if (isAlignToEdge) if (label.x < cx) linePoints[2][0] = viewLeft + layout$3.edgeDistance + realTextWidth + layout$3.labelDistance;
			else linePoints[2][0] = viewLeft + viewWidth - layout$3.edgeDistance - realTextWidth - layout$3.labelDistance;
			else {
				if (label.x < cx) linePoints[2][0] = label.x + layout$3.labelDistance;
				else linePoints[2][0] = label.x - layout$3.labelDistance;
				linePoints[1][0] = linePoints[2][0] + dist$2;
			}
			linePoints[1][1] = linePoints[2][1] = label.y;
		}
	}
}
/**
* Set max width of each label, and then wrap each label to the max width.
*
* @param layout label layout
* @param availableWidth max width for the label to display
* @param forceRecalculate recaculate the text layout even if the current width
* is smaller than `availableWidth`. This is useful when the text was previously
* wrapped by calling `constrainTextWidth` but now `availableWidth` changed, in
* which case, previous wrapping should be redo.
*/
function constrainTextWidth(layout$3, availableWidth, forceRecalculate) {
	if (layout$3.labelStyleWidth != null) return;
	var label = layout$3.label;
	var style = label.style;
	var textRect = layout$3.rect;
	var bgColor = style.backgroundColor;
	var padding = style.padding;
	var paddingH = padding ? padding[1] + padding[3] : 0;
	var overflow = style.overflow;
	var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);
	if (availableWidth < oldOuterWidth || forceRecalculate) {
		if (overflow && overflow.match("break")) {
			label.setStyle("backgroundColor", null);
			label.setStyle("width", availableWidth - paddingH);
			var innerRect = label.getBoundingRect();
			label.setStyle("width", Math.ceil(innerRect.width));
			label.setStyle("backgroundColor", bgColor);
		} else {
			var availableInnerWidth = availableWidth - paddingH;
			var newWidth = availableWidth < oldOuterWidth ? availableInnerWidth : forceRecalculate ? availableInnerWidth > layout$3.unconstrainedWidth ? null : availableInnerWidth : null;
			label.setStyle("width", newWidth);
		}
		computeLabelGlobalRect(textRect, label);
	}
}
function computeLabelGlobalRect(out$1, label) {
	_tmpLabelGeometry.rect = out$1;
	computeLabelGeometry(_tmpLabelGeometry, label, _computeLabelGeometryOpt);
}
var _computeLabelGeometryOpt = {
	minMarginForce: [
		null,
		0,
		null,
		0
	],
	marginDefault: [
		1,
		0,
		1,
		0
	]
};
var _tmpLabelGeometry = {};
function isPositionCenter(sectorShape) {
	return sectorShape.position === "center";
}
function pieLabelLayout(seriesModel) {
	var data = seriesModel.getData();
	var labelLayoutList = [];
	var cx;
	var cy;
	var hasLabelRotate = false;
	var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN$3;
	var viewRect$1 = data.getLayout("viewRect");
	var r = data.getLayout("r");
	var viewWidth = viewRect$1.width;
	var viewLeft = viewRect$1.x;
	var viewTop = viewRect$1.y;
	var viewHeight = viewRect$1.height;
	function setNotShow(el) {
		el.ignore = true;
	}
	function isLabelShown(label$1) {
		if (!label$1.ignore) return true;
		for (var key$1 in label$1.states) if (label$1.states[key$1].ignore === false) return true;
		return false;
	}
	data.each(function(idx) {
		var sector = data.getItemGraphicEl(idx);
		var sectorShape = sector.shape;
		var label$1 = sector.getTextContent();
		var labelLine$1 = sector.getTextGuideLine();
		var itemModel = data.getItemModel(idx);
		var labelModel = itemModel.getModel("label");
		var labelPosition = labelModel.get("position") || itemModel.get([
			"emphasis",
			"label",
			"position"
		]);
		var labelDistance = labelModel.get("distanceToLabelLine");
		var labelAlignTo = labelModel.get("alignTo");
		var edgeDistance = parsePercent$1(labelModel.get("edgeDistance"), viewWidth);
		var bleedMargin = labelModel.get("bleedMargin");
		if (bleedMargin == null) bleedMargin = Math.min(viewWidth, viewHeight) > 200 ? 10 : 2;
		var labelLineModel = itemModel.getModel("labelLine");
		var labelLineLen = labelLineModel.get("length");
		labelLineLen = parsePercent$1(labelLineLen, viewWidth);
		var labelLineLen2 = labelLineModel.get("length2");
		labelLineLen2 = parsePercent$1(labelLineLen2, viewWidth);
		if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
			each(label$1.states, setNotShow);
			label$1.ignore = true;
			if (labelLine$1) {
				each(labelLine$1.states, setNotShow);
				labelLine$1.ignore = true;
			}
			return;
		}
		if (!isLabelShown(label$1)) return;
		var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
		var nx = Math.cos(midAngle);
		var ny = Math.sin(midAngle);
		var textX;
		var textY;
		var linePoints$1;
		var textAlign;
		cx = sectorShape.cx;
		cy = sectorShape.cy;
		var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
		if (labelPosition === "center") {
			textX = sectorShape.cx;
			textY = sectorShape.cy;
			textAlign = "center";
		} else {
			var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
			var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
			textX = x1 + nx * 3;
			textY = y1 + ny * 3;
			if (!isLabelInside) {
				var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);
				var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);
				var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
				var y3 = y2;
				if (labelAlignTo === "edge") textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
				else textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
				textY = y3;
				linePoints$1 = [
					[x1, y1],
					[x2, y2],
					[x3, y3]
				];
			}
			textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? nx > 0 ? "right" : "left" : nx > 0 ? "left" : "right";
		}
		var PI$9 = Math.PI;
		var labelRotate = 0;
		var rotate$1 = labelModel.get("rotate");
		if (isNumber(rotate$1)) labelRotate = rotate$1 * (PI$9 / 180);
		else if (labelPosition === "center") labelRotate = 0;
		else if (rotate$1 === "radial" || rotate$1 === true) labelRotate = nx < 0 ? -midAngle + PI$9 : -midAngle;
		else if (rotate$1 === "tangential" && labelPosition !== "outside" && labelPosition !== "outer") {
			var rad = Math.atan2(nx, ny);
			if (rad < 0) rad = PI$9 * 2 + rad;
			if (ny > 0) rad = PI$9 + rad;
			labelRotate = rad - PI$9;
		}
		hasLabelRotate = !!labelRotate;
		label$1.x = textX;
		label$1.y = textY;
		label$1.rotation = labelRotate;
		label$1.setStyle({ verticalAlign: "middle" });
		if (!isLabelInside) {
			var textRect = new BoundingRect_default(0, 0, 0, 0);
			computeLabelGlobalRect(textRect, label$1);
			labelLayoutList.push({
				label: label$1,
				labelLine: labelLine$1,
				position: labelPosition,
				len: labelLineLen,
				len2: labelLineLen2,
				minTurnAngle: labelLineModel.get("minTurnAngle"),
				maxSurfaceAngle: labelLineModel.get("maxSurfaceAngle"),
				surfaceNormal: new Point_default(nx, ny),
				linePoints: linePoints$1,
				textAlign,
				labelDistance,
				labelAlignTo,
				edgeDistance,
				bleedMargin,
				rect: textRect,
				unconstrainedWidth: textRect.width,
				labelStyleWidth: label$1.style.width
			});
		} else {
			label$1.setStyle({ align: textAlign });
			var selectState$1 = label$1.states.select;
			if (selectState$1) {
				selectState$1.x += label$1.x;
				selectState$1.y += label$1.y;
			}
		}
		sector.setTextConfig({ inside: isLabelInside });
	});
	if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
	for (var i$1 = 0; i$1 < labelLayoutList.length; i$1++) {
		var layout$3 = labelLayoutList[i$1];
		var label = layout$3.label;
		var labelLine = layout$3.labelLine;
		var notShowLabel = isNaN(label.x) || isNaN(label.y);
		if (label) {
			label.setStyle({ align: layout$3.textAlign });
			if (notShowLabel) {
				each(label.states, setNotShow);
				label.ignore = true;
			}
			var selectState = label.states.select;
			if (selectState) {
				selectState.x += label.x;
				selectState.y += label.y;
			}
		}
		if (labelLine) {
			var linePoints = layout$3.linePoints;
			if (notShowLabel || !linePoints) {
				each(labelLine.states, setNotShow);
				labelLine.ignore = true;
			} else {
				limitTurnAngle(linePoints, layout$3.minTurnAngle);
				limitSurfaceAngle(linePoints, layout$3.surfaceNormal, layout$3.maxSurfaceAngle);
				labelLine.setShape({ points: linePoints });
				label.__hostTarget.textGuideLineConfig = { anchor: new Point_default(linePoints[0][0], linePoints[0][1]) };
			}
		}
	}
}

//#endregion
//#region node_modules/echarts/lib/chart/pie/PieView.js
/**
* Piece of pie including Sector, Label, LabelLine
*/
var PiePiece = function(_super) {
	__extends(PiePiece$1, _super);
	function PiePiece$1(data, idx, startAngle) {
		var _this = _super.call(this) || this;
		_this.z2 = 2;
		var text = new Text_default();
		_this.setTextContent(text);
		_this.updateData(data, idx, startAngle, true);
		return _this;
	}
	PiePiece$1.prototype.updateData = function(data, idx, startAngle, firstCreate) {
		var sector = this;
		var seriesModel = data.hostModel;
		var itemModel = data.getItemModel(idx);
		var emphasisModel = itemModel.getModel("emphasis");
		var layout$3 = data.getItemLayout(idx);
		var sectorShape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout$3, true), layout$3);
		if (isNaN(sectorShape.startAngle)) {
			sector.setShape(sectorShape);
			return;
		}
		if (firstCreate) {
			sector.setShape(sectorShape);
			var animationType = seriesModel.getShallow("animationType");
			if (seriesModel.ecModel.ssr) {
				initProps(sector, {
					scaleX: 0,
					scaleY: 0
				}, seriesModel, {
					dataIndex: idx,
					isFrom: true
				});
				sector.originX = sectorShape.cx;
				sector.originY = sectorShape.cy;
			} else if (animationType === "scale") {
				sector.shape.r = layout$3.r0;
				initProps(sector, { shape: { r: layout$3.r } }, seriesModel, idx);
			} else if (startAngle != null) {
				sector.setShape({
					startAngle,
					endAngle: startAngle
				});
				initProps(sector, { shape: {
					startAngle: layout$3.startAngle,
					endAngle: layout$3.endAngle
				} }, seriesModel, idx);
			} else {
				sector.shape.endAngle = layout$3.startAngle;
				updateProps(sector, { shape: { endAngle: layout$3.endAngle } }, seriesModel, idx);
			}
		} else {
			saveOldStyle(sector);
			updateProps(sector, { shape: sectorShape }, seriesModel, idx);
		}
		sector.useStyle(data.getItemVisual(idx, "style"));
		setStatesStylesFromModel(sector, itemModel);
		var midAngle = (layout$3.startAngle + layout$3.endAngle) / 2;
		var offset = seriesModel.get("selectedOffset");
		var dx = Math.cos(midAngle) * offset;
		var dy = Math.sin(midAngle) * offset;
		var cursorStyle = itemModel.getShallow("cursor");
		cursorStyle && sector.attr("cursor", cursorStyle);
		this._updateLabel(seriesModel, data, idx);
		sector.ensureState("emphasis").shape = extend({ r: layout$3.r + (emphasisModel.get("scale") ? emphasisModel.get("scaleSize") || 0 : 0) }, getSectorCornerRadius(emphasisModel.getModel("itemStyle"), layout$3));
		extend(sector.ensureState("select"), {
			x: dx,
			y: dy,
			shape: getSectorCornerRadius(itemModel.getModel(["select", "itemStyle"]), layout$3)
		});
		extend(sector.ensureState("blur"), { shape: getSectorCornerRadius(itemModel.getModel(["blur", "itemStyle"]), layout$3) });
		var labelLine = sector.getTextGuideLine();
		var labelText = sector.getTextContent();
		labelLine && extend(labelLine.ensureState("select"), {
			x: dx,
			y: dy
		});
		extend(labelText.ensureState("select"), {
			x: dx,
			y: dy
		});
		toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
	};
	PiePiece$1.prototype._updateLabel = function(seriesModel, data, idx) {
		var sector = this;
		var itemModel = data.getItemModel(idx);
		var labelLineModel = itemModel.getModel("labelLine");
		var style = data.getItemVisual(idx, "style");
		var visualColor = style && style.fill;
		var visualOpacity = style && style.opacity;
		setLabelStyle(sector, getLabelStatesModels(itemModel), {
			labelFetcher: data.hostModel,
			labelDataIndex: idx,
			inheritColor: visualColor,
			defaultOpacity: visualOpacity,
			defaultText: seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx)
		});
		var labelText = sector.getTextContent();
		sector.setTextConfig({
			position: null,
			rotation: null
		});
		labelText.attr({ z2: 10 });
		var labelPosition = itemModel.get(["label", "position"]);
		if (labelPosition !== "outside" && labelPosition !== "outer") sector.removeTextGuideLine();
		else {
			var polyline = this.getTextGuideLine();
			if (!polyline) {
				polyline = new Polyline_default();
				this.setTextGuideLine(polyline);
			}
			setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
				stroke: visualColor,
				opacity: retrieve3(labelLineModel.get(["lineStyle", "opacity"]), visualOpacity, 1)
			});
		}
	};
	return PiePiece$1;
}(Sector_default);
var PieView = function(_super) {
	__extends(PieView$1, _super);
	function PieView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.ignoreLabelLineUpdate = true;
		return _this;
	}
	PieView$1.prototype.render = function(seriesModel, ecModel, api, payload) {
		var data = seriesModel.getData();
		var oldData = this._data;
		var group = this.group;
		var startAngle;
		if (!oldData && data.count() > 0) {
			var shape = data.getItemLayout(0);
			for (var s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) shape = data.getItemLayout(s);
			if (shape) startAngle = shape.startAngle;
		}
		if (this._emptyCircleSector) group.remove(this._emptyCircleSector);
		if (data.count() === 0 && seriesModel.get("showEmptyCircle")) {
			var layoutData = getSeriesLayoutData(seriesModel);
			var sector = new Sector_default({ shape: clone(layoutData) });
			sector.useStyle(seriesModel.getModel("emptyCircleStyle").getItemStyle());
			this._emptyCircleSector = sector;
			group.add(sector);
		}
		data.diff(oldData).add(function(idx) {
			var piePiece = new PiePiece(data, idx, startAngle);
			data.setItemGraphicEl(idx, piePiece);
			group.add(piePiece);
		}).update(function(newIdx, oldIdx) {
			var piePiece = oldData.getItemGraphicEl(oldIdx);
			piePiece.updateData(data, newIdx, startAngle);
			piePiece.off("click");
			group.add(piePiece);
			data.setItemGraphicEl(newIdx, piePiece);
		}).remove(function(idx) {
			var piePiece = oldData.getItemGraphicEl(idx);
			removeElementWithFadeOut(piePiece, seriesModel, idx);
		}).execute();
		pieLabelLayout(seriesModel);
		if (seriesModel.get("animationTypeUpdate") !== "expansion") this._data = data;
	};
	PieView$1.prototype.dispose = function() {};
	PieView$1.prototype.containPoint = function(point, seriesModel) {
		var itemLayout = seriesModel.getData().getItemLayout(0);
		if (itemLayout) {
			var dx = point[0] - itemLayout.cx;
			var dy = point[1] - itemLayout.cy;
			var radius = Math.sqrt(dx * dx + dy * dy);
			return radius <= itemLayout.r && radius >= itemLayout.r0;
		}
	};
	PieView$1.type = "pie";
	return PieView$1;
}(Chart_default);
var PieView_default = PieView;

//#endregion
//#region node_modules/echarts/lib/chart/helper/createSeriesDataSimply.js
/**
* [Usage]:
* (1)
* createListSimply(seriesModel, ['value']);
* (2)
* createListSimply(seriesModel, {
*     coordDimensions: ['value'],
*     dimensionsCount: 5
* });
*/
function createSeriesDataSimply(seriesModel, opt, nameList) {
	opt = isArray(opt) && { coordDimensions: opt } || extend({ encodeDefine: seriesModel.getEncode() }, opt);
	var source = seriesModel.getSource();
	var dimensions = prepareSeriesDataSchema(source, opt).dimensions;
	var list = new SeriesData_default(dimensions, seriesModel);
	list.initData(source, nameList);
	return list;
}

//#endregion
//#region node_modules/echarts/lib/visual/LegendVisualProvider.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* LegendVisualProvider is an bridge that pick encoded color from data and
* provide to the legend component.
*/
var LegendVisualProvider = function() {
	function LegendVisualProvider$1(getDataWithEncodedVisual, getRawData$1) {
		this._getDataWithEncodedVisual = getDataWithEncodedVisual;
		this._getRawData = getRawData$1;
	}
	LegendVisualProvider$1.prototype.getAllNames = function() {
		var rawData = this._getRawData();
		return rawData.mapArray(rawData.getName);
	};
	LegendVisualProvider$1.prototype.containName = function(name) {
		return this._getRawData().indexOfName(name) >= 0;
	};
	LegendVisualProvider$1.prototype.indexOfName = function(name) {
		return this._getDataWithEncodedVisual().indexOfName(name);
	};
	LegendVisualProvider$1.prototype.getItemVisual = function(dataIndex, key$1) {
		return this._getDataWithEncodedVisual().getItemVisual(dataIndex, key$1);
	};
	return LegendVisualProvider$1;
}();
var LegendVisualProvider_default = LegendVisualProvider;

//#endregion
//#region node_modules/echarts/lib/chart/pie/PieSeries.js
var innerData = makeInner();
var PieSeriesModel = function(_super) {
	__extends(PieSeriesModel$1, _super);
	function PieSeriesModel$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* @overwrite
	*/
	PieSeriesModel$1.prototype.init = function(option) {
		_super.prototype.init.apply(this, arguments);
		this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
		this._defaultLabelLine(option);
	};
	/**
	* @overwrite
	*/
	PieSeriesModel$1.prototype.mergeOption = function() {
		_super.prototype.mergeOption.apply(this, arguments);
	};
	/**
	* @overwrite
	*/
	PieSeriesModel$1.prototype.getInitialData = function() {
		return createSeriesDataSimply(this, {
			coordDimensions: ["value"],
			encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
		});
	};
	/**
	* @overwrite
	*/
	PieSeriesModel$1.prototype.getDataParams = function(dataIndex) {
		var data = this.getData();
		var dataInner = innerData(data);
		var seats = dataInner.seats;
		if (!seats) {
			var valueList_1 = [];
			data.each(data.mapDimension("value"), function(value) {
				valueList_1.push(value);
			});
			seats = dataInner.seats = getPercentSeats(valueList_1, data.hostModel.get("percentPrecision"));
		}
		var params = _super.prototype.getDataParams.call(this, dataIndex);
		params.percent = seats[dataIndex] || 0;
		params.$vars.push("percent");
		return params;
	};
	PieSeriesModel$1.prototype._defaultLabelLine = function(option) {
		defaultEmphasis(option, "labelLine", ["show"]);
		var labelLineNormalOpt = option.labelLine;
		var labelLineEmphasisOpt = option.emphasis.labelLine;
		labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
		labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
	};
	PieSeriesModel$1.type = "series.pie";
	PieSeriesModel$1.defaultOption = {
		z: 2,
		legendHoverLink: true,
		colorBy: "data",
		center: ["50%", "50%"],
		radius: [0, "50%"],
		clockwise: true,
		startAngle: 90,
		endAngle: "auto",
		padAngle: 0,
		minAngle: 0,
		minShowLabelAngle: 0,
		selectedOffset: 10,
		percentPrecision: 2,
		stillShowZeroSum: true,
		coordinateSystemUsage: "box",
		left: 0,
		top: 0,
		right: 0,
		bottom: 0,
		width: null,
		height: null,
		label: {
			rotate: 0,
			show: true,
			overflow: "truncate",
			position: "outer",
			alignTo: "none",
			edgeDistance: "25%",
			distanceToLabelLine: 5
		},
		labelLine: {
			show: true,
			length: 15,
			length2: 30,
			smooth: false,
			minTurnAngle: 90,
			maxSurfaceAngle: 90,
			lineStyle: {
				width: 1,
				type: "solid"
			}
		},
		itemStyle: {
			borderWidth: 1,
			borderJoin: "round"
		},
		showEmptyCircle: true,
		emptyCircleStyle: {
			color: "lightgray",
			opacity: 1
		},
		labelLayout: { hideOverlap: true },
		emphasis: {
			scale: true,
			scaleSize: 5
		},
		avoidLabelOverlap: true,
		animationType: "expansion",
		animationDuration: 1e3,
		animationTypeUpdate: "transition",
		animationEasingUpdate: "cubicInOut",
		animationDurationUpdate: 500,
		animationEasing: "cubicInOut"
	};
	return PieSeriesModel$1;
}(Series_default);
registerLayOutOnCoordSysUsage({
	fullType: PieSeriesModel.type,
	getCoord2: function(model) {
		return model.getShallow("center");
	}
});
var PieSeries_default = PieSeriesModel;

//#endregion
//#region node_modules/echarts/lib/processor/negativeDataFilter.js
function negativeDataFilter(seriesType$1) {
	return {
		seriesType: seriesType$1,
		reset: function(seriesModel, ecModel) {
			var data = seriesModel.getData();
			data.filterSelf(function(idx) {
				var valueDim = data.mapDimension("value");
				var curValue = data.get(valueDim, idx);
				if (isNumber(curValue) && !isNaN(curValue) && curValue < 0) return false;
				return true;
			});
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/chart/pie/install.js
function install$4(registers) {
	registers.registerChartView(PieView_default);
	registers.registerSeriesModel(PieSeries_default);
	createLegacyDataSelectAction("pie", registers.registerAction);
	registers.registerLayout(curry(pieLayout, "pie"));
	registers.registerProcessor(dataFilter$1("pie"));
	registers.registerProcessor(negativeDataFilter("pie"));
}

//#endregion
//#region node_modules/echarts/lib/chart/scatter/ScatterSeries.js
var ScatterSeriesModel = function(_super) {
	__extends(ScatterSeriesModel$1, _super);
	function ScatterSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ScatterSeriesModel$1.type;
		_this.hasSymbolVisual = true;
		return _this;
	}
	ScatterSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		return createSeriesData_default(null, this, { useEncodeDefaulter: true });
	};
	ScatterSeriesModel$1.prototype.getProgressive = function() {
		var progressive = this.option.progressive;
		if (progressive == null) return this.option.large ? 5e3 : this.get("progressive");
		return progressive;
	};
	ScatterSeriesModel$1.prototype.getProgressiveThreshold = function() {
		var progressiveThreshold = this.option.progressiveThreshold;
		if (progressiveThreshold == null) return this.option.large ? 1e4 : this.get("progressiveThreshold");
		return progressiveThreshold;
	};
	ScatterSeriesModel$1.prototype.brushSelector = function(dataIndex, data, selectors) {
		return selectors.point(data.getItemLayout(dataIndex));
	};
	ScatterSeriesModel$1.prototype.getZLevelKey = function() {
		return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
	};
	ScatterSeriesModel$1.type = "series.scatter";
	ScatterSeriesModel$1.dependencies = [
		"grid",
		"polar",
		"geo",
		"singleAxis",
		"calendar",
		"matrix"
	];
	ScatterSeriesModel$1.defaultOption = {
		coordinateSystem: "cartesian2d",
		z: 2,
		legendHoverLink: true,
		symbolSize: 10,
		large: false,
		largeThreshold: 2e3,
		itemStyle: { opacity: .8 },
		emphasis: { scale: true },
		clip: true,
		select: { itemStyle: { borderColor: tokens_default.color.primary } },
		universalTransition: { divideShape: "clone" }
	};
	return ScatterSeriesModel$1;
}(Series_default);
var ScatterSeries_default = ScatterSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js
var BOOST_SIZE_THRESHOLD = 4;
var LargeSymbolPathShape = function() {
	function LargeSymbolPathShape$1() {}
	return LargeSymbolPathShape$1;
}();
var LargeSymbolPath = function(_super) {
	__extends(LargeSymbolPath$1, _super);
	function LargeSymbolPath$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this._off = 0;
		_this.hoverDataIdx = -1;
		return _this;
	}
	LargeSymbolPath$1.prototype.getDefaultShape = function() {
		return new LargeSymbolPathShape();
	};
	LargeSymbolPath$1.prototype.reset = function() {
		this.notClear = false;
		this._off = 0;
	};
	LargeSymbolPath$1.prototype.buildPath = function(path, shape) {
		var points$3 = shape.points;
		var size = shape.size;
		var symbolProxy = this.symbolProxy;
		var symbolProxyShape = symbolProxy.shape;
		var ctx = path.getContext ? path.getContext() : path;
		var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;
		var softClipShape = this.softClipShape;
		var i$1;
		if (canBoost) {
			this._ctx = ctx;
			return;
		}
		this._ctx = null;
		for (i$1 = this._off; i$1 < points$3.length;) {
			var x = points$3[i$1++];
			var y = points$3[i$1++];
			if (isNaN(x) || isNaN(y)) continue;
			if (softClipShape && !softClipShape.contain(x, y)) continue;
			symbolProxyShape.x = x - size[0] / 2;
			symbolProxyShape.y = y - size[1] / 2;
			symbolProxyShape.width = size[0];
			symbolProxyShape.height = size[1];
			symbolProxy.buildPath(path, symbolProxyShape, true);
		}
		if (this.incremental) {
			this._off = i$1;
			this.notClear = true;
		}
	};
	LargeSymbolPath$1.prototype.afterBrush = function() {
		var shape = this.shape;
		var points$3 = shape.points;
		var size = shape.size;
		var ctx = this._ctx;
		var softClipShape = this.softClipShape;
		var i$1;
		if (!ctx) return;
		for (i$1 = this._off; i$1 < points$3.length;) {
			var x = points$3[i$1++];
			var y = points$3[i$1++];
			if (isNaN(x) || isNaN(y)) continue;
			if (softClipShape && !softClipShape.contain(x, y)) continue;
			ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
		}
		if (this.incremental) {
			this._off = i$1;
			this.notClear = true;
		}
	};
	LargeSymbolPath$1.prototype.findDataIndex = function(x, y) {
		var shape = this.shape;
		var points$3 = shape.points;
		var size = shape.size;
		var w = Math.max(size[0], 4);
		var h = Math.max(size[1], 4);
		for (var idx = points$3.length / 2 - 1; idx >= 0; idx--) {
			var i$1 = idx * 2;
			var x0 = points$3[i$1] - w / 2;
			var y0 = points$3[i$1 + 1] - h / 2;
			if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) return idx;
		}
		return -1;
	};
	LargeSymbolPath$1.prototype.contain = function(x, y) {
		var localPos = this.transformCoordToLocal(x, y);
		var rect = this.getBoundingRect();
		x = localPos[0];
		y = localPos[1];
		if (rect.contain(x, y)) return (this.hoverDataIdx = this.findDataIndex(x, y)) >= 0;
		this.hoverDataIdx = -1;
		return false;
	};
	LargeSymbolPath$1.prototype.getBoundingRect = function() {
		var rect = this._rect;
		if (!rect) {
			var shape = this.shape;
			var points$3 = shape.points;
			var size = shape.size;
			var w = size[0];
			var h = size[1];
			var minX = Infinity;
			var minY = Infinity;
			var maxX = -Infinity;
			var maxY = -Infinity;
			for (var i$1 = 0; i$1 < points$3.length;) {
				var x = points$3[i$1++];
				var y = points$3[i$1++];
				minX = Math.min(x, minX);
				maxX = Math.max(x, maxX);
				minY = Math.min(y, minY);
				maxY = Math.max(y, maxY);
			}
			rect = this._rect = new BoundingRect_default(minX - w / 2, minY - h / 2, maxX - minX + w, maxY - minY + h);
		}
		return rect;
	};
	return LargeSymbolPath$1;
}(Path_default);
var LargeSymbolDraw = function() {
	function LargeSymbolDraw$1() {
		this.group = new Group_default();
	}
	/**
	* Update symbols draw by new data
	*/
	LargeSymbolDraw$1.prototype.updateData = function(data, opt) {
		this._clear();
		var symbolEl = this._create();
		symbolEl.setShape({ points: data.getLayout("points") });
		this._setCommon(symbolEl, data, opt);
	};
	LargeSymbolDraw$1.prototype.updateLayout = function(data) {
		var points$3 = data.getLayout("points");
		this.group.eachChild(function(child) {
			if (child.startIndex != null) {
				var len$1 = (child.endIndex - child.startIndex) * 2;
				var byteOffset = child.startIndex * 4 * 2;
				points$3 = new Float32Array(points$3.buffer, byteOffset, len$1);
			}
			child.setShape("points", points$3);
			child.reset();
		});
	};
	LargeSymbolDraw$1.prototype.incrementalPrepareUpdate = function(data) {
		this._clear();
	};
	LargeSymbolDraw$1.prototype.incrementalUpdate = function(taskParams, data, opt) {
		var lastAdded = this._newAdded[0];
		var points$3 = data.getLayout("points");
		var oldPoints = lastAdded && lastAdded.shape.points;
		if (oldPoints && oldPoints.length < 2e4) {
			var oldLen = oldPoints.length;
			var newPoints = new Float32Array(oldLen + points$3.length);
			newPoints.set(oldPoints);
			newPoints.set(points$3, oldLen);
			lastAdded.endIndex = taskParams.end;
			lastAdded.setShape({ points: newPoints });
		} else {
			this._newAdded = [];
			var symbolEl = this._create();
			symbolEl.startIndex = taskParams.start;
			symbolEl.endIndex = taskParams.end;
			symbolEl.incremental = true;
			symbolEl.setShape({ points: points$3 });
			this._setCommon(symbolEl, data, opt);
		}
	};
	LargeSymbolDraw$1.prototype.eachRendered = function(cb) {
		this._newAdded[0] && cb(this._newAdded[0]);
	};
	LargeSymbolDraw$1.prototype._create = function() {
		var symbolEl = new LargeSymbolPath({ cursor: "default" });
		symbolEl.ignoreCoarsePointer = true;
		this.group.add(symbolEl);
		this._newAdded.push(symbolEl);
		return symbolEl;
	};
	LargeSymbolDraw$1.prototype._setCommon = function(symbolEl, data, opt) {
		var hostModel = data.hostModel;
		opt = opt || {};
		var size = data.getVisual("symbolSize");
		symbolEl.setShape("size", size instanceof Array ? size : [size, size]);
		symbolEl.softClipShape = opt.clipShape || null;
		symbolEl.symbolProxy = createSymbol(data.getVisual("symbol"), 0, 0, 0, 0);
		symbolEl.setColor = symbolEl.symbolProxy.setColor;
		var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
		symbolEl.useStyle(hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? [
			"color",
			"shadowBlur",
			"shadowColor"
		] : ["color"]));
		var globalStyle = data.getVisual("style");
		var visualColor = globalStyle && globalStyle.fill;
		if (visualColor) symbolEl.setColor(visualColor);
		var ecData = getECData(symbolEl);
		ecData.seriesIndex = hostModel.seriesIndex;
		symbolEl.on("mousemove", function(e$1) {
			ecData.dataIndex = null;
			var dataIndex = symbolEl.hoverDataIdx;
			if (dataIndex >= 0) ecData.dataIndex = dataIndex + (symbolEl.startIndex || 0);
		});
	};
	LargeSymbolDraw$1.prototype.remove = function() {
		this._clear();
	};
	LargeSymbolDraw$1.prototype._clear = function() {
		this._newAdded = [];
		this.group.removeAll();
	};
	return LargeSymbolDraw$1;
}();
var LargeSymbolDraw_default = LargeSymbolDraw;

//#endregion
//#region node_modules/echarts/lib/chart/scatter/ScatterView.js
var ScatterView = function(_super) {
	__extends(ScatterView$1, _super);
	function ScatterView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ScatterView$1.type;
		return _this;
	}
	ScatterView$1.prototype.render = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		this._updateSymbolDraw(data, seriesModel).updateData(data, { clipShape: this._getClipShape(seriesModel) });
		this._finished = true;
	};
	ScatterView$1.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		this._updateSymbolDraw(data, seriesModel).incrementalPrepareUpdate(data);
		this._finished = false;
	};
	ScatterView$1.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
		this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), { clipShape: this._getClipShape(seriesModel) });
		this._finished = taskParams.end === seriesModel.getData().count();
	};
	ScatterView$1.prototype.updateTransform = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		this.group.dirty();
		if (!this._finished || data.count() > 1e4) return { update: true };
		else {
			var res = pointsLayout("").reset(seriesModel, ecModel, api);
			if (res.progress) res.progress({
				start: 0,
				end: data.count(),
				count: data.count()
			}, data);
			this._symbolDraw.updateLayout(data);
		}
	};
	ScatterView$1.prototype.eachRendered = function(cb) {
		this._symbolDraw && this._symbolDraw.eachRendered(cb);
	};
	ScatterView$1.prototype._getClipShape = function(seriesModel) {
		if (!seriesModel.get("clip", true)) return;
		var coordSys = seriesModel.coordinateSystem;
		return coordSys && coordSys.getArea && coordSys.getArea(.1);
	};
	ScatterView$1.prototype._updateSymbolDraw = function(data, seriesModel) {
		var symbolDraw = this._symbolDraw;
		var isLargeDraw = seriesModel.pipelineContext.large;
		if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
			symbolDraw && symbolDraw.remove();
			symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw_default() : new SymbolDraw_default();
			this._isLargeDraw = isLargeDraw;
			this.group.removeAll();
		}
		this.group.add(symbolDraw.group);
		return symbolDraw;
	};
	ScatterView$1.prototype.remove = function(ecModel, api) {
		this._symbolDraw && this._symbolDraw.remove(true);
		this._symbolDraw = null;
	};
	ScatterView$1.prototype.dispose = function() {};
	ScatterView$1.type = "scatter";
	return ScatterView$1;
}(Chart_default);
var ScatterView_default = ScatterView;

//#endregion
//#region node_modules/echarts/lib/coord/cartesian/GridModel.js
var OUTER_BOUNDS_DEFAULT = {
	left: 0,
	right: 0,
	top: 0,
	bottom: 0
};
var OUTER_BOUNDS_CLAMP_DEFAULT = ["25%", "25%"];
var GridModel = function(_super) {
	__extends(GridModel$1, _super);
	function GridModel$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	GridModel$1.prototype.mergeDefaultAndTheme = function(option, ecModel) {
		var outerBoundsCp = getLayoutParams(option.outerBounds);
		_super.prototype.mergeDefaultAndTheme.apply(this, arguments);
		if (outerBoundsCp && option.outerBounds) mergeLayoutParam(option.outerBounds, outerBoundsCp);
	};
	GridModel$1.prototype.mergeOption = function(newOption, ecModel) {
		_super.prototype.mergeOption.apply(this, arguments);
		if (this.option.outerBounds && newOption.outerBounds) mergeLayoutParam(this.option.outerBounds, newOption.outerBounds);
	};
	GridModel$1.type = "grid";
	GridModel$1.dependencies = ["xAxis", "yAxis"];
	GridModel$1.layoutMode = "box";
	GridModel$1.defaultOption = {
		show: false,
		z: 0,
		left: "15%",
		top: 65,
		right: "10%",
		bottom: 80,
		containLabel: false,
		outerBoundsMode: "auto",
		outerBounds: OUTER_BOUNDS_DEFAULT,
		outerBoundsContain: "all",
		outerBoundsClampWidth: OUTER_BOUNDS_CLAMP_DEFAULT[0],
		outerBoundsClampHeight: OUTER_BOUNDS_CLAMP_DEFAULT[1],
		backgroundColor: tokens_default.color.transparent,
		borderWidth: 1,
		borderColor: tokens_default.color.neutral30
	};
	return GridModel$1;
}(Component_default);
var GridModel_default = GridModel;

//#endregion
//#region node_modules/echarts/lib/coord/cartesian/AxisModel.js
var CartesianAxisModel = function(_super) {
	__extends(CartesianAxisModel$1, _super);
	function CartesianAxisModel$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	CartesianAxisModel$1.prototype.getCoordSysModel = function() {
		return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
	};
	CartesianAxisModel$1.type = "cartesian2dAxis";
	return CartesianAxisModel$1;
}(Component_default);
mixin(CartesianAxisModel, AxisModelCommonMixin);

//#endregion
//#region node_modules/echarts/lib/coord/axisDefault.js
var defaultOption$1 = {
	show: true,
	z: 0,
	inverse: false,
	name: "",
	nameLocation: "end",
	nameRotate: null,
	nameTruncate: {
		maxWidth: null,
		ellipsis: "...",
		placeholder: "."
	},
	nameTextStyle: {},
	nameGap: 15,
	silent: false,
	triggerEvent: false,
	tooltip: { show: false },
	axisPointer: {},
	axisLine: {
		show: true,
		onZero: true,
		onZeroAxisIndex: null,
		lineStyle: {
			color: tokens_default.color.axisLine,
			width: 1,
			type: "solid"
		},
		symbol: ["none", "none"],
		symbolSize: [10, 15],
		breakLine: true
	},
	axisTick: {
		show: true,
		inside: false,
		length: 5,
		lineStyle: { width: 1 }
	},
	axisLabel: {
		show: true,
		inside: false,
		rotate: 0,
		showMinLabel: null,
		showMaxLabel: null,
		margin: 8,
		fontSize: 12,
		color: tokens_default.color.axisLabel,
		textMargin: [0, 3]
	},
	splitLine: {
		show: true,
		showMinLine: true,
		showMaxLine: true,
		lineStyle: {
			color: tokens_default.color.axisSplitLine,
			width: 1,
			type: "solid"
		}
	},
	splitArea: {
		show: false,
		areaStyle: { color: [tokens_default.color.backgroundTint, tokens_default.color.backgroundTransparent] }
	},
	breakArea: {
		show: true,
		itemStyle: {
			color: tokens_default.color.neutral00,
			borderColor: tokens_default.color.border,
			borderWidth: 1,
			borderType: [3, 3],
			opacity: .6
		},
		zigzagAmplitude: 4,
		zigzagMinSpan: 4,
		zigzagMaxSpan: 20,
		zigzagZ: 100,
		expandOnClick: true
	},
	breakLabelLayout: { moveOverlap: "auto" }
};
var categoryAxis = merge({
	boundaryGap: true,
	deduplication: null,
	jitter: 0,
	jitterOverlap: true,
	jitterMargin: 2,
	splitLine: { show: false },
	axisTick: {
		alignWithLabel: false,
		interval: "auto",
		show: "auto"
	},
	axisLabel: { interval: "auto" }
}, defaultOption$1);
var valueAxis = merge({
	boundaryGap: [0, 0],
	axisLine: { show: "auto" },
	axisTick: { show: "auto" },
	splitNumber: 5,
	minorTick: {
		show: false,
		splitNumber: 5,
		length: 3,
		lineStyle: {}
	},
	minorSplitLine: {
		show: false,
		lineStyle: {
			color: tokens_default.color.axisMinorSplitLine,
			width: 1
		}
	}
}, defaultOption$1);
var timeAxis = merge({
	splitNumber: 6,
	axisLabel: {
		showMinLabel: false,
		showMaxLabel: false,
		rich: { primary: { fontWeight: "bold" } }
	},
	splitLine: { show: false }
}, valueAxis);
var logAxis = defaults({ logBase: 10 }, valueAxis);
var axisDefault_default = {
	category: categoryAxis,
	value: valueAxis,
	time: timeAxis,
	log: logAxis
};

//#endregion
//#region node_modules/echarts/lib/coord/axisCommonTypes.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var AXIS_TYPES = {
	value: 1,
	category: 1,
	time: 1,
	log: 1
};

//#endregion
//#region node_modules/echarts/lib/component/axis/axisBreakHelper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var _impl = null;
function registerAxisBreakHelperImpl(impl) {
	if (!_impl) _impl = impl;
}
function getAxisBreakHelper() {
	return _impl;
}

//#endregion
//#region node_modules/echarts/lib/coord/axisModelCreator.js
/**
* Generate sub axis model class
* @param axisName 'x' 'y' 'radius' 'angle' 'parallel' ...
*/
function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
	each(AXIS_TYPES, function(v, axisType) {
		var defaultOption$2 = merge(merge({}, axisDefault_default[axisType], true), extraDefaultOption, true);
		var AxisModel = function(_super) {
			__extends(AxisModel$1, _super);
			function AxisModel$1() {
				var _this = _super !== null && _super.apply(this, arguments) || this;
				_this.type = axisName + "Axis." + axisType;
				return _this;
			}
			AxisModel$1.prototype.mergeDefaultAndTheme = function(option, ecModel) {
				var layoutMode = fetchLayoutMode(this);
				var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
				merge(option, ecModel.getTheme().get(axisType + "Axis"));
				merge(option, this.getDefaultOption());
				option.type = getAxisType(option);
				if (layoutMode) mergeLayoutParam(option, inputPositionParams, layoutMode);
			};
			AxisModel$1.prototype.optionUpdated = function() {
				if (this.option.type === "category") this.__ordinalMeta = OrdinalMeta_default.createByAxisModel(this);
			};
			/**
			* Should not be called before all of 'getInitailData' finished.
			* Because categories are collected during initializing data.
			*/
			AxisModel$1.prototype.getCategories = function(rawData) {
				var option = this.option;
				if (option.type === "category") {
					if (rawData) return option.data;
					return this.__ordinalMeta.categories;
				}
			};
			AxisModel$1.prototype.getOrdinalMeta = function() {
				return this.__ordinalMeta;
			};
			AxisModel$1.prototype.updateAxisBreaks = function(payload) {
				var axisBreakHelper = getAxisBreakHelper();
				return axisBreakHelper ? axisBreakHelper.updateModelAxisBreak(this, payload) : { breaks: [] };
			};
			AxisModel$1.type = axisName + "Axis." + axisType;
			AxisModel$1.defaultOption = defaultOption$2;
			return AxisModel$1;
		}(BaseAxisModelClass);
		registers.registerComponentModel(AxisModel);
	});
	registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType);
}
function getAxisType(option) {
	return option.type || (option.data ? "category" : "value");
}

//#endregion
//#region node_modules/echarts/lib/coord/cartesian/Cartesian.js
var Cartesian = function() {
	function Cartesian$1(name) {
		this.type = "cartesian";
		this._dimList = [];
		this._axes = {};
		this.name = name || "";
	}
	Cartesian$1.prototype.getAxis = function(dim) {
		return this._axes[dim];
	};
	Cartesian$1.prototype.getAxes = function() {
		return map(this._dimList, function(dim) {
			return this._axes[dim];
		}, this);
	};
	Cartesian$1.prototype.getAxesByScale = function(scaleType) {
		scaleType = scaleType.toLowerCase();
		return filter(this.getAxes(), function(axis) {
			return axis.scale.type === scaleType;
		});
	};
	Cartesian$1.prototype.addAxis = function(axis) {
		var dim = axis.dim;
		this._axes[dim] = axis;
		this._dimList.push(dim);
	};
	return Cartesian$1;
}();
var Cartesian_default = Cartesian;

//#endregion
//#region node_modules/echarts/lib/coord/cartesian/Cartesian2D.js
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(scale$3) {
	return (scale$3.type === "interval" || scale$3.type === "time") && !scale$3.hasBreaks();
}
var Cartesian2D = function(_super) {
	__extends(Cartesian2D$1, _super);
	function Cartesian2D$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "cartesian2d";
		_this.dimensions = cartesian2DDimensions;
		return _this;
	}
	/**
	* Calculate an affine transform matrix if two axes are time or value.
	* It's mainly for accelartion on the large time series data.
	*/
	Cartesian2D$1.prototype.calcAffineTransform = function() {
		this._transform = this._invTransform = null;
		var xAxisScale = this.getAxis("x").scale;
		var yAxisScale = this.getAxis("y").scale;
		if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) return;
		var xScaleExtent = xAxisScale.getExtent();
		var yScaleExtent = yAxisScale.getExtent();
		var start$1 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
		var end$1 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
		var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
		var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
		if (!xScaleSpan || !yScaleSpan) return;
		var scaleX = (end$1[0] - start$1[0]) / xScaleSpan;
		var scaleY = (end$1[1] - start$1[1]) / yScaleSpan;
		this._invTransform = invert([], this._transform = [
			scaleX,
			0,
			0,
			scaleY,
			start$1[0] - xScaleExtent[0] * scaleX,
			start$1[1] - yScaleExtent[0] * scaleY
		]);
	};
	/**
	* Base axis will be used on stacking.
	*/
	Cartesian2D$1.prototype.getBaseAxis = function() {
		return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
	};
	Cartesian2D$1.prototype.containPoint = function(point) {
		var axisX = this.getAxis("x");
		var axisY = this.getAxis("y");
		return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
	};
	Cartesian2D$1.prototype.containData = function(data) {
		return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
	};
	Cartesian2D$1.prototype.containZone = function(data1, data2) {
		var zoneDiag1 = this.dataToPoint(data1);
		var zoneDiag2 = this.dataToPoint(data2);
		var area = this.getArea();
		var zone = new BoundingRect_default(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
		return area.intersect(zone);
	};
	Cartesian2D$1.prototype.dataToPoint = function(data, clamp$1, out$1) {
		out$1 = out$1 || [];
		var xVal = data[0];
		var yVal = data[1];
		if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) return applyTransform(out$1, data, this._transform);
		var xAxis = this.getAxis("x");
		var yAxis = this.getAxis("y");
		out$1[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp$1));
		out$1[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp$1));
		return out$1;
	};
	Cartesian2D$1.prototype.clampData = function(data, out$1) {
		var xScale = this.getAxis("x").scale;
		var yScale = this.getAxis("y").scale;
		var xAxisExtent = xScale.getExtent();
		var yAxisExtent = yScale.getExtent();
		var x = xScale.parse(data[0]);
		var y = yScale.parse(data[1]);
		out$1 = out$1 || [];
		out$1[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
		out$1[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
		return out$1;
	};
	Cartesian2D$1.prototype.pointToData = function(point, clamp$1, out$1) {
		out$1 = out$1 || [];
		if (this._invTransform) return applyTransform(out$1, point, this._invTransform);
		var xAxis = this.getAxis("x");
		var yAxis = this.getAxis("y");
		out$1[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp$1);
		out$1[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp$1);
		return out$1;
	};
	Cartesian2D$1.prototype.getOtherAxis = function(axis) {
		return this.getAxis(axis.dim === "x" ? "y" : "x");
	};
	/**
	* Get rect area of cartesian.
	* Area will have a contain function to determine if a point is in the coordinate system.
	*/
	Cartesian2D$1.prototype.getArea = function(tolerance) {
		tolerance = tolerance || 0;
		var xExtent = this.getAxis("x").getGlobalExtent();
		var yExtent = this.getAxis("y").getGlobalExtent();
		var x = Math.min(xExtent[0], xExtent[1]) - tolerance;
		var y = Math.min(yExtent[0], yExtent[1]) - tolerance;
		return new BoundingRect_default(x, y, Math.max(xExtent[0], xExtent[1]) - x + tolerance, Math.max(yExtent[0], yExtent[1]) - y + tolerance);
	};
	return Cartesian2D$1;
}(Cartesian_default);
var Cartesian2D_default = Cartesian2D;

//#endregion
//#region node_modules/echarts/lib/coord/cartesian/Axis2D.js
var Axis2D = function(_super) {
	__extends(Axis2D$1, _super);
	function Axis2D$1(dim, scale$3, coordExtent, axisType, position$1) {
		var _this = _super.call(this, dim, scale$3, coordExtent) || this;
		/**
		* Index of axis, can be used as key
		* Injected outside.
		*/
		_this.index = 0;
		_this.type = axisType || "value";
		_this.position = position$1 || "bottom";
		return _this;
	}
	Axis2D$1.prototype.isHorizontal = function() {
		var position$1 = this.position;
		return position$1 === "top" || position$1 === "bottom";
	};
	/**
	* Each item cooresponds to this.getExtent(), which
	* means globalExtent[0] may greater than globalExtent[1],
	* unless `asc` is input.
	*
	* @param {boolean} [asc]
	* @return {Array.<number>}
	*/
	Axis2D$1.prototype.getGlobalExtent = function(asc$3) {
		var ret = this.getExtent();
		ret[0] = this.toGlobalCoord(ret[0]);
		ret[1] = this.toGlobalCoord(ret[1]);
		asc$3 && ret[0] > ret[1] && ret.reverse();
		return ret;
	};
	Axis2D$1.prototype.pointToData = function(point, clamp$1) {
		return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp$1);
	};
	/**
	* Set ordinalSortInfo
	* @param info new OrdinalSortInfo
	*/
	Axis2D$1.prototype.setCategorySortInfo = function(info) {
		if (this.type !== "category") return false;
		this.model.option.categorySortInfo = info;
		this.scale.setSortInfo(info);
	};
	return Axis2D$1;
}(Axis_default);
var Axis2D_default = Axis2D;

//#endregion
//#region node_modules/echarts/lib/component/axis/axisAction.js
var AXIS_BREAK_EXPAND_ACTION_TYPE = "expandAxisBreak";
var AXIS_BREAK_COLLAPSE_ACTION_TYPE = "collapseAxisBreak";
var AXIS_BREAK_TOGGLE_ACTION_TYPE = "toggleAxisBreak";
var AXIS_BREAK_CHANGED_EVENT_TYPE = "axisbreakchanged";
var expandAxisBreakActionInfo = {
	type: AXIS_BREAK_EXPAND_ACTION_TYPE,
	event: AXIS_BREAK_CHANGED_EVENT_TYPE,
	update: "update",
	refineEvent: refineAxisBreakChangeEvent
};
var collapseAxisBreakActionInfo = {
	type: AXIS_BREAK_COLLAPSE_ACTION_TYPE,
	event: AXIS_BREAK_CHANGED_EVENT_TYPE,
	update: "update",
	refineEvent: refineAxisBreakChangeEvent
};
var toggleAxisBreakActionInfo = {
	type: AXIS_BREAK_TOGGLE_ACTION_TYPE,
	event: AXIS_BREAK_CHANGED_EVENT_TYPE,
	update: "update",
	refineEvent: refineAxisBreakChangeEvent
};
function refineAxisBreakChangeEvent(actionResultBatch, payload, ecModel, api) {
	var breaks = [];
	each(actionResultBatch, function(actionResult) {
		breaks = breaks.concat(actionResult.eventBreaks);
	});
	return { eventContent: { breaks } };
}
function registerAction$1(registers) {
	registers.registerAction(expandAxisBreakActionInfo, actionHandler);
	registers.registerAction(collapseAxisBreakActionInfo, actionHandler);
	registers.registerAction(toggleAxisBreakActionInfo, actionHandler);
	function actionHandler(payload, ecModel) {
		var eventBreaks = [];
		var finderResult = parseFinder(ecModel, payload);
		function dealUpdate(modelProp, indexProp) {
			each(finderResult[modelProp], function(axisModel) {
				each(axisModel.updateAxisBreaks(payload).breaks, function(item) {
					var _a$1;
					eventBreaks.push(defaults((_a$1 = {}, _a$1[indexProp] = axisModel.componentIndex, _a$1), item));
				});
			});
		}
		dealUpdate("xAxisModels", "xAxisIndex");
		dealUpdate("yAxisModels", "yAxisIndex");
		dealUpdate("singleAxisModels", "singleAxisIndex");
		return { eventBreaks };
	}
}

//#endregion
//#region node_modules/echarts/lib/component/axis/AxisBuilder.js
var PI$3 = Math.PI;
var DEFAULT_CENTER_NAME_MARGIN_LEVELS = [
	[
		1,
		2,
		1,
		2
	],
	[
		5,
		3,
		5,
		3
	],
	[
		8,
		3,
		8,
		3
	]
];
var DEFAULT_ENDS_NAME_MARGIN_LEVELS = [
	[
		0,
		1,
		0,
		1
	],
	[
		0,
		3,
		0,
		3
	],
	[
		0,
		3,
		0,
		3
	]
];
var getLabelInner = makeInner();
var getTickInner = makeInner();
/**
* A context shared by difference axisBuilder instances.
* For cross-axes overlap resolving.
*
* Lifecycle constraint: should not over a pass of ec main process.
*  If model is changed, the context must be disposed.
*
* @see AxisBuilderLocalContext
*/
var AxisBuilderSharedContext = function() {
	function AxisBuilderSharedContext$1(resolveAxisNameOverlap) {
		/**
		* [CAUTION] Do not modify this data structure outside this class.
		*/
		this.recordMap = {};
		this.resolveAxisNameOverlap = resolveAxisNameOverlap;
	}
	AxisBuilderSharedContext$1.prototype.ensureRecord = function(axisModel) {
		var dim = axisModel.axis.dim;
		var idx = axisModel.componentIndex;
		var recordMap = this.recordMap;
		var records = recordMap[dim] || (recordMap[dim] = []);
		return records[idx] || (records[idx] = { ready: {} });
	};
	return AxisBuilderSharedContext$1;
}();
/**
* [CAUTION]
*  1. The call of this function must be after axisLabel overlap handlings
*     (such as `hideOverlap`, `fixMinMaxLabelShow`) and after transform calculating.
*  2. Can be called multiple times and should be idempotent.
*/
function resetOverlapRecordToShared(cfg, shared, axisModel, labelLayoutList) {
	var axis = axisModel.axis;
	var record = shared.ensureRecord(axisModel);
	var labelInfoList = [];
	var stOccupiedRect;
	var useStOccupiedRect = hasAxisName(cfg.axisName) && isNameLocationCenter(cfg.nameLocation);
	each(labelLayoutList, function(layout$3) {
		var layoutInfo = ensureLabelLayoutWithGeometry(layout$3);
		if (!layoutInfo || layoutInfo.label.ignore) return;
		labelInfoList.push(layoutInfo);
		var transGroup = record.transGroup;
		if (useStOccupiedRect) {
			transGroup.transform ? invert(_stTransTmp, transGroup.transform) : identity(_stTransTmp);
			if (layoutInfo.transform) mul(_stTransTmp, _stTransTmp, layoutInfo.transform);
			BoundingRect_default.copy(_stLabelRectTmp, layoutInfo.localRect);
			_stLabelRectTmp.applyTransform(_stTransTmp);
			stOccupiedRect ? stOccupiedRect.union(_stLabelRectTmp) : BoundingRect_default.copy(stOccupiedRect = new BoundingRect_default(0, 0, 0, 0), _stLabelRectTmp);
		}
	});
	var sortByDim = Math.abs(record.dirVec.x) > .1 ? "x" : "y";
	var sortByValue = record.transGroup[sortByDim];
	labelInfoList.sort(function(info1, info2) {
		return Math.abs(info1.label[sortByDim] - sortByValue) - Math.abs(info2.label[sortByDim] - sortByValue);
	});
	if (useStOccupiedRect && stOccupiedRect) {
		var extent = axis.getExtent();
		var axisLineX = Math.min(extent[0], extent[1]);
		var axisLineWidth = Math.max(extent[0], extent[1]) - axisLineX;
		stOccupiedRect.union(new BoundingRect_default(axisLineX, 0, axisLineWidth, 1));
	}
	record.stOccupiedRect = stOccupiedRect;
	record.labelInfoList = labelInfoList;
}
var _stTransTmp = create$2();
var _stLabelRectTmp = new BoundingRect_default(0, 0, 0, 0);
/**
* The default resolver does not involve other axes within the same coordinate system.
*/
var resolveAxisNameOverlapDefault = function(cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord) {
	if (isNameLocationCenter(cfg.nameLocation)) {
		var stOccupiedRect = thisRecord.stOccupiedRect;
		if (stOccupiedRect) moveIfOverlap(computeLabelGeometry2({}, stOccupiedRect, thisRecord.transGroup.transform), nameLayoutInfo, nameMoveDirVec);
	} else moveIfOverlapByLinearLabels(thisRecord.labelInfoList, thisRecord.dirVec, nameLayoutInfo, nameMoveDirVec);
};
function moveIfOverlap(basedLayoutInfo, movableLayoutInfo, moveDirVec) {
	var mtv = new Point_default();
	if (labelIntersect(basedLayoutInfo, movableLayoutInfo, mtv, {
		direction: Math.atan2(moveDirVec.y, moveDirVec.x),
		bidirectional: false,
		touchThreshold: .05
	})) labelLayoutApplyTranslation(movableLayoutInfo, mtv);
}
function moveIfOverlapByLinearLabels(baseLayoutInfoList, baseDirVec, movableLayoutInfo, moveDirVec) {
	var sameDir = Point_default.dot(moveDirVec, baseDirVec) >= 0;
	for (var idx = 0, len$1 = baseLayoutInfoList.length; idx < len$1; idx++) {
		var labelInfo = baseLayoutInfoList[sameDir ? idx : len$1 - 1 - idx];
		if (!labelInfo.label.ignore) moveIfOverlap(labelInfo, movableLayoutInfo, moveDirVec);
	}
}
/**
* @caution
* - Ensure it is called after the data processing stage finished.
* - It might be called before `CahrtView#render`, sush as called at `CoordinateSystem#update`,
*  thus ensure the result the same whenever it is called.
*
* A builder for a straight-line axis.
*
* A final axis is translated and rotated from a "standard axis".
* So opt.position and opt.rotation is required.
*
* A "standard axis" is the axis [0,0]-->[abs(axisExtent[1]-axisExtent[0]),0]
* for example: [0,0]-->[50,0]
*/
var AxisBuilder = function() {
	/**
	* [CAUTION]: axisModel.axis.extent/scale must be ready to use.
	*/
	function AxisBuilder$1(axisModel, api, opt, shared) {
		this.group = new Group_default();
		this._axisModel = axisModel;
		this._api = api;
		this._local = {};
		this._shared = shared || new AxisBuilderSharedContext(resolveAxisNameOverlapDefault);
		this._resetCfgDetermined(opt);
	}
	/**
	* Regarding axis label related configurations, only the change of label.x/y is supported; other
	* changes are not necessary and not performant. To be specific, only `axis.position`
	* (and consequently `labelOffset`) and `axis.extent` can be changed, and assume everything in
	* `axisModel` are not changed.
	* Axis line related configurations can be changed since this method can only be called
	* before they are created.
	*/
	AxisBuilder$1.prototype.updateCfg = function(opt) {
		var ready = this._shared.ensureRecord(this._axisModel).ready;
		assert(!ready.axisLine && !ready.axisTickLabelDetermine);
		ready.axisName = ready.axisTickLabelEstimate = false;
		var raw = this._cfg.raw;
		raw.position = opt.position;
		raw.labelOffset = opt.labelOffset;
		this._resetCfgDetermined(raw);
	};
	/**
	* [CAUTION] For debug usage. Never change it outside!
	*/
	AxisBuilder$1.prototype.__getRawCfg = function() {
		return this._cfg.raw;
	};
	AxisBuilder$1.prototype._resetCfgDetermined = function(raw) {
		var axisModel = this._axisModel;
		var axisModelDefaultOption = axisModel.getDefaultOption ? axisModel.getDefaultOption() : {};
		var axisName = retrieve2(raw.axisName, axisModel.get("name"));
		var nameMoveOverlapOption = axisModel.get("nameMoveOverlap");
		if (nameMoveOverlapOption == null || nameMoveOverlapOption === "auto") nameMoveOverlapOption = retrieve2(raw.defaultNameMoveOverlap, true);
		var cfg = {
			raw,
			position: raw.position,
			rotation: raw.rotation,
			nameDirection: retrieve2(raw.nameDirection, 1),
			tickDirection: retrieve2(raw.tickDirection, 1),
			labelDirection: retrieve2(raw.labelDirection, 1),
			labelOffset: retrieve2(raw.labelOffset, 0),
			silent: retrieve2(raw.silent, true),
			axisName,
			nameLocation: retrieve3(axisModel.get("nameLocation"), axisModelDefaultOption.nameLocation, "end"),
			shouldNameMoveOverlap: hasAxisName(axisName) && nameMoveOverlapOption,
			optionHideOverlap: axisModel.get(["axisLabel", "hideOverlap"]),
			showMinorTicks: axisModel.get(["minorTick", "show"])
		};
		assert(cfg.position != null);
		assert(cfg.rotation != null);
		this._cfg = cfg;
		var transformGroup = new Group_default({
			x: cfg.position[0],
			y: cfg.position[1],
			rotation: cfg.rotation
		});
		transformGroup.updateTransform();
		this._transformGroup = transformGroup;
		var record = this._shared.ensureRecord(axisModel);
		record.transGroup = this._transformGroup;
		record.dirVec = new Point_default(Math.cos(-cfg.rotation), Math.sin(-cfg.rotation));
	};
	AxisBuilder$1.prototype.build = function(axisPartNameMap, extraParams) {
		var _this = this;
		if (!axisPartNameMap) axisPartNameMap = {
			axisLine: true,
			axisTickLabelEstimate: false,
			axisTickLabelDetermine: true,
			axisName: true
		};
		each(AXIS_BUILDER_AXIS_PART_NAMES, function(partName) {
			if (axisPartNameMap[partName]) builders[partName](_this._cfg, _this._local, _this._shared, _this._axisModel, _this.group, _this._transformGroup, _this._api, extraParams || {});
		});
		return this;
	};
	/**
	* Currently only get text align/verticalAlign by rotation.
	* NO `position` is involved, otherwise it have to be performed for each `updateAxisLabelChangableProps`.
	*/
	AxisBuilder$1.innerTextLayout = function(axisRotation, textRotation, direction) {
		var rotationDiff = remRadian(textRotation - axisRotation);
		var textAlign;
		var textVerticalAlign;
		if (isRadianAroundZero(rotationDiff)) {
			textVerticalAlign = direction > 0 ? "top" : "bottom";
			textAlign = "center";
		} else if (isRadianAroundZero(rotationDiff - PI$3)) {
			textVerticalAlign = direction > 0 ? "bottom" : "top";
			textAlign = "center";
		} else {
			textVerticalAlign = "middle";
			if (rotationDiff > 0 && rotationDiff < PI$3) textAlign = direction > 0 ? "right" : "left";
			else textAlign = direction > 0 ? "left" : "right";
		}
		return {
			rotation: rotationDiff,
			textAlign,
			textVerticalAlign
		};
	};
	AxisBuilder$1.makeAxisEventDataBase = function(axisModel) {
		var eventData = {
			componentType: axisModel.mainType,
			componentIndex: axisModel.componentIndex
		};
		eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
		return eventData;
	};
	AxisBuilder$1.isLabelSilent = function(axisModel) {
		var tooltipOpt = axisModel.get("tooltip");
		return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
	};
	return AxisBuilder$1;
}();
var AXIS_BUILDER_AXIS_PART_NAMES = [
	"axisLine",
	"axisTickLabelEstimate",
	"axisTickLabelDetermine",
	"axisName"
];
var builders = {
	axisLine: function(cfg, local, shared, axisModel, group, transformGroup, api) {
		var ready = shared.ensureRecord(axisModel).ready;
		assert(!ready.axisLine);
		ready.axisLine = true;
		var shown = axisModel.get(["axisLine", "show"]);
		if (shown === "auto") {
			shown = true;
			if (cfg.raw.axisLineAutoShow != null) shown = !!cfg.raw.axisLineAutoShow;
		}
		if (!shown) return;
		var extent = axisModel.axis.getExtent();
		var matrix = transformGroup.transform;
		var pt1$1 = [extent[0], 0];
		var pt2$1 = [extent[1], 0];
		var inverse = pt1$1[0] > pt2$1[0];
		if (matrix) {
			applyTransform(pt1$1, pt1$1, matrix);
			applyTransform(pt2$1, pt2$1, matrix);
		}
		var lineStyle = extend({ lineCap: "round" }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
		var pathBaseProp = {
			strokeContainThreshold: cfg.raw.strokeContainThreshold || 5,
			silent: true,
			z2: 1,
			style: lineStyle
		};
		if (axisModel.get(["axisLine", "breakLine"]) && axisModel.axis.scale.hasBreaks()) getAxisBreakHelper().buildAxisBreakLine(axisModel, group, transformGroup, pathBaseProp);
		else {
			var line = new Line_default(extend({ shape: {
				x1: pt1$1[0],
				y1: pt1$1[1],
				x2: pt2$1[0],
				y2: pt2$1[1]
			} }, pathBaseProp));
			subPixelOptimizeLine$1(line.shape, line.style.lineWidth);
			line.anid = "line";
			group.add(line);
		}
		var arrows = axisModel.get(["axisLine", "symbol"]);
		if (arrows != null) {
			var arrowSize = axisModel.get(["axisLine", "symbolSize"]);
			if (isString(arrows)) arrows = [arrows, arrows];
			if (isString(arrowSize) || isNumber(arrowSize)) arrowSize = [arrowSize, arrowSize];
			var arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
			var symbolWidth_1 = arrowSize[0];
			var symbolHeight_1 = arrowSize[1];
			each([{
				rotate: cfg.rotation + Math.PI / 2,
				offset: arrowOffset[0],
				r: 0
			}, {
				rotate: cfg.rotation - Math.PI / 2,
				offset: arrowOffset[1],
				r: Math.sqrt((pt1$1[0] - pt2$1[0]) * (pt1$1[0] - pt2$1[0]) + (pt1$1[1] - pt2$1[1]) * (pt1$1[1] - pt2$1[1]))
			}], function(point, index) {
				if (arrows[index] !== "none" && arrows[index] != null) {
					var symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);
					var r = point.r + point.offset;
					var pt = inverse ? pt2$1 : pt1$1;
					symbol.attr({
						rotation: point.rotate,
						x: pt[0] + r * Math.cos(cfg.rotation),
						y: pt[1] - r * Math.sin(cfg.rotation),
						silent: true,
						z2: 11
					});
					group.add(symbol);
				}
			});
		}
	},
	axisTickLabelEstimate: function(cfg, local, shared, axisModel, group, transformGroup, api, extraParams) {
		var ready = shared.ensureRecord(axisModel).ready;
		assert(!ready.axisTickLabelDetermine);
		ready.axisTickLabelEstimate = true;
		if (dealLastTickLabelResultReusable(local, group, extraParams)) layOutAxisTickLabel(cfg, local, shared, axisModel, group, transformGroup, api, AxisTickLabelComputingKind.estimate);
	},
	axisTickLabelDetermine: function(cfg, local, shared, axisModel, group, transformGroup, api, extraParams) {
		var ready = shared.ensureRecord(axisModel).ready;
		ready.axisTickLabelDetermine = true;
		if (dealLastTickLabelResultReusable(local, group, extraParams)) layOutAxisTickLabel(cfg, local, shared, axisModel, group, transformGroup, api, AxisTickLabelComputingKind.determine);
		var ticksEls = buildAxisMajorTicks(cfg, group, transformGroup, axisModel);
		syncLabelIgnoreToMajorTicks(cfg, local.labelLayoutList, ticksEls);
		buildAxisMinorTicks(cfg, group, transformGroup, axisModel, cfg.tickDirection);
	},
	axisName: function(cfg, local, shared, axisModel, group, transformGroup, api, extraParams) {
		var sharedRecord = shared.ensureRecord(axisModel);
		var ready = sharedRecord.ready;
		assert(ready.axisTickLabelEstimate || ready.axisTickLabelDetermine);
		ready.axisName = true;
		if (local.nameEl) {
			group.remove(local.nameEl);
			local.nameEl = sharedRecord.nameLayout = sharedRecord.nameLocation = null;
		}
		var name = cfg.axisName;
		if (!hasAxisName(name)) return;
		var nameLocation = cfg.nameLocation;
		var nameDirection = cfg.nameDirection;
		var textStyleModel = axisModel.getModel("nameTextStyle");
		var gap = axisModel.get("nameGap") || 0;
		var extent = axisModel.axis.getExtent();
		var gapStartEndSignal = axisModel.axis.inverse ? -1 : 1;
		var pos = new Point_default(0, 0);
		var nameMoveDirVec = new Point_default(0, 0);
		if (nameLocation === "start") {
			pos.x = extent[0] - gapStartEndSignal * gap;
			nameMoveDirVec.x = -gapStartEndSignal;
		} else if (nameLocation === "end") {
			pos.x = extent[1] + gapStartEndSignal * gap;
			nameMoveDirVec.x = gapStartEndSignal;
		} else {
			pos.x = (extent[0] + extent[1]) / 2;
			pos.y = cfg.labelOffset + nameDirection * gap;
			nameMoveDirVec.y = nameDirection;
		}
		var mt = create$2();
		nameMoveDirVec.transform(rotate(mt, mt, cfg.rotation));
		var nameRotation = axisModel.get("nameRotate");
		if (nameRotation != null) nameRotation = nameRotation * PI$3 / 180;
		var labelLayout$1;
		var axisNameAvailableWidth;
		if (isNameLocationCenter(nameLocation)) labelLayout$1 = AxisBuilder.innerTextLayout(cfg.rotation, nameRotation != null ? nameRotation : cfg.rotation, nameDirection);
		else {
			labelLayout$1 = endTextLayout(cfg.rotation, nameLocation, nameRotation || 0, extent);
			axisNameAvailableWidth = cfg.raw.axisNameAvailableWidth;
			if (axisNameAvailableWidth != null) {
				axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout$1.rotation));
				!isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
			}
		}
		var textFont = textStyleModel.getFont();
		var truncateOpt = axisModel.get("nameTruncate", true) || {};
		var ellipsis = truncateOpt.ellipsis;
		var maxWidth = retrieve(cfg.raw.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
		var nameMarginLevel = extraParams.nameMarginLevel || 0;
		var textEl = new Text_default({
			x: pos.x,
			y: pos.y,
			rotation: labelLayout$1.rotation,
			silent: AxisBuilder.isLabelSilent(axisModel),
			style: createTextStyle(textStyleModel, {
				text: name,
				font: textFont,
				overflow: "truncate",
				width: maxWidth,
				ellipsis,
				fill: textStyleModel.getTextColor() || axisModel.get([
					"axisLine",
					"lineStyle",
					"color"
				]),
				align: textStyleModel.get("align") || labelLayout$1.textAlign,
				verticalAlign: textStyleModel.get("verticalAlign") || labelLayout$1.textVerticalAlign
			}),
			z2: 1
		});
		setTooltipConfig({
			el: textEl,
			componentModel: axisModel,
			itemName: name
		});
		textEl.__fullText = name;
		textEl.anid = "name";
		if (axisModel.get("triggerEvent")) {
			var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
			eventData.targetType = "axisName";
			eventData.name = name;
			getECData(textEl).eventData = eventData;
		}
		transformGroup.add(textEl);
		textEl.updateTransform();
		local.nameEl = textEl;
		var nameLayout = sharedRecord.nameLayout = ensureLabelLayoutWithGeometry({
			label: textEl,
			priority: textEl.z2,
			defaultAttr: { ignore: textEl.ignore },
			marginDefault: isNameLocationCenter(nameLocation) ? DEFAULT_CENTER_NAME_MARGIN_LEVELS[nameMarginLevel] : DEFAULT_ENDS_NAME_MARGIN_LEVELS[nameMarginLevel]
		});
		sharedRecord.nameLocation = nameLocation;
		group.add(textEl);
		textEl.decomposeTransform();
		if (cfg.shouldNameMoveOverlap && nameLayout) {
			var record = shared.ensureRecord(axisModel);
			assert(record.labelInfoList);
			shared.resolveAxisNameOverlap(cfg, shared, axisModel, nameLayout, nameMoveDirVec, record);
		}
	}
};
function layOutAxisTickLabel(cfg, local, shared, axisModel, group, transformGroup, api, kind) {
	if (!axisLabelBuildResultExists(local)) buildAxisLabel(cfg, local, group, kind, axisModel, api);
	var labelLayoutList = local.labelLayoutList;
	updateAxisLabelChangableProps(cfg, axisModel, labelLayoutList, transformGroup);
	adjustBreakLabels(axisModel, cfg.rotation, labelLayoutList);
	var optionHideOverlap = cfg.optionHideOverlap;
	fixMinMaxLabelShow(axisModel, labelLayoutList, optionHideOverlap);
	if (optionHideOverlap) hideOverlap(filter(labelLayoutList, function(layout$3) {
		return layout$3 && !layout$3.label.ignore;
	}));
	resetOverlapRecordToShared(cfg, shared, axisModel, labelLayoutList);
}
function endTextLayout(rotation, textPosition, textRotate, extent) {
	var rotationDiff = remRadian(textRotate - rotation);
	var textAlign;
	var textVerticalAlign;
	var inverse = extent[0] > extent[1];
	var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
	if (isRadianAroundZero(rotationDiff - PI$3 / 2)) {
		textVerticalAlign = onLeft ? "bottom" : "top";
		textAlign = "center";
	} else if (isRadianAroundZero(rotationDiff - PI$3 * 1.5)) {
		textVerticalAlign = onLeft ? "top" : "bottom";
		textAlign = "center";
	} else {
		textVerticalAlign = "middle";
		if (rotationDiff < PI$3 * 1.5 && rotationDiff > PI$3 / 2) textAlign = onLeft ? "left" : "right";
		else textAlign = onLeft ? "right" : "left";
	}
	return {
		rotation: rotationDiff,
		textAlign,
		textVerticalAlign
	};
}
/**
* Assume `labelLayoutList` has no `label.ignore: true`.
* Assume `labelLayoutList` have been sorted by value ascending order.
*/
function fixMinMaxLabelShow(axisModel, labelLayoutList, optionHideOverlap) {
	if (shouldShowAllLabels(axisModel.axis)) return;
	function deal(showMinMaxLabel, outmostLabelIdx, innerLabelIdx) {
		var outmostLabelLayout = ensureLabelLayoutWithGeometry(labelLayoutList[outmostLabelIdx]);
		var innerLabelLayout = ensureLabelLayoutWithGeometry(labelLayoutList[innerLabelIdx]);
		if (!outmostLabelLayout || !innerLabelLayout) return;
		if (showMinMaxLabel === false || outmostLabelLayout.suggestIgnore) {
			ignoreEl(outmostLabelLayout.label);
			return;
		}
		if (innerLabelLayout.suggestIgnore) {
			ignoreEl(innerLabelLayout.label);
			return;
		}
		var touchThreshold = .1;
		if (!optionHideOverlap) {
			var marginForce = [
				0,
				0,
				0,
				0
			];
			outmostLabelLayout = newLabelLayoutWithGeometry({ marginForce }, outmostLabelLayout);
			innerLabelLayout = newLabelLayoutWithGeometry({ marginForce }, innerLabelLayout);
		}
		if (labelIntersect(outmostLabelLayout, innerLabelLayout, null, { touchThreshold })) if (showMinMaxLabel) ignoreEl(innerLabelLayout.label);
		else ignoreEl(outmostLabelLayout.label);
	}
	var showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
	var showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
	var labelsLen = labelLayoutList.length;
	deal(showMinLabel, 0, 1);
	deal(showMaxLabel, labelsLen - 1, labelsLen - 2);
}
function syncLabelIgnoreToMajorTicks(cfg, labelLayoutList, tickEls) {
	if (cfg.showMinorTicks) return;
	each(labelLayoutList, function(labelLayout$1) {
		if (labelLayout$1 && labelLayout$1.label.ignore) for (var idx = 0; idx < tickEls.length; idx++) {
			var tickEl = tickEls[idx];
			var tickInner = getTickInner(tickEl);
			var labelInner$1 = getLabelInner(labelLayout$1.label);
			if (tickInner.tickValue != null && !tickInner.onBand && tickInner.tickValue === labelInner$1.tickValue) {
				ignoreEl(tickEl);
				return;
			}
		}
	});
}
function ignoreEl(el) {
	el && (el.ignore = true);
}
function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
	var tickEls = [];
	var pt1$1 = [];
	var pt2$1 = [];
	for (var i$1 = 0; i$1 < ticksCoords.length; i$1++) {
		var tickCoord = ticksCoords[i$1].coord;
		pt1$1[0] = tickCoord;
		pt1$1[1] = 0;
		pt2$1[0] = tickCoord;
		pt2$1[1] = tickEndCoord;
		if (tickTransform) {
			applyTransform(pt1$1, pt1$1, tickTransform);
			applyTransform(pt2$1, pt2$1, tickTransform);
		}
		var tickEl = new Line_default({
			shape: {
				x1: pt1$1[0],
				y1: pt1$1[1],
				x2: pt2$1[0],
				y2: pt2$1[1]
			},
			style: tickLineStyle,
			z2: 2,
			autoBatch: true,
			silent: true
		});
		subPixelOptimizeLine$1(tickEl.shape, tickEl.style.lineWidth);
		tickEl.anid = anidPrefix + "_" + ticksCoords[i$1].tickValue;
		tickEls.push(tickEl);
		var inner$24 = getTickInner(tickEl);
		inner$24.onBand = !!ticksCoords[i$1].onBand;
		inner$24.tickValue = ticksCoords[i$1].tickValue;
	}
	return tickEls;
}
function buildAxisMajorTicks(cfg, group, transformGroup, axisModel) {
	var axis = axisModel.axis;
	var tickModel = axisModel.getModel("axisTick");
	var shown = tickModel.get("show");
	if (shown === "auto") {
		shown = true;
		if (cfg.raw.axisTickAutoShow != null) shown = !!cfg.raw.axisTickAutoShow;
	}
	if (!shown || axis.scale.isBlank()) return [];
	var lineStyleModel = tickModel.getModel("lineStyle");
	var tickEndCoord = cfg.tickDirection * tickModel.get("length");
	var ticksEls = createTicks(axis.getTicksCoords(), transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), { stroke: axisModel.get([
		"axisLine",
		"lineStyle",
		"color"
	]) }), "ticks");
	for (var i$1 = 0; i$1 < ticksEls.length; i$1++) group.add(ticksEls[i$1]);
	return ticksEls;
}
function buildAxisMinorTicks(cfg, group, transformGroup, axisModel, tickDirection) {
	var axis = axisModel.axis;
	var minorTickModel = axisModel.getModel("minorTick");
	if (!cfg.showMinorTicks || axis.scale.isBlank()) return;
	var minorTicksCoords = axis.getMinorTicksCoords();
	if (!minorTicksCoords.length) return;
	var lineStyleModel = minorTickModel.getModel("lineStyle");
	var tickEndCoord = tickDirection * minorTickModel.get("length");
	var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), { stroke: axisModel.get([
		"axisLine",
		"lineStyle",
		"color"
	]) }));
	for (var i$1 = 0; i$1 < minorTicksCoords.length; i$1++) {
		var minorTicksEls = createTicks(minorTicksCoords[i$1], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i$1);
		for (var k$1 = 0; k$1 < minorTicksEls.length; k$1++) group.add(minorTicksEls[k$1]);
	}
}
function dealLastTickLabelResultReusable(local, group, extraParams) {
	if (axisLabelBuildResultExists(local)) {
		var axisLabelsCreationContext = local.axisLabelsCreationContext;
		assert(local.labelGroup && axisLabelsCreationContext);
		var noPxChangeTryDetermine = axisLabelsCreationContext.out.noPxChangeTryDetermine;
		if (extraParams.noPxChange) {
			var canDetermine = true;
			for (var idx = 0; idx < noPxChangeTryDetermine.length; idx++) canDetermine = canDetermine && noPxChangeTryDetermine[idx]();
			if (canDetermine) return false;
		}
		if (noPxChangeTryDetermine.length) {
			group.remove(local.labelGroup);
			axisLabelBuildResultSet(local, null, null, null);
		}
	}
	return true;
}
function buildAxisLabel(cfg, local, group, kind, axisModel, api) {
	var axis = axisModel.axis;
	var show = retrieve(cfg.raw.axisLabelShow, axisModel.get(["axisLabel", "show"]));
	var labelGroup = new Group_default();
	group.add(labelGroup);
	var axisLabelCreationCtx = createAxisLabelsComputingContext(kind);
	if (!show || axis.scale.isBlank()) {
		axisLabelBuildResultSet(local, [], labelGroup, axisLabelCreationCtx);
		return;
	}
	var labelModel = axisModel.getModel("axisLabel");
	var labels = axis.getViewLabels(axisLabelCreationCtx);
	var labelRotation = (retrieve(cfg.raw.labelRotate, labelModel.get("rotate")) || 0) * PI$3 / 180;
	var labelLayout$1 = AxisBuilder.innerTextLayout(cfg.rotation, labelRotation, cfg.labelDirection);
	var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
	var labelEls = [];
	var triggerEvent = axisModel.get("triggerEvent");
	var z2Min = Infinity;
	var z2Max = -Infinity;
	each(labels, function(labelItem, index) {
		var _a$1;
		var tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
		var formattedLabel = labelItem.formattedLabel;
		var rawLabel = labelItem.rawLabel;
		var itemLabelModel = labelModel;
		if (rawCategoryData && rawCategoryData[tickValue]) {
			var rawCategoryItem = rawCategoryData[tickValue];
			if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) itemLabelModel = new Model_default(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
		}
		var textColor = itemLabelModel.getTextColor() || axisModel.get([
			"axisLine",
			"lineStyle",
			"color"
		]);
		var align = itemLabelModel.getShallow("align", true) || labelLayout$1.textAlign;
		var alignMin = retrieve2(itemLabelModel.getShallow("alignMinLabel", true), align);
		var alignMax = retrieve2(itemLabelModel.getShallow("alignMaxLabel", true), align);
		var verticalAlign = itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout$1.textVerticalAlign;
		var verticalAlignMin = retrieve2(itemLabelModel.getShallow("verticalAlignMinLabel", true), verticalAlign);
		var verticalAlignMax = retrieve2(itemLabelModel.getShallow("verticalAlignMaxLabel", true), verticalAlign);
		var z2 = 10 + (((_a$1 = labelItem.time) === null || _a$1 === void 0 ? void 0 : _a$1.level) || 0);
		z2Min = Math.min(z2Min, z2);
		z2Max = Math.max(z2Max, z2);
		var textEl = new Text_default({
			x: 0,
			y: 0,
			rotation: 0,
			silent: AxisBuilder.isLabelSilent(axisModel),
			z2,
			style: createTextStyle(itemLabelModel, {
				text: formattedLabel,
				align: index === 0 ? alignMin : index === labels.length - 1 ? alignMax : align,
				verticalAlign: index === 0 ? verticalAlignMin : index === labels.length - 1 ? verticalAlignMax : verticalAlign,
				fill: isFunction(textColor) ? textColor(axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue, index) : textColor
			})
		});
		textEl.anid = "label_" + tickValue;
		var inner$24 = getLabelInner(textEl);
		inner$24["break"] = labelItem["break"];
		inner$24.tickValue = tickValue;
		inner$24.layoutRotation = labelLayout$1.rotation;
		setTooltipConfig({
			el: textEl,
			componentModel: axisModel,
			itemName: formattedLabel,
			formatterParamsExtra: {
				isTruncated: function() {
					return textEl.isTruncated;
				},
				value: rawLabel,
				tickIndex: index
			}
		});
		if (triggerEvent) {
			var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
			eventData.targetType = "axisLabel";
			eventData.value = rawLabel;
			eventData.tickIndex = index;
			if (labelItem["break"]) eventData["break"] = {
				start: labelItem["break"].parsedBreak.vmin,
				end: labelItem["break"].parsedBreak.vmax
			};
			if (axis.type === "category") eventData.dataIndex = tickValue;
			getECData(textEl).eventData = eventData;
			if (labelItem["break"]) addBreakEventHandler(axisModel, api, textEl, labelItem["break"]);
		}
		labelEls.push(textEl);
		labelGroup.add(textEl);
	});
	axisLabelBuildResultSet(local, map(labelEls, function(label) {
		return {
			label,
			priority: getLabelInner(label)["break"] ? label.z2 + (z2Max - z2Min + 1) : label.z2,
			defaultAttr: { ignore: label.ignore }
		};
	}), labelGroup, axisLabelCreationCtx);
}
function axisLabelBuildResultExists(local) {
	return !!local.labelLayoutList;
}
function axisLabelBuildResultSet(local, labelLayoutList, labelGroup, axisLabelsCreationContext) {
	local.labelLayoutList = labelLayoutList;
	local.labelGroup = labelGroup;
	local.axisLabelsCreationContext = axisLabelsCreationContext;
}
function updateAxisLabelChangableProps(cfg, axisModel, labelLayoutList, transformGroup) {
	var labelMargin = axisModel.get(["axisLabel", "margin"]);
	each(labelLayoutList, function(layout$3, idx) {
		var geometry = ensureLabelLayoutWithGeometry(layout$3);
		if (!geometry) return;
		var labelEl = geometry.label;
		var inner$24 = getLabelInner(labelEl);
		geometry.suggestIgnore = labelEl.ignore;
		labelEl.ignore = false;
		copyTransform(_tmpLayoutEl, _tmpLayoutElReset);
		_tmpLayoutEl.x = axisModel.axis.dataToCoord(inner$24.tickValue);
		_tmpLayoutEl.y = cfg.labelOffset + cfg.labelDirection * labelMargin;
		_tmpLayoutEl.rotation = inner$24.layoutRotation;
		transformGroup.add(_tmpLayoutEl);
		_tmpLayoutEl.updateTransform();
		transformGroup.remove(_tmpLayoutEl);
		_tmpLayoutEl.decomposeTransform();
		copyTransform(labelEl, _tmpLayoutEl);
		labelEl.markRedraw();
		setLabelLayoutDirty(geometry, true);
		ensureLabelLayoutWithGeometry(geometry);
	});
}
var _tmpLayoutEl = new Rect_default();
var _tmpLayoutElReset = new Rect_default();
function hasAxisName(axisName) {
	return !!axisName;
}
function addBreakEventHandler(axisModel, api, textEl, visualBreak) {
	textEl.on("click", function(params) {
		var payload = {
			type: AXIS_BREAK_EXPAND_ACTION_TYPE,
			breaks: [{
				start: visualBreak.parsedBreak.breakOption.start,
				end: visualBreak.parsedBreak.breakOption.end
			}]
		};
		payload[axisModel.axis.dim + "AxisIndex"] = axisModel.componentIndex;
		api.dispatchAction(payload);
	});
}
function adjustBreakLabels(axisModel, axisRotation, labelLayoutList) {
	var scaleBreakHelper = getScaleBreakHelper();
	if (!scaleBreakHelper) return;
	var breakLabelIndexPairs = scaleBreakHelper.retrieveAxisBreakPairs(labelLayoutList, function(layoutInfo) {
		return layoutInfo && getLabelInner(layoutInfo.label)["break"];
	}, true);
	var moveOverlap = axisModel.get(["breakLabelLayout", "moveOverlap"], true);
	if (moveOverlap === true || moveOverlap === "auto") each(breakLabelIndexPairs, function(idxPair) {
		getAxisBreakHelper().adjustBreakLabelPair(axisModel.axis.inverse, axisRotation, [ensureLabelLayoutWithGeometry(labelLayoutList[idxPair[0]]), ensureLabelLayoutWithGeometry(labelLayoutList[idxPair[1]])]);
	});
}
var AxisBuilder_default = AxisBuilder;

//#endregion
//#region node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js
/**
* [__CAUTION__]
*  MUST guarantee: if only the input `rect` and `axis.extent` changed,
*  only `layout.position` changes.
*  This character is replied on `grid.contain` calculation in `AxisBuilder`.
*  @see updateCartesianAxisViewCommonPartBuilder
*
* Can only be called after coordinate system creation stage.
* (Can be called before coordinate system update stage).
*/
function layout$2(rect, axisModel, opt) {
	opt = opt || {};
	var axis = axisModel.axis;
	var layout$3 = {};
	var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
	var rawAxisPosition = axis.position;
	var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
	var axisDim = axis.dim;
	var rectBound = [
		rect.x,
		rect.x + rect.width,
		rect.y,
		rect.y + rect.height
	];
	var idx = {
		left: 0,
		right: 1,
		top: 0,
		bottom: 1,
		onZero: 2
	};
	var axisOffset = axisModel.get("offset") || 0;
	var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
	if (otherAxisOnZeroOf) {
		var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
		posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
	}
	layout$3.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
	layout$3.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
	layout$3.labelDirection = layout$3.tickDirection = layout$3.nameDirection = {
		top: -1,
		bottom: 1,
		left: -1,
		right: 1
	}[rawAxisPosition];
	layout$3.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
	if (axisModel.get(["axisTick", "inside"])) layout$3.tickDirection = -layout$3.tickDirection;
	if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) layout$3.labelDirection = -layout$3.labelDirection;
	var labelRotate = axisModel.get(["axisLabel", "rotate"]);
	layout$3.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
	layout$3.z2 = 1;
	return layout$3;
}
/**
* Note: If pie (or other similar series) use cartesian2d, here
*  option `seriesModel.get('coordinateSystem') === 'cartesian2d'`
*  and `seriesModel.coordinateSystem !== cartesian2dCoordSysInstance`
*  and `seriesModel.boxCoordinateSystem === cartesian2dCoordSysInstance`,
*  the logic below is probably wrong, therefore skip it temporarily.
*/
function isCartesian2DInjectedAsDataCoordSys(seriesModel) {
	return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function findAxisModels(seriesModel) {
	var axisModelMap = {
		xAxisModel: null,
		yAxisModel: null
	};
	each(axisModelMap, function(v, key$1) {
		var axisType = key$1.replace(/Model$/, "");
		var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
		if (!axisModel) throw new Error(axisType + " \"" + retrieve3(seriesModel.get(axisType + "Index"), seriesModel.get(axisType + "Id"), 0) + "\" not found");
		axisModelMap[key$1] = axisModel;
	});
	return axisModelMap;
}
function createCartesianAxisViewCommonPartBuilder(gridRect, cartesians, axisModel, api, ctx, defaultNameMoveOverlap) {
	var layoutResult = layout$2(gridRect, axisModel);
	var axisLineAutoShow = false;
	var axisTickAutoShow = false;
	for (var i$1 = 0; i$1 < cartesians.length; i$1++) if (isIntervalOrLogScale(cartesians[i$1].getOtherAxis(axisModel.axis).scale)) {
		axisLineAutoShow = axisTickAutoShow = true;
		if (axisModel.axis.type === "category" && axisModel.axis.onBand) axisTickAutoShow = false;
	}
	layoutResult.axisLineAutoShow = axisLineAutoShow;
	layoutResult.axisTickAutoShow = axisTickAutoShow;
	layoutResult.defaultNameMoveOverlap = defaultNameMoveOverlap;
	return new AxisBuilder_default(axisModel, api, layoutResult, ctx);
}
function updateCartesianAxisViewCommonPartBuilder(axisBuilder, gridRect, axisModel) {
	var newRaw = layout$2(gridRect, axisModel);
	var oldRaw_1 = axisBuilder.__getRawCfg();
	each(keys(newRaw), function(prop) {
		if (prop !== "position" && prop !== "labelOffset") assert(newRaw[prop] === oldRaw_1[prop]);
	});
	axisBuilder.updateCfg(newRaw);
}

//#endregion
//#region node_modules/echarts/lib/coord/axisAlignTicks.js
function alignScaleTicks(scale$3, axisModel, alignToScale) {
	var _a$1;
	var intervalScaleProto = Interval_default.prototype;
	var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);
	var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, { expandToNicedExtent: true });
	var alignToSplitNumber = alignToTicks.length - 1;
	var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);
	var scaleExtent = getScaleExtent(scale$3, axisModel);
	var rawExtent = scaleExtent.extent;
	var isMinFixed = scaleExtent.fixMin;
	var isMaxFixed = scaleExtent.fixMax;
	if (scale$3.type === "log") rawExtent = logTransform(scale$3.base, rawExtent, true);
	scale$3.setBreaksFromOption(retrieveAxisBreaksOption(axisModel));
	scale$3.setExtent(rawExtent[0], rawExtent[1]);
	scale$3.calcNiceExtent({
		splitNumber: alignToSplitNumber,
		fixMin: isMinFixed,
		fixMax: isMaxFixed
	});
	var extent = intervalScaleProto.getExtent.call(scale$3);
	if (isMinFixed) rawExtent[0] = extent[0];
	if (isMaxFixed) rawExtent[1] = extent[1];
	var interval = intervalScaleProto.getInterval.call(scale$3);
	var min$2 = rawExtent[0];
	var max$2 = rawExtent[1];
	if (isMinFixed && isMaxFixed) interval = (max$2 - min$2) / alignToSplitNumber;
	else if (isMinFixed) {
		max$2 = rawExtent[0] + interval * alignToSplitNumber;
		while (max$2 < rawExtent[1] && isFinite(max$2) && isFinite(rawExtent[1])) {
			interval = increaseInterval(interval);
			max$2 = rawExtent[0] + interval * alignToSplitNumber;
		}
	} else if (isMaxFixed) {
		min$2 = rawExtent[1] - interval * alignToSplitNumber;
		while (min$2 > rawExtent[0] && isFinite(min$2) && isFinite(rawExtent[0])) {
			interval = increaseInterval(interval);
			min$2 = rawExtent[1] - interval * alignToSplitNumber;
		}
	} else {
		if (scale$3.getTicks().length - 1 > alignToSplitNumber) interval = increaseInterval(interval);
		var range = interval * alignToSplitNumber;
		max$2 = Math.ceil(rawExtent[1] / interval) * interval;
		min$2 = round(max$2 - range);
		if (min$2 < 0 && rawExtent[0] >= 0) {
			min$2 = 0;
			max$2 = round(range);
		} else if (max$2 > 0 && rawExtent[1] <= 0) {
			max$2 = 0;
			min$2 = -round(range);
		}
	}
	var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
	var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
	intervalScaleProto.setExtent.call(scale$3, min$2 + interval * t0, max$2 + interval * t1);
	intervalScaleProto.setInterval.call(scale$3, interval);
	if (t0 || t1) intervalScaleProto.setNiceExtent.call(scale$3, min$2 + interval, max$2 - interval);
	var ticks = intervalScaleProto.getTicks.call(scale$3);
	if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) warn("The ticks may be not readable when set min: " + axisModel.get("min") + ", max: " + axisModel.get("max") + (" and alignTicks: true. (" + ((_a$1 = axisModel.axis) === null || _a$1 === void 0 ? void 0 : _a$1.dim) + "AxisIndex: " + axisModel.componentIndex + ")"), true);
}

//#endregion
//#region node_modules/echarts/lib/coord/cartesian/Grid.js
var XY_TO_MARGIN_IDX = [[3, 1], [0, 2]];
var Grid = function() {
	function Grid$1(gridModel, ecModel, api) {
		this.type = "grid";
		this._coordsMap = {};
		this._coordsList = [];
		this._axesMap = {};
		this._axesList = [];
		this.axisPointerEnabled = true;
		this.dimensions = cartesian2DDimensions;
		this._initCartesian(gridModel, ecModel, api);
		this.model = gridModel;
	}
	Grid$1.prototype.getRect = function() {
		return this._rect;
	};
	Grid$1.prototype.update = function(ecModel, api) {
		var axesMap = this._axesMap;
		this._updateScale(ecModel, this.model);
		function updateAxisTicks(axes) {
			var alignTo;
			var axesIndices = keys(axes);
			var len$1 = axesIndices.length;
			if (!len$1) return;
			var axisNeedsAlign = [];
			for (var i$1 = len$1 - 1; i$1 >= 0; i$1--) {
				var axis = axes[+axesIndices[i$1]];
				var model = axis.model;
				var scale$3 = axis.scale;
				if (isIntervalOrLogScale(scale$3) && model.get("alignTicks") && model.get("interval") == null) axisNeedsAlign.push(axis);
				else {
					niceScaleExtent(scale$3, model);
					if (isIntervalOrLogScale(scale$3)) alignTo = axis;
				}
			}
			if (axisNeedsAlign.length) {
				if (!alignTo) {
					alignTo = axisNeedsAlign.pop();
					niceScaleExtent(alignTo.scale, alignTo.model);
				}
				each(axisNeedsAlign, function(axis$1) {
					alignScaleTicks(axis$1.scale, axis$1.model, alignTo.scale);
				});
			}
		}
		updateAxisTicks(axesMap.x);
		updateAxisTicks(axesMap.y);
		var onZeroRecords = {};
		each(axesMap.x, function(xAxis) {
			fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
		});
		each(axesMap.y, function(yAxis) {
			fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
		});
		this.resize(this.model, api);
	};
	/**
	* Resize the grid.
	*
	* [NOTE]
	* If both "grid.containLabel/grid.contain" and pixel-required-data-processing (such as, "dataSampling")
	* exist, circular dependency occurs in logic.
	* The final compromised sequence is:
	*  1. Calculate "axis.extent" (pixel extent) and AffineTransform based on only "grid layout options".
	*      Not accurate if "grid.containLabel/grid.contain" is required, but it is a compromise to avoid
	*      circular dependency.
	*  2. Perform "series data processing" (where "dataSampling" requires "axis.extent").
	*  3. Calculate "scale.extent" (data extent) based on "processed series data".
	*  4. Modify "axis.extent" for "grid.containLabel/grid.contain":
	*      4.1. Calculate "axis labels" based on "scale.extent".
	*      4.2. Modify "axis.extent" by the bounding rects of "axis labels and names".
	*/
	Grid$1.prototype.resize = function(gridModel, api, beforeDataProcessing) {
		var layoutRef = createBoxLayoutReference(gridModel, api);
		var gridRect = this._rect = getLayoutRect(gridModel.getBoxLayoutParams(), layoutRef.refContainer);
		var axesMap = this._axesMap;
		var coordsList = this._coordsList;
		var optionContainLabel = gridModel.get("containLabel");
		updateAllAxisExtentTransByGridRect(axesMap, gridRect);
		if (!beforeDataProcessing) {
			var axisBuilderSharedCtx = createAxisBiulders(gridRect, coordsList, axesMap, optionContainLabel, api);
			var noPxChange = void 0;
			if (optionContainLabel) if (legacyLayOutGridByContainLabel) {
				legacyLayOutGridByContainLabel(this._axesList, gridRect);
				updateAllAxisExtentTransByGridRect(axesMap, gridRect);
			} else {
				log("Specified `grid.containLabel` but no `use(LegacyGridContainLabel)`;use `grid.outerBounds` instead.", true);
				noPxChange = layOutGridByOuterBounds(gridRect.clone(), "axisLabel", null, gridRect, axesMap, axisBuilderSharedCtx, layoutRef);
			}
			else {
				var _a$1 = prepareOuterBounds(gridModel, gridRect, layoutRef), outerBoundsRect = _a$1.outerBoundsRect, parsedOuterBoundsContain = _a$1.parsedOuterBoundsContain, outerBoundsClamp = _a$1.outerBoundsClamp;
				if (outerBoundsRect) noPxChange = layOutGridByOuterBounds(outerBoundsRect, parsedOuterBoundsContain, outerBoundsClamp, gridRect, axesMap, axisBuilderSharedCtx, layoutRef);
			}
			createOrUpdateAxesView(gridRect, axesMap, AxisTickLabelComputingKind.determine, null, noPxChange, layoutRef);
		}
		each(this._coordsList, function(coord) {
			coord.calcAffineTransform();
		});
	};
	Grid$1.prototype.getAxis = function(dim, axisIndex) {
		var axesMapOnDim = this._axesMap[dim];
		if (axesMapOnDim != null) return axesMapOnDim[axisIndex || 0];
	};
	Grid$1.prototype.getAxes = function() {
		return this._axesList.slice();
	};
	Grid$1.prototype.getCartesian = function(xAxisIndex, yAxisIndex) {
		if (xAxisIndex != null && yAxisIndex != null) {
			var key$1 = "x" + xAxisIndex + "y" + yAxisIndex;
			return this._coordsMap[key$1];
		}
		if (isObject(xAxisIndex)) {
			yAxisIndex = xAxisIndex.yAxisIndex;
			xAxisIndex = xAxisIndex.xAxisIndex;
		}
		for (var i$1 = 0, coordList = this._coordsList; i$1 < coordList.length; i$1++) if (coordList[i$1].getAxis("x").index === xAxisIndex || coordList[i$1].getAxis("y").index === yAxisIndex) return coordList[i$1];
	};
	Grid$1.prototype.getCartesians = function() {
		return this._coordsList.slice();
	};
	/**
	* @implements
	*/
	Grid$1.prototype.convertToPixel = function(ecModel, finder, value) {
		var target = this._findConvertTarget(finder);
		return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
	};
	/**
	* @implements
	*/
	Grid$1.prototype.convertFromPixel = function(ecModel, finder, value) {
		var target = this._findConvertTarget(finder);
		return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
	};
	Grid$1.prototype._findConvertTarget = function(finder) {
		var seriesModel = finder.seriesModel;
		var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
		var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
		var gridModel = finder.gridModel;
		var coordsList = this._coordsList;
		var cartesian;
		var axis;
		if (seriesModel) {
			cartesian = seriesModel.coordinateSystem;
			indexOf(coordsList, cartesian) < 0 && (cartesian = null);
		} else if (xAxisModel && yAxisModel) cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
		else if (xAxisModel) axis = this.getAxis("x", xAxisModel.componentIndex);
		else if (yAxisModel) axis = this.getAxis("y", yAxisModel.componentIndex);
		else if (gridModel) {
			if (gridModel.coordinateSystem === this) cartesian = this._coordsList[0];
		}
		return {
			cartesian,
			axis
		};
	};
	/**
	* @implements
	*/
	Grid$1.prototype.containPoint = function(point) {
		var coord = this._coordsList[0];
		if (coord) return coord.containPoint(point);
	};
	/**
	* Initialize cartesian coordinate systems
	*/
	Grid$1.prototype._initCartesian = function(gridModel, ecModel, api) {
		var _this = this;
		var grid = this;
		var axisPositionUsed = {
			left: false,
			right: false,
			top: false,
			bottom: false
		};
		var axesMap = {
			x: {},
			y: {}
		};
		var axesCount = {
			x: 0,
			y: 0
		};
		ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
		ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
		if (!axesCount.x || !axesCount.y) {
			this._axesMap = {};
			this._axesList = [];
			return;
		}
		this._axesMap = axesMap;
		each(axesMap.x, function(xAxis, xAxisIndex) {
			each(axesMap.y, function(yAxis, yAxisIndex) {
				var key$1 = "x" + xAxisIndex + "y" + yAxisIndex;
				var cartesian = new Cartesian2D_default(key$1);
				cartesian.master = _this;
				cartesian.model = gridModel;
				_this._coordsMap[key$1] = cartesian;
				_this._coordsList.push(cartesian);
				cartesian.addAxis(xAxis);
				cartesian.addAxis(yAxis);
			});
		});
		function createAxisCreator(dimName) {
			return function(axisModel, idx) {
				if (!isAxisUsedInTheGrid(axisModel, gridModel)) return;
				var axisPosition = axisModel.get("position");
				if (dimName === "x") {
					if (axisPosition !== "top" && axisPosition !== "bottom") axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
				} else if (axisPosition !== "left" && axisPosition !== "right") axisPosition = axisPositionUsed.left ? "right" : "left";
				axisPositionUsed[axisPosition] = true;
				var axis = new Axis2D_default(dimName, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisPosition);
				axis.onBand = axis.type === "category" && axisModel.get("boundaryGap");
				axis.inverse = axisModel.get("inverse");
				axisModel.axis = axis;
				axis.model = axisModel;
				axis.grid = grid;
				axis.index = idx;
				grid._axesList.push(axis);
				axesMap[dimName][idx] = axis;
				axesCount[dimName]++;
			};
		}
	};
	/**
	* Update cartesian properties from series.
	*/
	Grid$1.prototype._updateScale = function(ecModel, gridModel) {
		each(this._axesList, function(axis) {
			axis.scale.setExtent(Infinity, -Infinity);
			if (axis.type === "category") {
				var categorySortInfo = axis.model.get("categorySortInfo");
				axis.scale.setSortInfo(categorySortInfo);
			}
		});
		ecModel.eachSeries(function(seriesModel) {
			if (isCartesian2DInjectedAsDataCoordSys(seriesModel)) {
				var axesModelMap = findAxisModels(seriesModel);
				var xAxisModel = axesModelMap.xAxisModel;
				var yAxisModel = axesModelMap.yAxisModel;
				if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) return;
				var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
				var data = seriesModel.getData();
				var xAxis = cartesian.getAxis("x");
				var yAxis = cartesian.getAxis("y");
				unionExtent(data, xAxis);
				unionExtent(data, yAxis);
			}
		}, this);
		function unionExtent(data, axis) {
			each(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
				axis.scale.unionExtentFromData(data, dim);
			});
		}
	};
	/**
	* @param dim 'x' or 'y' or 'auto' or null/undefined
	*/
	Grid$1.prototype.getTooltipAxes = function(dim) {
		var baseAxes = [];
		var otherAxes = [];
		each(this.getCartesians(), function(cartesian) {
			var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
			var otherAxis = cartesian.getOtherAxis(baseAxis);
			indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
			indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
		});
		return {
			baseAxes,
			otherAxes
		};
	};
	Grid$1.create = function(ecModel, api) {
		var grids = [];
		ecModel.eachComponent("grid", function(gridModel, idx) {
			var grid = new Grid$1(gridModel, ecModel, api);
			grid.name = "grid_" + idx;
			grid.resize(gridModel, api, true);
			gridModel.coordinateSystem = grid;
			grids.push(grid);
		});
		ecModel.eachSeries(function(seriesModel) {
			injectCoordSysByOption({
				targetModel: seriesModel,
				coordSysType: "cartesian2d",
				coordSysProvider
			});
			function coordSysProvider() {
				var axesModelMap = findAxisModels(seriesModel);
				var xAxisModel = axesModelMap.xAxisModel;
				var yAxisModel = axesModelMap.yAxisModel;
				var gridModel = xAxisModel.getCoordSysModel();
				if (!gridModel) throw new Error("Grid \"" + retrieve3(xAxisModel.get("gridIndex"), xAxisModel.get("gridId"), 0) + "\" not found");
				if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) throw new Error("xAxis and yAxis must use the same grid");
				return gridModel.coordinateSystem.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
			}
		});
		return grids;
	};
	Grid$1.dimensions = cartesian2DDimensions;
	return Grid$1;
}();
/**
* Check if the axis is used in the specified grid.
*/
function isAxisUsedInTheGrid(axisModel, gridModel) {
	return axisModel.getCoordSysModel() === gridModel;
}
function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
	axis.getAxesOnZeroOf = function() {
		return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
	};
	var otherAxes = axesMap[otherAxisDim];
	var otherAxisOnZeroOf;
	var axisModel = axis.model;
	var onZero = axisModel.get(["axisLine", "onZero"]);
	var onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
	if (!onZero) return;
	if (onZeroAxisIndex != null) {
		if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
	} else for (var idx in otherAxes) if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
		otherAxisOnZeroOf = otherAxes[idx];
		break;
	}
	if (otherAxisOnZeroOf) onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
	function getOnZeroRecordKey(axis$1) {
		return axis$1.dim + "_" + axis$1.index;
	}
}
function canOnZeroToAxis(axis) {
	return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
}
function updateAxisTransform(axis, coordBase) {
	var axisExtent = axis.getExtent();
	var axisExtentSum = axisExtent[0] + axisExtent[1];
	axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
		return coord + coordBase;
	} : function(coord) {
		return axisExtentSum - coord + coordBase;
	};
	axis.toLocalCoord = axis.dim === "x" ? function(coord) {
		return coord - coordBase;
	} : function(coord) {
		return axisExtentSum - coord + coordBase;
	};
}
function updateAllAxisExtentTransByGridRect(axesMap, gridRect) {
	each(axesMap.x, function(axis) {
		return updateAxisExtentTransByGridRect(axis, gridRect.x, gridRect.width);
	});
	each(axesMap.y, function(axis) {
		return updateAxisExtentTransByGridRect(axis, gridRect.y, gridRect.height);
	});
}
function updateAxisExtentTransByGridRect(axis, gridXY, gridWH) {
	var extent = [0, gridWH];
	var idx = axis.inverse ? 1 : 0;
	axis.setExtent(extent[idx], extent[1 - idx]);
	updateAxisTransform(axis, gridXY);
}
var legacyLayOutGridByContainLabel;
function registerLegacyGridContainLabelImpl(impl) {
	legacyLayOutGridByContainLabel = impl;
}
function layOutGridByOuterBounds(outerBoundsRect, outerBoundsContain, outerBoundsClamp, gridRect, axesMap, axisBuilderSharedCtx, layoutRef) {
	assert(outerBoundsContain === "all" || outerBoundsContain === "axisLabel");
	createOrUpdateAxesView(gridRect, axesMap, AxisTickLabelComputingKind.estimate, outerBoundsContain, false, layoutRef);
	var margin = [
		0,
		0,
		0,
		0
	];
	fillLabelNameOverflowOnOneDimension(0);
	fillLabelNameOverflowOnOneDimension(1);
	fillMarginOnOneDimension(gridRect, 0, NaN);
	fillMarginOnOneDimension(gridRect, 1, NaN);
	var noPxChange = find(margin, function(item) {
		return item > 0;
	}) == null;
	expandOrShrinkRect(gridRect, margin, true, true, outerBoundsClamp);
	updateAllAxisExtentTransByGridRect(axesMap, gridRect);
	return noPxChange;
	function fillLabelNameOverflowOnOneDimension(xyIdx) {
		each(axesMap[XY[xyIdx]], function(axis) {
			if (!shouldAxisShow(axis.model)) return;
			var sharedRecord = axisBuilderSharedCtx.ensureRecord(axis.model);
			var labelInfoList = sharedRecord.labelInfoList;
			if (labelInfoList) for (var idx = 0; idx < labelInfoList.length; idx++) {
				var labelInfo = labelInfoList[idx];
				var proportion = axis.scale.normalize(getLabelInner(labelInfo.label).tickValue);
				proportion = xyIdx === 1 ? 1 - proportion : proportion;
				fillMarginOnOneDimension(labelInfo.rect, xyIdx, proportion);
				fillMarginOnOneDimension(labelInfo.rect, 1 - xyIdx, NaN);
			}
			var nameLayout = sharedRecord.nameLayout;
			if (nameLayout) {
				var proportion = isNameLocationCenter(sharedRecord.nameLocation) ? .5 : NaN;
				fillMarginOnOneDimension(nameLayout.rect, xyIdx, proportion);
				fillMarginOnOneDimension(nameLayout.rect, 1 - xyIdx, NaN);
			}
		});
	}
	function fillMarginOnOneDimension(itemRect, xyIdx, proportion) {
		var overflow1 = outerBoundsRect[XY[xyIdx]] - itemRect[XY[xyIdx]];
		var overflow2 = itemRect[WH[xyIdx]] + itemRect[XY[xyIdx]] - (outerBoundsRect[WH[xyIdx]] + outerBoundsRect[XY[xyIdx]]);
		overflow1 = applyProportion(overflow1, 1 - proportion);
		overflow2 = applyProportion(overflow2, proportion);
		var minIdx = XY_TO_MARGIN_IDX[xyIdx][0];
		var maxIdx = XY_TO_MARGIN_IDX[xyIdx][1];
		margin[minIdx] = mathMax$1(margin[minIdx], overflow1);
		margin[maxIdx] = mathMax$1(margin[maxIdx], overflow2);
	}
	function applyProportion(overflow, proportion) {
		if (overflow > 0 && !eqNaN(proportion) && proportion > 1e-4) overflow /= proportion;
		return overflow;
	}
}
function createAxisBiulders(gridRect, cartesians, axesMap, optionContainLabel, api) {
	var axisBuilderSharedCtx = new AxisBuilderSharedContext(resolveAxisNameOverlapForGrid);
	each(axesMap, function(axisList) {
		return each(axisList, function(axis) {
			if (shouldAxisShow(axis.model)) {
				var defaultNameMoveOverlap = !optionContainLabel;
				axis.axisBuilder = createCartesianAxisViewCommonPartBuilder(gridRect, cartesians, axis.model, api, axisBuilderSharedCtx, defaultNameMoveOverlap);
			}
		});
	});
	return axisBuilderSharedCtx;
}
/**
* Promote the axis-elements-building from "view render" stage to "coordinate system resize" stage.
* This is aimed to resovle overlap across multiple axes, since currently it's hard to reconcile
* multiple axes in "view render" stage.
*
* [CAUTION] But this promotion assumes that the subsequent "visual mapping" stage does not affect
* this axis-elements-building; otherwise we have to refactor it again.
*/
function createOrUpdateAxesView(gridRect, axesMap, kind, outerBoundsContain, noPxChange, layoutRef) {
	var isDetermine = kind === AxisTickLabelComputingKind.determine;
	each(axesMap, function(axisList) {
		return each(axisList, function(axis) {
			if (shouldAxisShow(axis.model)) {
				updateCartesianAxisViewCommonPartBuilder(axis.axisBuilder, gridRect, axis.model);
				axis.axisBuilder.build(isDetermine ? { axisTickLabelDetermine: true } : { axisTickLabelEstimate: true }, { noPxChange });
			}
		});
	});
	var nameMarginLevelMap = {
		x: 0,
		y: 0
	};
	calcNameMarginLevel(0);
	calcNameMarginLevel(1);
	function calcNameMarginLevel(xyIdx) {
		nameMarginLevelMap[XY[1 - xyIdx]] = gridRect[WH[xyIdx]] <= layoutRef.refContainer[WH[xyIdx]] * .5 ? 0 : 1 - xyIdx === 1 ? 2 : 1;
	}
	each(axesMap, function(axisList, xy) {
		return each(axisList, function(axis) {
			if (shouldAxisShow(axis.model)) {
				if (outerBoundsContain === "all" || isDetermine) axis.axisBuilder.build({ axisName: true }, { nameMarginLevel: nameMarginLevelMap[xy] });
				if (isDetermine) axis.axisBuilder.build({ axisLine: true });
			}
		});
	});
}
function prepareOuterBounds(gridModel, rawRridRect, layoutRef) {
	var outerBoundsRect;
	var optionOuterBoundsMode = gridModel.get("outerBoundsMode", true);
	if (optionOuterBoundsMode === "same") outerBoundsRect = rawRridRect.clone();
	else if (optionOuterBoundsMode == null || optionOuterBoundsMode === "auto") outerBoundsRect = getLayoutRect(gridModel.get("outerBounds", true) || OUTER_BOUNDS_DEFAULT, layoutRef.refContainer);
	else if (optionOuterBoundsMode !== "none") error("Invalid grid[" + gridModel.componentIndex + "].outerBoundsMode.");
	var optionOuterBoundsContain = gridModel.get("outerBoundsContain", true);
	var parsedOuterBoundsContain;
	if (optionOuterBoundsContain == null || optionOuterBoundsContain === "auto") parsedOuterBoundsContain = "all";
	else if (indexOf(["all", "axisLabel"], optionOuterBoundsContain) < 0) {
		error("Invalid grid[" + gridModel.componentIndex + "].outerBoundsContain.");
		parsedOuterBoundsContain = "all";
	} else parsedOuterBoundsContain = optionOuterBoundsContain;
	var outerBoundsClamp = [parsePositionSizeOption(retrieve2(gridModel.get("outerBoundsClampWidth", true), OUTER_BOUNDS_CLAMP_DEFAULT[0]), rawRridRect.width), parsePositionSizeOption(retrieve2(gridModel.get("outerBoundsClampHeight", true), OUTER_BOUNDS_CLAMP_DEFAULT[1]), rawRridRect.height)];
	return {
		outerBoundsRect,
		parsedOuterBoundsContain,
		outerBoundsClamp
	};
}
var resolveAxisNameOverlapForGrid = function(cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord) {
	var perpendicularDim = axisModel.axis.dim === "x" ? "y" : "x";
	resolveAxisNameOverlapDefault(cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord);
	if (!isNameLocationCenter(cfg.nameLocation)) each(ctx.recordMap[perpendicularDim], function(perpenRecord) {
		if (perpenRecord && perpenRecord.labelInfoList && perpenRecord.dirVec) moveIfOverlapByLinearLabels(perpenRecord.labelInfoList, perpenRecord.dirVec, nameLayoutInfo, nameMoveDirVec);
	});
};
var Grid_default = Grid;

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/modelHelper.js
function collect(ecModel, api) {
	var result = {
		axesInfo: {},
		seriesInvolved: false,
		coordSysAxesInfo: {},
		coordSysMap: {}
	};
	collectAxesInfo(result, ecModel, api);
	result.seriesInvolved && collectSeriesInfo(result, ecModel);
	return result;
}
function collectAxesInfo(result, ecModel, api) {
	var globalTooltipModel = ecModel.getComponent("tooltip");
	var globalAxisPointerModel = ecModel.getComponent("axisPointer");
	var linksOption = globalAxisPointerModel.get("link", true) || [];
	var linkGroups = [];
	each(api.getCoordinateSystems(), function(coordSys) {
		if (!coordSys.axisPointerEnabled) return;
		var coordSysKey = makeKey(coordSys.model);
		var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
		result.coordSysMap[coordSysKey] = coordSys;
		var baseTooltipModel = coordSys.model.getModel("tooltip", globalTooltipModel);
		each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));
		if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
			var triggerAxis = baseTooltipModel.get("trigger") === "axis";
			var cross = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
			var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
			if (triggerAxis || cross) each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
			if (cross) each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, "cross", false));
		}
		function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
			var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
			var axisPointerShow = axisPointerModel.get("show");
			if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) return;
			if (triggerTooltip == null) triggerTooltip = axisPointerModel.get("triggerTooltip");
			axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
			var snap = axisPointerModel.get("snap");
			var triggerEmphasis = axisPointerModel.get("triggerEmphasis");
			var axisKey = makeKey(axis.model);
			var involveSeries = triggerTooltip || snap || axis.type === "category";
			var axisInfo = result.axesInfo[axisKey] = {
				key: axisKey,
				axis,
				coordSys,
				axisPointerModel,
				triggerTooltip,
				triggerEmphasis,
				involveSeries,
				snap,
				useHandle: isHandleTrigger(axisPointerModel),
				seriesModels: [],
				linkGroup: null
			};
			axesInfoInCoordSys[axisKey] = axisInfo;
			result.seriesInvolved = result.seriesInvolved || involveSeries;
			var groupIndex = getLinkGroupIndex(linksOption, axis);
			if (groupIndex != null) {
				var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = { axesInfo: {} });
				linkGroup.axesInfo[axisKey] = axisInfo;
				linkGroup.mapper = linksOption[groupIndex].mapper;
				axisInfo.linkGroup = linkGroup;
			}
		}
	});
}
function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
	var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
	var fields = [
		"type",
		"snap",
		"lineStyle",
		"shadowStyle",
		"label",
		"animation",
		"animationDurationUpdate",
		"animationEasingUpdate",
		"z"
	];
	var volatileOption = {};
	each(fields, function(field) {
		volatileOption[field] = clone(tooltipAxisPointerModel.get(field));
	});
	volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
	if (tooltipAxisPointerModel.get("type") === "cross") volatileOption.type = "line";
	var labelOption = volatileOption.label || (volatileOption.label = {});
	labelOption.show ??= false;
	if (fromTooltip === "cross") {
		var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
		labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
		if (!triggerTooltip) {
			var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
			crossStyle && defaults(labelOption, crossStyle.textStyle);
		}
	}
	return axis.model.getModel("axisPointer", new Model_default(volatileOption, globalAxisPointerModel, ecModel));
}
function collectSeriesInfo(result, ecModel) {
	ecModel.eachSeries(function(seriesModel) {
		var coordSys = seriesModel.coordinateSystem;
		var seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
		var seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
		if (!coordSys || !coordSys.model || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) return;
		each(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
			var axis = axisInfo.axis;
			if (coordSys.getAxis(axis.dim) === axis) {
				axisInfo.seriesModels.push(seriesModel);
				axisInfo.seriesDataCount ??= 0;
				axisInfo.seriesDataCount += seriesModel.getData().count();
			}
		});
	});
}
/**
* For example:
* {
*     axisPointer: {
*         links: [{
*             xAxisIndex: [2, 4],
*             yAxisIndex: 'all'
*         }, {
*             xAxisId: ['a5', 'a7'],
*             xAxisName: 'xxx'
*         }]
*     }
* }
*/
function getLinkGroupIndex(linksOption, axis) {
	var axisModel = axis.model;
	var dim = axis.dim;
	for (var i$1 = 0; i$1 < linksOption.length; i$1++) {
		var linkOption = linksOption[i$1] || {};
		if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) return i$1;
	}
}
function checkPropInLink(linkPropValue, axisPropValue) {
	return linkPropValue === "all" || isArray(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}
function fixValue(axisModel) {
	var axisInfo = getAxisInfo$1(axisModel);
	if (!axisInfo) return;
	var axisPointerModel = axisInfo.axisPointerModel;
	var scale$3 = axisInfo.axis.scale;
	var option = axisPointerModel.option;
	var status = axisPointerModel.get("status");
	var value = axisPointerModel.get("value");
	if (value != null) value = scale$3.parse(value);
	var useHandle = isHandleTrigger(axisPointerModel);
	if (status == null) option.status = useHandle ? "show" : "hide";
	var extent = scale$3.getExtent().slice();
	extent[0] > extent[1] && extent.reverse();
	if (value == null || value > extent[1]) value = extent[1];
	if (value < extent[0]) value = extent[0];
	option.value = value;
	if (useHandle) option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
}
function getAxisInfo$1(axisModel) {
	var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
	return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}
function getAxisPointerModel(axisModel) {
	var axisInfo = getAxisInfo$1(axisModel);
	return axisInfo && axisInfo.axisPointerModel;
}
function isHandleTrigger(axisPointerModel) {
	return !!axisPointerModel.get(["handle", "show"]);
}
/**
* @param {module:echarts/model/Model} model
* @return {string} unique key
*/
function makeKey(model) {
	return model.type + "||" + model.id;
}

//#endregion
//#region node_modules/echarts/lib/component/axis/AxisView.js
var axisPointerClazz = {};
/**
* Base class of AxisView.
*/
var AxisView = function(_super) {
	__extends(AxisView$1, _super);
	function AxisView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = AxisView$1.type;
		return _this;
	}
	/**
	* @override
	*/
	AxisView$1.prototype.render = function(axisModel, ecModel, api, payload) {
		this.axisPointerClass && fixValue(axisModel);
		_super.prototype.render.apply(this, arguments);
		this._doUpdateAxisPointerClass(axisModel, api, true);
	};
	/**
	* Action handler.
	*/
	AxisView$1.prototype.updateAxisPointer = function(axisModel, ecModel, api, payload) {
		this._doUpdateAxisPointerClass(axisModel, api, false);
	};
	/**
	* @override
	*/
	AxisView$1.prototype.remove = function(ecModel, api) {
		var axisPointer = this._axisPointer;
		axisPointer && axisPointer.remove(api);
	};
	/**
	* @override
	*/
	AxisView$1.prototype.dispose = function(ecModel, api) {
		this._disposeAxisPointer(api);
		_super.prototype.dispose.apply(this, arguments);
	};
	AxisView$1.prototype._doUpdateAxisPointerClass = function(axisModel, api, forceRender) {
		var Clazz = AxisView$1.getAxisPointerClass(this.axisPointerClass);
		if (!Clazz) return;
		var axisPointerModel = getAxisPointerModel(axisModel);
		axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
	};
	AxisView$1.prototype._disposeAxisPointer = function(api) {
		this._axisPointer && this._axisPointer.dispose(api);
		this._axisPointer = null;
	};
	AxisView$1.registerAxisPointerClass = function(type, clazz) {
		if (axisPointerClazz[type]) throw new Error("axisPointer " + type + " exists");
		axisPointerClazz[type] = clazz;
	};
	AxisView$1.getAxisPointerClass = function(type) {
		return type && axisPointerClazz[type];
	};
	AxisView$1.type = "axis";
	return AxisView$1;
}(Component_default$1);
var AxisView_default = AxisView;

//#endregion
//#region node_modules/echarts/lib/component/axis/axisSplitHelper.js
var inner$18 = makeInner();
function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
	var axis = axisModel.axis;
	if (axis.scale.isBlank()) return;
	var splitAreaModel = axisModel.getModel("splitArea");
	var areaStyleModel = splitAreaModel.getModel("areaStyle");
	var areaColors = areaStyleModel.get("color");
	var gridRect = gridModel.coordinateSystem.getRect();
	var ticksCoords = axis.getTicksCoords({
		tickModel: splitAreaModel,
		clamp: true,
		breakTicks: "none",
		pruneByBreak: "preserve_extent_bound"
	});
	if (!ticksCoords.length) return;
	var areaColorsLen = areaColors.length;
	var lastSplitAreaColors = inner$18(axisView).splitAreaColors;
	var newSplitAreaColors = createHashMap();
	var colorIndex = 0;
	if (lastSplitAreaColors) for (var i$1 = 0; i$1 < ticksCoords.length; i$1++) {
		var cIndex = lastSplitAreaColors.get(ticksCoords[i$1].tickValue);
		if (cIndex != null) {
			colorIndex = (cIndex + (areaColorsLen - 1) * i$1) % areaColorsLen;
			break;
		}
	}
	var prev = axis.toGlobalCoord(ticksCoords[0].coord);
	var areaStyle = areaStyleModel.getAreaStyle();
	areaColors = isArray(areaColors) ? areaColors : [areaColors];
	for (var i$1 = 1; i$1 < ticksCoords.length; i$1++) {
		var tickCoord = axis.toGlobalCoord(ticksCoords[i$1].coord);
		var x = void 0;
		var y = void 0;
		var width = void 0;
		var height = void 0;
		if (axis.isHorizontal()) {
			x = prev;
			y = gridRect.y;
			width = tickCoord - x;
			height = gridRect.height;
			prev = x + width;
		} else {
			x = gridRect.x;
			y = prev;
			width = gridRect.width;
			height = tickCoord - y;
			prev = y + height;
		}
		var tickValue = ticksCoords[i$1 - 1].tickValue;
		tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
		axisGroup.add(new Rect_default({
			anid: tickValue != null ? "area_" + tickValue : null,
			shape: {
				x,
				y,
				width,
				height
			},
			style: defaults({ fill: areaColors[colorIndex] }, areaStyle),
			autoBatch: true,
			silent: true
		}));
		colorIndex = (colorIndex + 1) % areaColorsLen;
	}
	inner$18(axisView).splitAreaColors = newSplitAreaColors;
}
function rectCoordAxisHandleRemove(axisView) {
	inner$18(axisView).splitAreaColors = null;
}

//#endregion
//#region node_modules/echarts/lib/component/axis/CartesianAxisView.js
var selfBuilderAttrs$2 = [
	"splitArea",
	"splitLine",
	"minorSplitLine",
	"breakArea"
];
var CartesianAxisView = function(_super) {
	__extends(CartesianAxisView$1, _super);
	function CartesianAxisView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = CartesianAxisView$1.type;
		_this.axisPointerClass = "CartesianAxisPointer";
		return _this;
	}
	/**
	* @override
	*/
	CartesianAxisView$1.prototype.render = function(axisModel, ecModel, api, payload) {
		this.group.removeAll();
		var oldAxisGroup = this._axisGroup;
		this._axisGroup = new Group_default();
		this.group.add(this._axisGroup);
		if (!shouldAxisShow(axisModel)) return;
		this._axisGroup.add(axisModel.axis.axisBuilder.group);
		each(selfBuilderAttrs$2, function(name) {
			if (axisModel.get([name, "show"])) axisElementBuilders$2[name](this, this._axisGroup, axisModel, axisModel.getCoordSysModel(), api);
		}, this);
		if (!(payload && payload.type === "changeAxisOrder" && payload.isInitSort)) groupTransition(oldAxisGroup, this._axisGroup, axisModel);
		_super.prototype.render.call(this, axisModel, ecModel, api, payload);
	};
	CartesianAxisView$1.prototype.remove = function() {
		rectCoordAxisHandleRemove(this);
	};
	CartesianAxisView$1.type = "cartesianAxis";
	return CartesianAxisView$1;
}(AxisView_default);
var axisElementBuilders$2 = {
	splitLine: function(axisView, axisGroup, axisModel, gridModel, api) {
		var axis = axisModel.axis;
		if (axis.scale.isBlank()) return;
		var splitLineModel = axisModel.getModel("splitLine");
		var lineStyleModel = splitLineModel.getModel("lineStyle");
		var lineColors = lineStyleModel.get("color");
		var showMinLine = splitLineModel.get("showMinLine") !== false;
		var showMaxLine = splitLineModel.get("showMaxLine") !== false;
		lineColors = isArray(lineColors) ? lineColors : [lineColors];
		var gridRect = gridModel.coordinateSystem.getRect();
		var isHorizontal = axis.isHorizontal();
		var lineCount = 0;
		var ticksCoords = axis.getTicksCoords({
			tickModel: splitLineModel,
			breakTicks: "none",
			pruneByBreak: "preserve_extent_bound"
		});
		var p1 = [];
		var p2 = [];
		var lineStyle = lineStyleModel.getLineStyle();
		for (var i$1 = 0; i$1 < ticksCoords.length; i$1++) {
			var tickCoord = axis.toGlobalCoord(ticksCoords[i$1].coord);
			if (i$1 === 0 && !showMinLine || i$1 === ticksCoords.length - 1 && !showMaxLine) continue;
			var tickValue = ticksCoords[i$1].tickValue;
			if (isHorizontal) {
				p1[0] = tickCoord;
				p1[1] = gridRect.y;
				p2[0] = tickCoord;
				p2[1] = gridRect.y + gridRect.height;
			} else {
				p1[0] = gridRect.x;
				p1[1] = tickCoord;
				p2[0] = gridRect.x + gridRect.width;
				p2[1] = tickCoord;
			}
			var colorIndex = lineCount++ % lineColors.length;
			var line = new Line_default({
				anid: tickValue != null ? "line_" + tickValue : null,
				autoBatch: true,
				shape: {
					x1: p1[0],
					y1: p1[1],
					x2: p2[0],
					y2: p2[1]
				},
				style: defaults({ stroke: lineColors[colorIndex] }, lineStyle),
				silent: true
			});
			subPixelOptimizeLine$1(line.shape, lineStyle.lineWidth);
			axisGroup.add(line);
		}
	},
	minorSplitLine: function(axisView, axisGroup, axisModel, gridModel, api) {
		var axis = axisModel.axis;
		var lineStyleModel = axisModel.getModel("minorSplitLine").getModel("lineStyle");
		var gridRect = gridModel.coordinateSystem.getRect();
		var isHorizontal = axis.isHorizontal();
		var minorTicksCoords = axis.getMinorTicksCoords();
		if (!minorTicksCoords.length) return;
		var p1 = [];
		var p2 = [];
		var lineStyle = lineStyleModel.getLineStyle();
		for (var i$1 = 0; i$1 < minorTicksCoords.length; i$1++) for (var k$1 = 0; k$1 < minorTicksCoords[i$1].length; k$1++) {
			var tickCoord = axis.toGlobalCoord(minorTicksCoords[i$1][k$1].coord);
			if (isHorizontal) {
				p1[0] = tickCoord;
				p1[1] = gridRect.y;
				p2[0] = tickCoord;
				p2[1] = gridRect.y + gridRect.height;
			} else {
				p1[0] = gridRect.x;
				p1[1] = tickCoord;
				p2[0] = gridRect.x + gridRect.width;
				p2[1] = tickCoord;
			}
			var line = new Line_default({
				anid: "minor_line_" + minorTicksCoords[i$1][k$1].tickValue,
				autoBatch: true,
				shape: {
					x1: p1[0],
					y1: p1[1],
					x2: p2[0],
					y2: p2[1]
				},
				style: lineStyle,
				silent: true
			});
			subPixelOptimizeLine$1(line.shape, lineStyle.lineWidth);
			axisGroup.add(line);
		}
	},
	splitArea: function(axisView, axisGroup, axisModel, gridModel, api) {
		rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
	},
	breakArea: function(axisView, axisGroup, axisModel, gridModel, api) {
		var axisBreakHelper = getAxisBreakHelper();
		var scale$3 = axisModel.axis.scale;
		if (axisBreakHelper && scale$3.type !== "ordinal") axisBreakHelper.rectCoordBuildBreakAxis(axisGroup, axisView, axisModel, gridModel.coordinateSystem.getRect(), api);
	}
};
var CartesianXAxisView = function(_super) {
	__extends(CartesianXAxisView$1, _super);
	function CartesianXAxisView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = CartesianXAxisView$1.type;
		return _this;
	}
	CartesianXAxisView$1.type = "xAxis";
	return CartesianXAxisView$1;
}(CartesianAxisView);
var CartesianYAxisView = function(_super) {
	__extends(CartesianYAxisView$1, _super);
	function CartesianYAxisView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = CartesianXAxisView.type;
		return _this;
	}
	CartesianYAxisView$1.type = "yAxis";
	return CartesianYAxisView$1;
}(CartesianAxisView);

//#endregion
//#region node_modules/echarts/lib/component/grid/installSimple.js
var GridView = function(_super) {
	__extends(GridView$1, _super);
	function GridView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "grid";
		return _this;
	}
	GridView$1.prototype.render = function(gridModel, ecModel) {
		this.group.removeAll();
		if (gridModel.get("show")) this.group.add(new Rect_default({
			shape: gridModel.coordinateSystem.getRect(),
			style: defaults({ fill: gridModel.get("backgroundColor") }, gridModel.getItemStyle()),
			silent: true,
			z2: -1
		}));
	};
	GridView$1.type = "grid";
	return GridView$1;
}(Component_default$1);
var extraOption = { offset: 0 };
function install$56(registers) {
	registers.registerComponentView(GridView);
	registers.registerComponentModel(GridModel_default);
	registers.registerCoordinateSystem("cartesian2d", Grid_default);
	axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
	axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
	registers.registerComponentView(CartesianXAxisView);
	registers.registerComponentView(CartesianYAxisView);
	registers.registerPreprocessor(function(option) {
		if (option.xAxis && option.yAxis && !option.grid) option.grid = {};
	});
}

//#endregion
//#region node_modules/echarts/lib/util/jitter.js
function needFixJitter(seriesModel, axis) {
	var coordinateSystem = seriesModel.coordinateSystem;
	var coordType = coordinateSystem && coordinateSystem.type;
	var baseAxis = coordinateSystem && coordinateSystem.getBaseAxis && coordinateSystem.getBaseAxis();
	var scaleType = baseAxis && baseAxis.scale && baseAxis.scale.type;
	var seriesValid = coordType === "cartesian2d" && scaleType === "ordinal" || coordType === "single";
	var axisValid = axis.model.get("jitter") > 0;
	return seriesValid && axisValid;
}
var inner$17 = makeInner();
/**
* Fix jitter for overlapping data points.
*
* @param fixedAxis The axis whose coord doesn't change with jitter.
* @param fixedCoord The coord of fixedAxis.
* @param floatCoord The coord of the other axis, which should be changed with jittering.
* @param radius The radius of the data point, considering the symbol is a circle.
* @returns updated floatCoord.
*/
function fixJitter(fixedAxis, fixedCoord, floatCoord, radius) {
	if (fixedAxis instanceof Axis2D_default) {
		var scaleType = fixedAxis.scale.type;
		if (scaleType !== "category" && scaleType !== "ordinal") return floatCoord;
	}
	var axisModel = fixedAxis.model;
	var jitter = axisModel.get("jitter");
	var jitterOverlap = axisModel.get("jitterOverlap");
	var jitterMargin = axisModel.get("jitterMargin") || 0;
	var bandWidth = fixedAxis.scale.type === "ordinal" ? fixedAxis.getBandWidth() : null;
	if (jitter > 0) if (jitterOverlap) return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);
	else return fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, jitterMargin);
	return floatCoord;
}
function fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius) {
	if (bandWidth === null) return floatCoord + (Math.random() - .5) * jitter;
	var maxJitter = bandWidth - radius * 2;
	var actualJitter = Math.min(Math.max(0, jitter), maxJitter);
	return floatCoord + (Math.random() - .5) * actualJitter;
}
function fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, margin) {
	var store = inner$17(fixedAxis);
	if (!store.items) store.items = [];
	var items = store.items;
	var overlapA = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, 1);
	var overlapB = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, -1);
	var minFloat = Math.abs(overlapA - floatCoord) < Math.abs(overlapB - floatCoord) ? overlapA : overlapB;
	var bandWidth = fixedAxis.scale.type === "ordinal" ? fixedAxis.getBandWidth() : null;
	var distance$1 = Math.abs(minFloat - floatCoord);
	if (distance$1 > jitter / 2 || bandWidth && distance$1 > bandWidth / 2 - radius) return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);
	items.push({
		fixedCoord,
		floatCoord: minFloat,
		r: radius
	});
	return minFloat;
}
function placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, direction) {
	var y = floatCoord;
	for (var i$1 = 0; i$1 < items.length; i$1++) {
		var item = items[i$1];
		var dx = fixedCoord - item.fixedCoord;
		var dy = y - item.floatCoord;
		var d2 = dx * dx + dy * dy;
		var r = radius + item.r + margin;
		if (d2 < r * r) {
			var requiredY = item.floatCoord + Math.sqrt(r * r - dx * dx) * direction;
			if (Math.abs(requiredY - floatCoord) > jitter / 2) return Number.MAX_VALUE;
			if (direction === 1 && requiredY > y || direction === -1 && requiredY < y) {
				y = requiredY;
				i$1 = -1;
				continue;
			}
		}
	}
	return y;
}

//#endregion
//#region node_modules/echarts/lib/chart/scatter/jitterLayout.js
function jitterLayout(ecModel) {
	ecModel.eachSeriesByType("scatter", function(seriesModel) {
		var coordSys = seriesModel.coordinateSystem;
		if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "single")) {
			var baseAxis_1 = coordSys.getBaseAxis ? coordSys.getBaseAxis() : null;
			if (baseAxis_1 && needFixJitter(seriesModel, baseAxis_1)) {
				var data_1 = seriesModel.getData();
				data_1.each(function(idx) {
					var dim = baseAxis_1.dim;
					var orient = baseAxis_1.orient;
					var isSingleY = orient === "horizontal" && baseAxis_1.type !== "category" || orient === "vertical" && baseAxis_1.type === "category";
					var layout$3 = data_1.getItemLayout(idx);
					var rawSize = data_1.getItemVisual(idx, "symbolSize");
					var size = rawSize instanceof Array ? (rawSize[1] + rawSize[0]) / 2 : rawSize;
					if (dim === "y" || dim === "single" && isSingleY) {
						var jittered = fixJitter(baseAxis_1, layout$3[0], layout$3[1], size / 2);
						data_1.setItemLayout(idx, [layout$3[0], jittered]);
					} else if (dim === "x" || dim === "single" && !isSingleY) {
						var jittered = fixJitter(baseAxis_1, layout$3[1], layout$3[0], size / 2);
						data_1.setItemLayout(idx, [jittered, layout$3[1]]);
					}
				});
			}
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/scatter/install.js
function install$5(registers) {
	use(install$56);
	registers.registerSeriesModel(ScatterSeries_default);
	registers.registerChartView(ScatterView_default);
	registers.registerLayout(pointsLayout("scatter"));
}
function installScatterJitter(registers) {
	registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, jitterLayout);
}

//#endregion
//#region node_modules/echarts/lib/chart/radar/radarLayout.js
function radarLayout(ecModel) {
	ecModel.eachSeriesByType("radar", function(seriesModel) {
		var data = seriesModel.getData();
		var points$3 = [];
		var coordSys = seriesModel.coordinateSystem;
		if (!coordSys) return;
		var axes = coordSys.getIndicatorAxes();
		each(axes, function(axis, axisIndex) {
			data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
				points$3[dataIndex] = points$3[dataIndex] || [];
				var point = coordSys.dataToPoint(val, axisIndex);
				points$3[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
			});
		});
		data.each(function(idx) {
			var firstPoint = find(points$3[idx], function(point) {
				return isValidPoint(point);
			}) || getValueMissingPoint(coordSys);
			points$3[idx].push(firstPoint.slice());
			data.setItemLayout(idx, points$3[idx]);
		});
	});
}
function isValidPoint(point) {
	return !isNaN(point[0]) && !isNaN(point[1]);
}
function getValueMissingPoint(coordSys) {
	return [coordSys.cx, coordSys.cy];
}

//#endregion
//#region node_modules/echarts/lib/chart/radar/backwardCompat.js
function radarBackwardCompat(option) {
	var polarOptArr = option.polar;
	if (polarOptArr) {
		if (!isArray(polarOptArr)) polarOptArr = [polarOptArr];
		var polarNotRadar_1 = [];
		each(polarOptArr, function(polarOpt, idx) {
			if (polarOpt.indicator) {
				if (polarOpt.type && !polarOpt.shape) polarOpt.shape = polarOpt.type;
				option.radar = option.radar || [];
				if (!isArray(option.radar)) option.radar = [option.radar];
				option.radar.push(polarOpt);
			} else polarNotRadar_1.push(polarOpt);
		});
		option.polar = polarNotRadar_1;
	}
	each(option.series, function(seriesOpt) {
		if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) seriesOpt.radarIndex = seriesOpt.polarIndex;
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/radar/RadarView.js
var RadarView$1 = function(_super) {
	__extends(RadarView$2, _super);
	function RadarView$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = RadarView$2.type;
		return _this;
	}
	RadarView$2.prototype.render = function(seriesModel, ecModel, api) {
		var polar = seriesModel.coordinateSystem;
		var group = this.group;
		var data = seriesModel.getData();
		var oldData = this._data;
		function createSymbol$2(data$1, idx) {
			var symbolType = data$1.getItemVisual(idx, "symbol") || "circle";
			if (symbolType === "none") return;
			var symbolSize = normalizeSymbolSize(data$1.getItemVisual(idx, "symbolSize"));
			var symbolPath = createSymbol(symbolType, -1, -1, 2, 2);
			var symbolRotate = data$1.getItemVisual(idx, "symbolRotate") || 0;
			symbolPath.attr({
				style: { strokeNoScale: true },
				z2: 100,
				scaleX: symbolSize[0] / 2,
				scaleY: symbolSize[1] / 2,
				rotation: symbolRotate * Math.PI / 180 || 0
			});
			return symbolPath;
		}
		function updateSymbols(oldPoints, newPoints, symbolGroup, data$1, idx, isInit) {
			symbolGroup.removeAll();
			for (var i$1 = 0; i$1 < newPoints.length - 1; i$1++) {
				var symbolPath = createSymbol$2(data$1, idx);
				if (symbolPath) {
					symbolPath.__dimIdx = i$1;
					if (oldPoints[i$1]) {
						symbolPath.setPosition(oldPoints[i$1]);
						graphic_exports$1[isInit ? "initProps" : "updateProps"](symbolPath, {
							x: newPoints[i$1][0],
							y: newPoints[i$1][1]
						}, seriesModel, idx);
					} else symbolPath.setPosition(newPoints[i$1]);
					symbolGroup.add(symbolPath);
				}
			}
		}
		function getInitialPoints(points$3) {
			return map(points$3, function(pt) {
				return [polar.cx, polar.cy];
			});
		}
		data.diff(oldData).add(function(idx) {
			var points$3 = data.getItemLayout(idx);
			if (!points$3) return;
			var polygon = new Polygon_default();
			var polyline = new Polyline_default();
			var target = { shape: { points: points$3 } };
			polygon.shape.points = getInitialPoints(points$3);
			polyline.shape.points = getInitialPoints(points$3);
			initProps(polygon, target, seriesModel, idx);
			initProps(polyline, target, seriesModel, idx);
			var itemGroup = new Group_default();
			var symbolGroup = new Group_default();
			itemGroup.add(polyline);
			itemGroup.add(polygon);
			itemGroup.add(symbolGroup);
			updateSymbols(polyline.shape.points, points$3, symbolGroup, data, idx, true);
			data.setItemGraphicEl(idx, itemGroup);
		}).update(function(newIdx, oldIdx) {
			var itemGroup = oldData.getItemGraphicEl(oldIdx);
			var polyline = itemGroup.childAt(0);
			var polygon = itemGroup.childAt(1);
			var symbolGroup = itemGroup.childAt(2);
			var target = { shape: { points: data.getItemLayout(newIdx) } };
			if (!target.shape.points) return;
			updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
			saveOldStyle(polygon);
			saveOldStyle(polyline);
			updateProps(polyline, target, seriesModel);
			updateProps(polygon, target, seriesModel);
			data.setItemGraphicEl(newIdx, itemGroup);
		}).remove(function(idx) {
			group.remove(oldData.getItemGraphicEl(idx));
		}).execute();
		data.eachItemGraphicEl(function(itemGroup, idx) {
			var itemModel = data.getItemModel(idx);
			var polyline = itemGroup.childAt(0);
			var polygon = itemGroup.childAt(1);
			var symbolGroup = itemGroup.childAt(2);
			var itemStyle = data.getItemVisual(idx, "style");
			var color$2 = itemStyle.fill;
			group.add(itemGroup);
			polyline.useStyle(defaults(itemModel.getModel("lineStyle").getLineStyle(), {
				fill: "none",
				stroke: color$2
			}));
			setStatesStylesFromModel(polyline, itemModel, "lineStyle");
			setStatesStylesFromModel(polygon, itemModel, "areaStyle");
			var areaStyleModel = itemModel.getModel("areaStyle");
			var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
			polygon.ignore = polygonIgnore;
			each([
				"emphasis",
				"select",
				"blur"
			], function(stateName) {
				var stateModel = itemModel.getModel([stateName, "areaStyle"]);
				var stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty();
				polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore;
				var lineStyle = itemModel.getModel([stateName, "lineStyle"]).getLineStyle();
				polyline.ensureState(stateName).style = lineStyle;
				var areaStyle = stateModel.getAreaStyle();
				polygon.ensureState(stateName).style = areaStyle;
				var itemStateStyle = itemModel.getModel([stateName, "itemStyle"]).getItemStyle();
				symbolGroup.eachChild(function(symbolPath) {
					symbolPath.ensureState(stateName).style = clone(itemStateStyle);
				});
			});
			polygon.useStyle(defaults(itemModel.getModel("areaStyle").getAreaStyle(), {
				fill: color$2,
				opacity: .7,
				decal: itemStyle.decal
			}));
			var emphasisModel = itemModel.getModel("emphasis");
			symbolGroup.eachChild(function(symbolPath) {
				if (symbolPath instanceof Image_default) {
					var pathStyle = symbolPath.style;
					symbolPath.useStyle(extend({
						image: pathStyle.image,
						x: pathStyle.x,
						y: pathStyle.y,
						width: pathStyle.width,
						height: pathStyle.height
					}, itemStyle));
				} else {
					symbolPath.useStyle(itemStyle);
					symbolPath.setColor(color$2);
					symbolPath.style.strokeNoScale = true;
				}
				var defaultText = data.getStore().get(data.getDimensionIndex(symbolPath.__dimIdx), idx);
				(defaultText == null || isNaN(defaultText)) && (defaultText = "");
				setLabelStyle(symbolPath, getLabelStatesModels(itemModel), {
					labelFetcher: data.hostModel,
					labelDataIndex: idx,
					labelDimIndex: symbolPath.__dimIdx,
					defaultText,
					inheritColor: color$2,
					defaultOpacity: itemStyle.opacity
				});
			});
			toggleHoverEmphasis(itemGroup, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
		});
		this._data = data;
	};
	RadarView$2.prototype.remove = function() {
		this.group.removeAll();
		this._data = null;
	};
	RadarView$2.type = "radar";
	return RadarView$2;
}(Chart_default);
var RadarView_default = RadarView$1;

//#endregion
//#region node_modules/echarts/lib/chart/radar/RadarSeries.js
var RadarSeriesModel = function(_super) {
	__extends(RadarSeriesModel$1, _super);
	function RadarSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = RadarSeriesModel$1.type;
		_this.hasSymbolVisual = true;
		return _this;
	}
	RadarSeriesModel$1.prototype.init = function(option) {
		_super.prototype.init.apply(this, arguments);
		this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
	};
	RadarSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		return createSeriesDataSimply(this, {
			generateCoord: "indicator_",
			generateCoordCount: Infinity
		});
	};
	RadarSeriesModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		var data = this.getData();
		var indicatorAxes = this.coordinateSystem.getIndicatorAxes();
		var name = this.getData().getName(dataIndex);
		var nameToDisplay = name === "" ? this.name : name;
		var markerColor = retrieveVisualColorForTooltipMarker(this, dataIndex);
		return createTooltipMarkup("section", {
			header: nameToDisplay,
			sortBlocks: true,
			blocks: map(indicatorAxes, function(axis) {
				var val = data.get(data.mapDimension(axis.dim), dataIndex);
				return createTooltipMarkup("nameValue", {
					markerType: "subItem",
					markerColor,
					name: axis.name,
					value: val,
					sortParam: val
				});
			})
		});
	};
	RadarSeriesModel$1.prototype.getTooltipPosition = function(dataIndex) {
		if (dataIndex != null) {
			var data_1 = this.getData();
			var coordSys = this.coordinateSystem;
			var values = data_1.getValues(map(coordSys.dimensions, function(dim) {
				return data_1.mapDimension(dim);
			}), dataIndex);
			for (var i$1 = 0, len$1 = values.length; i$1 < len$1; i$1++) if (!isNaN(values[i$1])) {
				var indicatorAxes = coordSys.getIndicatorAxes();
				return coordSys.coordToPoint(indicatorAxes[i$1].dataToCoord(values[i$1]), i$1);
			}
		}
	};
	RadarSeriesModel$1.type = "series.radar";
	RadarSeriesModel$1.dependencies = ["radar"];
	RadarSeriesModel$1.defaultOption = {
		z: 2,
		colorBy: "data",
		coordinateSystem: "radar",
		legendHoverLink: true,
		radarIndex: 0,
		lineStyle: {
			width: 2,
			type: "solid",
			join: "round"
		},
		label: { position: "top" },
		symbolSize: 8
	};
	return RadarSeriesModel$1;
}(Series_default);
var RadarSeries_default = RadarSeriesModel;

//#endregion
//#region node_modules/echarts/lib/coord/radar/RadarModel.js
var valueAxisDefault = axisDefault_default.value;
function defaultsShow(opt, show) {
	return defaults({ show }, opt);
}
var RadarModel = function(_super) {
	__extends(RadarModel$1, _super);
	function RadarModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = RadarModel$1.type;
		return _this;
	}
	RadarModel$1.prototype.optionUpdated = function() {
		var boundaryGap = this.get("boundaryGap");
		var splitNumber = this.get("splitNumber");
		var scale$3 = this.get("scale");
		var axisLine = this.get("axisLine");
		var axisTick = this.get("axisTick");
		var axisLabel = this.get("axisLabel");
		var nameTextStyle = this.get("axisName");
		var showName = this.get(["axisName", "show"]);
		var nameFormatter = this.get(["axisName", "formatter"]);
		var nameGap = this.get("axisNameGap");
		var triggerEvent = this.get("triggerEvent");
		this._indicatorModels = map(this.get("indicator") || [], function(indicatorOpt) {
			if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) indicatorOpt.min = 0;
			else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) indicatorOpt.max = 0;
			var iNameTextStyle = nameTextStyle;
			if (indicatorOpt.color != null) iNameTextStyle = defaults({ color: indicatorOpt.color }, nameTextStyle);
			var innerIndicatorOpt = merge(clone(indicatorOpt), {
				boundaryGap,
				splitNumber,
				scale: scale$3,
				axisLine,
				axisTick,
				axisLabel,
				name: indicatorOpt.text,
				showName,
				nameLocation: "end",
				nameGap,
				nameTextStyle: iNameTextStyle,
				triggerEvent
			}, false);
			if (isString(nameFormatter)) {
				var indName = innerIndicatorOpt.name;
				innerIndicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
			} else if (isFunction(nameFormatter)) innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);
			var model = new Model_default(innerIndicatorOpt, null, this.ecModel);
			mixin(model, AxisModelCommonMixin.prototype);
			model.mainType = "radar";
			model.componentIndex = this.componentIndex;
			return model;
		}, this);
	};
	RadarModel$1.prototype.getIndicatorModels = function() {
		return this._indicatorModels;
	};
	RadarModel$1.type = "radar";
	RadarModel$1.defaultOption = {
		z: 0,
		center: ["50%", "50%"],
		radius: "50%",
		startAngle: 90,
		axisName: {
			show: true,
			color: tokens_default.color.axisLabel
		},
		boundaryGap: [0, 0],
		splitNumber: 5,
		axisNameGap: 15,
		scale: false,
		shape: "polygon",
		axisLine: merge({ lineStyle: { color: tokens_default.color.neutral20 } }, valueAxisDefault.axisLine),
		axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
		axisTick: defaultsShow(valueAxisDefault.axisTick, false),
		splitLine: defaultsShow(valueAxisDefault.splitLine, true),
		splitArea: defaultsShow(valueAxisDefault.splitArea, true),
		indicator: []
	};
	return RadarModel$1;
}(Component_default);
var RadarModel_default = RadarModel;

//#endregion
//#region node_modules/echarts/lib/component/radar/RadarView.js
var RadarView = function(_super) {
	__extends(RadarView$2, _super);
	function RadarView$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = RadarView$2.type;
		return _this;
	}
	RadarView$2.prototype.render = function(radarModel, ecModel, api) {
		this.group.removeAll();
		this._buildAxes(radarModel, api);
		this._buildSplitLineAndArea(radarModel);
	};
	RadarView$2.prototype._buildAxes = function(radarModel, api) {
		var radar = radarModel.coordinateSystem;
		var indicatorAxes = radar.getIndicatorAxes();
		var axisBuilders = map(indicatorAxes, function(indicatorAxis) {
			var axisName = indicatorAxis.model.get("showName") ? indicatorAxis.name : "";
			return new AxisBuilder_default(indicatorAxis.model, api, {
				axisName,
				position: [radar.cx, radar.cy],
				rotation: indicatorAxis.angle,
				labelDirection: -1,
				tickDirection: -1,
				nameDirection: 1
			});
		});
		each(axisBuilders, function(axisBuilder) {
			axisBuilder.build();
			this.group.add(axisBuilder.group);
		}, this);
	};
	RadarView$2.prototype._buildSplitLineAndArea = function(radarModel) {
		var radar = radarModel.coordinateSystem;
		var indicatorAxes = radar.getIndicatorAxes();
		if (!indicatorAxes.length) return;
		var shape = radarModel.get("shape");
		var splitLineModel = radarModel.getModel("splitLine");
		var splitAreaModel = radarModel.getModel("splitArea");
		var lineStyleModel = splitLineModel.getModel("lineStyle");
		var areaStyleModel = splitAreaModel.getModel("areaStyle");
		var showSplitLine = splitLineModel.get("show");
		var showSplitArea = splitAreaModel.get("show");
		var splitLineColors = lineStyleModel.get("color");
		var splitAreaColors = areaStyleModel.get("color");
		var splitLineColorsArr = isArray(splitLineColors) ? splitLineColors : [splitLineColors];
		var splitAreaColorsArr = isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
		var splitLines = [];
		var splitAreas = [];
		function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
			var colorIndex$1 = idx % areaOrLineColorList.length;
			areaOrLine[colorIndex$1] = areaOrLine[colorIndex$1] || [];
			return colorIndex$1;
		}
		if (shape === "circle") {
			var ticksRadius = indicatorAxes[0].getTicksCoords();
			var cx = radar.cx;
			var cy = radar.cy;
			for (var i$1 = 0; i$1 < ticksRadius.length; i$1++) {
				if (showSplitLine) {
					var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i$1);
					splitLines[colorIndex].push(new Circle_default({ shape: {
						cx,
						cy,
						r: ticksRadius[i$1].coord
					} }));
				}
				if (showSplitArea && i$1 < ticksRadius.length - 1) {
					var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i$1);
					splitAreas[colorIndex].push(new Ring_default({ shape: {
						cx,
						cy,
						r0: ticksRadius[i$1].coord,
						r: ticksRadius[i$1 + 1].coord
					} }));
				}
			}
		} else {
			var realSplitNumber_1;
			var axesTicksPoints = map(indicatorAxes, function(indicatorAxis, idx) {
				var ticksCoords = indicatorAxis.getTicksCoords();
				realSplitNumber_1 = realSplitNumber_1 == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber_1);
				return map(ticksCoords, function(tickCoord) {
					return radar.coordToPoint(tickCoord.coord, idx);
				});
			});
			var prevPoints = [];
			for (var i$1 = 0; i$1 <= realSplitNumber_1; i$1++) {
				var points$3 = [];
				for (var j = 0; j < indicatorAxes.length; j++) points$3.push(axesTicksPoints[j][i$1]);
				if (points$3[0]) points$3.push(points$3[0].slice());
				else console.error("Can't draw value axis " + i$1);
				if (showSplitLine) {
					var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i$1);
					splitLines[colorIndex].push(new Polyline_default({ shape: { points: points$3 } }));
				}
				if (showSplitArea && prevPoints) {
					var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i$1 - 1);
					splitAreas[colorIndex].push(new Polygon_default({ shape: { points: points$3.concat(prevPoints) } }));
				}
				prevPoints = points$3.slice().reverse();
			}
		}
		var lineStyle = lineStyleModel.getLineStyle();
		var areaStyle = areaStyleModel.getAreaStyle();
		each(splitAreas, function(splitAreas$1, idx) {
			this.group.add(mergePath(splitAreas$1, {
				style: defaults({
					stroke: "none",
					fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]
				}, areaStyle),
				silent: true
			}));
		}, this);
		each(splitLines, function(splitLines$1, idx) {
			this.group.add(mergePath(splitLines$1, {
				style: defaults({
					fill: "none",
					stroke: splitLineColorsArr[idx % splitLineColorsArr.length]
				}, lineStyle),
				silent: true
			}));
		}, this);
	};
	RadarView$2.type = "radar";
	return RadarView$2;
}(Component_default$1);
var RadarView_default$1 = RadarView;

//#endregion
//#region node_modules/echarts/lib/coord/radar/IndicatorAxis.js
var IndicatorAxis = function(_super) {
	__extends(IndicatorAxis$1, _super);
	function IndicatorAxis$1(dim, scale$3, radiusExtent) {
		var _this = _super.call(this, dim, scale$3, radiusExtent) || this;
		_this.type = "value";
		_this.angle = 0;
		_this.name = "";
		return _this;
	}
	return IndicatorAxis$1;
}(Axis_default);
var IndicatorAxis_default = IndicatorAxis;

//#endregion
//#region node_modules/echarts/lib/coord/radar/Radar.js
var Radar = function() {
	function Radar$1(radarModel, ecModel, api) {
		/**
		*
		* Radar dimensions
		*/
		this.dimensions = [];
		this._model = radarModel;
		this._indicatorAxes = map(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
			var dim = "indicator_" + idx;
			var indicatorAxis = new IndicatorAxis_default(dim, new Interval_default());
			indicatorAxis.name = indicatorModel.get("name");
			indicatorAxis.model = indicatorModel;
			indicatorModel.axis = indicatorAxis;
			this.dimensions.push(dim);
			return indicatorAxis;
		}, this);
		this.resize(radarModel, api);
	}
	Radar$1.prototype.getIndicatorAxes = function() {
		return this._indicatorAxes;
	};
	Radar$1.prototype.dataToPoint = function(value, indicatorIndex) {
		var indicatorAxis = this._indicatorAxes[indicatorIndex];
		return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
	};
	Radar$1.prototype.coordToPoint = function(coord, indicatorIndex) {
		var angle = this._indicatorAxes[indicatorIndex].angle;
		return [this.cx + coord * Math.cos(angle), this.cy - coord * Math.sin(angle)];
	};
	Radar$1.prototype.pointToData = function(pt) {
		var dx = pt[0] - this.cx;
		var dy = pt[1] - this.cy;
		var radius = Math.sqrt(dx * dx + dy * dy);
		dx /= radius;
		dy /= radius;
		var radian = Math.atan2(-dy, dx);
		var minRadianDiff = Infinity;
		var closestAxis;
		var closestAxisIdx = -1;
		for (var i$1 = 0; i$1 < this._indicatorAxes.length; i$1++) {
			var indicatorAxis = this._indicatorAxes[i$1];
			var diff = Math.abs(radian - indicatorAxis.angle);
			if (diff < minRadianDiff) {
				closestAxis = indicatorAxis;
				closestAxisIdx = i$1;
				minRadianDiff = diff;
			}
		}
		return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
	};
	Radar$1.prototype.resize = function(radarModel, api) {
		var refContainer = createBoxLayoutReference(radarModel, api).refContainer;
		var center$2 = radarModel.get("center");
		var viewSize = Math.min(refContainer.width, refContainer.height) / 2;
		this.cx = parsePercent$1(center$2[0], refContainer.width) + refContainer.x;
		this.cy = parsePercent$1(center$2[1], refContainer.height) + refContainer.y;
		this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
		var radius = radarModel.get("radius");
		if (isString(radius) || isNumber(radius)) radius = [0, radius];
		this.r0 = parsePercent$1(radius[0], viewSize);
		this.r = parsePercent$1(radius[1], viewSize);
		each(this._indicatorAxes, function(indicatorAxis, idx) {
			indicatorAxis.setExtent(this.r0, this.r);
			var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
			angle = Math.atan2(Math.sin(angle), Math.cos(angle));
			indicatorAxis.angle = angle;
		}, this);
	};
	Radar$1.prototype.update = function(ecModel, api) {
		var indicatorAxes = this._indicatorAxes;
		var radarModel = this._model;
		each(indicatorAxes, function(indicatorAxis) {
			indicatorAxis.scale.setExtent(Infinity, -Infinity);
		});
		ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
			if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) return;
			var data = radarSeries.getData();
			each(indicatorAxes, function(indicatorAxis) {
				indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
			});
		}, this);
		var splitNumber = radarModel.get("splitNumber");
		var dummyScale = new Interval_default();
		dummyScale.setExtent(0, splitNumber);
		dummyScale.setInterval(1);
		each(indicatorAxes, function(indicatorAxis, idx) {
			alignScaleTicks(indicatorAxis.scale, indicatorAxis.model, dummyScale);
		});
	};
	Radar$1.prototype.convertToPixel = function(ecModel, finder, value) {
		console.warn("Not implemented.");
		return null;
	};
	Radar$1.prototype.convertFromPixel = function(ecModel, finder, pixel) {
		console.warn("Not implemented.");
		return null;
	};
	Radar$1.prototype.containPoint = function(point) {
		console.warn("Not implemented.");
		return false;
	};
	Radar$1.create = function(ecModel, api) {
		var radarList = [];
		ecModel.eachComponent("radar", function(radarModel) {
			var radar = new Radar$1(radarModel, ecModel, api);
			radarList.push(radar);
			radarModel.coordinateSystem = radar;
		});
		ecModel.eachSeriesByType("radar", function(radarSeries) {
			if (radarSeries.get("coordinateSystem") === "radar") radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
		});
		return radarList;
	};
	/**
	* Radar dimensions is based on the data
	*/
	Radar$1.dimensions = [];
	return Radar$1;
}();
var Radar_default = Radar;

//#endregion
//#region node_modules/echarts/lib/component/radar/install.js
function install$57(registers) {
	registers.registerCoordinateSystem("radar", Radar_default);
	registers.registerComponentModel(RadarModel_default);
	registers.registerComponentView(RadarView_default$1);
	registers.registerVisual({
		seriesType: "radar",
		reset: function(seriesModel) {
			var data = seriesModel.getData();
			data.each(function(idx) {
				data.setItemVisual(idx, "legendIcon", "roundRect");
			});
			data.setVisual("legendIcon", "roundRect");
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/radar/install.js
function install$6(registers) {
	use(install$57);
	registers.registerChartView(RadarView_default);
	registers.registerSeriesModel(RadarSeries_default);
	registers.registerLayout(radarLayout);
	registers.registerProcessor(dataFilter$1("radar"));
	registers.registerPreprocessor(radarBackwardCompat);
}

//#endregion
//#region node_modules/echarts/lib/component/helper/interactionMutex.js
var inner$16 = makeInner();
function take(zr, resourceKey, userKey) {
	inner$16(zr)[resourceKey] = userKey;
}
function release(zr, resourceKey, userKey) {
	var store = inner$16(zr);
	if (store[resourceKey] === userKey) store[resourceKey] = null;
}
function isTaken(zr, resourceKey) {
	return !!inner$16(zr)[resourceKey];
}
/**
* payload: {
*     type: 'takeGlobalCursor',
*     key: 'dataZoomSelect', or 'brush', or ...,
*         If no userKey, release global cursor.
* }
*/
registerAction({
	type: "takeGlobalCursor",
	event: "globalCursorTaken",
	update: "update"
}, noop);

//#endregion
//#region node_modules/echarts/lib/component/helper/cursorHelper.js
var IRRELEVANT_EXCLUDES = {
	"axisPointer": 1,
	"tooltip": 1,
	"brush": 1
};
/**
* Used on roam/brush triggering determination.
* This is to avoid that: mouse clicking on an elements that is over geo or graph,
* but roam is triggered unexpectedly.
*/
function onIrrelevantElement(e$1, api, targetComponent) {
	var eventElComponent = api.getComponentByElement(e$1.topTarget);
	if (!eventElComponent || eventElComponent === targetComponent || IRRELEVANT_EXCLUDES.hasOwnProperty(eventElComponent.mainType)) return false;
	var eventElCoordSys = eventElComponent.coordinateSystem;
	if (!eventElCoordSys || eventElCoordSys.model === targetComponent) return false;
	var eventElCmptZInfo = retrieveZInfo(eventElComponent);
	var targetCmptZInfo = retrieveZInfo(targetComponent);
	if ((eventElCmptZInfo.zlevel - targetCmptZInfo.zlevel || eventElCmptZInfo.z - targetCmptZInfo.z) <= 0) return false;
	return true;
}

//#endregion
//#region node_modules/echarts/lib/component/helper/RoamController.js
/**
* An manager of zoom and pan(darg) hehavior.
* But it is not responsible for updating the view, since view updates vary and can
* not be handled in a uniform way.
*
* Note: regarding view updates:
*  - Transformabe views typically use `coord/View` (e.g., geo and series.graph roaming).
*    Some commonly used view update logic has been organized into `roamHelper.ts`.
*  - Non-transformable views handle updates themselves, possibly involving re-layout,
*    (e.g., treemap).
*  - Some scenarios do not require transformation (e.g., dataZoom roaming for cartesian,
*    brush component).
*/
var RoamController = function(_super) {
	__extends(RoamController$1, _super);
	function RoamController$1(zr) {
		var _this = _super.call(this) || this;
		_this._zr = zr;
		var mousedownHandler = bind(_this._mousedownHandler, _this);
		var mousemoveHandler = bind(_this._mousemoveHandler, _this);
		var mouseupHandler = bind(_this._mouseupHandler, _this);
		var mousewheelHandler = bind(_this._mousewheelHandler, _this);
		var pinchHandler = bind(_this._pinchHandler, _this);
		/**
		* Notice:
		*  - only enable needed types. For example, if 'zoom'
		*    is not needed, 'zoom' should not be enabled, otherwise
		*    default mousewheel behaviour (scroll page) will be disabled.
		*  - This method is idempotent.
		*/
		_this.enable = function(controlType, rawOpt) {
			var zInfo = rawOpt.zInfo;
			var _a$1 = retrieveZInfo(zInfo.component), z = _a$1.z, zlevel = _a$1.zlevel;
			var zInfoParsed = {
				component: zInfo.component,
				z,
				zlevel,
				z2: retrieve2(zInfo.z2, -Infinity)
			};
			var triggerInfo = extend({}, rawOpt.triggerInfo);
			this._opt = defaults(extend({}, rawOpt), {
				zoomOnMouseWheel: true,
				moveOnMouseMove: true,
				moveOnMouseWheel: false,
				preventDefaultMouseMove: true,
				zInfoParsed,
				triggerInfo
			});
			if (controlType == null) controlType = true;
			if (!this._enabled || this._controlType !== controlType) {
				this._enabled = true;
				this.disable();
				if (controlType === true || controlType === "move" || controlType === "pan") {
					addRoamZrListener(zr, "mousedown", mousedownHandler, zInfoParsed);
					addRoamZrListener(zr, "mousemove", mousemoveHandler, zInfoParsed);
					addRoamZrListener(zr, "mouseup", mouseupHandler, zInfoParsed);
				}
				if (controlType === true || controlType === "scale" || controlType === "zoom") {
					addRoamZrListener(zr, "mousewheel", mousewheelHandler, zInfoParsed);
					addRoamZrListener(zr, "pinch", pinchHandler, zInfoParsed);
				}
			}
		};
		_this.disable = function() {
			this._enabled = false;
			removeRoamZrListener(zr, "mousedown", mousedownHandler);
			removeRoamZrListener(zr, "mousemove", mousemoveHandler);
			removeRoamZrListener(zr, "mouseup", mouseupHandler);
			removeRoamZrListener(zr, "mousewheel", mousewheelHandler);
			removeRoamZrListener(zr, "pinch", pinchHandler);
		};
		return _this;
	}
	RoamController$1.prototype.isDragging = function() {
		return this._dragging;
	};
	RoamController$1.prototype.isPinching = function() {
		return this._pinching;
	};
	RoamController$1.prototype._checkPointer = function(e$1, x, y) {
		var opt = this._opt;
		var zInfoParsed = opt.zInfoParsed;
		if (onIrrelevantElement(e$1, opt.api, zInfoParsed.component)) return false;
		var triggerInfo = opt.triggerInfo;
		var roamTrigger = triggerInfo.roamTrigger;
		var inArea = false;
		if (roamTrigger === "global") inArea = true;
		if (!inArea) inArea = triggerInfo.isInSelf(e$1, x, y);
		if (inArea && triggerInfo.isInClip && !triggerInfo.isInClip(e$1, x, y)) inArea = false;
		return inArea;
	};
	RoamController$1.prototype._decideCursorStyle = function(e$1, x, y, forReverse) {
		var target = e$1.target;
		if (!target && this._checkPointer(e$1, x, y)) return "grab";
		if (forReverse) return target && target.cursor || "default";
	};
	RoamController$1.prototype.dispose = function() {
		this.disable();
	};
	RoamController$1.prototype._mousedownHandler = function(e$1) {
		if (isMiddleOrRightButtonOnMouseUpDown(e$1) || eventConsumed(e$1)) return;
		var el = e$1.target;
		while (el) {
			if (el.draggable) return;
			el = el.__hostTarget || el.parent;
		}
		var x = e$1.offsetX;
		var y = e$1.offsetY;
		if (this._checkPointer(e$1, x, y)) {
			this._x = x;
			this._y = y;
			this._dragging = true;
		}
	};
	RoamController$1.prototype._mousemoveHandler = function(e$1) {
		var zr = this._zr;
		if (e$1.gestureEvent === "pinch" || isTaken(zr, "globalPan") || eventConsumed(e$1)) return;
		var x = e$1.offsetX;
		var y = e$1.offsetY;
		if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e$1, this._opt)) {
			var cursorStyle = this._decideCursorStyle(e$1, x, y, false);
			if (cursorStyle) zr.setCursorStyle(cursorStyle);
			return;
		}
		zr.setCursorStyle("grabbing");
		var oldX = this._x;
		var oldY = this._y;
		var dx = x - oldX;
		var dy = y - oldY;
		this._x = x;
		this._y = y;
		if (this._opt.preventDefaultMouseMove) stop(e$1.event);
		e$1.__ecRoamConsumed = true;
		trigger$1(this, "pan", "moveOnMouseMove", e$1, {
			dx,
			dy,
			oldX,
			oldY,
			newX: x,
			newY: y,
			isAvailableBehavior: null
		});
	};
	RoamController$1.prototype._mouseupHandler = function(e$1) {
		if (eventConsumed(e$1)) return;
		var zr = this._zr;
		if (!isMiddleOrRightButtonOnMouseUpDown(e$1)) {
			this._dragging = false;
			var cursorStyle = this._decideCursorStyle(e$1, e$1.offsetX, e$1.offsetY, true);
			if (cursorStyle) zr.setCursorStyle(cursorStyle);
		}
	};
	RoamController$1.prototype._mousewheelHandler = function(e$1) {
		if (eventConsumed(e$1)) return;
		var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e$1, this._opt);
		var shouldMove = isAvailableBehavior("moveOnMouseWheel", e$1, this._opt);
		var wheelDelta = e$1.wheelDelta;
		var absWheelDeltaDelta = Math.abs(wheelDelta);
		var originX = e$1.offsetX;
		var originY = e$1.offsetY;
		if (wheelDelta === 0 || !shouldZoom && !shouldMove) return;
		if (shouldZoom) {
			var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
			var scale$3 = wheelDelta > 0 ? factor : 1 / factor;
			this._checkTriggerMoveZoom(this, "zoom", "zoomOnMouseWheel", e$1, {
				scale: scale$3,
				originX,
				originY,
				isAvailableBehavior: null
			});
		}
		if (shouldMove) {
			var absDelta = Math.abs(wheelDelta);
			var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? .4 : absDelta > 1 ? .15 : .05);
			this._checkTriggerMoveZoom(this, "scrollMove", "moveOnMouseWheel", e$1, {
				scrollDelta,
				originX,
				originY,
				isAvailableBehavior: null
			});
		}
	};
	RoamController$1.prototype._pinchHandler = function(e$1) {
		if (isTaken(this._zr, "globalPan") || eventConsumed(e$1)) return;
		var scale$3 = e$1.pinchScale > 1 ? 1.1 : 1 / 1.1;
		this._checkTriggerMoveZoom(this, "zoom", null, e$1, {
			scale: scale$3,
			originX: e$1.pinchX,
			originY: e$1.pinchY,
			isAvailableBehavior: null
		});
	};
	RoamController$1.prototype._checkTriggerMoveZoom = function(controller, eventName, behaviorToCheck, e$1, contollerEvent) {
		if (controller._checkPointer(e$1, contollerEvent.originX, contollerEvent.originY)) {
			stop(e$1.event);
			e$1.__ecRoamConsumed = true;
			trigger$1(controller, eventName, behaviorToCheck, e$1, contollerEvent);
		}
	};
	return RoamController$1;
}(Eventful_default);
function eventConsumed(e$1) {
	return e$1.__ecRoamConsumed;
}
var innerZrStore = makeInner();
function ensureZrStore(zr) {
	var store = innerZrStore(zr);
	store.roam = store.roam || {};
	store.uniform = store.uniform || {};
	return store;
}
/**
* Listeners are sorted by z2/z/zlevel in descending order.
* This decides the precedence between different roam controllers if they are overlapped.
*
* [MEMO]: It's not easy to perfectly reconcile the conflicts caused by overlap.
*  - Consider cases:
*    - Multiple roam controllers overlapped.
*      - Usually only the topmost can trigger roam.
*    - Roam controllers overlap with other zr elements:
*      - zr elements are relevant or irrelevent to the host of the roam controller. e.g., axis split line
*        or series elements is relevant to a cartesian and should trigger roam.
*      - zr elements is above or below the roam controller host, which affects the precedence of interaction.
*      - zr elements may not silent only for triggering tooltip by hovering, which is available to roam;
*        or may not silent for click, where roam is not preferable.
*  - Approach - `addRoamZrListener+pointerChecker+onIrrelevantElement` (currently used):
*    - Resolve the precedence between different roam controllers
*    - But cannot prevent the handling on other zr elements that under the roam controller in z-order.
*  - Approach - "use an invisible zr elements to receive the zr events to trigger roam":
*    - More complicated in impl.
*    - May cause bad cases where zr event cannot be receive due to other non-silient zr elements covering it.
*/
function addRoamZrListener(zr, eventType, listener, zInfoParsed) {
	var roam = ensureZrStore(zr).roam;
	var listenerList = roam[eventType] = roam[eventType] || [];
	var idx = 0;
	for (; idx < listenerList.length; idx++) {
		var currZInfo = listenerList[idx].zInfoParsed;
		if ((currZInfo.zlevel - zInfoParsed.zlevel || currZInfo.z - zInfoParsed.z || currZInfo.z2 - zInfoParsed.z2) <= 0) break;
	}
	listenerList.splice(idx, 0, {
		listener,
		zInfoParsed
	});
	ensureUniformListener(zr, eventType);
}
function removeRoamZrListener(zr, eventType, listener) {
	var listenerList = ensureZrStore(zr).roam[eventType] || [];
	for (var idx = 0; idx < listenerList.length; idx++) if (listenerList[idx].listener === listener) {
		listenerList.splice(idx, 1);
		if (!listenerList.length) removeUniformListener(zr, eventType);
		return;
	}
}
function ensureUniformListener(zr, eventType) {
	var store = ensureZrStore(zr);
	if (!store.uniform[eventType]) zr.on(eventType, store.uniform[eventType] = function(event) {
		var listenerList = store.roam[eventType];
		if (listenerList) for (var i$1 = 0; i$1 < listenerList.length; i$1++) listenerList[i$1].listener(event);
	});
}
function removeUniformListener(zr, eventType) {
	var uniform = ensureZrStore(zr).uniform;
	if (uniform[eventType]) {
		zr.off(eventType, uniform[eventType]);
		uniform[eventType] = null;
	}
}
function trigger$1(controller, eventName, behaviorToCheck, e$1, contollerEvent) {
	contollerEvent.isAvailableBehavior = bind(isAvailableBehavior, null, behaviorToCheck, e$1);
	controller.trigger(eventName, contollerEvent);
}
function isAvailableBehavior(behaviorToCheck, e$1, settings) {
	var setting = settings[behaviorToCheck];
	return !behaviorToCheck || setting && (!isString(setting) || e$1.event[setting + "Key"]);
}
var RoamController_default = RoamController;

//#endregion
//#region node_modules/echarts/lib/component/helper/roamHelper.js
/**
* [CAVEAT] `updateViewOnPan` and `updateViewOnZoom` modifies the group transform directly,
*  but the 'center' and 'zoom' in echarts option and 'View' coordinate system are not updated yet,
*  which must be performed later in 'xxxRoam' action by calling `updateCenterAndZoom`.
* @see {updateCenterAndZoomInAction}
*/
function updateViewOnPan(controllerHost, dx, dy) {
	var target = controllerHost.target;
	target.x += dx;
	target.y += dy;
	target.dirty();
}
function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
	var target = controllerHost.target;
	var zoomLimit = controllerHost.zoomLimit;
	var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
	newZoom *= zoomDelta;
	newZoom = clampByZoomLimit(newZoom, zoomLimit);
	var zoomScale = newZoom / controllerHost.zoom;
	controllerHost.zoom = newZoom;
	zoomTransformableByOrigin(target, zoomX, zoomY, zoomScale);
	target.dirty();
}
/**
* A abstraction for some similar impl in roaming.
*/
function updateController(seriesModel, api, pointerCheckerEl, controller, controllerHost, clipRect) {
	var tmpRect$2 = new BoundingRect_default(0, 0, 0, 0);
	controller.enable(seriesModel.get("roam"), {
		api,
		zInfo: { component: seriesModel },
		triggerInfo: {
			roamTrigger: seriesModel.get("roamTrigger"),
			isInSelf: function(e$1, x, y) {
				tmpRect$2.copy(pointerCheckerEl.getBoundingRect());
				tmpRect$2.applyTransform(pointerCheckerEl.getComputedTransform());
				return tmpRect$2.contain(x, y);
			},
			isInClip: function(e$1, x, y) {
				return !clipRect || clipRect.contain(x, y);
			}
		}
	});
	controllerHost.zoomLimit = seriesModel.get("scaleLimit");
	var coordinate = seriesModel.coordinateSystem;
	controllerHost.zoom = coordinate ? coordinate.getZoom() : 1;
	var type = seriesModel.subType + "Roam";
	controller.off("pan").off("zoom").on("pan", function(e$1) {
		updateViewOnPan(controllerHost, e$1.dx, e$1.dy);
		api.dispatchAction({
			seriesId: seriesModel.id,
			type,
			dx: e$1.dx,
			dy: e$1.dy
		});
	}).on("zoom", function(e$1) {
		/**
		* FIXME: should do nothing except `api.dispatchAction` here, the other logic
		*  should be performed in the action handler and `updateTransform`; otherwise,
		*  they are inconsistent if user triggers this action explicitly.
		*/
		updateViewOnZoom(controllerHost, e$1.scale, e$1.originX, e$1.originY);
		api.dispatchAction({
			seriesId: seriesModel.id,
			type,
			zoom: e$1.scale,
			originX: e$1.originX,
			originY: e$1.originY
		});
		api.updateLabelLayout();
	});
}
function getCenterCoord(view, point) {
	return view.pointToProjected ? view.pointToProjected(point) : view.pointToData(point);
}
/**
* Should be called only in action handler.
* @see {updateViewOnPan|updateViewOnZoom}
*/
function updateCenterAndZoomInAction(view, payload, zoomLimit) {
	var previousZoom = view.getZoom();
	var center$2 = view.getCenter();
	var deltaZoom = payload.zoom;
	var point = view.projectedToPoint ? view.projectedToPoint(center$2) : view.dataToPoint(center$2);
	if (payload.dx != null && payload.dy != null) {
		point[0] -= payload.dx;
		point[1] -= payload.dy;
		view.setCenter(getCenterCoord(view, point));
	}
	if (deltaZoom != null) {
		deltaZoom = clampByZoomLimit(previousZoom * deltaZoom, zoomLimit) / previousZoom;
		zoomTransformableByOrigin(view, payload.originX, payload.originY, deltaZoom);
		view.updateTransform();
		view.setCenter(getCenterCoord(view, point));
		view.setZoom(deltaZoom * previousZoom);
	}
	return {
		center: view.getCenter(),
		zoom: view.getZoom()
	};
}
function zoomTransformableByOrigin(target, originX, originY, deltaZoom) {
	target.x -= (originX - target.x) * (deltaZoom - 1);
	target.y -= (originY - target.y) * (deltaZoom - 1);
	target.scaleX *= deltaZoom;
	target.scaleY *= deltaZoom;
}
function clampByZoomLimit(zoom, zoomLimit) {
	if (zoomLimit) {
		var zoomMin = zoomLimit.min || 0;
		var zoomMax = zoomLimit.max || Infinity;
		zoom = Math.max(Math.min(zoomMax, zoom), zoomMin);
	}
	return zoom;
}

//#endregion
//#region node_modules/zrender/lib/tool/parseXML.js
function parseXML(svg) {
	if (isString(svg)) svg = new DOMParser().parseFromString(svg, "text/xml");
	var svgNode = svg;
	if (svgNode.nodeType === 9) svgNode = svgNode.firstChild;
	while (svgNode.nodeName.toLowerCase() !== "svg" || svgNode.nodeType !== 1) svgNode = svgNode.nextSibling;
	return svgNode;
}

//#endregion
//#region node_modules/zrender/lib/tool/parseSVG.js
var nodeParsers;
var INHERITABLE_STYLE_ATTRIBUTES_MAP = {
	"fill": "fill",
	"stroke": "stroke",
	"stroke-width": "lineWidth",
	"opacity": "opacity",
	"fill-opacity": "fillOpacity",
	"stroke-opacity": "strokeOpacity",
	"stroke-dasharray": "lineDash",
	"stroke-dashoffset": "lineDashOffset",
	"stroke-linecap": "lineCap",
	"stroke-linejoin": "lineJoin",
	"stroke-miterlimit": "miterLimit",
	"font-family": "fontFamily",
	"font-size": "fontSize",
	"font-style": "fontStyle",
	"font-weight": "fontWeight",
	"text-anchor": "textAlign",
	"visibility": "visibility",
	"display": "display"
};
var INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP);
var SELF_STYLE_ATTRIBUTES_MAP = {
	"alignment-baseline": "textBaseline",
	"stop-color": "stopColor"
};
var SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP);
var SVGParser = function() {
	function SVGParser$1() {
		this._defs = {};
		this._root = null;
	}
	SVGParser$1.prototype.parse = function(xml, opt) {
		opt = opt || {};
		var svg = parseXML(xml);
		if (!svg) throw new Error("Illegal svg");
		this._defsUsePending = [];
		var root = new Group_default();
		this._root = root;
		var named = [];
		var viewBox = svg.getAttribute("viewBox") || "";
		var width = parseFloat(svg.getAttribute("width") || opt.width);
		var height = parseFloat(svg.getAttribute("height") || opt.height);
		isNaN(width) && (width = null);
		isNaN(height) && (height = null);
		parseAttributes(svg, root, null, true, false);
		var child = svg.firstChild;
		while (child) {
			this._parseNode(child, root, named, null, false, false);
			child = child.nextSibling;
		}
		applyDefs(this._defs, this._defsUsePending);
		this._defsUsePending = [];
		var viewBoxRect;
		var viewBoxTransform;
		if (viewBox) {
			var viewBoxArr = splitNumberSequence(viewBox);
			if (viewBoxArr.length >= 4) viewBoxRect = {
				x: parseFloat(viewBoxArr[0] || 0),
				y: parseFloat(viewBoxArr[1] || 0),
				width: parseFloat(viewBoxArr[2]),
				height: parseFloat(viewBoxArr[3])
			};
		}
		if (viewBoxRect && width != null && height != null) {
			viewBoxTransform = makeViewBoxTransform(viewBoxRect, {
				x: 0,
				y: 0,
				width,
				height
			});
			if (!opt.ignoreViewBox) {
				var elRoot = root;
				root = new Group_default();
				root.add(elRoot);
				elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
				elRoot.x = viewBoxTransform.x;
				elRoot.y = viewBoxTransform.y;
			}
		}
		if (!opt.ignoreRootClip && width != null && height != null) root.setClipPath(new Rect_default({ shape: {
			x: 0,
			y: 0,
			width,
			height
		} }));
		return {
			root,
			width,
			height,
			viewBoxRect,
			viewBoxTransform,
			named
		};
	};
	SVGParser$1.prototype._parseNode = function(xmlNode, parentGroup, named, namedFrom, isInDefs, isInText) {
		var nodeName = xmlNode.nodeName.toLowerCase();
		var el;
		var namedFromForSub = namedFrom;
		if (nodeName === "defs") isInDefs = true;
		if (nodeName === "text") isInText = true;
		if (nodeName === "defs" || nodeName === "switch") el = parentGroup;
		else {
			if (!isInDefs) {
				var parser_1 = nodeParsers[nodeName];
				if (parser_1 && hasOwn(nodeParsers, nodeName)) {
					el = parser_1.call(this, xmlNode, parentGroup);
					var nameAttr = xmlNode.getAttribute("name");
					if (nameAttr) {
						var newNamed = {
							name: nameAttr,
							namedFrom: null,
							svgNodeTagLower: nodeName,
							el
						};
						named.push(newNamed);
						if (nodeName === "g") namedFromForSub = newNamed;
					} else if (namedFrom) named.push({
						name: namedFrom.name,
						namedFrom,
						svgNodeTagLower: nodeName,
						el
					});
					parentGroup.add(el);
				}
			}
			var parser = paintServerParsers[nodeName];
			if (parser && hasOwn(paintServerParsers, nodeName)) {
				var def = parser.call(this, xmlNode);
				var id = xmlNode.getAttribute("id");
				if (id) this._defs[id] = def;
			}
		}
		if (el && el.isGroup) {
			var child = xmlNode.firstChild;
			while (child) {
				if (child.nodeType === 1) this._parseNode(child, el, named, namedFromForSub, isInDefs, isInText);
				else if (child.nodeType === 3 && isInText) this._parseText(child, el);
				child = child.nextSibling;
			}
		}
	};
	SVGParser$1.prototype._parseText = function(xmlNode, parentGroup) {
		var text = new TSpan_default({
			style: { text: xmlNode.textContent },
			silent: true,
			x: this._textX || 0,
			y: this._textY || 0
		});
		inheritStyle(parentGroup, text);
		parseAttributes(xmlNode, text, this._defsUsePending, false, false);
		applyTextAlignment(text, parentGroup);
		var textStyle = text.style;
		var fontSize = textStyle.fontSize;
		if (fontSize && fontSize < 9) {
			textStyle.fontSize = 9;
			text.scaleX *= fontSize / 9;
			text.scaleY *= fontSize / 9;
		}
		textStyle.font = (textStyle.fontSize || textStyle.fontFamily) && [
			textStyle.fontStyle,
			textStyle.fontWeight,
			(textStyle.fontSize || 12) + "px",
			textStyle.fontFamily || "sans-serif"
		].join(" ");
		var rect = text.getBoundingRect();
		this._textX += rect.width;
		parentGroup.add(text);
		return text;
	};
	SVGParser$1.internalField = (function() {
		nodeParsers = {
			"g": function(xmlNode, parentGroup) {
				var g = new Group_default();
				inheritStyle(parentGroup, g);
				parseAttributes(xmlNode, g, this._defsUsePending, false, false);
				return g;
			},
			"rect": function(xmlNode, parentGroup) {
				var rect = new Rect_default();
				inheritStyle(parentGroup, rect);
				parseAttributes(xmlNode, rect, this._defsUsePending, false, false);
				rect.setShape({
					x: parseFloat(xmlNode.getAttribute("x") || "0"),
					y: parseFloat(xmlNode.getAttribute("y") || "0"),
					width: parseFloat(xmlNode.getAttribute("width") || "0"),
					height: parseFloat(xmlNode.getAttribute("height") || "0")
				});
				rect.silent = true;
				return rect;
			},
			"circle": function(xmlNode, parentGroup) {
				var circle = new Circle_default();
				inheritStyle(parentGroup, circle);
				parseAttributes(xmlNode, circle, this._defsUsePending, false, false);
				circle.setShape({
					cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
					cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
					r: parseFloat(xmlNode.getAttribute("r") || "0")
				});
				circle.silent = true;
				return circle;
			},
			"line": function(xmlNode, parentGroup) {
				var line = new Line_default();
				inheritStyle(parentGroup, line);
				parseAttributes(xmlNode, line, this._defsUsePending, false, false);
				line.setShape({
					x1: parseFloat(xmlNode.getAttribute("x1") || "0"),
					y1: parseFloat(xmlNode.getAttribute("y1") || "0"),
					x2: parseFloat(xmlNode.getAttribute("x2") || "0"),
					y2: parseFloat(xmlNode.getAttribute("y2") || "0")
				});
				line.silent = true;
				return line;
			},
			"ellipse": function(xmlNode, parentGroup) {
				var ellipse = new Ellipse_default();
				inheritStyle(parentGroup, ellipse);
				parseAttributes(xmlNode, ellipse, this._defsUsePending, false, false);
				ellipse.setShape({
					cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
					cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
					rx: parseFloat(xmlNode.getAttribute("rx") || "0"),
					ry: parseFloat(xmlNode.getAttribute("ry") || "0")
				});
				ellipse.silent = true;
				return ellipse;
			},
			"polygon": function(xmlNode, parentGroup) {
				var pointsStr = xmlNode.getAttribute("points");
				var pointsArr;
				if (pointsStr) pointsArr = parsePoints(pointsStr);
				var polygon = new Polygon_default({
					shape: { points: pointsArr || [] },
					silent: true
				});
				inheritStyle(parentGroup, polygon);
				parseAttributes(xmlNode, polygon, this._defsUsePending, false, false);
				return polygon;
			},
			"polyline": function(xmlNode, parentGroup) {
				var pointsStr = xmlNode.getAttribute("points");
				var pointsArr;
				if (pointsStr) pointsArr = parsePoints(pointsStr);
				var polyline = new Polyline_default({
					shape: { points: pointsArr || [] },
					silent: true
				});
				inheritStyle(parentGroup, polyline);
				parseAttributes(xmlNode, polyline, this._defsUsePending, false, false);
				return polyline;
			},
			"image": function(xmlNode, parentGroup) {
				var img = new Image_default();
				inheritStyle(parentGroup, img);
				parseAttributes(xmlNode, img, this._defsUsePending, false, false);
				img.setStyle({
					image: xmlNode.getAttribute("xlink:href") || xmlNode.getAttribute("href"),
					x: +xmlNode.getAttribute("x"),
					y: +xmlNode.getAttribute("y"),
					width: +xmlNode.getAttribute("width"),
					height: +xmlNode.getAttribute("height")
				});
				img.silent = true;
				return img;
			},
			"text": function(xmlNode, parentGroup) {
				var x = xmlNode.getAttribute("x") || "0";
				var y = xmlNode.getAttribute("y") || "0";
				var dx = xmlNode.getAttribute("dx") || "0";
				var dy = xmlNode.getAttribute("dy") || "0";
				this._textX = parseFloat(x) + parseFloat(dx);
				this._textY = parseFloat(y) + parseFloat(dy);
				var g = new Group_default();
				inheritStyle(parentGroup, g);
				parseAttributes(xmlNode, g, this._defsUsePending, false, true);
				return g;
			},
			"tspan": function(xmlNode, parentGroup) {
				var x = xmlNode.getAttribute("x");
				var y = xmlNode.getAttribute("y");
				if (x != null) this._textX = parseFloat(x);
				if (y != null) this._textY = parseFloat(y);
				var dx = xmlNode.getAttribute("dx") || "0";
				var dy = xmlNode.getAttribute("dy") || "0";
				var g = new Group_default();
				inheritStyle(parentGroup, g);
				parseAttributes(xmlNode, g, this._defsUsePending, false, true);
				this._textX += parseFloat(dx);
				this._textY += parseFloat(dy);
				return g;
			},
			"path": function(xmlNode, parentGroup) {
				var path = createFromString(xmlNode.getAttribute("d") || "");
				inheritStyle(parentGroup, path);
				parseAttributes(xmlNode, path, this._defsUsePending, false, false);
				path.silent = true;
				return path;
			}
		};
	})();
	return SVGParser$1;
}();
var paintServerParsers = {
	"lineargradient": function(xmlNode) {
		var gradient = new LinearGradient_default(parseInt(xmlNode.getAttribute("x1") || "0", 10), parseInt(xmlNode.getAttribute("y1") || "0", 10), parseInt(xmlNode.getAttribute("x2") || "10", 10), parseInt(xmlNode.getAttribute("y2") || "0", 10));
		parsePaintServerUnit(xmlNode, gradient);
		parseGradientColorStops(xmlNode, gradient);
		return gradient;
	},
	"radialgradient": function(xmlNode) {
		var gradient = new RadialGradient_default(parseInt(xmlNode.getAttribute("cx") || "0", 10), parseInt(xmlNode.getAttribute("cy") || "0", 10), parseInt(xmlNode.getAttribute("r") || "0", 10));
		parsePaintServerUnit(xmlNode, gradient);
		parseGradientColorStops(xmlNode, gradient);
		return gradient;
	}
};
function parsePaintServerUnit(xmlNode, gradient) {
	if (xmlNode.getAttribute("gradientUnits") === "userSpaceOnUse") gradient.global = true;
}
function parseGradientColorStops(xmlNode, gradient) {
	var stop$1 = xmlNode.firstChild;
	while (stop$1) {
		if (stop$1.nodeType === 1 && stop$1.nodeName.toLocaleLowerCase() === "stop") {
			var offsetStr = stop$1.getAttribute("offset");
			var offset = void 0;
			if (offsetStr && offsetStr.indexOf("%") > 0) offset = parseInt(offsetStr, 10) / 100;
			else if (offsetStr) offset = parseFloat(offsetStr);
			else offset = 0;
			var styleVals = {};
			parseInlineStyle(stop$1, styleVals, styleVals);
			var stopColor = styleVals.stopColor || stop$1.getAttribute("stop-color") || "#000000";
			var stopOpacity = styleVals.stopOpacity || stop$1.getAttribute("stop-opacity");
			if (stopOpacity) {
				var rgba = parse(stopColor);
				if (rgba && rgba[3]) {
					rgba[3] *= parseCssFloat(stopOpacity);
					stopColor = stringify(rgba, "rgba");
				}
			}
			gradient.colorStops.push({
				offset,
				color: stopColor
			});
		}
		stop$1 = stop$1.nextSibling;
	}
}
function inheritStyle(parent, child) {
	if (parent && parent.__inheritedStyle) {
		if (!child.__inheritedStyle) child.__inheritedStyle = {};
		defaults(child.__inheritedStyle, parent.__inheritedStyle);
	}
}
function parsePoints(pointsString) {
	var list = splitNumberSequence(pointsString);
	var points$3 = [];
	for (var i$1 = 0; i$1 < list.length; i$1 += 2) {
		var x = parseFloat(list[i$1]);
		var y = parseFloat(list[i$1 + 1]);
		points$3.push([x, y]);
	}
	return points$3;
}
function parseAttributes(xmlNode, el, defsUsePending, onlyInlineStyle, isTextGroup) {
	var disp = el;
	var inheritedStyle = disp.__inheritedStyle = disp.__inheritedStyle || {};
	var selfStyle = {};
	if (xmlNode.nodeType === 1) {
		parseTransformAttribute(xmlNode, el);
		parseInlineStyle(xmlNode, inheritedStyle, selfStyle);
		if (!onlyInlineStyle) parseAttributeStyle(xmlNode, inheritedStyle, selfStyle);
	}
	disp.style = disp.style || {};
	if (inheritedStyle.fill != null) disp.style.fill = getFillStrokeStyle(disp, "fill", inheritedStyle.fill, defsUsePending);
	if (inheritedStyle.stroke != null) disp.style.stroke = getFillStrokeStyle(disp, "stroke", inheritedStyle.stroke, defsUsePending);
	each([
		"lineWidth",
		"opacity",
		"fillOpacity",
		"strokeOpacity",
		"miterLimit",
		"fontSize"
	], function(propName) {
		if (inheritedStyle[propName] != null) disp.style[propName] = parseFloat(inheritedStyle[propName]);
	});
	each([
		"lineDashOffset",
		"lineCap",
		"lineJoin",
		"fontWeight",
		"fontFamily",
		"fontStyle",
		"textAlign"
	], function(propName) {
		if (inheritedStyle[propName] != null) disp.style[propName] = inheritedStyle[propName];
	});
	if (isTextGroup) disp.__selfStyle = selfStyle;
	if (inheritedStyle.lineDash) disp.style.lineDash = map(splitNumberSequence(inheritedStyle.lineDash), function(str) {
		return parseFloat(str);
	});
	if (inheritedStyle.visibility === "hidden" || inheritedStyle.visibility === "collapse") disp.invisible = true;
	if (inheritedStyle.display === "none") disp.ignore = true;
}
function applyTextAlignment(text, parentGroup) {
	var parentSelfStyle = parentGroup.__selfStyle;
	if (parentSelfStyle) {
		var textBaseline = parentSelfStyle.textBaseline;
		var zrTextBaseline = textBaseline;
		if (!textBaseline || textBaseline === "auto") zrTextBaseline = "alphabetic";
		else if (textBaseline === "baseline") zrTextBaseline = "alphabetic";
		else if (textBaseline === "before-edge" || textBaseline === "text-before-edge") zrTextBaseline = "top";
		else if (textBaseline === "after-edge" || textBaseline === "text-after-edge") zrTextBaseline = "bottom";
		else if (textBaseline === "central" || textBaseline === "mathematical") zrTextBaseline = "middle";
		text.style.textBaseline = zrTextBaseline;
	}
	var parentInheritedStyle = parentGroup.__inheritedStyle;
	if (parentInheritedStyle) {
		var textAlign = parentInheritedStyle.textAlign;
		var zrTextAlign = textAlign;
		if (textAlign) {
			if (textAlign === "middle") zrTextAlign = "center";
			text.style.textAlign = zrTextAlign;
		}
	}
}
var urlRegex = /^url\(\s*#(.*?)\)/;
function getFillStrokeStyle(el, method, str, defsUsePending) {
	var urlMatch = str && str.match(urlRegex);
	if (urlMatch) {
		var url = trim(urlMatch[1]);
		defsUsePending.push([
			el,
			method,
			url
		]);
		return;
	}
	if (str === "none") str = null;
	return str;
}
function applyDefs(defs, defsUsePending) {
	for (var i$1 = 0; i$1 < defsUsePending.length; i$1++) {
		var item = defsUsePending[i$1];
		item[0].style[item[1]] = defs[item[2]];
	}
}
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(rawStr) {
	return rawStr.match(numberReg) || [];
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g;
var DEGREE_TO_ANGLE = Math.PI / 180;
function parseTransformAttribute(xmlNode, node) {
	var transform = xmlNode.getAttribute("transform");
	if (transform) {
		transform = transform.replace(/,/g, " ");
		var transformOps_1 = [];
		var mt = null;
		transform.replace(transformRegex, function(str, type$1, value$1) {
			transformOps_1.push(type$1, value$1);
			return "";
		});
		for (var i$1 = transformOps_1.length - 1; i$1 > 0; i$1 -= 2) {
			var value = transformOps_1[i$1];
			var type = transformOps_1[i$1 - 1];
			var valueArr = splitNumberSequence(value);
			mt = mt || create$2();
			switch (type) {
				case "translate":
					translate(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || "0")]);
					break;
				case "scale":
					scale$2(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);
					break;
				case "rotate":
					rotate(mt, mt, -parseFloat(valueArr[0]) * DEGREE_TO_ANGLE, [parseFloat(valueArr[1] || "0"), parseFloat(valueArr[2] || "0")]);
					break;
				case "skewX":
					var sx = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
					mul(mt, [
						1,
						0,
						sx,
						1,
						0,
						0
					], mt);
					break;
				case "skewY":
					var sy = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
					mul(mt, [
						1,
						sy,
						0,
						1,
						0,
						0
					], mt);
					break;
				case "matrix":
					mt[0] = parseFloat(valueArr[0]);
					mt[1] = parseFloat(valueArr[1]);
					mt[2] = parseFloat(valueArr[2]);
					mt[3] = parseFloat(valueArr[3]);
					mt[4] = parseFloat(valueArr[4]);
					mt[5] = parseFloat(valueArr[5]);
					break;
			}
		}
		node.setLocalTransform(mt);
	}
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseInlineStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
	var style = xmlNode.getAttribute("style");
	if (!style) return;
	styleRegex.lastIndex = 0;
	var styleRegResult;
	while ((styleRegResult = styleRegex.exec(style)) != null) {
		var svgStlAttr = styleRegResult[1];
		var zrInheritableStlAttr = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
		if (zrInheritableStlAttr) inheritableStyleResult[zrInheritableStlAttr] = styleRegResult[2];
		var zrSelfStlAttr = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? SELF_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
		if (zrSelfStlAttr) selfStyleResult[zrSelfStlAttr] = styleRegResult[2];
	}
}
function parseAttributeStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
	for (var i$1 = 0; i$1 < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; i$1++) {
		var svgAttrName = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[i$1];
		var attrValue = xmlNode.getAttribute(svgAttrName);
		if (attrValue != null) inheritableStyleResult[INHERITABLE_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
	}
	for (var i$1 = 0; i$1 < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; i$1++) {
		var svgAttrName = SELF_STYLE_ATTRIBUTES_MAP_KEYS[i$1];
		var attrValue = xmlNode.getAttribute(svgAttrName);
		if (attrValue != null) selfStyleResult[SELF_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
	}
}
function makeViewBoxTransform(viewBoxRect, boundingRect) {
	var scaleX = boundingRect.width / viewBoxRect.width;
	var scaleY = boundingRect.height / viewBoxRect.height;
	var scale$3 = Math.min(scaleX, scaleY);
	return {
		scale: scale$3,
		x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale$3 + (boundingRect.x + boundingRect.width / 2),
		y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale$3 + (boundingRect.y + boundingRect.height / 2)
	};
}
function parseSVG(xml, opt) {
	return new SVGParser().parse(xml, opt);
}

//#endregion
//#region node_modules/echarts/lib/coord/geo/GeoSVGResource.js
/**
* "region available" means that: enable users to set attribute `name="xxx"` on those tags
* to make it be a region.
* 1. region styles and its label styles can be defined in echarts opton:
* ```js
* geo: {
*     regions: [{
*         name: 'xxx',
*         itemStyle: { ... },
*         label: { ... }
*     }, {
*         ...
*     },
*     ...]
* };
* ```
* 2. name can be duplicated in different SVG tag. All of the tags with the same name share
* a region option. For exampel if there are two <path> representing two lung lobes. They have
* no common parents but both of them need to display label "lung" inside.
*/
var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
	"rect",
	"circle",
	"line",
	"ellipse",
	"polygon",
	"polyline",
	"path",
	"text",
	"tspan",
	"g"
]);
var GeoSVGResource = function() {
	function GeoSVGResource$1(mapName, svg) {
		this.type = "geoSVG";
		this._usedGraphicMap = createHashMap();
		this._freedGraphics = [];
		this._mapName = mapName;
		this._parsedXML = parseXML(svg);
	}
	GeoSVGResource$1.prototype.load = function() {
		var firstGraphic = this._firstGraphic;
		if (!firstGraphic) {
			firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);
			this._freedGraphics.push(firstGraphic);
			this._boundingRect = this._firstGraphic.boundingRect.clone();
			var _a$1 = createRegions(firstGraphic.named), regions = _a$1.regions, regionsMap = _a$1.regionsMap;
			this._regions = regions;
			this._regionsMap = regionsMap;
		}
		return {
			boundingRect: this._boundingRect,
			regions: this._regions,
			regionsMap: this._regionsMap
		};
	};
	GeoSVGResource$1.prototype._buildGraphic = function(svgXML) {
		var result;
		var rootFromParse;
		try {
			result = svgXML && parseSVG(svgXML, {
				ignoreViewBox: true,
				ignoreRootClip: true
			}) || {};
			rootFromParse = result.root;
			assert(rootFromParse != null);
		} catch (e$1) {
			throw new Error("Invalid svg format\n" + e$1.message);
		}
		var root = new Group_default();
		root.add(rootFromParse);
		root.isGeoSVGGraphicRoot = true;
		var svgWidth = result.width;
		var svgHeight = result.height;
		var viewBoxRect = result.viewBoxRect;
		var boundingRect = this._boundingRect;
		if (!boundingRect) {
			var bRectX = void 0;
			var bRectY = void 0;
			var bRectWidth = void 0;
			var bRectHeight = void 0;
			if (svgWidth != null) {
				bRectX = 0;
				bRectWidth = svgWidth;
			} else if (viewBoxRect) {
				bRectX = viewBoxRect.x;
				bRectWidth = viewBoxRect.width;
			}
			if (svgHeight != null) {
				bRectY = 0;
				bRectHeight = svgHeight;
			} else if (viewBoxRect) {
				bRectY = viewBoxRect.y;
				bRectHeight = viewBoxRect.height;
			}
			if (bRectX == null || bRectY == null) {
				var calculatedBoundingRect = rootFromParse.getBoundingRect();
				if (bRectX == null) {
					bRectX = calculatedBoundingRect.x;
					bRectWidth = calculatedBoundingRect.width;
				}
				if (bRectY == null) {
					bRectY = calculatedBoundingRect.y;
					bRectHeight = calculatedBoundingRect.height;
				}
			}
			boundingRect = this._boundingRect = new BoundingRect_default(bRectX, bRectY, bRectWidth, bRectHeight);
		}
		if (viewBoxRect) {
			var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect);
			rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;
			rootFromParse.x = viewBoxTransform.x;
			rootFromParse.y = viewBoxTransform.y;
		}
		root.setClipPath(new Rect_default({ shape: boundingRect.plain() }));
		var named = [];
		each(result.named, function(namedItem) {
			if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {
				named.push(namedItem);
				setSilent(namedItem.el);
			}
		});
		return {
			root,
			boundingRect,
			named
		};
	};
	/**
	* Consider:
	* (1) One graphic element can not be shared by different `geoView` running simultaneously.
	*     Notice, also need to consider multiple echarts instances share a `mapRecord`.
	* (2) Converting SVG to graphic elements is time consuming.
	* (3) In the current architecture, `load` should be called frequently to get boundingRect,
	*     and it is called without view info.
	* So we maintain graphic elements in this module, and enables `view` to use/return these
	* graphics from/to the pool with it's uid.
	*/
	GeoSVGResource$1.prototype.useGraphic = function(hostKey) {
		var usedRootMap = this._usedGraphicMap;
		var svgGraphic = usedRootMap.get(hostKey);
		if (svgGraphic) return svgGraphic;
		svgGraphic = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML);
		usedRootMap.set(hostKey, svgGraphic);
		return svgGraphic;
	};
	GeoSVGResource$1.prototype.freeGraphic = function(hostKey) {
		var usedRootMap = this._usedGraphicMap;
		var svgGraphic = usedRootMap.get(hostKey);
		if (svgGraphic) {
			usedRootMap.removeKey(hostKey);
			this._freedGraphics.push(svgGraphic);
		}
	};
	return GeoSVGResource$1;
}();
function setSilent(el) {
	el.silent = false;
	if (el.isGroup) el.traverse(function(child) {
		child.silent = false;
	});
}
function createRegions(named) {
	var regions = [];
	var regionsMap = createHashMap();
	each(named, function(namedItem) {
		if (namedItem.namedFrom != null) return;
		var region = new GeoSVGRegion(namedItem.name, namedItem.el);
		regions.push(region);
		regionsMap.set(namedItem.name, region);
	});
	return {
		regions,
		regionsMap
	};
}

//#endregion
//#region node_modules/echarts/lib/coord/geo/fix/nanhai.js
var geoCoord = [126, 25];
var nanhaiName = "";
var points$1 = [
	[
		[0, 3.5],
		[7, 11.2],
		[15, 11.9],
		[30, 7],
		[42, .7],
		[52, .7],
		[56, 7.7],
		[59, .7],
		[64, .7],
		[64, 0],
		[5, 0],
		[0, 3.5]
	],
	[
		[13, 16.1],
		[19, 14.7],
		[16, 21.7],
		[11, 23.1],
		[13, 16.1]
	],
	[
		[12, 32.2],
		[14, 38.5],
		[15, 38.5],
		[13, 32.2],
		[12, 32.2]
	],
	[
		[16, 47.6],
		[12, 53.2],
		[13, 53.2],
		[18, 47.6],
		[16, 47.6]
	],
	[
		[6, 64.4],
		[8, 70],
		[9, 70],
		[8, 64.4],
		[6, 64.4]
	],
	[
		[23, 82.6],
		[29, 79.8],
		[30, 79.8],
		[25, 82.6],
		[23, 82.6]
	],
	[
		[37, 70.7],
		[43, 62.3],
		[44, 62.3],
		[39, 70.7],
		[37, 70.7]
	],
	[
		[48, 51.1],
		[51, 45.5],
		[53, 45.5],
		[50, 51.1],
		[48, 51.1]
	],
	[
		[51, 35],
		[51, 28.7],
		[53, 28.7],
		[53, 35],
		[51, 35]
	],
	[
		[52, 22.4],
		[55, 17.5],
		[56, 17.5],
		[53, 22.4],
		[52, 22.4]
	],
	[
		[58, 12.6],
		[62, 7],
		[63, 7],
		[60, 12.6],
		[58, 12.6]
	],
	[
		[0, 3.5],
		[0, 93.1],
		[64, 93.1],
		[64, 0],
		[63, 0],
		[63, 92.4],
		[1, 92.4],
		[1, 3.5],
		[0, 3.5]
	]
];
for (var i = 0; i < points$1.length; i++) for (var k = 0; k < points$1[i].length; k++) {
	points$1[i][k][0] /= 10.5;
	points$1[i][k][1] /= -10.5 / .75;
	points$1[i][k][0] += geoCoord[0];
	points$1[i][k][1] += geoCoord[1];
}
function fixNanhai(mapType, regions) {
	if (mapType === "china") {
		for (var i$1 = 0; i$1 < regions.length; i$1++) if (regions[i$1].name === nanhaiName) return;
		regions.push(new GeoJSONRegion(nanhaiName, map(points$1, function(exterior) {
			return {
				type: "polygon",
				exterior
			};
		}), geoCoord));
	}
}

//#endregion
//#region node_modules/echarts/lib/coord/geo/fix/textCoord.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var coordsOffsetMap = {
	"": [32, 80],
	"": [0, -10],
	"": [10, 5],
	"": [-10, 10],
	"": [5, 5]
};
function fixTextCoords(mapType, region) {
	if (mapType === "china") {
		var coordFix = coordsOffsetMap[region.name];
		if (coordFix) {
			var cp = region.getCenter();
			cp[0] += coordFix[0] / 10.5;
			cp[1] += -coordFix[1] / (10.5 / .75);
			region.setCenter(cp);
		}
	}
}

//#endregion
//#region node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var points = [[
	[123.45165252685547, 25.73527164402261],
	[123.49731445312499, 25.73527164402261],
	[123.49731445312499, 25.750734064600884],
	[123.45165252685547, 25.750734064600884],
	[123.45165252685547, 25.73527164402261]
]];
function fixDiaoyuIsland(mapType, region) {
	if (mapType === "china" && region.name === "") region.geometries.push({
		type: "polygon",
		exterior: points[0]
	});
}

//#endregion
//#region node_modules/echarts/lib/coord/geo/GeoJSONResource.js
var DEFAULT_NAME_PROPERTY = "name";
var GeoJSONResource = function() {
	function GeoJSONResource$1(mapName, geoJSON, specialAreas) {
		this.type = "geoJSON";
		this._parsedMap = createHashMap();
		this._mapName = mapName;
		this._specialAreas = specialAreas;
		this._geoJSON = parseInput(geoJSON);
	}
	/**
	* @param nameMap can be null/undefined
	* @param nameProperty can be null/undefined
	*/
	GeoJSONResource$1.prototype.load = function(nameMap, nameProperty) {
		nameProperty = nameProperty || DEFAULT_NAME_PROPERTY;
		var parsed = this._parsedMap.get(nameProperty);
		if (!parsed) {
			var rawRegions = this._parseToRegions(nameProperty);
			parsed = this._parsedMap.set(nameProperty, {
				regions: rawRegions,
				boundingRect: calculateBoundingRect(rawRegions)
			});
		}
		var regionsMap = createHashMap();
		var finalRegions = [];
		each(parsed.regions, function(region) {
			var regionName = region.name;
			if (nameMap && hasOwn(nameMap, regionName)) region = region.cloneShallow(regionName = nameMap[regionName]);
			finalRegions.push(region);
			regionsMap.set(regionName, region);
		});
		return {
			regions: finalRegions,
			boundingRect: parsed.boundingRect || new BoundingRect_default(0, 0, 0, 0),
			regionsMap
		};
	};
	GeoJSONResource$1.prototype._parseToRegions = function(nameProperty) {
		var mapName = this._mapName;
		var geoJSON = this._geoJSON;
		var rawRegions;
		try {
			rawRegions = geoJSON ? parseGeoJSON(geoJSON, nameProperty) : [];
		} catch (e$1) {
			throw new Error("Invalid geoJson format\n" + e$1.message);
		}
		fixNanhai(mapName, rawRegions);
		each(rawRegions, function(region) {
			var regionName = region.name;
			fixTextCoords(mapName, region);
			fixDiaoyuIsland(mapName, region);
			var specialArea = this._specialAreas && this._specialAreas[regionName];
			if (specialArea) region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
		}, this);
		return rawRegions;
	};
	/**
	* Only for exporting to users.
	* **MUST NOT** used internally.
	*/
	GeoJSONResource$1.prototype.getMapForUser = function() {
		return {
			geoJson: this._geoJSON,
			geoJSON: this._geoJSON,
			specialAreas: this._specialAreas
		};
	};
	return GeoJSONResource$1;
}();
function calculateBoundingRect(regions) {
	var rect;
	for (var i$1 = 0; i$1 < regions.length; i$1++) {
		var regionRect = regions[i$1].getBoundingRect();
		rect = rect || regionRect.clone();
		rect.union(regionRect);
	}
	return rect;
}
function parseInput(source) {
	return !isString(source) ? source : typeof JSON !== "undefined" && JSON.parse ? JSON.parse(source) : new Function("return (" + source + ");")();
}

//#endregion
//#region node_modules/echarts/lib/coord/geo/geoSourceManager.js
var storage = createHashMap();
var geoSourceManager_default = {
	registerMap: function(mapName, rawDef, rawSpecialAreas) {
		if (rawDef.svg) {
			var resource = new GeoSVGResource(mapName, rawDef.svg);
			storage.set(mapName, resource);
		} else {
			var geoJSON = rawDef.geoJson || rawDef.geoJSON;
			if (geoJSON && !rawDef.features) rawSpecialAreas = rawDef.specialAreas;
			else geoJSON = rawDef;
			var resource = new GeoJSONResource(mapName, geoJSON, rawSpecialAreas);
			storage.set(mapName, resource);
		}
	},
	getGeoResource: function(mapName) {
		return storage.get(mapName);
	},
	getMapForUser: function(mapName) {
		var resource = storage.get(mapName);
		return resource && resource.type === "geoJSON" && resource.getMapForUser();
	},
	load: function(mapName, nameMap, nameProperty) {
		var resource = storage.get(mapName);
		if (!resource) {
			console.error("Map " + mapName + " not exists. The GeoJSON of the map must be provided.");
			return;
		}
		return resource.load(nameMap, nameProperty);
	}
};

//#endregion
//#region node_modules/echarts/lib/component/helper/MapDraw.js
/**
* Only these tags enable use `itemStyle` if they are named in SVG.
* Other tags like <text> <tspan> <image> might not suitable for `itemStyle`.
* They will not be considered to be styled until some requirements come.
*/
var OPTION_STYLE_ENABLED_TAGS = [
	"rect",
	"circle",
	"line",
	"ellipse",
	"polygon",
	"polyline",
	"path"
];
var OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS);
var STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var mapLabelRaw = makeInner();
function getFixedItemStyle(model) {
	var itemStyle = model.getItemStyle();
	var areaColor = model.get("areaColor");
	if (areaColor != null) itemStyle.fill = areaColor;
	return itemStyle;
}
function fixLineStyle(styleHost) {
	var style = styleHost.style;
	if (style) {
		style.stroke = style.stroke || style.fill;
		style.fill = null;
	}
}
var MapDraw = function() {
	function MapDraw$1(api) {
		var group = this.group = new Group_default();
		var transformGroup = this._transformGroup = new Group_default();
		group.add(transformGroup);
		this.uid = getUID("ec_map_draw");
		this._controller = new RoamController_default(api.getZr());
		this._controllerHost = { target: transformGroup };
		transformGroup.add(this._regionsGroup = new Group_default());
		transformGroup.add(this._svgGroup = new Group_default());
	}
	MapDraw$1.prototype.draw = function(mapOrGeoModel, ecModel, api, fromView, payload) {
		var isGeo = mapOrGeoModel.mainType === "geo";
		var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
		isGeo && ecModel.eachComponent({
			mainType: "series",
			subType: "map"
		}, function(mapSeries) {
			if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) data = mapSeries.getData();
		});
		var geo = mapOrGeoModel.coordinateSystem;
		var regionsGroup = this._regionsGroup;
		var transformGroup = this._transformGroup;
		var transformInfo = geo.getTransformInfo();
		var transformInfoRaw = transformInfo.raw;
		var transformInfoRoam = transformInfo.roam;
		var isFirstDraw = !regionsGroup.childAt(0) || payload;
		var clip$1 = mapOrGeoModel.getShallow("clip", true);
		var clipRect;
		if (clip$1) {
			clipRect = geo.getViewRect().clone();
			this.group.setClipPath(new Rect_default({ shape: clipRect.clone() }));
		} else this.group.removeClipPath();
		if (isFirstDraw) {
			transformGroup.x = transformInfoRoam.x;
			transformGroup.y = transformInfoRoam.y;
			transformGroup.scaleX = transformInfoRoam.scaleX;
			transformGroup.scaleY = transformInfoRoam.scaleY;
			transformGroup.dirty();
		} else updateProps(transformGroup, transformInfoRoam, mapOrGeoModel);
		var isVisualEncodedByVisualMap = data && data.getVisual("visualMeta") && data.getVisual("visualMeta").length > 0;
		var viewBuildCtx = {
			api,
			geo,
			mapOrGeoModel,
			data,
			isVisualEncodedByVisualMap,
			isGeo,
			transformInfoRaw
		};
		if (geo.resourceType === "geoJSON") this._buildGeoJSON(viewBuildCtx);
		else if (geo.resourceType === "geoSVG") this._buildSVG(viewBuildCtx);
		this._updateController(mapOrGeoModel, clipRect, ecModel, api);
		this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api, fromView);
	};
	MapDraw$1.prototype._buildGeoJSON = function(viewBuildCtx) {
		var regionsGroupByName = this._regionsGroupByName = createHashMap();
		var regionsInfoByName = createHashMap();
		var regionsGroup = this._regionsGroup;
		var transformInfoRaw = viewBuildCtx.transformInfoRaw;
		var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
		var data = viewBuildCtx.data;
		var projection = viewBuildCtx.geo.projection;
		var projectionStream = projection && projection.stream;
		function transformPoint(point, project) {
			if (project) point = project(point);
			return point && [point[0] * transformInfoRaw.scaleX + transformInfoRaw.x, point[1] * transformInfoRaw.scaleY + transformInfoRaw.y];
		}
		function transformPolygonPoints(inPoints) {
			var outPoints = [];
			var project = !projectionStream && projection && projection.project;
			for (var i$1 = 0; i$1 < inPoints.length; ++i$1) {
				var newPt = transformPoint(inPoints[i$1], project);
				newPt && outPoints.push(newPt);
			}
			return outPoints;
		}
		function getPolyShape(points$3) {
			return { shape: { points: transformPolygonPoints(points$3) } };
		}
		regionsGroup.removeAll();
		each(viewBuildCtx.geo.regions, function(region) {
			var regionName = region.name;
			var regionGroup = regionsGroupByName.get(regionName);
			var _a$1 = regionsInfoByName.get(regionName) || {}, dataIdx = _a$1.dataIdx, regionModel = _a$1.regionModel;
			if (!regionGroup) {
				regionGroup = regionsGroupByName.set(regionName, new Group_default());
				regionsGroup.add(regionGroup);
				dataIdx = data ? data.indexOfName(regionName) : null;
				regionModel = viewBuildCtx.isGeo ? mapOrGeoModel.getRegionModel(regionName) : data ? data.getItemModel(dataIdx) : null;
				var silent = regionModel.get("silent", true);
				silent != null && (regionGroup.silent = silent);
				regionsInfoByName.set(regionName, {
					dataIdx,
					regionModel
				});
			}
			var polygonSubpaths = [];
			var polylineSubpaths = [];
			each(region.geometries, function(geometry) {
				if (geometry.type === "polygon") {
					var polys = [geometry.exterior].concat(geometry.interiors || []);
					if (projectionStream) polys = projectPolys(polys, projectionStream);
					each(polys, function(poly) {
						polygonSubpaths.push(new Polygon_default(getPolyShape(poly)));
					});
				} else {
					var points$3 = geometry.points;
					if (projectionStream) points$3 = projectPolys(points$3, projectionStream, true);
					each(points$3, function(points$4) {
						polylineSubpaths.push(new Polyline_default(getPolyShape(points$4)));
					});
				}
			});
			var centerPt = transformPoint(region.getCenter(), projection && projection.project);
			function createCompoundPath(subpaths, isLine) {
				if (!subpaths.length) return;
				var compoundPath = new CompoundPath_default({
					culling: true,
					segmentIgnoreThreshold: 1,
					shape: { paths: subpaths }
				});
				regionGroup.add(compoundPath);
				applyOptionStyleForRegion(viewBuildCtx, compoundPath, dataIdx, regionModel);
				resetLabelForRegion(viewBuildCtx, compoundPath, regionName, regionModel, mapOrGeoModel, dataIdx, centerPt);
				if (isLine) {
					fixLineStyle(compoundPath);
					each(compoundPath.states, fixLineStyle);
				}
			}
			createCompoundPath(polygonSubpaths);
			createCompoundPath(polylineSubpaths, true);
		});
		regionsGroupByName.each(function(regionGroup, regionName) {
			var _a$1 = regionsInfoByName.get(regionName), dataIdx = _a$1.dataIdx, regionModel = _a$1.regionModel;
			resetEventTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel, dataIdx);
			resetTooltipForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
			resetStateTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
		}, this);
	};
	MapDraw$1.prototype._buildSVG = function(viewBuildCtx) {
		var mapName = viewBuildCtx.geo.map;
		var transformInfoRaw = viewBuildCtx.transformInfoRaw;
		this._svgGroup.x = transformInfoRaw.x;
		this._svgGroup.y = transformInfoRaw.y;
		this._svgGroup.scaleX = transformInfoRaw.scaleX;
		this._svgGroup.scaleY = transformInfoRaw.scaleY;
		if (this._svgResourceChanged(mapName)) {
			this._freeSVG();
			this._useSVG(mapName);
		}
		var svgDispatcherMap = this._svgDispatcherMap = createHashMap();
		var focusSelf = false;
		each(this._svgGraphicRecord.named, function(namedItem) {
			var regionName = namedItem.name;
			var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
			var data = viewBuildCtx.data;
			var svgNodeTagLower = namedItem.svgNodeTagLower;
			var el = namedItem.el;
			var dataIdx = data ? data.indexOfName(regionName) : null;
			var regionModel = mapOrGeoModel.getRegionModel(regionName);
			if (OPTION_STYLE_ENABLED_TAG_MAP.get(svgNodeTagLower) != null && el instanceof Displayable_default) applyOptionStyleForRegion(viewBuildCtx, el, dataIdx, regionModel);
			if (el instanceof Displayable_default) el.culling = true;
			var silent = regionModel.get("silent", true);
			silent != null && (el.silent = silent);
			el.z2EmphasisLift = 0;
			if (!namedItem.namedFrom) {
				if (LABEL_HOST_MAP.get(svgNodeTagLower) != null) resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, null);
				resetEventTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx);
				resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
				if (STATE_TRIGGER_TAG_MAP.get(svgNodeTagLower) != null) {
					if (resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) === "self") focusSelf = true;
					(svgDispatcherMap.get(regionName) || svgDispatcherMap.set(regionName, [])).push(el);
				}
			}
		}, this);
		this._enableBlurEntireSVG(focusSelf, viewBuildCtx);
	};
	MapDraw$1.prototype._enableBlurEntireSVG = function(focusSelf, viewBuildCtx) {
		if (focusSelf && viewBuildCtx.isGeo) {
			var opacity_1 = viewBuildCtx.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle().opacity;
			this._svgGraphicRecord.root.traverse(function(el) {
				if (!el.isGroup) {
					setDefaultStateProxy(el);
					var style = el.ensureState("blur").style || {};
					if (style.opacity == null && opacity_1 != null) style.opacity = opacity_1;
					el.ensureState("emphasis");
				}
			});
		}
	};
	MapDraw$1.prototype.remove = function() {
		this._regionsGroup.removeAll();
		this._regionsGroupByName = null;
		this._svgGroup.removeAll();
		this._freeSVG();
		this._controller.dispose();
		this._controllerHost = null;
	};
	MapDraw$1.prototype.findHighDownDispatchers = function(name, geoModel) {
		if (name == null) return [];
		var geo = geoModel.coordinateSystem;
		if (geo.resourceType === "geoJSON") {
			var regionsGroupByName = this._regionsGroupByName;
			if (regionsGroupByName) {
				var regionGroup = regionsGroupByName.get(name);
				return regionGroup ? [regionGroup] : [];
			}
		} else if (geo.resourceType === "geoSVG") return this._svgDispatcherMap && this._svgDispatcherMap.get(name) || [];
	};
	MapDraw$1.prototype._svgResourceChanged = function(mapName) {
		return this._svgMapName !== mapName;
	};
	MapDraw$1.prototype._useSVG = function(mapName) {
		var resource = geoSourceManager_default.getGeoResource(mapName);
		if (resource && resource.type === "geoSVG") {
			var svgGraphic = resource.useGraphic(this.uid);
			this._svgGroup.add(svgGraphic.root);
			this._svgGraphicRecord = svgGraphic;
			this._svgMapName = mapName;
		}
	};
	MapDraw$1.prototype._freeSVG = function() {
		var mapName = this._svgMapName;
		if (mapName == null) return;
		var resource = geoSourceManager_default.getGeoResource(mapName);
		if (resource && resource.type === "geoSVG") resource.freeGraphic(this.uid);
		this._svgGraphicRecord = null;
		this._svgDispatcherMap = null;
		this._svgGroup.removeAll();
		this._svgMapName = null;
	};
	MapDraw$1.prototype._updateController = function(mapOrGeoModel, clipRect, ecModel, api) {
		var geo = mapOrGeoModel.coordinateSystem;
		var controller = this._controller;
		var controllerHost = this._controllerHost;
		controllerHost.zoomLimit = mapOrGeoModel.get("scaleLimit");
		controllerHost.zoom = geo.getZoom();
		controller.enable(mapOrGeoModel.get("roam") || false, {
			api,
			zInfo: { component: mapOrGeoModel },
			triggerInfo: {
				roamTrigger: mapOrGeoModel.get("roamTrigger"),
				isInSelf: function(e$1, x, y) {
					return geo.containPoint([x, y]);
				},
				isInClip: function(e$1, x, y) {
					return !clipRect || clipRect.contain(x, y);
				}
			}
		});
		var mainType = mapOrGeoModel.mainType;
		function makeActionBase() {
			var action = {
				type: "geoRoam",
				componentType: mainType
			};
			action[mainType + "Id"] = mapOrGeoModel.id;
			return action;
		}
		controller.off("pan").on("pan", function(e$1) {
			this._mouseDownFlag = false;
			updateViewOnPan(controllerHost, e$1.dx, e$1.dy);
			api.dispatchAction(extend(makeActionBase(), {
				dx: e$1.dx,
				dy: e$1.dy,
				animation: { duration: 0 }
			}));
		}, this);
		controller.off("zoom").on("zoom", function(e$1) {
			this._mouseDownFlag = false;
			updateViewOnZoom(controllerHost, e$1.scale, e$1.originX, e$1.originY);
			api.dispatchAction(extend(makeActionBase(), {
				totalZoom: controllerHost.zoom,
				zoom: e$1.scale,
				originX: e$1.originX,
				originY: e$1.originY,
				animation: { duration: 0 }
			}));
		}, this);
	};
	/**
	* FIXME: this is a temporarily workaround.
	* When `geoRoam` the elements need to be reset in `MapView['render']`, because the props like
	* `ignore` might have been modified by `LabelManager`, and `LabelManager#addLabelsOfSeries`
	* will subsequently cache `defaultAttr` like `ignore`. If do not do this reset, the modified
	* props will have no chance to be restored.
	* Note: This reset should be after `clearStates` in `renderSeries` because `useStates` in
	* `renderSeries` will cache the modified `ignore` to `el._normalState`.
	* TODO:
	* Use clone/immutable in `LabelManager`?
	*/
	MapDraw$1.prototype.resetForLabelLayout = function() {
		this.group.traverse(function(el) {
			var label = el.getTextContent();
			if (label) label.ignore = mapLabelRaw(label).ignore;
		});
	};
	MapDraw$1.prototype._updateMapSelectHandler = function(mapOrGeoModel, regionsGroup, api, fromView) {
		var mapDraw = this;
		regionsGroup.off("mousedown");
		regionsGroup.off("click");
		if (mapOrGeoModel.get("selectedMode")) {
			regionsGroup.on("mousedown", function() {
				mapDraw._mouseDownFlag = true;
			});
			regionsGroup.on("click", function(e$1) {
				if (!mapDraw._mouseDownFlag) return;
				mapDraw._mouseDownFlag = false;
			});
		}
	};
	return MapDraw$1;
}();
function applyOptionStyleForRegion(viewBuildCtx, el, dataIndex, regionModel) {
	var normalStyleModel = regionModel.getModel("itemStyle");
	var emphasisStyleModel = regionModel.getModel(["emphasis", "itemStyle"]);
	var blurStyleModel = regionModel.getModel(["blur", "itemStyle"]);
	var selectStyleModel = regionModel.getModel(["select", "itemStyle"]);
	var normalStyle = getFixedItemStyle(normalStyleModel);
	var emphasisStyle = getFixedItemStyle(emphasisStyleModel);
	var selectStyle = getFixedItemStyle(selectStyleModel);
	var blurStyle = getFixedItemStyle(blurStyleModel);
	var data = viewBuildCtx.data;
	if (data) {
		var style = data.getItemVisual(dataIndex, "style");
		var decal = data.getItemVisual(dataIndex, "decal");
		if (viewBuildCtx.isVisualEncodedByVisualMap && style.fill) normalStyle.fill = style.fill;
		if (decal) normalStyle.decal = createOrUpdatePatternFromDecal(decal, viewBuildCtx.api);
	}
	el.setStyle(normalStyle);
	el.style.strokeNoScale = true;
	el.ensureState("emphasis").style = emphasisStyle;
	el.ensureState("select").style = selectStyle;
	el.ensureState("blur").style = blurStyle;
	setDefaultStateProxy(el);
}
function resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, labelXY) {
	var data = viewBuildCtx.data;
	var isGeo = viewBuildCtx.isGeo;
	var isDataNaN = data && isNaN(data.get(data.mapDimension("value"), dataIdx));
	var itemLayout = data && data.getItemLayout(dataIdx);
	if (isGeo || isDataNaN || itemLayout && itemLayout.showLabel) {
		var query = !isGeo ? dataIdx : regionName;
		var labelFetcher = void 0;
		if (!data || dataIdx >= 0) labelFetcher = mapOrGeoModel;
		var specifiedTextOpt = labelXY ? { normal: {
			align: "center",
			verticalAlign: "middle"
		} } : null;
		setLabelStyle(el, getLabelStatesModels(regionModel), {
			labelFetcher,
			labelDataIndex: query,
			defaultText: regionName
		}, specifiedTextOpt);
		var textEl = el.getTextContent();
		if (textEl) {
			mapLabelRaw(textEl).ignore = textEl.ignore;
			if (el.textConfig && labelXY) {
				var rect = el.getBoundingRect().clone();
				el.textConfig.layoutRect = rect;
				el.textConfig.position = [(labelXY[0] - rect.x) / rect.width * 100 + "%", (labelXY[1] - rect.y) / rect.height * 100 + "%"];
			}
		}
		el.disableLabelAnimation = true;
	} else {
		el.removeTextContent();
		el.removeTextConfig();
		el.disableLabelAnimation = null;
	}
}
function resetEventTriggerForRegion(viewBuildCtx, eventTrigger, regionName, regionModel, mapOrGeoModel, dataIdx) {
	if (viewBuildCtx.data) viewBuildCtx.data.setItemGraphicEl(dataIdx, eventTrigger);
	else getECData(eventTrigger).eventData = {
		componentType: "geo",
		componentIndex: mapOrGeoModel.componentIndex,
		geoIndex: mapOrGeoModel.componentIndex,
		name: regionName,
		region: regionModel && regionModel.option || {}
	};
}
function resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
	if (!viewBuildCtx.data) setTooltipConfig({
		el,
		componentModel: mapOrGeoModel,
		itemName: regionName,
		itemTooltipOption: regionModel.get("tooltip")
	});
}
function resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
	el.highDownSilentOnTouch = !!mapOrGeoModel.get("selectedMode");
	var emphasisModel = regionModel.getModel("emphasis");
	var focus = emphasisModel.get("focus");
	toggleHoverEmphasis(el, focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
	if (viewBuildCtx.isGeo) enableComponentHighDownFeatures(el, mapOrGeoModel, regionName);
	return focus;
}
function projectPolys(rings, createStream, isLine) {
	var polygons = [];
	var curPoly;
	function startPolygon() {
		curPoly = [];
	}
	function endPolygon() {
		if (curPoly.length) {
			polygons.push(curPoly);
			curPoly = [];
		}
	}
	var stream = createStream({
		polygonStart: startPolygon,
		polygonEnd: endPolygon,
		lineStart: startPolygon,
		lineEnd: endPolygon,
		point: function(x, y) {
			if (isFinite(x) && isFinite(y)) curPoly.push([x, y]);
		},
		sphere: function() {}
	});
	!isLine && stream.polygonStart();
	each(rings, function(ring) {
		stream.lineStart();
		for (var i$1 = 0; i$1 < ring.length; i$1++) stream.point(ring[i$1][0], ring[i$1][1]);
		stream.lineEnd();
	});
	!isLine && stream.polygonEnd();
	return polygons;
}
var MapDraw_default = MapDraw;

//#endregion
//#region node_modules/echarts/lib/chart/map/MapView.js
var MapView = function(_super) {
	__extends(MapView$1, _super);
	function MapView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MapView$1.type;
		return _this;
	}
	MapView$1.prototype.render = function(mapModel, ecModel, api, payload) {
		if (payload && payload.type === "mapToggleSelect" && payload.from === this.uid) return;
		var group = this.group;
		group.removeAll();
		if (mapModel.getHostGeoModel()) return;
		if (this._mapDraw && payload && payload.type === "geoRoam") this._mapDraw.resetForLabelLayout();
		if (!(payload && payload.type === "geoRoam" && payload.componentType === "series" && payload.seriesId === mapModel.id)) if (mapModel.needsDrawMap) {
			var mapDraw = this._mapDraw || new MapDraw_default(api);
			group.add(mapDraw.group);
			mapDraw.draw(mapModel, ecModel, api, this, payload);
			this._mapDraw = mapDraw;
		} else {
			this._mapDraw && this._mapDraw.remove();
			this._mapDraw = null;
		}
		else {
			var mapDraw = this._mapDraw;
			mapDraw && group.add(mapDraw.group);
		}
		mapModel.get("showLegendSymbol") && ecModel.getComponent("legend") && this._renderSymbols(mapModel, ecModel, api);
	};
	MapView$1.prototype.remove = function() {
		this._mapDraw && this._mapDraw.remove();
		this._mapDraw = null;
		this.group.removeAll();
	};
	MapView$1.prototype.dispose = function() {
		this._mapDraw && this._mapDraw.remove();
		this._mapDraw = null;
	};
	MapView$1.prototype._renderSymbols = function(mapModel, ecModel, api) {
		var originalData = mapModel.originalData;
		var group = this.group;
		originalData.each(originalData.mapDimension("value"), function(value, originalDataIndex) {
			if (isNaN(value)) return;
			var layout$3 = originalData.getItemLayout(originalDataIndex);
			if (!layout$3 || !layout$3.point) return;
			var point = layout$3.point;
			var offset = layout$3.offset;
			var circle = new Circle_default({
				style: { fill: mapModel.getData().getVisual("style").fill },
				shape: {
					cx: point[0] + offset * 9,
					cy: point[1],
					r: 3
				},
				silent: true,
				z2: 8 + (!offset ? Z2_EMPHASIS_LIFT + 1 : 0)
			});
			if (!offset) {
				var fullData = mapModel.mainSeries.getData();
				var name_1 = originalData.getName(originalDataIndex);
				var fullIndex_1 = fullData.indexOfName(name_1);
				var itemModel = originalData.getItemModel(originalDataIndex);
				var labelModel = itemModel.getModel("label");
				var regionGroup = fullData.getItemGraphicEl(fullIndex_1);
				setLabelStyle(circle, getLabelStatesModels(itemModel), {
					labelFetcher: { getFormattedLabel: function(idx, state) {
						return mapModel.getFormattedLabel(fullIndex_1, state);
					} },
					defaultText: name_1
				});
				circle.disableLabelAnimation = true;
				if (!labelModel.get("position")) circle.setTextConfig({ position: "bottom" });
				regionGroup.onHoverStateChange = function(toState) {
					setStatesFlag(circle, toState);
				};
			}
			group.add(circle);
		});
	};
	MapView$1.type = "map";
	return MapView$1;
}(Chart_default);
var MapView_default = MapView;

//#endregion
//#region node_modules/echarts/lib/chart/map/MapSeries.js
var MapSeries = function(_super) {
	__extends(MapSeries$1, _super);
	function MapSeries$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MapSeries$1.type;
		_this.needsDrawMap = false;
		_this.seriesGroup = [];
		_this.getTooltipPosition = function(dataIndex) {
			if (dataIndex != null) {
				var name_1 = this.getData().getName(dataIndex);
				var geo = this.coordinateSystem;
				var region = geo.getRegion(name_1);
				return region && geo.dataToPoint(region.getCenter());
			}
		};
		return _this;
	}
	MapSeries$1.prototype.getInitialData = function(option) {
		var data = createSeriesDataSimply(this, {
			coordDimensions: ["value"],
			encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
		});
		var dataNameIndexMap = createHashMap();
		var toAppendItems = [];
		for (var i$1 = 0, len$1 = data.count(); i$1 < len$1; i$1++) {
			var name_2 = data.getName(i$1);
			dataNameIndexMap.set(name_2, i$1);
		}
		var geoSource = geoSourceManager_default.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
		each(geoSource.regions, function(region) {
			var name = region.name;
			var dataNameIdx = dataNameIndexMap.get(name);
			var specifiedGeoJSONRegionStyle = region.properties && region.properties.echartsStyle;
			var dataItem;
			if (dataNameIdx == null) {
				dataItem = { name };
				toAppendItems.push(dataItem);
			} else dataItem = data.getRawDataItem(dataNameIdx);
			specifiedGeoJSONRegionStyle && merge(dataItem, specifiedGeoJSONRegionStyle);
		});
		data.appendData(toAppendItems);
		return data;
	};
	/**
	* If no host geo model, return null, which means using a
	* inner exclusive geo model.
	*/
	MapSeries$1.prototype.getHostGeoModel = function() {
		if (decideCoordSysUsageKind(this).kind === CoordinateSystemUsageKind.boxCoordSys) return;
		return this.getReferringComponents("geo", {
			useDefault: false,
			enableAll: false,
			enableNone: false
		}).models[0];
	};
	MapSeries$1.prototype.getMapType = function() {
		return (this.getHostGeoModel() || this).option.map;
	};
	MapSeries$1.prototype.getRawValue = function(dataIndex) {
		var data = this.getData();
		return data.get(data.mapDimension("value"), dataIndex);
	};
	/**
	* Get model of region
	*/
	MapSeries$1.prototype.getRegionModel = function(regionName) {
		var data = this.getData();
		return data.getItemModel(data.indexOfName(regionName));
	};
	/**
	* Map tooltip formatter
	*/
	MapSeries$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		var data = this.getData();
		var value = this.getRawValue(dataIndex);
		var name = data.getName(dataIndex);
		var seriesGroup = this.seriesGroup;
		var seriesNames = [];
		for (var i$1 = 0; i$1 < seriesGroup.length; i$1++) {
			var otherIndex = seriesGroup[i$1].originalData.indexOfName(name);
			var valueDim = data.mapDimension("value");
			if (!isNaN(seriesGroup[i$1].originalData.get(valueDim, otherIndex))) seriesNames.push(seriesGroup[i$1].name);
		}
		return createTooltipMarkup("section", {
			header: seriesNames.join(", "),
			noHeader: !seriesNames.length,
			blocks: [createTooltipMarkup("nameValue", {
				name,
				value
			})]
		});
	};
	MapSeries$1.prototype.setZoom = function(zoom) {
		this.option.zoom = zoom;
	};
	MapSeries$1.prototype.setCenter = function(center$2) {
		this.option.center = center$2;
	};
	MapSeries$1.prototype.getLegendIcon = function(opt) {
		var iconType = opt.icon || "roundRect";
		var icon = createSymbol(iconType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill);
		icon.setStyle(opt.itemStyle);
		icon.style.stroke = "none";
		if (iconType.indexOf("empty") > -1) {
			icon.style.stroke = icon.style.fill;
			icon.style.fill = tokens_default.color.neutral00;
			icon.style.lineWidth = 2;
		}
		return icon;
	};
	MapSeries$1.type = "series.map";
	MapSeries$1.dependencies = ["geo"];
	MapSeries$1.layoutMode = "box";
	MapSeries$1.defaultOption = {
		z: 2,
		coordinateSystem: "geo",
		map: "",
		left: "center",
		top: "center",
		aspectScale: null,
		showLegendSymbol: true,
		boundingCoords: null,
		center: null,
		zoom: 1,
		scaleLimit: null,
		selectedMode: true,
		label: {
			show: false,
			color: tokens_default.color.tertiary
		},
		itemStyle: {
			borderWidth: .5,
			borderColor: tokens_default.color.border,
			areaColor: tokens_default.color.background
		},
		emphasis: {
			label: {
				show: true,
				color: tokens_default.color.primary
			},
			itemStyle: { areaColor: tokens_default.color.highlight }
		},
		select: {
			label: {
				show: true,
				color: tokens_default.color.primary
			},
			itemStyle: { color: tokens_default.color.highlight }
		},
		nameProperty: "name"
	};
	return MapSeries$1;
}(Series_default);
var MapSeries_default = MapSeries;

//#endregion
//#region node_modules/echarts/lib/chart/map/mapDataStatistic.js
function dataStatistics(datas, statisticType) {
	var dataNameMap = {};
	each(datas, function(data) {
		data.each(data.mapDimension("value"), function(value, idx) {
			var mapKey = "ec-" + data.getName(idx);
			dataNameMap[mapKey] = dataNameMap[mapKey] || [];
			if (!isNaN(value)) dataNameMap[mapKey].push(value);
		});
	});
	return datas[0].map(datas[0].mapDimension("value"), function(value, idx) {
		var mapKey = "ec-" + datas[0].getName(idx);
		var sum$1 = 0;
		var min$2 = Infinity;
		var max$2 = -Infinity;
		var len$1 = dataNameMap[mapKey].length;
		for (var i$1 = 0; i$1 < len$1; i$1++) {
			min$2 = Math.min(min$2, dataNameMap[mapKey][i$1]);
			max$2 = Math.max(max$2, dataNameMap[mapKey][i$1]);
			sum$1 += dataNameMap[mapKey][i$1];
		}
		var result;
		if (statisticType === "min") result = min$2;
		else if (statisticType === "max") result = max$2;
		else if (statisticType === "average") result = sum$1 / len$1;
		else result = sum$1;
		return len$1 === 0 ? NaN : result;
	});
}
function mapDataStatistic(ecModel) {
	var seriesGroups = {};
	ecModel.eachSeriesByType("map", function(seriesModel) {
		var hostGeoModel = seriesModel.getHostGeoModel();
		var key$1 = hostGeoModel ? "o" + hostGeoModel.id : "i" + seriesModel.getMapType();
		(seriesGroups[key$1] = seriesGroups[key$1] || []).push(seriesModel);
	});
	each(seriesGroups, function(seriesList, key$1) {
		var data = dataStatistics(map(seriesList, function(seriesModel) {
			return seriesModel.getData();
		}), seriesList[0].get("mapValueCalculation"));
		for (var i$1 = 0; i$1 < seriesList.length; i$1++) seriesList[i$1].originalData = seriesList[i$1].getData();
		for (var i$1 = 0; i$1 < seriesList.length; i$1++) {
			seriesList[i$1].seriesGroup = seriesList;
			seriesList[i$1].needsDrawMap = i$1 === 0 && !seriesList[i$1].getHostGeoModel();
			seriesList[i$1].setData(data.cloneShallow());
			seriesList[i$1].mainSeries = seriesList[0];
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/map/mapSymbolLayout.js
function mapSymbolLayout(ecModel) {
	var processedMapType = {};
	ecModel.eachSeriesByType("map", function(mapSeries) {
		var mapType = mapSeries.getMapType();
		if (mapSeries.getHostGeoModel() || processedMapType[mapType]) return;
		var mapSymbolOffsets = {};
		each(mapSeries.seriesGroup, function(subMapSeries) {
			var geo = subMapSeries.coordinateSystem;
			var data$1 = subMapSeries.originalData;
			if (subMapSeries.get("showLegendSymbol") && ecModel.getComponent("legend")) data$1.each(data$1.mapDimension("value"), function(value, idx) {
				var name = data$1.getName(idx);
				var region = geo.getRegion(name);
				if (!region || isNaN(value)) return;
				var offset = mapSymbolOffsets[name] || 0;
				var point = geo.dataToPoint(region.getCenter());
				mapSymbolOffsets[name] = offset + 1;
				data$1.setItemLayout(idx, {
					point,
					offset
				});
			});
		});
		var data = mapSeries.getData();
		data.each(function(idx) {
			var name = data.getName(idx);
			var layout$3 = data.getItemLayout(idx) || {};
			layout$3.showLabel = !mapSymbolOffsets[name];
			data.setItemLayout(idx, layout$3);
		});
		processedMapType[mapType] = true;
	});
}

//#endregion
//#region node_modules/echarts/lib/coord/View.js
var v2ApplyTransform = applyTransform;
var View = function(_super) {
	__extends(View$1, _super);
	function View$1(name, opt) {
		var _this = _super.call(this) || this;
		_this.type = "view";
		_this.dimensions = ["x", "y"];
		/**
		* Represents the transform brought by roam/zoom.
		* If `View['_viewRect']` applies roam transform,
		* we can get the final displayed rect.
		*/
		_this._roamTransformable = new Transformable_default();
		/**
		* Represents the transform from `View['_rect']` to `View['_viewRect']`.
		*/
		_this._rawTransformable = new Transformable_default();
		_this.name = name;
		_this._opt = opt;
		return _this;
	}
	View$1.prototype.setBoundingRect = function(x, y, width, height) {
		this._rect = new BoundingRect_default(x, y, width, height);
		this._updateCenterAndZoom();
		return this._rect;
	};
	View$1.prototype.getBoundingRect = function() {
		return this._rect;
	};
	/**
	* If no need to transform `View['_rect']` to `View['_viewRect']`, the calling of
	* `setViewRect` can be omitted.
	*/
	View$1.prototype.setViewRect = function(x, y, width, height) {
		this._transformTo(x, y, width, height);
		this._viewRect = new BoundingRect_default(x, y, width, height);
	};
	/**
	* Transformed to particular position and size
	*/
	View$1.prototype._transformTo = function(x, y, width, height) {
		var rect = this.getBoundingRect();
		var rawTransform = this._rawTransformable;
		rawTransform.transform = rect.calculateTransform(new BoundingRect_default(x, y, width, height));
		var rawParent = rawTransform.parent;
		rawTransform.parent = null;
		rawTransform.decomposeTransform();
		rawTransform.parent = rawParent;
		this._updateTransform();
	};
	/**
	* [NOTICE]
	*  The definition of this center has always been irrelevant to some other series center like
	*  'series-pie.center' - this center is a point on the same coord sys as `View['_rect'].x/y`,
	*  rather than canvas viewport, and the unit is not necessarily pixel (e.g., in geo case).
	*  @see {View['_center']} for details.
	*/
	View$1.prototype.setCenter = function(centerCoord) {
		var opt = this._opt;
		if (opt && opt.api && opt.ecModel && opt.ecModel.getShallow("legacyViewCoordSysCenterBase") && centerCoord) centerCoord = [parsePercent$1(centerCoord[0], opt.api.getWidth()), parsePercent$1(centerCoord[1], opt.api.getWidth())];
		this._centerOption = clone(centerCoord);
		this._updateCenterAndZoom();
	};
	View$1.prototype.setZoom = function(zoom) {
		this._zoom = clampByZoomLimit(zoom || 1, this.zoomLimit);
		this._updateCenterAndZoom();
	};
	/**
	* Get default center without roam
	*/
	View$1.prototype.getDefaultCenter = function() {
		var rawRect = this.getBoundingRect();
		return [rawRect.x + rawRect.width / 2, rawRect.y + rawRect.height / 2];
	};
	View$1.prototype.getCenter = function() {
		return this._center || this.getDefaultCenter();
	};
	View$1.prototype.getZoom = function() {
		return this._zoom || 1;
	};
	View$1.prototype.getRoamTransform = function() {
		return this._roamTransformable.getLocalTransform();
	};
	/**
	* Ensure this method is idempotent, since it should be called when
	* every relevant prop (e.g. _centerOption/_zoom/_rect/_viewRect) changed.
	*/
	View$1.prototype._updateCenterAndZoom = function() {
		var centerOption = this._centerOption;
		var rect = this._rect;
		if (centerOption && rect) this._center = [parsePercent$1(centerOption[0], rect.width, rect.x), parsePercent$1(centerOption[1], rect.height, rect.y)];
		var rawTransformMatrix = this._rawTransformable.getLocalTransform();
		var roamTransform = this._roamTransformable;
		var defaultCenter = this.getDefaultCenter();
		var center$2 = this.getCenter();
		var zoom = this.getZoom();
		center$2 = applyTransform([], center$2, rawTransformMatrix);
		defaultCenter = applyTransform([], defaultCenter, rawTransformMatrix);
		roamTransform.originX = center$2[0];
		roamTransform.originY = center$2[1];
		roamTransform.x = defaultCenter[0] - center$2[0];
		roamTransform.y = defaultCenter[1] - center$2[1];
		roamTransform.scaleX = roamTransform.scaleY = zoom;
		this._updateTransform();
	};
	/**
	* Update transform props on `this` based on the current
	* `this._roamTransformable` and `this._rawTransformable`.
	*/
	View$1.prototype._updateTransform = function() {
		var roamTransformable = this._roamTransformable;
		var rawTransformable = this._rawTransformable;
		rawTransformable.parent = roamTransformable;
		roamTransformable.updateTransform();
		rawTransformable.updateTransform();
		copy(this.transform || (this.transform = []), rawTransformable.transform || create$2());
		this._rawTransform = rawTransformable.getLocalTransform();
		this.invTransform = this.invTransform || [];
		invert(this.invTransform, this.transform);
		this.decomposeTransform();
	};
	View$1.prototype.getTransformInfo = function() {
		var rawTransformable = this._rawTransformable;
		var roamTransformable = this._roamTransformable;
		var dummyTransformable$1 = new Transformable_default();
		dummyTransformable$1.transform = roamTransformable.transform;
		dummyTransformable$1.decomposeTransform();
		return {
			roam: {
				x: dummyTransformable$1.x,
				y: dummyTransformable$1.y,
				scaleX: dummyTransformable$1.scaleX,
				scaleY: dummyTransformable$1.scaleY
			},
			raw: {
				x: rawTransformable.x,
				y: rawTransformable.y,
				scaleX: rawTransformable.scaleX,
				scaleY: rawTransformable.scaleY
			}
		};
	};
	View$1.prototype.getViewRect = function() {
		return this._viewRect;
	};
	/**
	* Get view rect after roam transform
	*/
	View$1.prototype.getViewRectAfterRoam = function() {
		var rect = this.getBoundingRect().clone();
		rect.applyTransform(this.transform);
		return rect;
	};
	/**
	* Convert a single (lon, lat) data item to (x, y) point.
	*/
	View$1.prototype.dataToPoint = function(data, noRoam, out$1) {
		var transform = noRoam ? this._rawTransform : this.transform;
		out$1 = out$1 || [];
		return transform ? v2ApplyTransform(out$1, data, transform) : copy$1(out$1, data);
	};
	/**
	* Convert a (x, y) point to (lon, lat) data
	*/
	View$1.prototype.pointToData = function(point, reserved, out$1) {
		out$1 = out$1 || [];
		var invTransform = this.invTransform;
		return invTransform ? v2ApplyTransform(out$1, point, invTransform) : (out$1[0] = point[0], out$1[1] = point[1], out$1);
	};
	View$1.prototype.convertToPixel = function(ecModel, finder, value) {
		var coordSys = getCoordSys$5(finder);
		return coordSys === this ? coordSys.dataToPoint(value) : null;
	};
	View$1.prototype.convertFromPixel = function(ecModel, finder, pixel) {
		var coordSys = getCoordSys$5(finder);
		return coordSys === this ? coordSys.pointToData(pixel) : null;
	};
	/**
	* @implements
	*/
	View$1.prototype.containPoint = function(point) {
		return this.getViewRectAfterRoam().contain(point[0], point[1]);
	};
	View$1.dimensions = ["x", "y"];
	return View$1;
}(Transformable_default);
function getCoordSys$5(finder) {
	var seriesModel = finder.seriesModel;
	return seriesModel ? seriesModel.coordinateSystem : null;
}
var View_default = View;

//#endregion
//#region node_modules/echarts/lib/coord/geo/Geo.js
var GEO_DEFAULT_PARAMS = {
	"geoJSON": {
		aspectScale: .75,
		invertLongitute: true
	},
	"geoSVG": {
		aspectScale: 1,
		invertLongitute: false
	}
};
var geo2DDimensions = ["lng", "lat"];
var Geo = function(_super) {
	__extends(Geo$1, _super);
	function Geo$1(name, map$2, opt) {
		var _this = _super.call(this, name, {
			api: opt.api,
			ecModel: opt.ecModel
		}) || this;
		_this.dimensions = geo2DDimensions;
		_this.type = "geo";
		_this._nameCoordMap = createHashMap();
		_this.map = map$2;
		var projection = opt.projection;
		var source = geoSourceManager_default.load(map$2, opt.nameMap, opt.nameProperty);
		var resource = geoSourceManager_default.getGeoResource(map$2);
		var resourceType = _this.resourceType = resource ? resource.type : null;
		var regions = _this.regions = source.regions;
		var defaultParams = GEO_DEFAULT_PARAMS[resource.type];
		_this._regionsMap = source.regionsMap;
		_this.regions = source.regions;
		if (projection) {
			if (resourceType === "geoSVG") {
				warn("Map " + map$2 + " with SVG source can't use projection. Only GeoJSON source supports projection.");
				projection = null;
			}
			if (!(projection.project && projection.unproject)) {
				warn("project and unproject must be both provided in the projeciton.");
				projection = null;
			}
		}
		_this.projection = projection;
		var boundingRect;
		if (projection) for (var i$1 = 0; i$1 < regions.length; i$1++) {
			var regionRect = regions[i$1].getBoundingRect(projection);
			boundingRect = boundingRect || regionRect.clone();
			boundingRect.union(regionRect);
		}
		else boundingRect = source.boundingRect;
		_this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);
		_this.aspectScale = projection ? 1 : retrieve2(opt.aspectScale, defaultParams.aspectScale);
		_this._invertLongitute = projection ? false : defaultParams.invertLongitute;
		return _this;
	}
	Geo$1.prototype._transformTo = function(x, y, width, height) {
		var rect = this.getBoundingRect();
		var invertLongitute = this._invertLongitute;
		rect = rect.clone();
		if (invertLongitute) rect.y = -rect.y - rect.height;
		var rawTransformable = this._rawTransformable;
		rawTransformable.transform = rect.calculateTransform(new BoundingRect_default(x, y, width, height));
		var rawParent = rawTransformable.parent;
		rawTransformable.parent = null;
		rawTransformable.decomposeTransform();
		rawTransformable.parent = rawParent;
		if (invertLongitute) rawTransformable.scaleY = -rawTransformable.scaleY;
		this._updateTransform();
	};
	Geo$1.prototype.getRegion = function(name) {
		return this._regionsMap.get(name);
	};
	Geo$1.prototype.getRegionByCoord = function(coord) {
		var regions = this.regions;
		for (var i$1 = 0; i$1 < regions.length; i$1++) {
			var region = regions[i$1];
			if (region.type === "geoJSON" && region.contain(coord)) return regions[i$1];
		}
	};
	/**
	* Add geoCoord for indexing by name
	*/
	Geo$1.prototype.addGeoCoord = function(name, geoCoord$1) {
		this._nameCoordMap.set(name, geoCoord$1);
	};
	/**
	* Get geoCoord by name
	*/
	Geo$1.prototype.getGeoCoord = function(name) {
		var region = this._regionsMap.get(name);
		return this._nameCoordMap.get(name) || region && region.getCenter();
	};
	Geo$1.prototype.dataToPoint = function(data, noRoam, out$1) {
		if (isString(data)) data = this.getGeoCoord(data);
		if (data) {
			var projection = this.projection;
			if (projection) data = projection.project(data);
			return data && this.projectedToPoint(data, noRoam, out$1);
		}
	};
	Geo$1.prototype.pointToData = function(point, reserved, out$1) {
		var projection = this.projection;
		if (projection) point = projection.unproject(point);
		return point && this.pointToProjected(point, out$1);
	};
	/**
	* Point to projected data. Same with pointToData when projection is used.
	*/
	Geo$1.prototype.pointToProjected = function(point, out$1) {
		return _super.prototype.pointToData.call(this, point, 0, out$1);
	};
	Geo$1.prototype.projectedToPoint = function(projected, noRoam, out$1) {
		return _super.prototype.dataToPoint.call(this, projected, noRoam, out$1);
	};
	Geo$1.prototype.convertToPixel = function(ecModel, finder, value) {
		var coordSys = getCoordSys$4(finder);
		return coordSys === this ? coordSys.dataToPoint(value) : null;
	};
	Geo$1.prototype.convertFromPixel = function(ecModel, finder, pixel) {
		var coordSys = getCoordSys$4(finder);
		return coordSys === this ? coordSys.pointToData(pixel) : null;
	};
	return Geo$1;
}(View_default);
mixin(Geo, View_default);
function getCoordSys$4(finder) {
	var geoModel = finder.geoModel;
	var seriesModel = finder.seriesModel;
	return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents("geo", SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}
var Geo_default = Geo;

//#endregion
//#region node_modules/echarts/lib/coord/geo/geoCreator.js
/**
* Resize method bound to the geo
*/
function resizeGeo(geoModel, api) {
	var boundingCoords = geoModel.get("boundingCoords");
	if (boundingCoords != null) {
		var leftTop_1 = boundingCoords[0];
		var rightBottom_1 = boundingCoords[1];
		if (!(isFinite(leftTop_1[0]) && isFinite(leftTop_1[1]) && isFinite(rightBottom_1[0]) && isFinite(rightBottom_1[1]))) console.error("Invalid boundingCoords");
		else {
			var projection_1 = this.projection;
			if (projection_1) {
				var xMin = leftTop_1[0];
				var yMin = leftTop_1[1];
				var xMax = rightBottom_1[0];
				var yMax = rightBottom_1[1];
				leftTop_1 = [Infinity, Infinity];
				rightBottom_1 = [-Infinity, -Infinity];
				var sampleLine = function(x0, y0, x1, y1) {
					var dx = x1 - x0;
					var dy = y1 - y0;
					for (var i$1 = 0; i$1 <= 100; i$1++) {
						var p = i$1 / 100;
						var pt = projection_1.project([x0 + dx * p, y0 + dy * p]);
						min(leftTop_1, leftTop_1, pt);
						max(rightBottom_1, rightBottom_1, pt);
					}
				};
				sampleLine(xMin, yMin, xMax, yMin);
				sampleLine(xMax, yMin, xMax, yMax);
				sampleLine(xMax, yMax, xMin, yMax);
				sampleLine(xMin, yMax, xMax, yMin);
			}
			this.setBoundingRect(leftTop_1[0], leftTop_1[1], rightBottom_1[0] - leftTop_1[0], rightBottom_1[1] - leftTop_1[1]);
		}
	}
	var rect = this.getBoundingRect();
	var centerOption = geoModel.get("layoutCenter");
	var sizeOption = geoModel.get("layoutSize");
	var refContainer = createBoxLayoutReference(geoModel, api).refContainer;
	var aspect = rect.width / rect.height * this.aspectScale;
	var useCenterAndSize = false;
	var center$2;
	var size;
	if (centerOption && sizeOption) {
		center$2 = [parsePercent$1(centerOption[0], refContainer.width) + refContainer.x, parsePercent$1(centerOption[1], refContainer.height) + refContainer.y];
		size = parsePercent$1(sizeOption, Math.min(refContainer.width, refContainer.height));
		if (!isNaN(center$2[0]) && !isNaN(center$2[1]) && !isNaN(size)) useCenterAndSize = true;
		else console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.");
	}
	var viewRect$1;
	if (useCenterAndSize) {
		viewRect$1 = {};
		if (aspect > 1) {
			viewRect$1.width = size;
			viewRect$1.height = size / aspect;
		} else {
			viewRect$1.height = size;
			viewRect$1.width = size * aspect;
		}
		viewRect$1.y = center$2[1] - viewRect$1.height / 2;
		viewRect$1.x = center$2[0] - viewRect$1.width / 2;
	} else {
		var boxLayoutOption = geoModel.getBoxLayoutParams();
		boxLayoutOption.aspect = aspect;
		viewRect$1 = getLayoutRect(boxLayoutOption, refContainer);
		viewRect$1 = applyPreserveAspect(geoModel, viewRect$1, aspect);
	}
	this.setViewRect(viewRect$1.x, viewRect$1.y, viewRect$1.width, viewRect$1.height);
	this.setCenter(geoModel.get("center"));
	this.setZoom(geoModel.get("zoom"));
}
function setGeoCoords(geo, model) {
	each(model.get("geoCoord"), function(geoCoord$1, name) {
		geo.addGeoCoord(name, geoCoord$1);
	});
}
var geoCreator = new (function() {
	function GeoCreator() {
		this.dimensions = geo2DDimensions;
	}
	GeoCreator.prototype.create = function(ecModel, api) {
		var geoList = [];
		function getCommonGeoProperties(model) {
			return {
				nameProperty: model.get("nameProperty"),
				aspectScale: model.get("aspectScale"),
				projection: model.get("projection")
			};
		}
		ecModel.eachComponent("geo", function(geoModel, idx) {
			var mapName = geoModel.get("map");
			var geo = new Geo_default(mapName + idx, mapName, extend({
				nameMap: geoModel.get("nameMap"),
				api,
				ecModel
			}, getCommonGeoProperties(geoModel)));
			geo.zoomLimit = geoModel.get("scaleLimit");
			geoList.push(geo);
			geoModel.coordinateSystem = geo;
			geo.model = geoModel;
			geo.resize = resizeGeo;
			geo.resize(geoModel, api);
		});
		ecModel.eachSeries(function(seriesModel) {
			injectCoordSysByOption({
				targetModel: seriesModel,
				coordSysType: "geo",
				coordSysProvider: function() {
					var geoModel = seriesModel.subType === "map" ? seriesModel.getHostGeoModel() : seriesModel.getReferringComponents("geo", SINGLE_REFERRING).models[0];
					return geoModel && geoModel.coordinateSystem;
				},
				allowNotFound: true
			});
		});
		var mapModelGroupBySeries = {};
		ecModel.eachSeriesByType("map", function(seriesModel) {
			if (!seriesModel.getHostGeoModel()) {
				var mapType = seriesModel.getMapType();
				mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
				mapModelGroupBySeries[mapType].push(seriesModel);
			}
		});
		each(mapModelGroupBySeries, function(mapSeries, mapType) {
			var nameMapList = map(mapSeries, function(singleMapSeries) {
				return singleMapSeries.get("nameMap");
			});
			var geo = new Geo_default(mapType, mapType, extend({
				nameMap: mergeAll(nameMapList),
				api,
				ecModel
			}, getCommonGeoProperties(mapSeries[0])));
			geo.zoomLimit = retrieve.apply(null, map(mapSeries, function(singleMapSeries) {
				return singleMapSeries.get("scaleLimit");
			}));
			geoList.push(geo);
			geo.resize = resizeGeo;
			geo.resize(mapSeries[0], api);
			each(mapSeries, function(singleMapSeries) {
				singleMapSeries.coordinateSystem = geo;
				setGeoCoords(geo, singleMapSeries);
			});
		});
		return geoList;
	};
	/**
	* Fill given regions array
	*/
	GeoCreator.prototype.getFilledRegions = function(originRegionArr, mapName, nameMap, nameProperty) {
		var regionsArr = (originRegionArr || []).slice();
		var dataNameMap = createHashMap();
		for (var i$1 = 0; i$1 < regionsArr.length; i$1++) dataNameMap.set(regionsArr[i$1].name, regionsArr[i$1]);
		var source = geoSourceManager_default.load(mapName, nameMap, nameProperty);
		each(source.regions, function(region) {
			var name = region.name;
			var regionOption = dataNameMap.get(name);
			var specifiedGeoJSONRegionStyle = region.properties && region.properties.echartsStyle;
			if (!regionOption) {
				regionOption = { name };
				regionsArr.push(regionOption);
			}
			specifiedGeoJSONRegionStyle && merge(regionOption, specifiedGeoJSONRegionStyle);
		});
		return regionsArr;
	};
	return GeoCreator;
}())();
var geoCreator_default = geoCreator;

//#endregion
//#region node_modules/echarts/lib/coord/geo/GeoModel.js
var GeoModel = function(_super) {
	__extends(GeoModel$1, _super);
	function GeoModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = GeoModel$1.type;
		return _this;
	}
	GeoModel$1.prototype.init = function(option, parentModel, ecModel) {
		this.mergeDefaultAndTheme(option, ecModel);
		var source = geoSourceManager_default.getGeoResource(option.map);
		if (source && source.type === "geoJSON") {
			var itemStyle = option.itemStyle = option.itemStyle || {};
			if (!("color" in itemStyle)) itemStyle.color = option.defaultItemStyleColor || tokens_default.color.backgroundTint;
		}
		defaultEmphasis(option, "label", ["show"]);
	};
	GeoModel$1.prototype.optionUpdated = function() {
		var _this = this;
		var option = this.option;
		option.regions = geoCreator_default.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty);
		var selectedMap = {};
		this._optionModelMap = reduce(option.regions || [], function(optionModelMap, regionOpt) {
			var regionName = regionOpt.name;
			if (regionName) {
				optionModelMap.set(regionName, new Model_default(regionOpt, _this, _this.ecModel));
				if (regionOpt.selected) selectedMap[regionName] = true;
			}
			return optionModelMap;
		}, createHashMap());
		if (!option.selectedMap) option.selectedMap = selectedMap;
	};
	/**
	* Get model of region.
	*/
	GeoModel$1.prototype.getRegionModel = function(name) {
		return this._optionModelMap.get(name) || new Model_default(null, this, this.ecModel);
	};
	/**
	* Format label
	* @param name Region name
	*/
	GeoModel$1.prototype.getFormattedLabel = function(name, status) {
		var regionModel = this.getRegionModel(name);
		var formatter = status === "normal" ? regionModel.get(["label", "formatter"]) : regionModel.get([
			"emphasis",
			"label",
			"formatter"
		]);
		var params = { name };
		if (isFunction(formatter)) {
			params.status = status;
			return formatter(params);
		} else if (isString(formatter)) return formatter.replace("{a}", name != null ? name : "");
	};
	GeoModel$1.prototype.setZoom = function(zoom) {
		this.option.zoom = zoom;
	};
	GeoModel$1.prototype.setCenter = function(center$2) {
		this.option.center = center$2;
	};
	GeoModel$1.prototype.select = function(name) {
		var option = this.option;
		var selectedMode = option.selectedMode;
		if (!selectedMode) return;
		if (selectedMode !== "multiple") option.selectedMap = null;
		var selectedMap = option.selectedMap || (option.selectedMap = {});
		selectedMap[name] = true;
	};
	GeoModel$1.prototype.unSelect = function(name) {
		var selectedMap = this.option.selectedMap;
		if (selectedMap) selectedMap[name] = false;
	};
	GeoModel$1.prototype.toggleSelected = function(name) {
		this[this.isSelected(name) ? "unSelect" : "select"](name);
	};
	GeoModel$1.prototype.isSelected = function(name) {
		var selectedMap = this.option.selectedMap;
		return !!(selectedMap && selectedMap[name]);
	};
	GeoModel$1.type = "geo";
	GeoModel$1.layoutMode = "box";
	GeoModel$1.defaultOption = {
		z: 0,
		show: true,
		left: "center",
		top: "center",
		aspectScale: null,
		silent: false,
		map: "",
		boundingCoords: null,
		center: null,
		zoom: 1,
		scaleLimit: null,
		label: {
			show: false,
			color: tokens_default.color.tertiary
		},
		itemStyle: {
			borderWidth: .5,
			borderColor: tokens_default.color.border
		},
		emphasis: {
			label: {
				show: true,
				color: tokens_default.color.primary
			},
			itemStyle: { color: tokens_default.color.highlight }
		},
		select: {
			label: {
				show: true,
				color: tokens_default.color.primary
			},
			itemStyle: { color: tokens_default.color.highlight }
		},
		regions: []
	};
	return GeoModel$1;
}(Component_default);
var GeoModel_default = GeoModel;

//#endregion
//#region node_modules/echarts/lib/component/geo/GeoView.js
var GeoView = function(_super) {
	__extends(GeoView$1, _super);
	function GeoView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = GeoView$1.type;
		_this.focusBlurEnabled = true;
		return _this;
	}
	GeoView$1.prototype.init = function(ecModel, api) {
		this._api = api;
	};
	GeoView$1.prototype.render = function(geoModel, ecModel, api, payload) {
		this._model = geoModel;
		if (!geoModel.get("show")) {
			this._mapDraw && this._mapDraw.remove();
			this._mapDraw = null;
			return;
		}
		if (!this._mapDraw) this._mapDraw = new MapDraw_default(api);
		var mapDraw = this._mapDraw;
		mapDraw.draw(geoModel, ecModel, api, this, payload);
		mapDraw.group.on("click", this._handleRegionClick, this);
		mapDraw.group.silent = geoModel.get("silent");
		this.group.add(mapDraw.group);
		this.updateSelectStatus(geoModel, ecModel, api);
	};
	GeoView$1.prototype._handleRegionClick = function(e$1) {
		var eventData;
		findEventDispatcher(e$1.target, function(current) {
			return (eventData = getECData(current).eventData) != null;
		}, true);
		if (eventData) this._api.dispatchAction({
			type: "geoToggleSelect",
			geoId: this._model.id,
			name: eventData.name
		});
	};
	GeoView$1.prototype.updateSelectStatus = function(model, ecModel, api) {
		var _this = this;
		this._mapDraw.group.traverse(function(node) {
			var eventData = getECData(node).eventData;
			if (eventData) {
				_this._model.isSelected(eventData.name) ? api.enterSelect(node) : api.leaveSelect(node);
				return true;
			}
		});
	};
	GeoView$1.prototype.findHighDownDispatchers = function(name) {
		return this._mapDraw && this._mapDraw.findHighDownDispatchers(name, this._model);
	};
	GeoView$1.prototype.dispose = function() {
		this._mapDraw && this._mapDraw.remove();
	};
	GeoView$1.type = "geo";
	return GeoView$1;
}(Component_default$1);
var GeoView_default = GeoView;

//#endregion
//#region node_modules/echarts/lib/component/geo/install.js
function registerMap$1(mapName, geoJson, specialAreas) {
	geoSourceManager_default.registerMap(mapName, geoJson, specialAreas);
}
function install$27(registers) {
	registers.registerCoordinateSystem("geo", geoCreator_default);
	registers.registerComponentModel(GeoModel_default);
	registers.registerComponentView(GeoView_default);
	registers.registerImpl("registerMap", registerMap$1);
	registers.registerImpl("getMap", function(mapName) {
		return geoSourceManager_default.getMapForUser(mapName);
	});
	function makeAction(method, actionInfo$1) {
		actionInfo$1.update = "geo:updateSelectStatus";
		registers.registerAction(actionInfo$1, function(payload, ecModel) {
			var selected = {};
			var allSelected = [];
			ecModel.eachComponent({
				mainType: "geo",
				query: payload
			}, function(geoModel) {
				geoModel[method](payload.name);
				var geo = geoModel.coordinateSystem;
				each(geo.regions, function(region) {
					selected[region.name] = geoModel.isSelected(region.name) || false;
				});
				var names = [];
				each(selected, function(v, name) {
					selected[name] && names.push(name);
				});
				allSelected.push({
					geoIndex: geoModel.componentIndex,
					name: names
				});
			});
			return {
				selected,
				allSelected,
				name: payload.name
			};
		});
	}
	makeAction("toggleSelected", {
		type: "geoToggleSelect",
		event: "geoselectchanged"
	});
	makeAction("select", {
		type: "geoSelect",
		event: "geoselected"
	});
	makeAction("unSelect", {
		type: "geoUnSelect",
		event: "geounselected"
	});
	/**
	* @payload
	* @property {string} [componentType=series]
	* @property {number} [dx]
	* @property {number} [dy]
	* @property {number} [zoom]
	* @property {number} [originX]
	* @property {number} [originY]
	*/
	registers.registerAction({
		type: "geoRoam",
		event: "geoRoam",
		update: "updateTransform"
	}, function(payload, ecModel, api) {
		var componentType = payload.componentType;
		if (!componentType) {
			if (payload.geoId != null) componentType = "geo";
			else if (payload.seriesId != null) componentType = "series";
		}
		if (!componentType) componentType = "series";
		ecModel.eachComponent({
			mainType: componentType,
			query: payload
		}, function(componentModel) {
			var geo = componentModel.coordinateSystem;
			if (geo.type !== "geo") return;
			var res = updateCenterAndZoomInAction(geo, payload, componentModel.get("scaleLimit"));
			componentModel.setCenter && componentModel.setCenter(res.center);
			componentModel.setZoom && componentModel.setZoom(res.zoom);
			if (componentType === "series") each(componentModel.seriesGroup, function(seriesModel) {
				seriesModel.setCenter(res.center);
				seriesModel.setZoom(res.zoom);
			});
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/map/install.js
function install$7(registers) {
	use(install$27);
	registers.registerChartView(MapView_default);
	registers.registerSeriesModel(MapSeries_default);
	registers.registerLayout(mapSymbolLayout);
	registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
	createLegacyDataSelectAction("map", registers.registerAction);
}

//#endregion
//#region node_modules/echarts/lib/chart/tree/layoutHelper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Initialize all computational message for following algorithm.
*/
function init$1(inRoot) {
	var root = inRoot;
	root.hierNode = {
		defaultAncestor: null,
		ancestor: root,
		prelim: 0,
		modifier: 0,
		change: 0,
		shift: 0,
		i: 0,
		thread: null
	};
	var nodes = [root];
	var node;
	var children;
	while (node = nodes.pop()) {
		children = node.children;
		if (node.isExpand && children.length) for (var i$1 = children.length - 1; i$1 >= 0; i$1--) {
			var child = children[i$1];
			child.hierNode = {
				defaultAncestor: null,
				ancestor: child,
				prelim: 0,
				modifier: 0,
				change: 0,
				shift: 0,
				i: i$1,
				thread: null
			};
			nodes.push(child);
		}
	}
}
/**
* The implementation of this function was originally copied from "d3.js"
* <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
* with some modifications made for this program.
* See the license statement at the head of this file.
*
* Computes a preliminary x coordinate for node. Before that, this function is
* applied recursively to the children of node, as well as the function
* apportion(). After spacing out the children by calling executeShifts(), the
* node is placed to the midpoint of its outermost children.
*/
function firstWalk(node, separation$1) {
	var children = node.isExpand ? node.children : [];
	var siblings = node.parentNode.children;
	var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;
	if (children.length) {
		executeShifts(node);
		var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;
		if (subtreeW) {
			node.hierNode.prelim = subtreeW.hierNode.prelim + separation$1(node, subtreeW);
			node.hierNode.modifier = node.hierNode.prelim - midPoint;
		} else node.hierNode.prelim = midPoint;
	} else if (subtreeW) node.hierNode.prelim = subtreeW.hierNode.prelim + separation$1(node, subtreeW);
	node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation$1);
}
/**
* The implementation of this function was originally copied from "d3.js"
* <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
* with some modifications made for this program.
* See the license statement at the head of this file.
*
* Computes all real x-coordinates by summing up the modifiers recursively.
*/
function secondWalk(node) {
	var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
	node.setLayout({ x: nodeX }, true);
	node.hierNode.modifier += node.parentNode.hierNode.modifier;
}
function separation(cb) {
	return arguments.length ? cb : defaultSeparation;
}
/**
* Transform the common coordinate to radial coordinate.
*/
function radialCoordinate(rad, r) {
	rad -= Math.PI / 2;
	return {
		x: r * Math.cos(rad),
		y: r * Math.sin(rad)
	};
}
/**
* All other shifts, applied to the smaller subtrees between w- and w+, are
* performed by this function.
*
* The implementation of this function was originally copied from "d3.js"
* <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
* with some modifications made for this program.
* See the license statement at the head of this file.
*/
function executeShifts(node) {
	var children = node.children;
	var n = children.length;
	var shift = 0;
	var change = 0;
	while (--n >= 0) {
		var child = children[n];
		child.hierNode.prelim += shift;
		child.hierNode.modifier += shift;
		change += child.hierNode.change;
		shift += child.hierNode.shift + change;
	}
}
/**
* The implementation of this function was originally copied from "d3.js"
* <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
* with some modifications made for this program.
* See the license statement at the head of this file.
*
* The core of the algorithm. Here, a new subtree is combined with the
* previous subtrees. Threads are used to traverse the inside and outside
* contours of the left and right subtree up to the highest common level.
* Whenever two nodes of the inside contours conflict, we compute the left
* one of the greatest uncommon ancestors using the function nextAncestor()
* and call moveSubtree() to shift the subtree and prepare the shifts of
* smaller subtrees. Finally, we add a new thread (if necessary).
*/
function apportion(subtreeV, subtreeW, ancestor, separation$1) {
	if (subtreeW) {
		var nodeOutRight = subtreeV;
		var nodeInRight = subtreeV;
		var nodeOutLeft = nodeInRight.parentNode.children[0];
		var nodeInLeft = subtreeW;
		var sumOutRight = nodeOutRight.hierNode.modifier;
		var sumInRight = nodeInRight.hierNode.modifier;
		var sumOutLeft = nodeOutLeft.hierNode.modifier;
		var sumInLeft = nodeInLeft.hierNode.modifier;
		while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
			nodeOutRight = nextRight(nodeOutRight);
			nodeOutLeft = nextLeft(nodeOutLeft);
			nodeOutRight.hierNode.ancestor = subtreeV;
			var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation$1(nodeInLeft, nodeInRight);
			if (shift > 0) {
				moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
				sumInRight += shift;
				sumOutRight += shift;
			}
			sumInLeft += nodeInLeft.hierNode.modifier;
			sumInRight += nodeInRight.hierNode.modifier;
			sumOutRight += nodeOutRight.hierNode.modifier;
			sumOutLeft += nodeOutLeft.hierNode.modifier;
		}
		if (nodeInLeft && !nextRight(nodeOutRight)) {
			nodeOutRight.hierNode.thread = nodeInLeft;
			nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
		}
		if (nodeInRight && !nextLeft(nodeOutLeft)) {
			nodeOutLeft.hierNode.thread = nodeInRight;
			nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
			ancestor = subtreeV;
		}
	}
	return ancestor;
}
/**
* This function is used to traverse the right contour of a subtree.
* It returns the rightmost child of node or the thread of node. The function
* returns null if and only if node is on the highest depth of its subtree.
*/
function nextRight(node) {
	var children = node.children;
	return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
}
/**
* This function is used to traverse the left contour of a subtree (or a subforest).
* It returns the leftmost child of node or the thread of node. The function
* returns null if and only if node is on the highest depth of its subtree.
*/
function nextLeft(node) {
	var children = node.children;
	return children.length && node.isExpand ? children[0] : node.hierNode.thread;
}
/**
* If nodeInLefts ancestor is a sibling of node, returns nodeInLefts ancestor.
* Otherwise, returns the specified ancestor.
*/
function nextAncestor(nodeInLeft, node, ancestor) {
	return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
}
/**
* The implementation of this function was originally copied from "d3.js"
* <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
* with some modifications made for this program.
* See the license statement at the head of this file.
*
* Shifts the current subtree rooted at wr.
* This is done by increasing prelim(w+) and modifier(w+) by shift.
*/
function moveSubtree(wl, wr, shift) {
	var change = shift / (wr.hierNode.i - wl.hierNode.i);
	wr.hierNode.change -= change;
	wr.hierNode.shift += shift;
	wr.hierNode.modifier += shift;
	wr.hierNode.prelim += shift;
	wl.hierNode.change += change;
}
/**
* The implementation of this function was originally copied from "d3.js"
* <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
* with some modifications made for this program.
* See the license statement at the head of this file.
*/
function defaultSeparation(node1, node2) {
	return node1.parentNode === node2.parentNode ? 1 : 2;
}

//#endregion
//#region node_modules/echarts/lib/chart/tree/TreeView.js
var TreeEdgeShape = function() {
	function TreeEdgeShape$1() {
		this.parentPoint = [];
		this.childPoints = [];
	}
	return TreeEdgeShape$1;
}();
var TreePath = function(_super) {
	__extends(TreePath$1, _super);
	function TreePath$1(opts) {
		return _super.call(this, opts) || this;
	}
	TreePath$1.prototype.getDefaultStyle = function() {
		return {
			stroke: tokens_default.color.neutral99,
			fill: null
		};
	};
	TreePath$1.prototype.getDefaultShape = function() {
		return new TreeEdgeShape();
	};
	TreePath$1.prototype.buildPath = function(ctx, shape) {
		var childPoints = shape.childPoints;
		var childLen = childPoints.length;
		var parentPoint = shape.parentPoint;
		var firstChildPos = childPoints[0];
		var lastChildPos = childPoints[childLen - 1];
		if (childLen === 1) {
			ctx.moveTo(parentPoint[0], parentPoint[1]);
			ctx.lineTo(firstChildPos[0], firstChildPos[1]);
			return;
		}
		var orient = shape.orient;
		var forkDim = orient === "TB" || orient === "BT" ? 0 : 1;
		var otherDim = 1 - forkDim;
		var forkPosition = parsePercent$1(shape.forkPosition, 1);
		var tmpPoint = [];
		tmpPoint[forkDim] = parentPoint[forkDim];
		tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;
		ctx.moveTo(parentPoint[0], parentPoint[1]);
		ctx.lineTo(tmpPoint[0], tmpPoint[1]);
		ctx.moveTo(firstChildPos[0], firstChildPos[1]);
		tmpPoint[forkDim] = firstChildPos[forkDim];
		ctx.lineTo(tmpPoint[0], tmpPoint[1]);
		tmpPoint[forkDim] = lastChildPos[forkDim];
		ctx.lineTo(tmpPoint[0], tmpPoint[1]);
		ctx.lineTo(lastChildPos[0], lastChildPos[1]);
		for (var i$1 = 1; i$1 < childLen - 1; i$1++) {
			var point = childPoints[i$1];
			ctx.moveTo(point[0], point[1]);
			tmpPoint[forkDim] = point[forkDim];
			ctx.lineTo(tmpPoint[0], tmpPoint[1]);
		}
	};
	return TreePath$1;
}(Path_default);
var TreeView = function(_super) {
	__extends(TreeView$1, _super);
	function TreeView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = TreeView$1.type;
		_this._mainGroup = new Group_default();
		return _this;
	}
	TreeView$1.prototype.init = function(ecModel, api) {
		this._controller = new RoamController_default(api.getZr());
		this._controllerHost = { target: this.group };
		this.group.add(this._mainGroup);
	};
	TreeView$1.prototype.render = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		var layoutInfo = seriesModel.layoutInfo;
		var group = this._mainGroup;
		if (seriesModel.get("layout") === "radial") {
			group.x = layoutInfo.x + layoutInfo.width / 2;
			group.y = layoutInfo.y + layoutInfo.height / 2;
		} else {
			group.x = layoutInfo.x;
			group.y = layoutInfo.y;
		}
		this._updateViewCoordSys(seriesModel, api);
		this._updateController(seriesModel, null, ecModel, api);
		var oldData = this._data;
		data.diff(oldData).add(function(newIdx) {
			if (symbolNeedsDraw(data, newIdx)) updateNode(data, newIdx, null, group, seriesModel);
		}).update(function(newIdx, oldIdx) {
			var symbolEl = oldData.getItemGraphicEl(oldIdx);
			if (!symbolNeedsDraw(data, newIdx)) {
				symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
				return;
			}
			updateNode(data, newIdx, symbolEl, group, seriesModel);
		}).remove(function(oldIdx) {
			var symbolEl = oldData.getItemGraphicEl(oldIdx);
			if (symbolEl) removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
		}).execute();
		this._nodeScaleRatio = seriesModel.get("nodeScaleRatio");
		this._updateNodeAndLinkScale(seriesModel);
		if (seriesModel.get("expandAndCollapse") === true) data.eachItemGraphicEl(function(el, dataIndex) {
			el.off("click").on("click", function() {
				api.dispatchAction({
					type: "treeExpandAndCollapse",
					seriesId: seriesModel.id,
					dataIndex
				});
			});
		});
		this._data = data;
	};
	TreeView$1.prototype._updateViewCoordSys = function(seriesModel, api) {
		var data = seriesModel.getData();
		var points$3 = [];
		data.each(function(idx) {
			var layout$3 = data.getItemLayout(idx);
			if (layout$3 && !isNaN(layout$3.x) && !isNaN(layout$3.y)) points$3.push([+layout$3.x, +layout$3.y]);
		});
		var min$2 = [];
		var max$2 = [];
		fromPoints(points$3, min$2, max$2);
		var oldMin = this._min;
		var oldMax = this._max;
		if (max$2[0] - min$2[0] === 0) {
			min$2[0] = oldMin ? oldMin[0] : min$2[0] - 1;
			max$2[0] = oldMax ? oldMax[0] : max$2[0] + 1;
		}
		if (max$2[1] - min$2[1] === 0) {
			min$2[1] = oldMin ? oldMin[1] : min$2[1] - 1;
			max$2[1] = oldMax ? oldMax[1] : max$2[1] + 1;
		}
		var viewCoordSys = seriesModel.coordinateSystem = new View_default(null, {
			api,
			ecModel: seriesModel.ecModel
		});
		viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
		viewCoordSys.setBoundingRect(min$2[0], min$2[1], max$2[0] - min$2[0], max$2[1] - min$2[1]);
		viewCoordSys.setCenter(seriesModel.get("center"));
		viewCoordSys.setZoom(seriesModel.get("zoom"));
		this.group.attr({
			x: viewCoordSys.x,
			y: viewCoordSys.y,
			scaleX: viewCoordSys.scaleX,
			scaleY: viewCoordSys.scaleY
		});
		this._min = min$2;
		this._max = max$2;
	};
	TreeView$1.prototype._updateController = function(seriesModel, clipRect, ecModel, api) {
		var _this = this;
		updateController(seriesModel, api, this.group, this._controller, this._controllerHost, clipRect);
		this._controller.on("zoom", function(e$1) {
			_this._updateNodeAndLinkScale(seriesModel);
		});
	};
	TreeView$1.prototype._updateNodeAndLinkScale = function(seriesModel) {
		var data = seriesModel.getData();
		var nodeScale = this._getNodeGlobalScale(seriesModel);
		data.eachItemGraphicEl(function(el, idx) {
			el.setSymbolScale(nodeScale);
		});
	};
	TreeView$1.prototype._getNodeGlobalScale = function(seriesModel) {
		var coordSys = seriesModel.coordinateSystem;
		if (coordSys.type !== "view") return 1;
		var nodeScaleRatio = this._nodeScaleRatio;
		var groupZoom = coordSys.scaleX || 1;
		return ((coordSys.getZoom() - 1) * nodeScaleRatio + 1) / groupZoom;
	};
	TreeView$1.prototype.dispose = function() {
		this._controller && this._controller.dispose();
		this._controllerHost = null;
	};
	TreeView$1.prototype.remove = function() {
		this._mainGroup.removeAll();
		this._data = null;
	};
	TreeView$1.type = "tree";
	return TreeView$1;
}(Chart_default);
function symbolNeedsDraw(data, dataIndex) {
	var layout$3 = data.getItemLayout(dataIndex);
	return layout$3 && !isNaN(layout$3.x) && !isNaN(layout$3.y);
}
function updateNode(data, dataIndex, symbolEl, group, seriesModel) {
	var isInit = !symbolEl;
	var node = data.tree.getNodeByDataIndex(dataIndex);
	var itemModel = node.getModel();
	var visualColor = node.getVisual("style").fill;
	var symbolInnerColor = node.isExpand === false && node.children.length !== 0 ? visualColor : tokens_default.color.neutral00;
	var virtualRoot = data.tree.root;
	var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
	var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
	var sourceLayout = source.getLayout();
	var sourceOldLayout = sourceSymbolEl ? {
		x: sourceSymbolEl.__oldX,
		y: sourceSymbolEl.__oldY,
		rawX: sourceSymbolEl.__radialOldRawX,
		rawY: sourceSymbolEl.__radialOldRawY
	} : sourceLayout;
	var targetLayout = node.getLayout();
	if (isInit) {
		symbolEl = new Symbol_default(data, dataIndex, null, {
			symbolInnerColor,
			useNameLabel: true
		});
		symbolEl.x = sourceOldLayout.x;
		symbolEl.y = sourceOldLayout.y;
	} else symbolEl.updateData(data, dataIndex, null, {
		symbolInnerColor,
		useNameLabel: true
	});
	symbolEl.__radialOldRawX = symbolEl.__radialRawX;
	symbolEl.__radialOldRawY = symbolEl.__radialRawY;
	symbolEl.__radialRawX = targetLayout.rawX;
	symbolEl.__radialRawY = targetLayout.rawY;
	group.add(symbolEl);
	data.setItemGraphicEl(dataIndex, symbolEl);
	symbolEl.__oldX = symbolEl.x;
	symbolEl.__oldY = symbolEl.y;
	updateProps(symbolEl, {
		x: targetLayout.x,
		y: targetLayout.y
	}, seriesModel);
	var symbolPath = symbolEl.getSymbolPath();
	if (seriesModel.get("layout") === "radial") {
		var realRoot = virtualRoot.children[0];
		var rootLayout = realRoot.getLayout();
		var length_1 = realRoot.children.length;
		var rad = void 0;
		var isLeft = void 0;
		if (targetLayout.x === rootLayout.x && node.isExpand === true && realRoot.children.length) {
			var center$2 = {
				x: (realRoot.children[0].getLayout().x + realRoot.children[length_1 - 1].getLayout().x) / 2,
				y: (realRoot.children[0].getLayout().y + realRoot.children[length_1 - 1].getLayout().y) / 2
			};
			rad = Math.atan2(center$2.y - rootLayout.y, center$2.x - rootLayout.x);
			if (rad < 0) rad = Math.PI * 2 + rad;
			isLeft = center$2.x < rootLayout.x;
			if (isLeft) rad = rad - Math.PI;
		} else {
			rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);
			if (rad < 0) rad = Math.PI * 2 + rad;
			if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
				isLeft = targetLayout.x < rootLayout.x;
				if (isLeft) rad = rad - Math.PI;
			} else {
				isLeft = targetLayout.x > rootLayout.x;
				if (!isLeft) rad = rad - Math.PI;
			}
		}
		var textPosition = isLeft ? "left" : "right";
		var normalLabelModel = itemModel.getModel("label");
		var rotate$1 = normalLabelModel.get("rotate");
		var labelRotateRadian = rotate$1 * (Math.PI / 180);
		var textContent = symbolPath.getTextContent();
		if (textContent) {
			symbolPath.setTextConfig({
				position: normalLabelModel.get("position") || textPosition,
				rotation: rotate$1 == null ? -rad : labelRotateRadian,
				origin: "center"
			});
			textContent.setStyle("verticalAlign", "middle");
		}
	}
	var focus = itemModel.get(["emphasis", "focus"]);
	var focusDataIndices = focus === "relative" ? concatArray(node.getAncestorsIndices(), node.getDescendantIndices()) : focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : null;
	if (focusDataIndices) getECData(symbolEl).focus = focusDataIndices;
	drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group);
	if (symbolEl.__edge) symbolEl.onHoverStateChange = function(toState) {
		if (toState !== "blur") {
			var parentEl = node.parentNode && data.getItemGraphicEl(node.parentNode.dataIndex);
			if (!(parentEl && parentEl.hoverState === HOVER_STATE_BLUR)) setStatesFlag(symbolEl.__edge, toState);
		}
	};
}
function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group) {
	var itemModel = node.getModel();
	var edgeShape = seriesModel.get("edgeShape");
	var layout$3 = seriesModel.get("layout");
	var orient = seriesModel.getOrient();
	var curvature = seriesModel.get(["lineStyle", "curveness"]);
	var edgeForkPosition = seriesModel.get("edgeForkPosition");
	var lineStyle = itemModel.getModel("lineStyle").getLineStyle();
	var edge = symbolEl.__edge;
	if (edgeShape === "curve") {
		if (node.parentNode && node.parentNode !== virtualRoot) {
			if (!edge) edge = symbolEl.__edge = new BezierCurve_default({ shape: getEdgeShape(layout$3, orient, curvature, sourceOldLayout, sourceOldLayout) });
			updateProps(edge, { shape: getEdgeShape(layout$3, orient, curvature, sourceLayout, targetLayout) }, seriesModel);
		}
	} else if (edgeShape === "polyline") if (layout$3 === "orthogonal") {
		if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
			var children = node.children;
			var childPoints = [];
			for (var i$1 = 0; i$1 < children.length; i$1++) {
				var childLayout = children[i$1].getLayout();
				childPoints.push([childLayout.x, childLayout.y]);
			}
			if (!edge) edge = symbolEl.__edge = new TreePath({ shape: {
				parentPoint: [targetLayout.x, targetLayout.y],
				childPoints: [[targetLayout.x, targetLayout.y]],
				orient,
				forkPosition: edgeForkPosition
			} });
			updateProps(edge, { shape: {
				parentPoint: [targetLayout.x, targetLayout.y],
				childPoints
			} }, seriesModel);
		}
	} else throw new Error("The polyline edgeShape can only be used in orthogonal layout");
	if (edge && !(edgeShape === "polyline" && !node.isExpand)) {
		edge.useStyle(defaults({
			strokeNoScale: true,
			fill: null
		}, lineStyle));
		setStatesStylesFromModel(edge, itemModel, "lineStyle");
		setDefaultStateProxy(edge);
		group.add(edge);
	}
}
function removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt) {
	var virtualRoot = data.tree.root;
	var _a$1 = getSourceNode(virtualRoot, node), source = _a$1.source, sourceLayout = _a$1.sourceLayout;
	var symbolEl = data.getItemGraphicEl(node.dataIndex);
	if (!symbolEl) return;
	var sourceEdge = data.getItemGraphicEl(source.dataIndex).__edge;
	var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : void 0);
	var edgeShape = seriesModel.get("edgeShape");
	var layoutOpt = seriesModel.get("layout");
	var orient = seriesModel.get("orient");
	var curvature = seriesModel.get(["lineStyle", "curveness"]);
	if (edge) {
		if (edgeShape === "curve") removeElement(edge, {
			shape: getEdgeShape(layoutOpt, orient, curvature, sourceLayout, sourceLayout),
			style: { opacity: 0 }
		}, seriesModel, {
			cb: function() {
				group.remove(edge);
			},
			removeOpt: removeAnimationOpt
		});
		else if (edgeShape === "polyline" && seriesModel.get("layout") === "orthogonal") removeElement(edge, {
			shape: {
				parentPoint: [sourceLayout.x, sourceLayout.y],
				childPoints: [[sourceLayout.x, sourceLayout.y]]
			},
			style: { opacity: 0 }
		}, seriesModel, {
			cb: function() {
				group.remove(edge);
			},
			removeOpt: removeAnimationOpt
		});
	}
}
function getSourceNode(virtualRoot, node) {
	var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
	var sourceLayout;
	while (sourceLayout = source.getLayout(), sourceLayout == null) source = source.parentNode === virtualRoot ? source : source.parentNode || source;
	return {
		source,
		sourceLayout
	};
}
function removeNode(data, dataIndex, symbolEl, group, seriesModel) {
	var node = data.tree.getNodeByDataIndex(dataIndex);
	var virtualRoot = data.tree.root;
	var sourceLayout = getSourceNode(virtualRoot, node).sourceLayout;
	var removeAnimationOpt = {
		duration: seriesModel.get("animationDurationUpdate"),
		easing: seriesModel.get("animationEasingUpdate")
	};
	removeElement(symbolEl, {
		x: sourceLayout.x + 1,
		y: sourceLayout.y + 1
	}, seriesModel, {
		cb: function() {
			group.remove(symbolEl);
			data.setItemGraphicEl(dataIndex, null);
		},
		removeOpt: removeAnimationOpt
	});
	symbolEl.fadeOut(null, data.hostModel, {
		fadeLabel: true,
		animation: removeAnimationOpt
	});
	node.children.forEach(function(childNode) {
		removeNodeEdge(childNode, data, group, seriesModel, removeAnimationOpt);
	});
	removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt);
}
function getEdgeShape(layoutOpt, orient, curvature, sourceLayout, targetLayout) {
	var cpx1;
	var cpy1;
	var cpx2;
	var cpy2;
	var x1;
	var x2;
	var y1;
	var y2;
	if (layoutOpt === "radial") {
		x1 = sourceLayout.rawX;
		y1 = sourceLayout.rawY;
		x2 = targetLayout.rawX;
		y2 = targetLayout.rawY;
		var radialCoor1 = radialCoordinate(x1, y1);
		var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * curvature);
		var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * curvature);
		var radialCoor4 = radialCoordinate(x2, y2);
		return {
			x1: radialCoor1.x || 0,
			y1: radialCoor1.y || 0,
			x2: radialCoor4.x || 0,
			y2: radialCoor4.y || 0,
			cpx1: radialCoor2.x || 0,
			cpy1: radialCoor2.y || 0,
			cpx2: radialCoor3.x || 0,
			cpy2: radialCoor3.y || 0
		};
	} else {
		x1 = sourceLayout.x;
		y1 = sourceLayout.y;
		x2 = targetLayout.x;
		y2 = targetLayout.y;
		if (orient === "LR" || orient === "RL") {
			cpx1 = x1 + (x2 - x1) * curvature;
			cpy1 = y1;
			cpx2 = x2 + (x1 - x2) * curvature;
			cpy2 = y2;
		}
		if (orient === "TB" || orient === "BT") {
			cpx1 = x1;
			cpy1 = y1 + (y2 - y1) * curvature;
			cpx2 = x2;
			cpy2 = y2 + (y1 - y2) * curvature;
		}
	}
	return {
		x1,
		y1,
		x2,
		y2,
		cpx1,
		cpy1,
		cpx2,
		cpy2
	};
}
var TreeView_default = TreeView;

//#endregion
//#region node_modules/echarts/lib/data/helper/linkSeriesData.js
var inner$15 = makeInner();
function linkSeriesData(opt) {
	var mainData = opt.mainData;
	var datas = opt.datas;
	if (!datas) {
		datas = { main: mainData };
		opt.datasAttr = { main: "data" };
	}
	opt.datas = opt.mainData = null;
	linkAll(mainData, datas, opt);
	each(datas, function(data) {
		each(mainData.TRANSFERABLE_METHODS, function(methodName) {
			data.wrapMethod(methodName, curry(transferInjection, opt));
		});
	});
	mainData.wrapMethod("cloneShallow", curry(cloneShallowInjection, opt));
	each(mainData.CHANGABLE_METHODS, function(methodName) {
		mainData.wrapMethod(methodName, curry(changeInjection, opt));
	});
	assert(datas[mainData.dataType] === mainData);
}
function transferInjection(opt, res) {
	if (isMainData(this)) {
		var datas = extend({}, inner$15(this).datas);
		datas[this.dataType] = res;
		linkAll(res, datas, opt);
	} else linkSingle(res, this.dataType, inner$15(this).mainData, opt);
	return res;
}
function changeInjection(opt, res) {
	opt.struct && opt.struct.update();
	return res;
}
function cloneShallowInjection(opt, res) {
	each(inner$15(res).datas, function(data, dataType) {
		data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
	});
	return res;
}
/**
* Supplement method to List.
*
* @public
* @param [dataType] If not specified, return mainData.
*/
function getLinkedData(dataType) {
	var mainData = inner$15(this).mainData;
	return dataType == null || mainData == null ? mainData : inner$15(mainData).datas[dataType];
}
/**
* Get list of all linked data
*/
function getLinkedDataAll() {
	var mainData = inner$15(this).mainData;
	return mainData == null ? [{ data: mainData }] : map(keys(inner$15(mainData).datas), function(type) {
		return {
			type,
			data: inner$15(mainData).datas[type]
		};
	});
}
function isMainData(data) {
	return inner$15(data).mainData === data;
}
function linkAll(mainData, datas, opt) {
	inner$15(mainData).datas = {};
	each(datas, function(data, dataType) {
		linkSingle(data, dataType, mainData, opt);
	});
}
function linkSingle(data, dataType, mainData, opt) {
	inner$15(mainData).datas[dataType] = data;
	inner$15(data).mainData = mainData;
	data.dataType = dataType;
	if (opt.struct) {
		data[opt.structAttr] = opt.struct;
		opt.struct[opt.datasAttr[dataType]] = data;
	}
	data.getLinkedData = getLinkedData;
	data.getLinkedDataAll = getLinkedDataAll;
}
var linkSeriesData_default = linkSeriesData;

//#endregion
//#region node_modules/echarts/lib/data/Tree.js
var TreeNode = function() {
	function TreeNode$1(name, hostTree) {
		this.depth = 0;
		this.height = 0;
		/**
		* Reference to list item.
		* Do not persistent dataIndex outside,
		* besause it may be changed by list.
		* If dataIndex -1,
		* this node is logical deleted (filtered) in list.
		*/
		this.dataIndex = -1;
		this.children = [];
		this.viewChildren = [];
		this.isExpand = false;
		this.name = name || "";
		this.hostTree = hostTree;
	}
	/**
	* The node is removed.
	*/
	TreeNode$1.prototype.isRemoved = function() {
		return this.dataIndex < 0;
	};
	TreeNode$1.prototype.eachNode = function(options, cb, context) {
		if (isFunction(options)) {
			context = cb;
			cb = options;
			options = null;
		}
		options = options || {};
		if (isString(options)) options = { order: options };
		var order = options.order || "preorder";
		var children = this[options.attr || "children"];
		var suppressVisitSub;
		order === "preorder" && (suppressVisitSub = cb.call(context, this));
		for (var i$1 = 0; !suppressVisitSub && i$1 < children.length; i$1++) children[i$1].eachNode(options, cb, context);
		order === "postorder" && cb.call(context, this);
	};
	/**
	* Update depth and height of this subtree.
	*/
	TreeNode$1.prototype.updateDepthAndHeight = function(depth) {
		var height = 0;
		this.depth = depth;
		for (var i$1 = 0; i$1 < this.children.length; i$1++) {
			var child = this.children[i$1];
			child.updateDepthAndHeight(depth + 1);
			if (child.height > height) height = child.height;
		}
		this.height = height + 1;
	};
	TreeNode$1.prototype.getNodeById = function(id) {
		if (this.getId() === id) return this;
		for (var i$1 = 0, children = this.children, len$1 = children.length; i$1 < len$1; i$1++) {
			var res = children[i$1].getNodeById(id);
			if (res) return res;
		}
	};
	TreeNode$1.prototype.contains = function(node) {
		if (node === this) return true;
		for (var i$1 = 0, children = this.children, len$1 = children.length; i$1 < len$1; i$1++) {
			var res = children[i$1].contains(node);
			if (res) return res;
		}
	};
	/**
	* @param includeSelf Default false.
	* @return order: [root, child, grandchild, ...]
	*/
	TreeNode$1.prototype.getAncestors = function(includeSelf) {
		var ancestors = [];
		var node = includeSelf ? this : this.parentNode;
		while (node) {
			ancestors.push(node);
			node = node.parentNode;
		}
		ancestors.reverse();
		return ancestors;
	};
	TreeNode$1.prototype.getAncestorsIndices = function() {
		var indices = [];
		var currNode = this;
		while (currNode) {
			indices.push(currNode.dataIndex);
			currNode = currNode.parentNode;
		}
		indices.reverse();
		return indices;
	};
	TreeNode$1.prototype.getDescendantIndices = function() {
		var indices = [];
		this.eachNode(function(childNode) {
			indices.push(childNode.dataIndex);
		});
		return indices;
	};
	TreeNode$1.prototype.getValue = function(dimension) {
		var data = this.hostTree.data;
		return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
	};
	TreeNode$1.prototype.setLayout = function(layout$3, merge$1) {
		this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout$3, merge$1);
	};
	/**
	* @return {Object} layout
	*/
	TreeNode$1.prototype.getLayout = function() {
		return this.hostTree.data.getItemLayout(this.dataIndex);
	};
	TreeNode$1.prototype.getModel = function(path) {
		if (this.dataIndex < 0) return;
		return this.hostTree.data.getItemModel(this.dataIndex).getModel(path);
	};
	TreeNode$1.prototype.getLevelModel = function() {
		return (this.hostTree.levelModels || [])[this.depth];
	};
	TreeNode$1.prototype.setVisual = function(key$1, value) {
		this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key$1, value);
	};
	/**
	* Get item visual
	* FIXME: make return type better
	*/
	TreeNode$1.prototype.getVisual = function(key$1) {
		return this.hostTree.data.getItemVisual(this.dataIndex, key$1);
	};
	TreeNode$1.prototype.getRawIndex = function() {
		return this.hostTree.data.getRawIndex(this.dataIndex);
	};
	TreeNode$1.prototype.getId = function() {
		return this.hostTree.data.getId(this.dataIndex);
	};
	/**
	* index in parent's children
	*/
	TreeNode$1.prototype.getChildIndex = function() {
		if (this.parentNode) {
			var children = this.parentNode.children;
			for (var i$1 = 0; i$1 < children.length; ++i$1) if (children[i$1] === this) return i$1;
			return -1;
		}
		return -1;
	};
	/**
	* if this is an ancestor of another node
	*
	* @param node another node
	* @return if is ancestor
	*/
	TreeNode$1.prototype.isAncestorOf = function(node) {
		var parent = node.parentNode;
		while (parent) {
			if (parent === this) return true;
			parent = parent.parentNode;
		}
		return false;
	};
	/**
	* if this is an descendant of another node
	*
	* @param node another node
	* @return if is descendant
	*/
	TreeNode$1.prototype.isDescendantOf = function(node) {
		return node !== this && node.isAncestorOf(this);
	};
	return TreeNode$1;
}();
var Tree = function() {
	function Tree$1(hostModel) {
		this.type = "tree";
		this._nodes = [];
		this.hostModel = hostModel;
	}
	Tree$1.prototype.eachNode = function(options, cb, context) {
		this.root.eachNode(options, cb, context);
	};
	Tree$1.prototype.getNodeByDataIndex = function(dataIndex) {
		var rawIndex = this.data.getRawIndex(dataIndex);
		return this._nodes[rawIndex];
	};
	Tree$1.prototype.getNodeById = function(name) {
		return this.root.getNodeById(name);
	};
	/**
	* Update item available by list,
	* when list has been performed options like 'filterSelf' or 'map'.
	*/
	Tree$1.prototype.update = function() {
		var data = this.data;
		var nodes = this._nodes;
		for (var i$1 = 0, len$1 = nodes.length; i$1 < len$1; i$1++) nodes[i$1].dataIndex = -1;
		for (var i$1 = 0, len$1 = data.count(); i$1 < len$1; i$1++) nodes[data.getRawIndex(i$1)].dataIndex = i$1;
	};
	/**
	* Clear all layouts
	*/
	Tree$1.prototype.clearLayouts = function() {
		this.data.clearItemLayouts();
	};
	/**
	* data node format:
	* {
	*     name: ...
	*     value: ...
	*     children: [
	*         {
	*             name: ...
	*             value: ...
	*             children: ...
	*         },
	*         ...
	*     ]
	* }
	*/
	Tree$1.createTree = function(dataRoot, hostModel, beforeLink) {
		var tree = new Tree$1(hostModel);
		var listData = [];
		var dimMax = 1;
		buildHierarchy(dataRoot);
		function buildHierarchy(dataNode, parentNode$1) {
			var value = dataNode.value;
			dimMax = Math.max(dimMax, isArray(value) ? value.length : 1);
			listData.push(dataNode);
			var node = new TreeNode(convertOptionIdName(dataNode.name, ""), tree);
			parentNode$1 ? addChild(node, parentNode$1) : tree.root = node;
			tree._nodes.push(node);
			var children = dataNode.children;
			if (children) for (var i$1 = 0; i$1 < children.length; i$1++) buildHierarchy(children[i$1], node);
		}
		tree.root.updateDepthAndHeight(0);
		var dimensions = prepareSeriesDataSchema(listData, {
			coordDimensions: ["value"],
			dimensionsCount: dimMax
		}).dimensions;
		var list = new SeriesData_default(dimensions, hostModel);
		list.initData(listData);
		beforeLink && beforeLink(list);
		linkSeriesData_default({
			mainData: list,
			struct: tree,
			structAttr: "tree"
		});
		tree.update();
		return tree;
	};
	return Tree$1;
}();
/**
* It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,
* so this function is not ready and not necessary to be public.
*/
function addChild(child, node) {
	var children = node.children;
	if (child.parentNode === node) return;
	children.push(child);
	child.parentNode = node;
}
var Tree_default = Tree;

//#endregion
//#region node_modules/echarts/lib/chart/helper/treeHelper.js
function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
	if (payload && indexOf(validPayloadTypes, payload.type) >= 0) {
		var root = seriesModel.getData().tree.root;
		var targetNode = payload.targetNode;
		if (isString(targetNode)) targetNode = root.getNodeById(targetNode);
		if (targetNode && root.contains(targetNode)) return { node: targetNode };
		var targetNodeId = payload.targetNodeId;
		if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) return { node: targetNode };
	}
}
function getPathToRoot(node) {
	var path = [];
	while (node) {
		node = node.parentNode;
		node && path.push(node);
	}
	return path.reverse();
}
function aboveViewRoot(viewRoot, node) {
	var viewPath = getPathToRoot(viewRoot);
	return indexOf(viewPath, node) >= 0;
}
function wrapTreePathInfo(node, seriesModel) {
	var treePathInfo = [];
	while (node) {
		var nodeDataIndex = node.dataIndex;
		treePathInfo.push({
			name: node.name,
			dataIndex: nodeDataIndex,
			value: seriesModel.getRawValue(nodeDataIndex)
		});
		node = node.parentNode;
	}
	treePathInfo.reverse();
	return treePathInfo;
}

//#endregion
//#region node_modules/echarts/lib/chart/tree/TreeSeries.js
var TreeSeriesModel = function(_super) {
	__extends(TreeSeriesModel$1, _super);
	function TreeSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.hasSymbolVisual = true;
		_this.ignoreStyleOnData = true;
		return _this;
	}
	/**
	* Init a tree data structure from data in option series
	*/
	TreeSeriesModel$1.prototype.getInitialData = function(option) {
		var root = {
			name: option.name,
			children: option.data
		};
		var leavesModel = new Model_default(option.leaves || {}, this, this.ecModel);
		var tree = Tree_default.createTree(root, this, beforeLink);
		function beforeLink(nodeData) {
			nodeData.wrapMethod("getItemModel", function(model, idx) {
				var node = tree.getNodeByDataIndex(idx);
				if (!(node && node.children.length && node.isExpand)) model.parentModel = leavesModel;
				return model;
			});
		}
		var treeDepth = 0;
		tree.eachNode("preorder", function(node) {
			if (node.depth > treeDepth) treeDepth = node.depth;
		});
		var expandTreeDepth = option.expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
		tree.root.eachNode("preorder", function(node) {
			var item = node.hostTree.data.getRawDataItem(node.dataIndex);
			node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
		});
		return tree.data;
	};
	/**
	* Make the configuration 'orient' backward compatibly, with 'horizontal = LR', 'vertical = TB'.
	* @returns {string} orient
	*/
	TreeSeriesModel$1.prototype.getOrient = function() {
		var orient = this.get("orient");
		if (orient === "horizontal") orient = "LR";
		else if (orient === "vertical") orient = "TB";
		return orient;
	};
	TreeSeriesModel$1.prototype.setZoom = function(zoom) {
		this.option.zoom = zoom;
	};
	TreeSeriesModel$1.prototype.setCenter = function(center$2) {
		this.option.center = center$2;
	};
	TreeSeriesModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		var tree = this.getData().tree;
		var realRoot = tree.root.children[0];
		var node = tree.getNodeByDataIndex(dataIndex);
		var value = node.getValue();
		var name = node.name;
		while (node && node !== realRoot) {
			name = node.parentNode.name + "." + name;
			node = node.parentNode;
		}
		return createTooltipMarkup("nameValue", {
			name,
			value,
			noValue: isNaN(value) || value == null
		});
	};
	TreeSeriesModel$1.prototype.getDataParams = function(dataIndex) {
		var params = _super.prototype.getDataParams.apply(this, arguments);
		var node = this.getData().tree.getNodeByDataIndex(dataIndex);
		params.treeAncestors = wrapTreePathInfo(node, this);
		params.collapsed = !node.isExpand;
		return params;
	};
	TreeSeriesModel$1.type = "series.tree";
	TreeSeriesModel$1.layoutMode = "box";
	TreeSeriesModel$1.defaultOption = {
		z: 2,
		coordinateSystemUsage: "box",
		left: "12%",
		top: "12%",
		right: "12%",
		bottom: "12%",
		layout: "orthogonal",
		edgeShape: "curve",
		edgeForkPosition: "50%",
		roam: false,
		roamTrigger: "global",
		nodeScaleRatio: .4,
		center: null,
		zoom: 1,
		orient: "LR",
		symbol: "emptyCircle",
		symbolSize: 7,
		expandAndCollapse: true,
		initialTreeDepth: 2,
		lineStyle: {
			color: tokens_default.color.borderTint,
			width: 1.5,
			curveness: .5
		},
		itemStyle: {
			color: "lightsteelblue",
			borderWidth: 1.5
		},
		label: { show: true },
		animationEasing: "linear",
		animationDuration: 700,
		animationDurationUpdate: 500
	};
	return TreeSeriesModel$1;
}(Series_default);
var TreeSeries_default = TreeSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/tree/traversalHelper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Traverse the tree from bottom to top and do something
*/
function eachAfter(root, callback, separation$1) {
	var nodes = [root];
	var next = [];
	var node;
	while (node = nodes.pop()) {
		next.push(node);
		if (node.isExpand) {
			var children = node.children;
			if (children.length) for (var i$1 = 0; i$1 < children.length; i$1++) nodes.push(children[i$1]);
		}
	}
	while (node = next.pop()) callback(node, separation$1);
}
/**
* Traverse the tree from top to bottom and do something
*/
function eachBefore(root, callback) {
	var nodes = [root];
	var node;
	while (node = nodes.pop()) {
		callback(node);
		if (node.isExpand) {
			var children = node.children;
			if (children.length) for (var i$1 = children.length - 1; i$1 >= 0; i$1--) nodes.push(children[i$1]);
		}
	}
}

//#endregion
//#region node_modules/echarts/lib/chart/tree/treeLayout.js
function treeLayout(ecModel, api) {
	ecModel.eachSeriesByType("tree", function(seriesModel) {
		commonLayout(seriesModel, api);
	});
}
function commonLayout(seriesModel, api) {
	var refContainer = createBoxLayoutReference(seriesModel, api).refContainer;
	var layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), refContainer);
	seriesModel.layoutInfo = layoutInfo;
	var layout$3 = seriesModel.get("layout");
	var width = 0;
	var height = 0;
	var separation$1 = null;
	if (layout$3 === "radial") {
		width = 2 * Math.PI;
		height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
		separation$1 = separation(function(node1, node2) {
			return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
		});
	} else {
		width = layoutInfo.width;
		height = layoutInfo.height;
		separation$1 = separation();
	}
	var virtualRoot = seriesModel.getData().tree.root;
	var realRoot = virtualRoot.children[0];
	if (realRoot) {
		init$1(virtualRoot);
		eachAfter(realRoot, firstWalk, separation$1);
		virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
		eachBefore(realRoot, secondWalk);
		var left_1 = realRoot;
		var right_1 = realRoot;
		var bottom_1 = realRoot;
		eachBefore(realRoot, function(node) {
			var x = node.getLayout().x;
			if (x < left_1.getLayout().x) left_1 = node;
			if (x > right_1.getLayout().x) right_1 = node;
			if (node.depth > bottom_1.depth) bottom_1 = node;
		});
		var delta = left_1 === right_1 ? 1 : separation$1(left_1, right_1) / 2;
		var tx_1 = delta - left_1.getLayout().x;
		var kx_1 = 0;
		var ky_1 = 0;
		var coorX_1 = 0;
		var coorY_1 = 0;
		if (layout$3 === "radial") {
			kx_1 = width / (right_1.getLayout().x + delta + tx_1);
			ky_1 = height / (bottom_1.depth - 1 || 1);
			eachBefore(realRoot, function(node) {
				coorX_1 = (node.getLayout().x + tx_1) * kx_1;
				coorY_1 = (node.depth - 1) * ky_1;
				var finalCoor = radialCoordinate(coorX_1, coorY_1);
				node.setLayout({
					x: finalCoor.x,
					y: finalCoor.y,
					rawX: coorX_1,
					rawY: coorY_1
				}, true);
			});
		} else {
			var orient_1 = seriesModel.getOrient();
			if (orient_1 === "RL" || orient_1 === "LR") {
				ky_1 = height / (right_1.getLayout().x + delta + tx_1);
				kx_1 = width / (bottom_1.depth - 1 || 1);
				eachBefore(realRoot, function(node) {
					coorY_1 = (node.getLayout().x + tx_1) * ky_1;
					coorX_1 = orient_1 === "LR" ? (node.depth - 1) * kx_1 : width - (node.depth - 1) * kx_1;
					node.setLayout({
						x: coorX_1,
						y: coorY_1
					}, true);
				});
			} else if (orient_1 === "TB" || orient_1 === "BT") {
				kx_1 = width / (right_1.getLayout().x + delta + tx_1);
				ky_1 = height / (bottom_1.depth - 1 || 1);
				eachBefore(realRoot, function(node) {
					coorX_1 = (node.getLayout().x + tx_1) * kx_1;
					coorY_1 = orient_1 === "TB" ? (node.depth - 1) * ky_1 : height - (node.depth - 1) * ky_1;
					node.setLayout({
						x: coorX_1,
						y: coorY_1
					}, true);
				});
			}
		}
	}
}

//#endregion
//#region node_modules/echarts/lib/chart/tree/treeVisual.js
function treeVisual(ecModel) {
	ecModel.eachSeriesByType("tree", function(seriesModel) {
		var data = seriesModel.getData();
		data.tree.eachNode(function(node) {
			var style = node.getModel().getModel("itemStyle").getItemStyle();
			extend(data.ensureUniqueItemVisual(node.dataIndex, "style"), style);
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/tree/treeAction.js
function installTreeAction(registers) {
	registers.registerAction({
		type: "treeExpandAndCollapse",
		event: "treeExpandAndCollapse",
		update: "update"
	}, function(payload, ecModel) {
		ecModel.eachComponent({
			mainType: "series",
			subType: "tree",
			query: payload
		}, function(seriesModel) {
			var dataIndex = payload.dataIndex;
			var node = seriesModel.getData().tree.getNodeByDataIndex(dataIndex);
			node.isExpand = !node.isExpand;
		});
	});
	registers.registerAction({
		type: "treeRoam",
		event: "treeRoam",
		update: "none"
	}, function(payload, ecModel, api) {
		ecModel.eachComponent({
			mainType: "series",
			subType: "tree",
			query: payload
		}, function(seriesModel) {
			var coordSys = seriesModel.coordinateSystem;
			var res = updateCenterAndZoomInAction(coordSys, payload, seriesModel.get("scaleLimit"));
			seriesModel.setCenter(res.center);
			seriesModel.setZoom(res.zoom);
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/tree/install.js
function install$8(registers) {
	registers.registerChartView(TreeView_default);
	registers.registerSeriesModel(TreeSeries_default);
	registers.registerLayout(treeLayout);
	registers.registerVisual(treeVisual);
	installTreeAction(registers);
}

//#endregion
//#region node_modules/echarts/lib/chart/treemap/treemapAction.js
var actionTypes = [
	"treemapZoomToNode",
	"treemapRender",
	"treemapMove"
];
function installTreemapAction(registers) {
	for (var i$1 = 0; i$1 < actionTypes.length; i$1++) registers.registerAction({
		type: actionTypes[i$1],
		update: "updateView"
	}, noop);
	registers.registerAction({
		type: "treemapRootToNode",
		update: "updateView"
	}, function(payload, ecModel) {
		ecModel.eachComponent({
			mainType: "series",
			subType: "treemap",
			query: payload
		}, handleRootToNode);
		function handleRootToNode(model, index) {
			var targetInfo = retrieveTargetInfo(payload, ["treemapZoomToNode", "treemapRootToNode"], model);
			if (targetInfo) {
				var originViewRoot = model.getViewRoot();
				if (originViewRoot) payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
				model.resetViewRoot(targetInfo.node);
			}
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/helper/enableAriaDecalForTree.js
function enableAriaDecalForTree(seriesModel) {
	var tree = seriesModel.getData().tree;
	var decalPaletteScope$1 = {};
	tree.eachNode(function(node) {
		var current = node;
		while (current && current.depth > 1) current = current.parentNode;
		var decal = getDecalFromPalette(seriesModel.ecModel, current.name || current.dataIndex + "", decalPaletteScope$1);
		node.setVisual("decal", decal);
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/treemap/TreemapSeries.js
var TreemapSeriesModel = function(_super) {
	__extends(TreemapSeriesModel$1, _super);
	function TreemapSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = TreemapSeriesModel$1.type;
		_this.preventUsingHoverLayer = true;
		return _this;
	}
	/**
	* @override
	*/
	TreemapSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		var root = {
			name: option.name,
			children: option.data
		};
		completeTreeValue$1(root);
		var levels = option.levels || [];
		var designatedVisualModel = new Model_default({ itemStyle: this.designatedVisualItemStyle = {} }, this, ecModel);
		levels = option.levels = setDefault(levels, ecModel);
		var levelModels = map(levels || [], function(levelDefine) {
			return new Model_default(levelDefine, designatedVisualModel, ecModel);
		}, this);
		var tree = Tree_default.createTree(root, this, beforeLink);
		function beforeLink(nodeData) {
			nodeData.wrapMethod("getItemModel", function(model, idx) {
				var node = tree.getNodeByDataIndex(idx);
				model.parentModel = (node ? levelModels[node.depth] : null) || designatedVisualModel;
				return model;
			});
		}
		return tree.data;
	};
	TreemapSeriesModel$1.prototype.optionUpdated = function() {
		this.resetViewRoot();
	};
	/**
	* @override
	* @param {number} dataIndex
	* @param {boolean} [mutipleSeries=false]
	*/
	TreemapSeriesModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		var data = this.getData();
		var value = this.getRawValue(dataIndex);
		return createTooltipMarkup("nameValue", {
			name: data.getName(dataIndex),
			value
		});
	};
	/**
	* Add tree path to tooltip param
	*
	* @override
	* @param {number} dataIndex
	* @return {Object}
	*/
	TreemapSeriesModel$1.prototype.getDataParams = function(dataIndex) {
		var params = _super.prototype.getDataParams.apply(this, arguments);
		params.treeAncestors = wrapTreePathInfo(this.getData().tree.getNodeByDataIndex(dataIndex), this);
		params.treePathInfo = params.treeAncestors;
		return params;
	};
	/**
	* @public
	* @param {Object} layoutInfo {
	*                                x: containerGroup x
	*                                y: containerGroup y
	*                                width: containerGroup width
	*                                height: containerGroup height
	*                            }
	*/
	TreemapSeriesModel$1.prototype.setLayoutInfo = function(layoutInfo) {
		/**
		* @readOnly
		* @type {Object}
		*/
		this.layoutInfo = this.layoutInfo || {};
		extend(this.layoutInfo, layoutInfo);
	};
	/**
	* @param  {string} id
	* @return {number} index
	*/
	TreemapSeriesModel$1.prototype.mapIdToIndex = function(id) {
		/**
		* @private
		* @type {Object}
		*/
		var idIndexMap = this._idIndexMap;
		if (!idIndexMap) {
			idIndexMap = this._idIndexMap = createHashMap();
			/**
			* @private
			* @type {number}
			*/
			this._idIndexMapCount = 0;
		}
		var index = idIndexMap.get(id);
		if (index == null) idIndexMap.set(id, index = this._idIndexMapCount++);
		return index;
	};
	TreemapSeriesModel$1.prototype.getViewRoot = function() {
		return this._viewRoot;
	};
	TreemapSeriesModel$1.prototype.resetViewRoot = function(viewRoot) {
		viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
		var root = this.getRawData().tree.root;
		if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) this._viewRoot = root;
	};
	TreemapSeriesModel$1.prototype.enableAriaDecal = function() {
		enableAriaDecalForTree(this);
	};
	TreemapSeriesModel$1.type = "series.treemap";
	TreemapSeriesModel$1.layoutMode = "box";
	TreemapSeriesModel$1.defaultOption = {
		progressive: 0,
		coordinateSystemUsage: "box",
		left: tokens_default.size.l,
		top: tokens_default.size.xxxl,
		right: tokens_default.size.l,
		bottom: tokens_default.size.xxxl,
		sort: true,
		clipWindow: "origin",
		squareRatio: .5 * (1 + Math.sqrt(5)),
		leafDepth: null,
		drillDownIcon: "",
		zoomToNodeRatio: .32 * .32,
		scaleLimit: {
			max: 5,
			min: .2
		},
		roam: true,
		roamTrigger: "global",
		nodeClick: "zoomToNode",
		animation: true,
		animationDurationUpdate: 900,
		animationEasing: "quinticInOut",
		breadcrumb: {
			show: true,
			height: 22,
			left: "center",
			bottom: tokens_default.size.m,
			emptyItemWidth: 25,
			itemStyle: {
				color: tokens_default.color.backgroundShade,
				textStyle: { color: tokens_default.color.secondary }
			},
			emphasis: { itemStyle: { color: tokens_default.color.background } }
		},
		label: {
			show: true,
			distance: 0,
			padding: 5,
			position: "inside",
			color: tokens_default.color.neutral00,
			overflow: "truncate"
		},
		upperLabel: {
			show: false,
			position: [0, "50%"],
			height: 20,
			overflow: "truncate",
			verticalAlign: "middle"
		},
		itemStyle: {
			color: null,
			colorAlpha: null,
			colorSaturation: null,
			borderWidth: 0,
			gapWidth: 0,
			borderColor: tokens_default.color.neutral00,
			borderColorSaturation: null
		},
		emphasis: { upperLabel: {
			show: true,
			position: [0, "50%"],
			overflow: "truncate",
			verticalAlign: "middle"
		} },
		visualDimension: 0,
		visualMin: null,
		visualMax: null,
		color: [],
		colorAlpha: null,
		colorSaturation: null,
		colorMappingBy: "index",
		visibleMin: 10,
		childrenVisibleMin: null,
		levels: []
	};
	return TreemapSeriesModel$1;
}(Series_default);
/**
* @param {Object} dataNode
*/
function completeTreeValue$1(dataNode) {
	var sum$1 = 0;
	each(dataNode.children, function(child) {
		completeTreeValue$1(child);
		var childValue = child.value;
		isArray(childValue) && (childValue = childValue[0]);
		sum$1 += childValue;
	});
	var thisValue = dataNode.value;
	if (isArray(thisValue)) thisValue = thisValue[0];
	if (thisValue == null || isNaN(thisValue)) thisValue = sum$1;
	if (thisValue < 0) thisValue = 0;
	isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
/**
* set default to level configuration
*/
function setDefault(levels, ecModel) {
	var globalColorList = normalizeToArray(ecModel.get("color"));
	var globalDecalList = normalizeToArray(ecModel.get([
		"aria",
		"decal",
		"decals"
	]));
	if (!globalColorList) return;
	levels = levels || [];
	var hasColorDefine;
	var hasDecalDefine;
	each(levels, function(levelDefine) {
		var model = new Model_default(levelDefine);
		var modelColor = model.get("color");
		var modelDecal = model.get("decal");
		if (model.get(["itemStyle", "color"]) || modelColor && modelColor !== "none") hasColorDefine = true;
		if (model.get(["itemStyle", "decal"]) || modelDecal && modelDecal !== "none") hasDecalDefine = true;
	});
	var level0 = levels[0] || (levels[0] = {});
	if (!hasColorDefine) level0.color = globalColorList.slice();
	if (!hasDecalDefine && globalDecalList) level0.decal = globalDecalList.slice();
	return levels;
}
var TreemapSeries_default = TreemapSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/treemap/Breadcrumb.js
var TEXT_PADDING = 8;
var ITEM_GAP = 8;
var ARRAY_LENGTH = 5;
var Breadcrumb = function() {
	function Breadcrumb$1(containerGroup) {
		this.group = new Group_default();
		containerGroup.add(this.group);
	}
	Breadcrumb$1.prototype.render = function(seriesModel, api, targetNode, onSelect) {
		var model = seriesModel.getModel("breadcrumb");
		var thisGroup = this.group;
		thisGroup.removeAll();
		if (!model.get("show") || !targetNode) return;
		var normalStyleModel = model.getModel("itemStyle");
		var emphasisModel = model.getModel("emphasis");
		var textStyleModel = normalStyleModel.getModel("textStyle");
		var emphasisTextStyleModel = emphasisModel.getModel(["itemStyle", "textStyle"]);
		var refContainer = createBoxLayoutReference(seriesModel, api).refContainer;
		var boxLayoutParams = {
			left: model.get("left"),
			right: model.get("right"),
			top: model.get("top"),
			bottom: model.get("bottom")
		};
		var layoutParam = {
			emptyItemWidth: model.get("emptyItemWidth"),
			totalWidth: 0,
			renderList: []
		};
		var availableSize = getLayoutRect(boxLayoutParams, refContainer);
		this._prepare(targetNode, layoutParam, textStyleModel);
		this._renderContent(seriesModel, layoutParam, availableSize, normalStyleModel, emphasisModel, textStyleModel, emphasisTextStyleModel, onSelect);
		positionElement(thisGroup, boxLayoutParams, refContainer);
	};
	/**
	* Prepare render list and total width
	* @private
	*/
	Breadcrumb$1.prototype._prepare = function(targetNode, layoutParam, textStyleModel) {
		for (var node = targetNode; node; node = node.parentNode) {
			var text = convertOptionIdName(node.getModel().get("name"), "");
			var textRect = textStyleModel.getTextRect(text);
			var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
			layoutParam.totalWidth += itemWidth + ITEM_GAP;
			layoutParam.renderList.push({
				node,
				text,
				width: itemWidth
			});
		}
	};
	/**
	* @private
	*/
	Breadcrumb$1.prototype._renderContent = function(seriesModel, layoutParam, availableSize, normalStyleModel, emphasisModel, textStyleModel, emphasisTextStyleModel, onSelect) {
		var lastX = 0;
		var emptyItemWidth = layoutParam.emptyItemWidth;
		var height = seriesModel.get(["breadcrumb", "height"]);
		var totalWidth = layoutParam.totalWidth;
		var renderList = layoutParam.renderList;
		var emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
		for (var i$1 = renderList.length - 1; i$1 >= 0; i$1--) {
			var item = renderList[i$1];
			var itemNode = item.node;
			var itemWidth = item.width;
			var text = item.text;
			if (totalWidth > availableSize.width) {
				totalWidth -= itemWidth - emptyItemWidth;
				itemWidth = emptyItemWidth;
				text = null;
			}
			var el = new Polygon_default({
				shape: { points: makeItemPoints(lastX, 0, itemWidth, height, i$1 === renderList.length - 1, i$1 === 0) },
				style: defaults(normalStyleModel.getItemStyle(), { lineJoin: "bevel" }),
				textContent: new Text_default({ style: createTextStyle(textStyleModel, { text }) }),
				textConfig: { position: "inside" },
				z2: Z2_EMPHASIS_LIFT * 1e4,
				onclick: curry(onSelect, itemNode)
			});
			el.disableLabelAnimation = true;
			el.getTextContent().ensureState("emphasis").style = createTextStyle(emphasisTextStyleModel, { text });
			el.ensureState("emphasis").style = emphasisItemStyle;
			toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
			this.group.add(el);
			packEventData(el, seriesModel, itemNode);
			lastX += itemWidth + ITEM_GAP;
		}
	};
	Breadcrumb$1.prototype.remove = function() {
		this.group.removeAll();
	};
	return Breadcrumb$1;
}();
function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
	var points$3 = [
		[head ? x : x - ARRAY_LENGTH, y],
		[x + itemWidth, y],
		[x + itemWidth, y + itemHeight],
		[head ? x : x - ARRAY_LENGTH, y + itemHeight]
	];
	!tail && points$3.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
	!head && points$3.push([x, y + itemHeight / 2]);
	return points$3;
}
function packEventData(el, seriesModel, itemNode) {
	getECData(el).eventData = {
		componentType: "series",
		componentSubType: "treemap",
		componentIndex: seriesModel.componentIndex,
		seriesIndex: seriesModel.seriesIndex,
		seriesName: seriesModel.name,
		seriesType: "treemap",
		selfType: "breadcrumb",
		nodeData: {
			dataIndex: itemNode && itemNode.dataIndex,
			name: itemNode && itemNode.name
		},
		treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
	};
}
var Breadcrumb_default = Breadcrumb;

//#endregion
//#region node_modules/echarts/lib/util/animation.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Animate multiple elements with a single done-callback.
*
* @example
*  animation
*      .createWrap()
*      .add(el1, {x: 10, y: 10})
*      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)
*      .done(function () { // done })
*      .start('cubicOut');
*/
var AnimationWrap = function() {
	function AnimationWrap$1() {
		this._storage = [];
		this._elExistsMap = {};
	}
	/**
	* Caution: a el can only be added once, otherwise 'done'
	* might not be called. This method checks this (by el.id),
	* suppresses adding and returns false when existing el found.
	*
	* @return Whether adding succeeded.
	*/
	AnimationWrap$1.prototype.add = function(el, target, duration, delay, easing) {
		if (this._elExistsMap[el.id]) return false;
		this._elExistsMap[el.id] = true;
		this._storage.push({
			el,
			target,
			duration,
			delay,
			easing
		});
		return true;
	};
	/**
	* Only execute when animation done/aborted.
	*/
	AnimationWrap$1.prototype.finished = function(callback) {
		this._finishedCallback = callback;
		return this;
	};
	/**
	* Will stop exist animation firstly.
	*/
	AnimationWrap$1.prototype.start = function() {
		var _this = this;
		var count$1 = this._storage.length;
		var checkTerminate = function() {
			count$1--;
			if (count$1 <= 0) {
				_this._storage.length = 0;
				_this._elExistsMap = {};
				_this._finishedCallback && _this._finishedCallback();
			}
		};
		for (var i$1 = 0, len$1 = this._storage.length; i$1 < len$1; i$1++) {
			var item = this._storage[i$1];
			item.el.animateTo(item.target, {
				duration: item.duration,
				delay: item.delay,
				easing: item.easing,
				setToFinal: true,
				done: checkTerminate,
				aborted: checkTerminate
			});
		}
		return this;
	};
	return AnimationWrap$1;
}();
function createWrap() {
	return new AnimationWrap();
}

//#endregion
//#region node_modules/echarts/lib/chart/treemap/TreemapView.js
var Group$2 = Group_default;
var Rect$1 = Rect_default;
var DRAG_THRESHOLD = 3;
var PATH_LABEL_NOAMAL = "label";
var PATH_UPPERLABEL_NORMAL = "upperLabel";
var Z2_BASE = Z2_EMPHASIS_LIFT * 10;
var Z2_BG = Z2_EMPHASIS_LIFT * 2;
var Z2_CONTENT = Z2_EMPHASIS_LIFT * 3;
var getStateItemStyle = makeStyleMapper([
	["fill", "color"],
	["stroke", "strokeColor"],
	["lineWidth", "strokeWidth"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["shadowColor"]
]);
var getItemStyleNormal = function(model) {
	var itemStyle = getStateItemStyle(model);
	itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
	return itemStyle;
};
var inner$14 = makeInner();
var TreemapView = function(_super) {
	__extends(TreemapView$1, _super);
	function TreemapView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = TreemapView$1.type;
		_this._state = "ready";
		_this._storage = createStorage();
		return _this;
	}
	/**
	* @override
	*/
	TreemapView$1.prototype.render = function(seriesModel, ecModel, api, payload) {
		if (indexOf(ecModel.findComponents({
			mainType: "series",
			subType: "treemap",
			query: payload
		}), seriesModel) < 0) return;
		this.seriesModel = seriesModel;
		this.api = api;
		this.ecModel = ecModel;
		var targetInfo = retrieveTargetInfo(payload, ["treemapZoomToNode", "treemapRootToNode"], seriesModel);
		var payloadType = payload && payload.type;
		var layoutInfo = seriesModel.layoutInfo;
		var isInit = !this._oldTree;
		var thisStorage = this._storage;
		var reRoot = payloadType === "treemapRootToNode" && targetInfo && thisStorage ? {
			rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
			direction: payload.direction
		} : null;
		var containerGroup = this._giveContainerGroup(layoutInfo);
		var hasAnimation = seriesModel.get("animation");
		var renderResult = this._doRender(containerGroup, seriesModel, reRoot);
		hasAnimation && !isInit && (!payloadType || payloadType === "treemapZoomToNode" || payloadType === "treemapRootToNode") ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
		this._resetController(api);
		this._renderBreadcrumb(seriesModel, api, targetInfo);
	};
	TreemapView$1.prototype._giveContainerGroup = function(layoutInfo) {
		var containerGroup = this._containerGroup;
		if (!containerGroup) {
			containerGroup = this._containerGroup = new Group$2();
			this._initEvents(containerGroup);
			this.group.add(containerGroup);
		}
		containerGroup.x = layoutInfo.x;
		containerGroup.y = layoutInfo.y;
		return containerGroup;
	};
	TreemapView$1.prototype._doRender = function(containerGroup, seriesModel, reRoot) {
		var thisTree = seriesModel.getData().tree;
		var oldTree = this._oldTree;
		var lastsForAnimation = createStorage();
		var thisStorage = createStorage();
		var oldStorage = this._storage;
		var willInvisibleEls = [];
		function doRenderNode(thisNode, oldNode, parentGroup, depth) {
			return renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth);
		}
		dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
		var willDeleteEls = clearStorage(oldStorage);
		this._oldTree = thisTree;
		this._storage = thisStorage;
		if (this._controllerHost) {
			var _oldRootLayout = this.seriesModel.layoutInfo;
			var rootLayout = thisTree.root.getLayout();
			if (rootLayout.width === _oldRootLayout.width && rootLayout.height === _oldRootLayout.height) this._controllerHost.zoom = 1;
		}
		return {
			lastsForAnimation,
			willDeleteEls,
			renderFinally
		};
		function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
			if (sameTree) {
				oldViewChildren = thisViewChildren;
				each(thisViewChildren, function(child, index) {
					!child.isRemoved() && processNode(index, index);
				});
			} else new DataDiffer_default(oldViewChildren, thisViewChildren, getKey$1, getKey$1).add(processNode).update(processNode).remove(curry(processNode, null)).execute();
			function getKey$1(node) {
				return node.getId();
			}
			function processNode(newIndex, oldIndex) {
				var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
				var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
				var group = doRenderNode(thisNode, oldNode, parentGroup, depth);
				group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
			}
		}
		function clearStorage(storage$1) {
			var willDeleteEls$1 = createStorage();
			storage$1 && each(storage$1, function(store, storageName) {
				var delEls = willDeleteEls$1[storageName];
				each(store, function(el) {
					el && (delEls.push(el), inner$14(el).willDelete = true);
				});
			});
			return willDeleteEls$1;
		}
		function renderFinally() {
			each(willDeleteEls, function(els) {
				each(els, function(el) {
					el.parent && el.parent.remove(el);
				});
			});
			each(willInvisibleEls, function(el) {
				el.invisible = true;
				el.dirty();
			});
		}
	};
	TreemapView$1.prototype._doAnimation = function(containerGroup, renderResult, seriesModel, reRoot) {
		var durationOption = seriesModel.get("animationDurationUpdate");
		var easingOption = seriesModel.get("animationEasing");
		var duration = (isFunction(durationOption) ? 0 : durationOption) || 0;
		var easing = (isFunction(easingOption) ? null : easingOption) || "cubicOut";
		var animationWrap = createWrap();
		each(renderResult.willDeleteEls, function(store, storageName) {
			each(store, function(el, rawIndex) {
				if (el.invisible) return;
				var parent = el.parent;
				var target;
				var innerStore = inner$14(parent);
				if (reRoot && reRoot.direction === "drillDown") target = parent === reRoot.rootNodeGroup ? {
					shape: {
						x: 0,
						y: 0,
						width: innerStore.nodeWidth,
						height: innerStore.nodeHeight
					},
					style: { opacity: 0 }
				} : { style: { opacity: 0 } };
				else {
					var targetX = 0;
					var targetY = 0;
					if (!innerStore.willDelete) {
						targetX = innerStore.nodeWidth / 2;
						targetY = innerStore.nodeHeight / 2;
					}
					target = storageName === "nodeGroup" ? {
						x: targetX,
						y: targetY,
						style: { opacity: 0 }
					} : {
						shape: {
							x: targetX,
							y: targetY,
							width: 0,
							height: 0
						},
						style: { opacity: 0 }
					};
				}
				target && animationWrap.add(el, target, duration, 0, easing);
			});
		});
		each(this._storage, function(store, storageName) {
			each(store, function(el, rawIndex) {
				var last = renderResult.lastsForAnimation[storageName][rawIndex];
				var target = {};
				if (!last) return;
				if (el instanceof Group_default) {
					if (last.oldX != null) {
						target.x = el.x;
						target.y = el.y;
						el.x = last.oldX;
						el.y = last.oldY;
					}
				} else {
					if (last.oldShape) {
						target.shape = extend({}, el.shape);
						el.setShape(last.oldShape);
					}
					if (last.fadein) {
						el.setStyle("opacity", 0);
						target.style = { opacity: 1 };
					} else if (el.style.opacity !== 1) target.style = { opacity: 1 };
				}
				animationWrap.add(el, target, duration, 0, easing);
			});
		}, this);
		this._state = "animating";
		animationWrap.finished(bind(function() {
			this._state = "ready";
			renderResult.renderFinally();
		}, this)).start();
	};
	TreemapView$1.prototype._resetController = function(api) {
		var _this = this;
		var controller = this._controller;
		var controllerHost = this._controllerHost;
		if (!controllerHost) {
			this._controllerHost = { target: this.group };
			controllerHost = this._controllerHost;
		}
		var seriesModel = this.seriesModel;
		if (!controller) {
			controller = this._controller = new RoamController_default(api.getZr());
			controller.on("pan", bind(this._onPan, this));
			controller.on("zoom", bind(this._onZoom, this));
		}
		controller.enable(seriesModel.get("roam"), {
			api,
			zInfo: { component: seriesModel },
			triggerInfo: {
				roamTrigger: seriesModel.get("roamTrigger"),
				isInSelf: function(e$1, x, y) {
					var containerGroup = _this._containerGroup;
					return containerGroup ? containerGroup.getBoundingRect().contain(x - containerGroup.x, y - containerGroup.y) : false;
				}
			}
		});
		controllerHost.zoomLimit = seriesModel.get("scaleLimit");
		controllerHost.zoom = seriesModel.get("zoom");
	};
	TreemapView$1.prototype._clearController = function() {
		var controller = this._controller;
		this._controllerHost = null;
		if (controller) {
			controller.dispose();
			controller = null;
		}
	};
	TreemapView$1.prototype._onPan = function(e$1) {
		if (this._state !== "animating" && (Math.abs(e$1.dx) > DRAG_THRESHOLD || Math.abs(e$1.dy) > DRAG_THRESHOLD)) {
			var root = this.seriesModel.getData().tree.root;
			if (!root) return;
			var rootLayout = root.getLayout();
			if (!rootLayout) return;
			this.api.dispatchAction({
				type: "treemapMove",
				from: this.uid,
				seriesId: this.seriesModel.id,
				rootRect: {
					x: rootLayout.x + e$1.dx,
					y: rootLayout.y + e$1.dy,
					width: rootLayout.width,
					height: rootLayout.height
				}
			});
		}
	};
	TreemapView$1.prototype._onZoom = function(e$1) {
		var mouseX = e$1.originX;
		var mouseY = e$1.originY;
		var zoomDelta = e$1.scale;
		if (this._state !== "animating") {
			var root = this.seriesModel.getData().tree.root;
			if (!root) return;
			var rootLayout = root.getLayout();
			if (!rootLayout) return;
			var rect = new BoundingRect_default(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
			var zoomLimit = null;
			var _controllerHost = this._controllerHost;
			zoomLimit = _controllerHost.zoomLimit;
			var newZoom = _controllerHost.zoom = _controllerHost.zoom || 1;
			newZoom *= zoomDelta;
			if (zoomLimit) {
				var zoomMin = zoomLimit.min || 0;
				var zoomMax = zoomLimit.max || Infinity;
				newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
			}
			var zoomScale = newZoom / _controllerHost.zoom;
			_controllerHost.zoom = newZoom;
			var layoutInfo = this.seriesModel.layoutInfo;
			mouseX -= layoutInfo.x;
			mouseY -= layoutInfo.y;
			var m$1 = create$2();
			translate(m$1, m$1, [-mouseX, -mouseY]);
			scale$2(m$1, m$1, [zoomScale, zoomScale]);
			translate(m$1, m$1, [mouseX, mouseY]);
			rect.applyTransform(m$1);
			this.api.dispatchAction({
				type: "treemapRender",
				from: this.uid,
				seriesId: this.seriesModel.id,
				rootRect: {
					x: rect.x,
					y: rect.y,
					width: rect.width,
					height: rect.height
				}
			});
		}
	};
	TreemapView$1.prototype._initEvents = function(containerGroup) {
		var _this = this;
		containerGroup.on("click", function(e$1) {
			if (_this._state !== "ready") return;
			var nodeClick = _this.seriesModel.get("nodeClick", true);
			if (!nodeClick) return;
			var targetInfo = _this.findTarget(e$1.offsetX, e$1.offsetY);
			if (!targetInfo) return;
			var node = targetInfo.node;
			if (node.getLayout().isLeafRoot) _this._rootToNode(targetInfo);
			else if (nodeClick === "zoomToNode") _this._zoomToNode(targetInfo);
			else if (nodeClick === "link") {
				var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
				var link = itemModel.get("link", true);
				var linkTarget = itemModel.get("target", true) || "blank";
				link && windowOpen(link, linkTarget);
			}
		}, this);
	};
	TreemapView$1.prototype._renderBreadcrumb = function(seriesModel, api, targetInfo) {
		var _this = this;
		if (!targetInfo) {
			targetInfo = seriesModel.get("leafDepth", true) != null ? { node: seriesModel.getViewRoot() } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);
			if (!targetInfo) targetInfo = { node: seriesModel.getData().tree.root };
		}
		(this._breadcrumb || (this._breadcrumb = new Breadcrumb_default(this.group))).render(seriesModel, api, targetInfo.node, function(node) {
			if (_this._state !== "animating") aboveViewRoot(seriesModel.getViewRoot(), node) ? _this._rootToNode({ node }) : _this._zoomToNode({ node });
		});
	};
	/**
	* @override
	*/
	TreemapView$1.prototype.remove = function() {
		this._clearController();
		this._containerGroup && this._containerGroup.removeAll();
		this._storage = createStorage();
		this._state = "ready";
		this._breadcrumb && this._breadcrumb.remove();
	};
	TreemapView$1.prototype.dispose = function() {
		this._clearController();
	};
	TreemapView$1.prototype._zoomToNode = function(targetInfo) {
		this.api.dispatchAction({
			type: "treemapZoomToNode",
			from: this.uid,
			seriesId: this.seriesModel.id,
			targetNode: targetInfo.node
		});
	};
	TreemapView$1.prototype._rootToNode = function(targetInfo) {
		this.api.dispatchAction({
			type: "treemapRootToNode",
			from: this.uid,
			seriesId: this.seriesModel.id,
			targetNode: targetInfo.node
		});
	};
	/**
	* @param x Global coord x.
	* @param y Global coord y.
	* @return info If not found, return undefined;
	* @return info.node Target node.
	* @return info.offsetX x refer to target node.
	* @return info.offsetY y refer to target node.
	*/
	TreemapView$1.prototype.findTarget = function(x, y) {
		var targetInfo;
		this.seriesModel.getViewRoot().eachNode({
			attr: "viewChildren",
			order: "preorder"
		}, function(node) {
			var bgEl = this._storage.background[node.getRawIndex()];
			if (bgEl) {
				var point = bgEl.transformCoordToLocal(x, y);
				var shape = bgEl.shape;
				if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) targetInfo = {
					node,
					offsetX: point[0],
					offsetY: point[1]
				};
				else return false;
			}
		}, this);
		return targetInfo;
	};
	TreemapView$1.type = "treemap";
	return TreemapView$1;
}(Chart_default);
function createStorage() {
	return {
		nodeGroup: [],
		background: [],
		content: []
	};
}
/**
* @return Return undefined means do not travel further.
*/
function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
	if (!thisNode) return;
	var thisLayout = thisNode.getLayout();
	var data = seriesModel.getData();
	var nodeModel = thisNode.getModel();
	data.setItemGraphicEl(thisNode.dataIndex, null);
	if (!thisLayout || !thisLayout.isInView) return;
	var thisWidth = thisLayout.width;
	var thisHeight = thisLayout.height;
	var borderWidth = thisLayout.borderWidth;
	var thisInvisible = thisLayout.invisible;
	var thisRawIndex = thisNode.getRawIndex();
	var oldRawIndex = oldNode && oldNode.getRawIndex();
	var thisViewChildren = thisNode.viewChildren;
	var upperHeight = thisLayout.upperHeight;
	var isParent = thisViewChildren && thisViewChildren.length;
	var itemStyleNormalModel = nodeModel.getModel("itemStyle");
	var itemStyleEmphasisModel = nodeModel.getModel(["emphasis", "itemStyle"]);
	var itemStyleBlurModel = nodeModel.getModel(["blur", "itemStyle"]);
	var itemStyleSelectModel = nodeModel.getModel(["select", "itemStyle"]);
	var borderRadius = itemStyleNormalModel.get("borderRadius") || 0;
	var group = giveGraphic("nodeGroup", Group$2);
	if (!group) return;
	parentGroup.add(group);
	group.x = thisLayout.x || 0;
	group.y = thisLayout.y || 0;
	group.markRedraw();
	inner$14(group).nodeWidth = thisWidth;
	inner$14(group).nodeHeight = thisHeight;
	if (thisLayout.isAboveViewRoot) return group;
	var bg = giveGraphic("background", Rect$1, depth, Z2_BG);
	bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);
	var emphasisModel = nodeModel.getModel("emphasis");
	var focus = emphasisModel.get("focus");
	var blurScope = emphasisModel.get("blurScope");
	var isDisabled = emphasisModel.get("disabled");
	var focusOrIndices = focus === "ancestor" ? thisNode.getAncestorsIndices() : focus === "descendant" ? thisNode.getDescendantIndices() : focus;
	if (isParent) {
		if (isHighDownDispatcher(group)) setAsHighDownDispatcher(group, false);
		if (bg) {
			setAsHighDownDispatcher(bg, !isDisabled);
			data.setItemGraphicEl(thisNode.dataIndex, bg);
			enableHoverFocus(bg, focusOrIndices, blurScope);
		}
	} else {
		var content = giveGraphic("content", Rect$1, depth, Z2_CONTENT);
		content && renderContent(group, content);
		bg.disableMorphing = true;
		if (bg && isHighDownDispatcher(bg)) setAsHighDownDispatcher(bg, false);
		setAsHighDownDispatcher(group, !isDisabled);
		data.setItemGraphicEl(thisNode.dataIndex, group);
		var cursorStyle = nodeModel.getShallow("cursor");
		cursorStyle && content.attr("cursor", cursorStyle);
		enableHoverFocus(group, focusOrIndices, blurScope);
	}
	return group;
	function renderBackground(group$1, bg$1, useUpperLabel) {
		var ecData = getECData(bg$1);
		ecData.dataIndex = thisNode.dataIndex;
		ecData.seriesIndex = seriesModel.seriesIndex;
		bg$1.setShape({
			x: 0,
			y: 0,
			width: thisWidth,
			height: thisHeight,
			r: borderRadius
		});
		if (thisInvisible) processInvisible(bg$1);
		else {
			bg$1.invisible = false;
			var style = thisNode.getVisual("style");
			var visualBorderColor = style.stroke;
			var normalStyle = getItemStyleNormal(itemStyleNormalModel);
			normalStyle.fill = visualBorderColor;
			var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
			emphasisStyle.fill = itemStyleEmphasisModel.get("borderColor");
			var blurStyle = getStateItemStyle(itemStyleBlurModel);
			blurStyle.fill = itemStyleBlurModel.get("borderColor");
			var selectStyle = getStateItemStyle(itemStyleSelectModel);
			selectStyle.fill = itemStyleSelectModel.get("borderColor");
			if (useUpperLabel) {
				var upperLabelWidth = thisWidth - 2 * borderWidth;
				prepareText(bg$1, visualBorderColor, style.opacity, {
					x: borderWidth,
					y: 0,
					width: upperLabelWidth,
					height: upperHeight
				});
			} else bg$1.removeTextContent();
			bg$1.setStyle(normalStyle);
			bg$1.ensureState("emphasis").style = emphasisStyle;
			bg$1.ensureState("blur").style = blurStyle;
			bg$1.ensureState("select").style = selectStyle;
			setDefaultStateProxy(bg$1);
		}
		group$1.add(bg$1);
	}
	function renderContent(group$1, content$1) {
		var ecData = getECData(content$1);
		ecData.dataIndex = thisNode.dataIndex;
		ecData.seriesIndex = seriesModel.seriesIndex;
		var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
		var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
		content$1.culling = true;
		content$1.setShape({
			x: borderWidth,
			y: borderWidth,
			width: contentWidth,
			height: contentHeight,
			r: borderRadius
		});
		if (thisInvisible) processInvisible(content$1);
		else {
			content$1.invisible = false;
			var nodeStyle = thisNode.getVisual("style");
			var visualColor = nodeStyle.fill;
			var normalStyle = getItemStyleNormal(itemStyleNormalModel);
			normalStyle.fill = visualColor;
			normalStyle.decal = nodeStyle.decal;
			var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
			var blurStyle = getStateItemStyle(itemStyleBlurModel);
			var selectStyle = getStateItemStyle(itemStyleSelectModel);
			prepareText(content$1, visualColor, nodeStyle.opacity, null);
			content$1.setStyle(normalStyle);
			content$1.ensureState("emphasis").style = emphasisStyle;
			content$1.ensureState("blur").style = blurStyle;
			content$1.ensureState("select").style = selectStyle;
			setDefaultStateProxy(content$1);
		}
		group$1.add(content$1);
	}
	function processInvisible(element) {
		!element.invisible && willInvisibleEls.push(element);
	}
	function prepareText(rectEl, visualColor, visualOpacity, upperLabelRect) {
		var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
		var defaultText = convertOptionIdName(nodeModel.get("name"), null);
		var isShow = normalLabelModel.getShallow("show");
		setLabelStyle(rectEl, getLabelStatesModels(nodeModel, upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
			defaultText: isShow ? defaultText : null,
			inheritColor: visualColor,
			defaultOpacity: visualOpacity,
			labelFetcher: seriesModel,
			labelDataIndex: thisNode.dataIndex
		});
		var textEl = rectEl.getTextContent();
		if (!textEl) return;
		var textStyle = textEl.style;
		var textPadding = normalizeCssArray$1(textStyle.padding || 0);
		if (upperLabelRect) {
			rectEl.setTextConfig({ layoutRect: upperLabelRect });
			textEl.disableLabelLayout = true;
		}
		textEl.beforeUpdate = function() {
			var width = Math.max((upperLabelRect ? upperLabelRect.width : rectEl.shape.width) - textPadding[1] - textPadding[3], 0);
			var height = Math.max((upperLabelRect ? upperLabelRect.height : rectEl.shape.height) - textPadding[0] - textPadding[2], 0);
			if (textStyle.width !== width || textStyle.height !== height) textEl.setStyle({
				width,
				height
			});
		};
		textStyle.truncateMinChar = 2;
		textStyle.lineOverflow = "truncate";
		addDrillDownIcon(textStyle, upperLabelRect, thisLayout);
		var textEmphasisState = textEl.getState("emphasis");
		addDrillDownIcon(textEmphasisState ? textEmphasisState.style : null, upperLabelRect, thisLayout);
	}
	function addDrillDownIcon(style, upperLabelRect, thisLayout$1) {
		var text = style ? style.text : null;
		if (!upperLabelRect && thisLayout$1.isLeafRoot && text != null) {
			var iconChar = seriesModel.get("drillDownIcon", true);
			style.text = iconChar ? iconChar + " " + text : text;
		}
	}
	function giveGraphic(storageName, Ctor, depth$1, z) {
		var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
		var lasts = lastsForAnimation[storageName];
		if (element) {
			oldStorage[storageName][oldRawIndex] = null;
			prepareAnimationWhenHasOld(lasts, element);
		} else if (!thisInvisible) {
			element = new Ctor();
			if (element instanceof Displayable_default) element.z2 = calculateZ2(depth$1, z);
			prepareAnimationWhenNoOld(lasts, element);
		}
		return thisStorage[storageName][thisRawIndex] = element;
	}
	function prepareAnimationWhenHasOld(lasts, element) {
		var lastCfg = lasts[thisRawIndex] = {};
		if (element instanceof Group$2) {
			lastCfg.oldX = element.x;
			lastCfg.oldY = element.y;
		} else lastCfg.oldShape = extend({}, element.shape);
	}
	function prepareAnimationWhenNoOld(lasts, element) {
		var lastCfg = lasts[thisRawIndex] = {};
		var parentNode$1 = thisNode.parentNode;
		var isGroup = element instanceof Group_default;
		if (parentNode$1 && (!reRoot || reRoot.direction === "drillDown")) {
			var parentOldX = 0;
			var parentOldY = 0;
			var parentOldBg = lastsForAnimation.background[parentNode$1.getRawIndex()];
			if (!reRoot && parentOldBg && parentOldBg.oldShape) {
				parentOldX = parentOldBg.oldShape.width;
				parentOldY = parentOldBg.oldShape.height;
			}
			if (isGroup) {
				lastCfg.oldX = 0;
				lastCfg.oldY = parentOldY;
			} else lastCfg.oldShape = {
				x: parentOldX,
				y: parentOldY,
				width: 0,
				height: 0
			};
		}
		lastCfg.fadein = !isGroup;
	}
}
function calculateZ2(depth, z2InLevel) {
	return depth * Z2_BASE + z2InLevel;
}
var TreemapView_default = TreemapView;

//#endregion
//#region node_modules/echarts/lib/visual/VisualMapping.js
var each$13 = each;
var isObject$1 = isObject;
var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
var VisualMapping = function() {
	function VisualMapping$1(option) {
		var mappingMethod = option.mappingMethod;
		var visualType = option.type;
		var thisOption = this.option = clone(option);
		this.type = visualType;
		this.mappingMethod = mappingMethod;
		this._normalizeData = normalizers[mappingMethod];
		var visualHandler = VisualMapping$1.visualHandlers[visualType];
		this.applyVisual = visualHandler.applyVisual;
		this.getColorMapper = visualHandler.getColorMapper;
		this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];
		if (mappingMethod === "piecewise") {
			normalizeVisualRange(thisOption);
			preprocessForPiecewise(thisOption);
		} else if (mappingMethod === "category") thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
		else {
			assert(mappingMethod !== "linear" || thisOption.dataExtent);
			normalizeVisualRange(thisOption);
		}
	}
	VisualMapping$1.prototype.mapValueToVisual = function(value) {
		var normalized = this._normalizeData(value);
		return this._normalizedToVisual(normalized, value);
	};
	VisualMapping$1.prototype.getNormalizer = function() {
		return bind(this._normalizeData, this);
	};
	/**
	* List available visual types.
	*
	* @public
	* @return {Array.<string>}
	*/
	VisualMapping$1.listVisualTypes = function() {
		return keys(VisualMapping$1.visualHandlers);
	};
	/**
	* @public
	*/
	VisualMapping$1.isValidType = function(visualType) {
		return VisualMapping$1.visualHandlers.hasOwnProperty(visualType);
	};
	/**
	* Convenient method.
	* Visual can be Object or Array or primary type.
	*/
	VisualMapping$1.eachVisual = function(visual, callback, context) {
		if (isObject(visual)) each(visual, callback, context);
		else callback.call(context, visual);
	};
	VisualMapping$1.mapVisual = function(visual, callback, context) {
		var isPrimary;
		var newVisual = isArray(visual) ? [] : isObject(visual) ? {} : (isPrimary = true, null);
		VisualMapping$1.eachVisual(visual, function(v, key$1) {
			var newVal = callback.call(context, v, key$1);
			isPrimary ? newVisual = newVal : newVisual[key$1] = newVal;
		});
		return newVisual;
	};
	/**
	* Retrieve visual properties from given object.
	*/
	VisualMapping$1.retrieveVisuals = function(obj) {
		var ret = {};
		var hasVisual;
		obj && each$13(VisualMapping$1.visualHandlers, function(h, visualType) {
			if (obj.hasOwnProperty(visualType)) {
				ret[visualType] = obj[visualType];
				hasVisual = true;
			}
		});
		return hasVisual ? ret : null;
	};
	/**
	* Give order to visual types, considering colorSaturation, colorAlpha depends on color.
	*
	* @public
	* @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}
	*                                     IF Array, like: ['color', 'symbol', 'colorSaturation']
	* @return {Array.<string>} Sorted visual types.
	*/
	VisualMapping$1.prepareVisualTypes = function(visualTypes) {
		if (isArray(visualTypes)) visualTypes = visualTypes.slice();
		else if (isObject$1(visualTypes)) {
			var types_1 = [];
			each$13(visualTypes, function(item, type) {
				types_1.push(type);
			});
			visualTypes = types_1;
		} else return [];
		visualTypes.sort(function(type1, type2) {
			return type2 === "color" && type1 !== "color" && type1.indexOf("color") === 0 ? 1 : -1;
		});
		return visualTypes;
	};
	/**
	* 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.
	* Other visuals are only depends on themself.
	*/
	VisualMapping$1.dependsOn = function(visualType1, visualType2) {
		return visualType2 === "color" ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
	};
	/**
	* @param value
	* @param pieceList [{value: ..., interval: [min, max]}, ...]
	*                         Always from small to big.
	* @param findClosestWhenOutside Default to be false
	* @return index
	*/
	VisualMapping$1.findPieceIndex = function(value, pieceList, findClosestWhenOutside) {
		var possibleI;
		var abs$1 = Infinity;
		for (var i$1 = 0, len$1 = pieceList.length; i$1 < len$1; i$1++) {
			var pieceValue = pieceList[i$1].value;
			if (pieceValue != null) {
				if (pieceValue === value || isString(pieceValue) && pieceValue === value + "") return i$1;
				findClosestWhenOutside && updatePossible(pieceValue, i$1);
			}
		}
		for (var i$1 = 0, len$1 = pieceList.length; i$1 < len$1; i$1++) {
			var piece = pieceList[i$1];
			var interval = piece.interval;
			var close_1 = piece.close;
			if (interval) {
				if (interval[0] === -Infinity) {
					if (littleThan(close_1[1], value, interval[1])) return i$1;
				} else if (interval[1] === Infinity) {
					if (littleThan(close_1[0], interval[0], value)) return i$1;
				} else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) return i$1;
				findClosestWhenOutside && updatePossible(interval[0], i$1);
				findClosestWhenOutside && updatePossible(interval[1], i$1);
			}
		}
		if (findClosestWhenOutside) return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
		function updatePossible(val, index) {
			var newAbs = Math.abs(val - value);
			if (newAbs < abs$1) {
				abs$1 = newAbs;
				possibleI = index;
			}
		}
	};
	VisualMapping$1.visualHandlers = {
		color: {
			applyVisual: makeApplyVisual("color"),
			getColorMapper: function() {
				var thisOption = this.option;
				return bind(thisOption.mappingMethod === "category" ? function(value, isNormalized) {
					!isNormalized && (value = this._normalizeData(value));
					return doMapCategory.call(this, value);
				} : function(value, isNormalized, out$1) {
					var returnRGBArray = !!out$1;
					!isNormalized && (value = this._normalizeData(value));
					out$1 = fastLerp(value, thisOption.parsedVisual, out$1);
					return returnRGBArray ? out$1 : stringify(out$1, "rgba");
				}, this);
			},
			_normalizedToVisual: {
				linear: function(normalized) {
					return stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
				},
				category: doMapCategory,
				piecewise: function(normalized, value) {
					var result = getSpecifiedVisual.call(this, value);
					if (result == null) result = stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
					return result;
				},
				fixed: doMapFixed
			}
		},
		colorHue: makePartialColorVisualHandler(function(color$2, value) {
			return modifyHSL(color$2, value);
		}),
		colorSaturation: makePartialColorVisualHandler(function(color$2, value) {
			return modifyHSL(color$2, null, value);
		}),
		colorLightness: makePartialColorVisualHandler(function(color$2, value) {
			return modifyHSL(color$2, null, null, value);
		}),
		colorAlpha: makePartialColorVisualHandler(function(color$2, value) {
			return modifyAlpha(color$2, value);
		}),
		decal: {
			applyVisual: makeApplyVisual("decal"),
			_normalizedToVisual: {
				linear: null,
				category: doMapCategory,
				piecewise: null,
				fixed: null
			}
		},
		opacity: {
			applyVisual: makeApplyVisual("opacity"),
			_normalizedToVisual: createNormalizedToNumericVisual([0, 1])
		},
		liftZ: {
			applyVisual: makeApplyVisual("liftZ"),
			_normalizedToVisual: {
				linear: doMapFixed,
				category: doMapFixed,
				piecewise: doMapFixed,
				fixed: doMapFixed
			}
		},
		symbol: {
			applyVisual: function(value, getter, setter) {
				setter("symbol", this.mapValueToVisual(value));
			},
			_normalizedToVisual: {
				linear: doMapToArray,
				category: doMapCategory,
				piecewise: function(normalized, value) {
					var result = getSpecifiedVisual.call(this, value);
					if (result == null) result = doMapToArray.call(this, normalized);
					return result;
				},
				fixed: doMapFixed
			}
		},
		symbolSize: {
			applyVisual: makeApplyVisual("symbolSize"),
			_normalizedToVisual: createNormalizedToNumericVisual([0, 1])
		}
	};
	return VisualMapping$1;
}();
function preprocessForPiecewise(thisOption) {
	var pieceList = thisOption.pieceList;
	thisOption.hasSpecialVisual = false;
	each(pieceList, function(piece, index) {
		piece.originIndex = index;
		if (piece.visual != null) thisOption.hasSpecialVisual = true;
	});
}
function preprocessForSpecifiedCategory(thisOption) {
	var categories = thisOption.categories;
	var categoryMap = thisOption.categoryMap = {};
	var visual = thisOption.visual;
	each$13(categories, function(cate, index) {
		categoryMap[cate] = index;
	});
	if (!isArray(visual)) {
		var visualArr_1 = [];
		if (isObject(visual)) each$13(visual, function(v, cate) {
			var index = categoryMap[cate];
			visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
		});
		else visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
		visual = setVisualToOption(thisOption, visualArr_1);
	}
	for (var i$1 = categories.length - 1; i$1 >= 0; i$1--) if (visual[i$1] == null) {
		delete categoryMap[categories[i$1]];
		categories.pop();
	}
}
function normalizeVisualRange(thisOption, isCategory$1) {
	var visual = thisOption.visual;
	var visualArr = [];
	if (isObject(visual)) each$13(visual, function(v) {
		visualArr.push(v);
	});
	else if (visual != null) visualArr.push(visual);
	if (!isCategory$1 && visualArr.length === 1 && !{
		color: 1,
		symbol: 1
	}.hasOwnProperty(thisOption.type)) visualArr[1] = visualArr[0];
	setVisualToOption(thisOption, visualArr);
}
function makePartialColorVisualHandler(applyValue) {
	return {
		applyVisual: function(value, getter, setter) {
			var colorChannel = this.mapValueToVisual(value);
			setter("color", applyValue(getter("color"), colorChannel));
		},
		_normalizedToVisual: createNormalizedToNumericVisual([0, 1])
	};
}
function doMapToArray(normalized) {
	var visual = this.option.visual;
	return visual[Math.round(linearMap$2(normalized, [0, 1], [0, visual.length - 1], true))] || {};
}
function makeApplyVisual(visualType) {
	return function(value, getter, setter) {
		setter(visualType, this.mapValueToVisual(value));
	};
}
function doMapCategory(normalized) {
	var visual = this.option.visual;
	return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
}
function doMapFixed() {
	return this.option.visual[0];
}
/**
* Create mapped to numeric visual
*/
function createNormalizedToNumericVisual(sourceExtent) {
	return {
		linear: function(normalized) {
			return linearMap$2(normalized, sourceExtent, this.option.visual, true);
		},
		category: doMapCategory,
		piecewise: function(normalized, value) {
			var result = getSpecifiedVisual.call(this, value);
			if (result == null) result = linearMap$2(normalized, sourceExtent, this.option.visual, true);
			return result;
		},
		fixed: doMapFixed
	};
}
function getSpecifiedVisual(value) {
	var thisOption = this.option;
	var pieceList = thisOption.pieceList;
	if (thisOption.hasSpecialVisual) {
		var piece = pieceList[VisualMapping.findPieceIndex(value, pieceList)];
		if (piece && piece.visual) return piece.visual[this.type];
	}
}
function setVisualToOption(thisOption, visualArr) {
	thisOption.visual = visualArr;
	if (thisOption.type === "color") thisOption.parsedVisual = map(visualArr, function(item) {
		var color$2 = parse(item);
		if (!color$2 && true) warn("'" + item + "' is an illegal color, fallback to '#000000'", true);
		return color$2 || [
			0,
			0,
			0,
			1
		];
	});
	return visualArr;
}
/**
* Normalizers by mapping methods.
*/
var normalizers = {
	linear: function(value) {
		return linearMap$2(value, this.option.dataExtent, [0, 1], true);
	},
	piecewise: function(value) {
		var pieceList = this.option.pieceList;
		var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
		if (pieceIndex != null) return linearMap$2(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
	},
	category: function(value) {
		var index = this.option.categories ? this.option.categoryMap[value] : value;
		return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
	},
	fixed: noop
};
function littleThan(close, a, b) {
	return close ? a <= b : a < b;
}
var VisualMapping_default = VisualMapping;

//#endregion
//#region node_modules/echarts/lib/chart/treemap/treemapVisual.js
var ITEM_STYLE_NORMAL = "itemStyle";
var inner$13 = makeInner();
var treemapVisual_default = {
	seriesType: "treemap",
	reset: function(seriesModel) {
		var root = seriesModel.getData().tree.root;
		if (root.isRemoved()) return;
		travelTree(root, {}, seriesModel.getViewRoot().getAncestors(), seriesModel);
	}
};
function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
	var nodeModel = node.getModel();
	var nodeLayout = node.getLayout();
	var data = node.hostTree.data;
	if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) return;
	var nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL);
	var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);
	var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
	var borderColor = nodeItemStyleModel.get("borderColor");
	var borderColorSaturation = nodeItemStyleModel.get("borderColorSaturation");
	var thisNodeColor;
	if (borderColorSaturation != null) {
		thisNodeColor = calculateColor(visuals);
		borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
	}
	existsStyle.stroke = borderColor;
	var viewChildren = node.viewChildren;
	if (!viewChildren || !viewChildren.length) {
		thisNodeColor = calculateColor(visuals);
		existsStyle.fill = thisNodeColor;
	} else {
		var mapping_1 = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
		each(viewChildren, function(child, index) {
			if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) travelTree(child, mapVisual$1(nodeModel, visuals, child, index, mapping_1, seriesModel), viewRootAncestors, seriesModel);
		});
	}
}
function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
	var visuals = extend({}, designatedVisual);
	var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
	each([
		"color",
		"colorAlpha",
		"colorSaturation"
	], function(visualName) {
		designatedVisualItemStyle[visualName] = designatedVisual[visualName];
		var val = nodeItemStyleModel.get(visualName);
		designatedVisualItemStyle[visualName] = null;
		val != null && (visuals[visualName] = val);
	});
	return visuals;
}
function calculateColor(visuals) {
	var color$2 = getValueVisualDefine(visuals, "color");
	if (color$2) {
		var colorAlpha = getValueVisualDefine(visuals, "colorAlpha");
		var colorSaturation = getValueVisualDefine(visuals, "colorSaturation");
		if (colorSaturation) color$2 = modifyHSL(color$2, null, null, colorSaturation);
		if (colorAlpha) color$2 = modifyAlpha(color$2, colorAlpha);
		return color$2;
	}
}
function calculateBorderColor(borderColorSaturation, thisNodeColor) {
	return thisNodeColor != null ? modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
}
function getValueVisualDefine(visuals, name) {
	var value = visuals[name];
	if (value != null && value !== "none") return value;
}
function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
	if (!viewChildren || !viewChildren.length) return;
	var rangeVisual = getRangeVisual(nodeModel, "color") || visuals.color != null && visuals.color !== "none" && (getRangeVisual(nodeModel, "colorAlpha") || getRangeVisual(nodeModel, "colorSaturation"));
	if (!rangeVisual) return;
	var visualMin = nodeModel.get("visualMin");
	var visualMax = nodeModel.get("visualMax");
	var dataExtent = nodeLayout.dataExtent.slice();
	visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
	visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
	var colorMappingBy = nodeModel.get("colorMappingBy");
	var opt = {
		type: rangeVisual.name,
		dataExtent,
		visual: rangeVisual.range
	};
	if (opt.type === "color" && (colorMappingBy === "index" || colorMappingBy === "id")) {
		opt.mappingMethod = "category";
		opt.loop = true;
	} else opt.mappingMethod = "linear";
	var mapping = new VisualMapping_default(opt);
	inner$13(mapping).drColorMappingBy = colorMappingBy;
	return mapping;
}
function getRangeVisual(nodeModel, name) {
	var range = nodeModel.get(name);
	return isArray(range) && range.length ? {
		name,
		range
	} : null;
}
function mapVisual$1(nodeModel, visuals, child, index, mapping, seriesModel) {
	var childVisuals = extend({}, visuals);
	if (mapping) {
		var mappingType = mapping.type;
		var colorMappingBy = mappingType === "color" && inner$13(mapping).drColorMappingBy;
		var value = colorMappingBy === "index" ? index : colorMappingBy === "id" ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get("visualDimension"));
		childVisuals[mappingType] = mapping.mapValueToVisual(value);
	}
	return childVisuals;
}

//#endregion
//#region node_modules/echarts/lib/chart/treemap/treemapLayout.js
var mathMax$4 = Math.max;
var mathMin$4 = Math.min;
var retrieveValue = retrieve;
var each$12 = each;
var PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"];
var PATH_GAP_WIDTH = ["itemStyle", "gapWidth"];
var PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"];
var PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
/**
* @public
*/
var treemapLayout_default = {
	seriesType: "treemap",
	reset: function(seriesModel, ecModel, api, payload) {
		var seriesOption = seriesModel.option;
		var refContainer = createBoxLayoutReference(seriesModel, api).refContainer;
		var layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), refContainer);
		var size = seriesOption.size || [];
		var containerWidth = parsePercent$1(retrieveValue(layoutInfo.width, size[0]), refContainer.width);
		var containerHeight = parsePercent$1(retrieveValue(layoutInfo.height, size[1]), refContainer.height);
		var payloadType = payload && payload.type;
		var targetInfo = retrieveTargetInfo(payload, ["treemapZoomToNode", "treemapRootToNode"], seriesModel);
		var rootRect = payloadType === "treemapRender" || payloadType === "treemapMove" ? payload.rootRect : null;
		var viewRoot = seriesModel.getViewRoot();
		var viewAbovePath = getPathToRoot(viewRoot);
		if (payloadType !== "treemapMove") {
			var rootSize = payloadType === "treemapZoomToNode" ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
			var sort_1 = seriesOption.sort;
			if (sort_1 && sort_1 !== "asc" && sort_1 !== "desc") sort_1 = "desc";
			var options = {
				squareRatio: seriesOption.squareRatio,
				sort: sort_1,
				leafDepth: seriesOption.leafDepth
			};
			viewRoot.hostTree.clearLayouts();
			var viewRootLayout_1 = {
				x: 0,
				y: 0,
				width: rootSize[0],
				height: rootSize[1],
				area: rootSize[0] * rootSize[1]
			};
			viewRoot.setLayout(viewRootLayout_1);
			squarify(viewRoot, options, false, 0);
			viewRootLayout_1 = viewRoot.getLayout();
			each$12(viewAbovePath, function(node, index) {
				var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
				node.setLayout(extend({
					dataExtent: [childValue, childValue],
					borderWidth: 0,
					upperHeight: 0
				}, viewRootLayout_1));
			});
		}
		var treeRoot = seriesModel.getData().tree.root;
		treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
		seriesModel.setLayoutInfo(layoutInfo);
		prunning(treeRoot, new BoundingRect_default(-layoutInfo.x, -layoutInfo.y, api.getWidth(), api.getHeight()), viewAbovePath, viewRoot, 0);
	}
};
/**
* Layout treemap with squarify algorithm.
* The original presentation of this algorithm
* was made by Mark Bruls, Kees Huizing, and Jarke J. van Wijk
* <https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf>.
* The implementation of this algorithm was originally copied from "d3.js"
* <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/layout/treemap.js>
* with some modifications made for this program.
* See the license statement at the head of this file.
*
* @protected
* @param {module:echarts/data/Tree~TreeNode} node
* @param {Object} options
* @param {string} options.sort 'asc' or 'desc'
* @param {number} options.squareRatio
* @param {boolean} hideChildren
* @param {number} depth
*/
function squarify(node, options, hideChildren, depth) {
	var width;
	var height;
	if (node.isRemoved()) return;
	var thisLayout = node.getLayout();
	width = thisLayout.width;
	height = thisLayout.height;
	var nodeModel = node.getModel();
	var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
	var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
	var upperLabelHeight = getUpperLabelHeight(nodeModel);
	var upperHeight = Math.max(borderWidth, upperLabelHeight);
	var layoutOffset = borderWidth - halfGapWidth;
	var layoutOffsetUpper = upperHeight - halfGapWidth;
	node.setLayout({
		borderWidth,
		upperHeight,
		upperLabelHeight
	}, true);
	width = mathMax$4(width - 2 * layoutOffset, 0);
	height = mathMax$4(height - layoutOffset - layoutOffsetUpper, 0);
	var totalArea = width * height;
	var viewChildren = initChildren$1(node, nodeModel, totalArea, options, hideChildren, depth);
	if (!viewChildren.length) return;
	var rect = {
		x: layoutOffset,
		y: layoutOffsetUpper,
		width,
		height
	};
	var rowFixedLength = mathMin$4(width, height);
	var best = Infinity;
	var row = [];
	row.area = 0;
	for (var i$1 = 0, len$1 = viewChildren.length; i$1 < len$1;) {
		var child = viewChildren[i$1];
		row.push(child);
		row.area += child.getLayout().area;
		var score = worst(row, rowFixedLength, options.squareRatio);
		if (score <= best) {
			i$1++;
			best = score;
		} else {
			row.area -= row.pop().getLayout().area;
			position(row, rowFixedLength, rect, halfGapWidth, false);
			rowFixedLength = mathMin$4(rect.width, rect.height);
			row.length = row.area = 0;
			best = Infinity;
		}
	}
	if (row.length) position(row, rowFixedLength, rect, halfGapWidth, true);
	if (!hideChildren) {
		var childrenVisibleMin = nodeModel.get("childrenVisibleMin");
		if (childrenVisibleMin != null && totalArea < childrenVisibleMin) hideChildren = true;
	}
	for (var i$1 = 0, len$1 = viewChildren.length; i$1 < len$1; i$1++) squarify(viewChildren[i$1], options, hideChildren, depth + 1);
}
/**
* Set area to each child, and calculate data extent for visual coding.
*/
function initChildren$1(node, nodeModel, totalArea, options, hideChildren, depth) {
	var viewChildren = node.children || [];
	var orderBy = options.sort;
	orderBy !== "asc" && orderBy !== "desc" && (orderBy = null);
	var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;
	if (hideChildren && !overLeafDepth) return node.viewChildren = [];
	viewChildren = filter(viewChildren, function(child) {
		return !child.isRemoved();
	});
	sort$1(viewChildren, orderBy);
	var info = statistic(nodeModel, viewChildren, orderBy);
	if (info.sum === 0) return node.viewChildren = [];
	info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
	if (info.sum === 0) return node.viewChildren = [];
	for (var i$1 = 0, len$1 = viewChildren.length; i$1 < len$1; i$1++) {
		var area = viewChildren[i$1].getValue() / info.sum * totalArea;
		viewChildren[i$1].setLayout({ area });
	}
	if (overLeafDepth) {
		viewChildren.length && node.setLayout({ isLeafRoot: true }, true);
		viewChildren.length = 0;
	}
	node.viewChildren = viewChildren;
	node.setLayout({ dataExtent: info.dataExtent }, true);
	return viewChildren;
}
/**
* Consider 'visibleMin'. Modify viewChildren and get new sum.
*/
function filterByThreshold(nodeModel, totalArea, sum$1, orderBy, orderedChildren) {
	if (!orderBy) return sum$1;
	var visibleMin = nodeModel.get("visibleMin");
	var len$1 = orderedChildren.length;
	var deletePoint = len$1;
	for (var i$1 = len$1 - 1; i$1 >= 0; i$1--) {
		var value = orderedChildren[orderBy === "asc" ? len$1 - i$1 - 1 : i$1].getValue();
		if (value / sum$1 * totalArea < visibleMin) {
			deletePoint = i$1;
			sum$1 -= value;
		}
	}
	orderBy === "asc" ? orderedChildren.splice(0, len$1 - deletePoint) : orderedChildren.splice(deletePoint, len$1 - deletePoint);
	return sum$1;
}
/**
* Sort
*/
function sort$1(viewChildren, orderBy) {
	if (orderBy) viewChildren.sort(function(a, b) {
		var diff = orderBy === "asc" ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
		return diff === 0 ? orderBy === "asc" ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;
	});
	return viewChildren;
}
/**
* Statistic
*/
function statistic(nodeModel, children, orderBy) {
	var sum$1 = 0;
	for (var i$1 = 0, len$1 = children.length; i$1 < len$1; i$1++) sum$1 += children[i$1].getValue();
	var dimension = nodeModel.get("visualDimension");
	var dataExtent;
	if (!children || !children.length) dataExtent = [NaN, NaN];
	else if (dimension === "value" && orderBy) {
		dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
		orderBy === "asc" && dataExtent.reverse();
	} else {
		dataExtent = [Infinity, -Infinity];
		each$12(children, function(child) {
			var value = child.getValue(dimension);
			value < dataExtent[0] && (dataExtent[0] = value);
			value > dataExtent[1] && (dataExtent[1] = value);
		});
	}
	return {
		sum: sum$1,
		dataExtent
	};
}
/**
* Computes the score for the specified row,
* as the worst aspect ratio.
*/
function worst(row, rowFixedLength, ratio) {
	var areaMax = 0;
	var areaMin = Infinity;
	for (var i$1 = 0, area = void 0, len$1 = row.length; i$1 < len$1; i$1++) {
		area = row[i$1].getLayout().area;
		if (area) {
			area < areaMin && (areaMin = area);
			area > areaMax && (areaMax = area);
		}
	}
	var squareArea = row.area * row.area;
	var f = rowFixedLength * rowFixedLength * ratio;
	return squareArea ? mathMax$4(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
}
/**
* Positions the specified row of nodes. Modifies `rect`.
*/
function position(row, rowFixedLength, rect, halfGapWidth, flush) {
	var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
	var idx1WhenH = 1 - idx0WhenH;
	var xy = ["x", "y"];
	var wh = ["width", "height"];
	var last = rect[xy[idx0WhenH]];
	var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
	if (flush || rowOtherLength > rect[wh[idx1WhenH]]) rowOtherLength = rect[wh[idx1WhenH]];
	for (var i$1 = 0, rowLen = row.length; i$1 < rowLen; i$1++) {
		var node = row[i$1];
		var nodeLayout = {};
		var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
		var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax$4(rowOtherLength - 2 * halfGapWidth, 0);
		var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
		var modWH = i$1 === rowLen - 1 || remain < step ? remain : step;
		var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax$4(modWH - 2 * halfGapWidth, 0);
		nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin$4(halfGapWidth, wh1 / 2);
		nodeLayout[xy[idx0WhenH]] = last + mathMin$4(halfGapWidth, wh0 / 2);
		last += modWH;
		node.setLayout(nodeLayout, true);
	}
	rect[xy[idx1WhenH]] += rowOtherLength;
	rect[wh[idx1WhenH]] -= rowOtherLength;
}
function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
	var currNode = (targetInfo || {}).node;
	var defaultSize = [containerWidth, containerHeight];
	if (!currNode || currNode === viewRoot) return defaultSize;
	var parent;
	var viewArea = containerWidth * containerHeight;
	var area = viewArea * seriesModel.option.zoomToNodeRatio;
	while (parent = currNode.parentNode) {
		var sum$1 = 0;
		var siblings = parent.children;
		for (var i$1 = 0, len$1 = siblings.length; i$1 < len$1; i$1++) sum$1 += siblings[i$1].getValue();
		var currNodeValue = currNode.getValue();
		if (currNodeValue === 0) return defaultSize;
		area *= sum$1 / currNodeValue;
		var parentModel = parent.getModel();
		var borderWidth = parentModel.get(PATH_BORDER_WIDTH);
		var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));
		area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, .5);
		area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);
		currNode = parent;
	}
	area < viewArea && (area = viewArea);
	var scale$3 = Math.pow(area / viewArea, .5);
	return [containerWidth * scale$3, containerHeight * scale$3];
}
function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
	if (rootRect) return {
		x: rootRect.x,
		y: rootRect.y
	};
	var defaultPosition = {
		x: 0,
		y: 0
	};
	if (!targetInfo) return defaultPosition;
	var targetNode = targetInfo.node;
	var layout$3 = targetNode.getLayout();
	if (!layout$3) return defaultPosition;
	var targetCenter = [layout$3.width / 2, layout$3.height / 2];
	var node = targetNode;
	while (node) {
		var nodeLayout = node.getLayout();
		targetCenter[0] += nodeLayout.x;
		targetCenter[1] += nodeLayout.y;
		node = node.parentNode;
	}
	return {
		x: layoutInfo.width / 2 - targetCenter[0],
		y: layoutInfo.height / 2 - targetCenter[1]
	};
}
function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
	var nodeLayout = node.getLayout();
	var nodeInViewAbovePath = viewAbovePath[depth];
	var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;
	if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) return;
	node.setLayout({
		isInView: true,
		invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
		isAboveViewRoot
	}, true);
	var childClipRect = new BoundingRect_default(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
	each$12(node.viewChildren || [], function(child) {
		prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
	});
}
function getUpperLabelHeight(model) {
	return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
}

//#endregion
//#region node_modules/echarts/lib/chart/treemap/install.js
function install$9(registers) {
	registers.registerSeriesModel(TreemapSeries_default);
	registers.registerChartView(TreemapView_default);
	registers.registerVisual(treemapVisual_default);
	registers.registerLayout(treemapLayout_default);
	installTreemapAction(registers);
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/categoryFilter.js
function categoryFilter(ecModel) {
	var legendModels = ecModel.findComponents({ mainType: "legend" });
	if (!legendModels || !legendModels.length) return;
	ecModel.eachSeriesByType("graph", function(graphSeries) {
		var categoriesData = graphSeries.getCategoriesData();
		var data = graphSeries.getGraph().data;
		var categoryNames = categoriesData.mapArray(categoriesData.getName);
		data.filterSelf(function(idx) {
			var category = data.getItemModel(idx).getShallow("category");
			if (category != null) {
				if (isNumber(category)) category = categoryNames[category];
				for (var i$1 = 0; i$1 < legendModels.length; i$1++) if (!legendModels[i$1].isSelected(category)) return false;
			}
			return true;
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/categoryVisual.js
function categoryVisual(ecModel) {
	var paletteScope = {};
	ecModel.eachSeriesByType("graph", function(seriesModel) {
		var categoriesData = seriesModel.getCategoriesData();
		var data = seriesModel.getData();
		var categoryNameIdxMap = {};
		categoriesData.each(function(idx) {
			var name = categoriesData.getName(idx);
			categoryNameIdxMap["ec-" + name] = idx;
			var itemModel = categoriesData.getItemModel(idx);
			var style = itemModel.getModel("itemStyle").getItemStyle();
			if (!style.fill) style.fill = seriesModel.getColorFromPalette(name, paletteScope);
			categoriesData.setItemVisual(idx, "style", style);
			var symbolVisualList = [
				"symbol",
				"symbolSize",
				"symbolKeepAspect"
			];
			for (var i$1 = 0; i$1 < symbolVisualList.length; i$1++) {
				var symbolVisual = itemModel.getShallow(symbolVisualList[i$1], true);
				if (symbolVisual != null) categoriesData.setItemVisual(idx, symbolVisualList[i$1], symbolVisual);
			}
		});
		if (categoriesData.count()) data.each(function(idx) {
			var categoryIdx = data.getItemModel(idx).getShallow("category");
			if (categoryIdx != null) {
				if (isString(categoryIdx)) categoryIdx = categoryNameIdxMap["ec-" + categoryIdx];
				var categoryStyle = categoriesData.getItemVisual(categoryIdx, "style");
				extend(data.ensureUniqueItemVisual(idx, "style"), categoryStyle);
				var visualList = [
					"symbol",
					"symbolSize",
					"symbolKeepAspect"
				];
				for (var i$1 = 0; i$1 < visualList.length; i$1++) data.setItemVisual(idx, visualList[i$1], categoriesData.getItemVisual(categoryIdx, visualList[i$1]));
			}
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/edgeVisual.js
function normalize$1(a) {
	if (!(a instanceof Array)) a = [a, a];
	return a;
}
function graphEdgeVisual(ecModel) {
	ecModel.eachSeriesByType("graph", function(seriesModel) {
		var graph = seriesModel.getGraph();
		var edgeData = seriesModel.getEdgeData();
		var symbolType = normalize$1(seriesModel.get("edgeSymbol"));
		var symbolSize = normalize$1(seriesModel.get("edgeSymbolSize"));
		edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
		edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
		edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
		edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
		edgeData.setVisual("style", seriesModel.getModel("lineStyle").getLineStyle());
		edgeData.each(function(idx) {
			var itemModel = edgeData.getItemModel(idx);
			var edge = graph.getEdgeByIndex(idx);
			var symbolType$1 = normalize$1(itemModel.getShallow("symbol", true));
			var symbolSize$1 = normalize$1(itemModel.getShallow("symbolSize", true));
			var style = itemModel.getModel("lineStyle").getLineStyle();
			var existsStyle = edgeData.ensureUniqueItemVisual(idx, "style");
			extend(existsStyle, style);
			switch (existsStyle.stroke) {
				case "source":
					var nodeStyle = edge.node1.getVisual("style");
					existsStyle.stroke = nodeStyle && nodeStyle.fill;
					break;
				case "target":
					var nodeStyle = edge.node2.getVisual("style");
					existsStyle.stroke = nodeStyle && nodeStyle.fill;
					break;
			}
			symbolType$1[0] && edge.setVisual("fromSymbol", symbolType$1[0]);
			symbolType$1[1] && edge.setVisual("toSymbol", symbolType$1[1]);
			symbolSize$1[0] && edge.setVisual("fromSymbolSize", symbolSize$1[0]);
			symbolSize$1[1] && edge.setVisual("toSymbolSize", symbolSize$1[1]);
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js
var KEY_DELIMITER = "-->";
/**
* params handler
* @param {module:echarts/model/SeriesModel} seriesModel
* @returns {*}
*/
var getAutoCurvenessParams = function(seriesModel) {
	return seriesModel.get("autoCurveness") || null;
};
/**
* Generate a list of edge curvatures, 20 is the default
* @param {module:echarts/model/SeriesModel} seriesModel
* @param {number} appendLength
* @return  20 => [0, -0.2, 0.2, -0.4, 0.4, -0.6, 0.6, -0.8, 0.8, -1, 1, -1.2, 1.2, -1.4, 1.4, -1.6, 1.6, -1.8, 1.8, -2]
*/
var createCurveness = function(seriesModel, appendLength) {
	var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
	var length$1 = 20;
	var curvenessList = [];
	if (isNumber(autoCurvenessParmas)) length$1 = autoCurvenessParmas;
	else if (isArray(autoCurvenessParmas)) {
		seriesModel.__curvenessList = autoCurvenessParmas;
		return;
	}
	if (appendLength > length$1) length$1 = appendLength;
	var len$1 = length$1 % 2 ? length$1 + 2 : length$1 + 3;
	curvenessList = [];
	for (var i$1 = 0; i$1 < len$1; i$1++) curvenessList.push((i$1 % 2 ? i$1 + 1 : i$1) / 10 * (i$1 % 2 ? -1 : 1));
	seriesModel.__curvenessList = curvenessList;
};
/**
* Create different cache key data in the positive and negative directions, in order to set the curvature later
* @param {number|string|module:echarts/data/Graph.Node} n1
* @param {number|string|module:echarts/data/Graph.Node} n2
* @param {module:echarts/model/SeriesModel} seriesModel
* @returns {string} key
*/
var getKeyOfEdges = function(n1, n2, seriesModel) {
	var source = [n1.id, n1.dataIndex].join(".");
	var target = [n2.id, n2.dataIndex].join(".");
	return [
		seriesModel.uid,
		source,
		target
	].join(KEY_DELIMITER);
};
/**
* get opposite key
* @param {string} key
* @returns {string}
*/
var getOppositeKey = function(key$1) {
	var keys$1 = key$1.split(KEY_DELIMITER);
	return [
		keys$1[0],
		keys$1[2],
		keys$1[1]
	].join(KEY_DELIMITER);
};
/**
* get edgeMap with key
* @param edge
* @param {module:echarts/model/SeriesModel} seriesModel
*/
var getEdgeFromMap = function(edge, seriesModel) {
	var key$1 = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
	return seriesModel.__edgeMap[key$1];
};
/**
* calculate all cases total length
* @param edge
* @param seriesModel
* @returns {number}
*/
var getTotalLengthBetweenNodes = function(edge, seriesModel) {
	return getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel) + getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
};
/**
*
* @param key
*/
var getEdgeMapLengthWithKey = function(key$1, seriesModel) {
	var edgeMap = seriesModel.__edgeMap;
	return edgeMap[key$1] ? edgeMap[key$1].length : 0;
};
/**
* Count the number of edges between the same two points, used to obtain the curvature table and the parity of the edge
* @see /graph/GraphSeries.js@getInitialData
* @param {module:echarts/model/SeriesModel} seriesModel
*/
function initCurvenessList(seriesModel) {
	if (!getAutoCurvenessParams(seriesModel)) return;
	seriesModel.__curvenessList = [];
	seriesModel.__edgeMap = {};
	createCurveness(seriesModel);
}
/**
* set edgeMap with key
* @param {number|string|module:echarts/data/Graph.Node} n1
* @param {number|string|module:echarts/data/Graph.Node} n2
* @param {module:echarts/model/SeriesModel} seriesModel
* @param {number} index
*/
function createEdgeMapForCurveness(n1, n2, seriesModel, index) {
	if (!getAutoCurvenessParams(seriesModel)) return;
	var key$1 = getKeyOfEdges(n1, n2, seriesModel);
	var edgeMap = seriesModel.__edgeMap;
	var oppositeEdges = edgeMap[getOppositeKey(key$1)];
	if (edgeMap[key$1] && !oppositeEdges) edgeMap[key$1].isForward = true;
	else if (oppositeEdges && edgeMap[key$1]) {
		oppositeEdges.isForward = true;
		edgeMap[key$1].isForward = false;
	}
	edgeMap[key$1] = edgeMap[key$1] || [];
	edgeMap[key$1].push(index);
}
/**
* get curvature for edge
* @param edge
* @param {module:echarts/model/SeriesModel} seriesModel
* @param index
*/
function getCurvenessForEdge(edge, seriesModel, index, needReverse) {
	var autoCurvenessParams = getAutoCurvenessParams(seriesModel);
	var isArrayParam = isArray(autoCurvenessParams);
	if (!autoCurvenessParams) return null;
	var edgeArray = getEdgeFromMap(edge, seriesModel);
	if (!edgeArray) return null;
	var edgeIndex = -1;
	for (var i$1 = 0; i$1 < edgeArray.length; i$1++) if (edgeArray[i$1] === index) {
		edgeIndex = i$1;
		break;
	}
	var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
	createCurveness(seriesModel, totalLen);
	edge.lineStyle = edge.lineStyle || {};
	var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
	var curvenessList = seriesModel.__curvenessList;
	var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;
	if (!edgeArray.isForward) {
		var len$1 = getEdgeMapLengthWithKey(getOppositeKey(curKey), seriesModel);
		var resValue = curvenessList[edgeIndex + len$1 + parityCorrection];
		if (needReverse) if (isArrayParam) if (autoCurvenessParams && autoCurvenessParams[0] === 0) return (len$1 + parityCorrection) % 2 ? resValue : -resValue;
		else return ((len$1 % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
		else return (len$1 + parityCorrection) % 2 ? resValue : -resValue;
		else return curvenessList[edgeIndex + len$1 + parityCorrection];
	} else return curvenessList[parityCorrection + edgeIndex];
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js
function simpleLayout(seriesModel) {
	var coordSys = seriesModel.coordinateSystem;
	if (coordSys && coordSys.type !== "view") return;
	var graph = seriesModel.getGraph();
	graph.eachNode(function(node) {
		var model = node.getModel();
		node.setLayout([+model.get("x"), +model.get("y")]);
	});
	simpleLayoutEdge(graph, seriesModel);
}
function simpleLayoutEdge(graph, seriesModel) {
	graph.eachEdge(function(edge, index) {
		var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, seriesModel, index, true), 0);
		var p1 = clone$3(edge.node1.getLayout());
		var p2 = clone$3(edge.node2.getLayout());
		var points$3 = [p1, p2];
		if (+curveness) points$3.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);
		edge.setLayout(points$3);
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/simpleLayout.js
function graphSimpleLayout(ecModel, api) {
	ecModel.eachSeriesByType("graph", function(seriesModel) {
		var layout$3 = seriesModel.get("layout");
		var coordSys = seriesModel.coordinateSystem;
		if (coordSys && coordSys.type !== "view") {
			var data_1 = seriesModel.getData();
			var dimensions_1 = [];
			each(coordSys.dimensions, function(coordDim) {
				dimensions_1 = dimensions_1.concat(data_1.mapDimensionsAll(coordDim));
			});
			for (var dataIndex = 0; dataIndex < data_1.count(); dataIndex++) {
				var value = [];
				var hasValue = false;
				for (var i$1 = 0; i$1 < dimensions_1.length; i$1++) {
					var val = data_1.get(dimensions_1[i$1], dataIndex);
					if (!isNaN(val)) hasValue = true;
					value.push(val);
				}
				if (hasValue) data_1.setItemLayout(dataIndex, coordSys.dataToPoint(value));
				else data_1.setItemLayout(dataIndex, [NaN, NaN]);
			}
			simpleLayoutEdge(data_1.graph, seriesModel);
		} else if (!layout$3 || layout$3 === "none") simpleLayout(seriesModel);
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/graphHelper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function getNodeGlobalScale(seriesModel) {
	var coordSys = seriesModel.coordinateSystem;
	if (coordSys.type !== "view") return 1;
	var nodeScaleRatio = seriesModel.option.nodeScaleRatio;
	var groupZoom = coordSys.scaleX;
	return ((coordSys.getZoom() - 1) * nodeScaleRatio + 1) / groupZoom;
}
function getSymbolSize(node) {
	var symbolSize = node.getVisual("symbolSize");
	if (symbolSize instanceof Array) symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
	return +symbolSize;
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/circularLayoutHelper.js
var PI$2 = Math.PI;
var _symbolRadiansHalf = [];
/**
* `basedOn` can be:
* 'value':
*     This layout is not accurate and have same bad case. For example,
*     if the min value is very smaller than the max value, the nodes
*     with the min value probably overlap even though there is enough
*     space to layout them. So we only use this approach in the as the
*     init layout of the force layout.
*     FIXME
*     Probably we do not need this method any more but use
*     `basedOn: 'symbolSize'` in force layout if
*     delay its init operations to GraphView.
* 'symbolSize':
*     This approach work only if all of the symbol size calculated.
*     That is, the progressive rendering is not applied to graph.
*     FIXME
*     If progressive rendering is applied to graph some day,
*     probably we have to use `basedOn: 'value'`.
*/
function circularLayout(seriesModel, basedOn, draggingNode, pointer) {
	var coordSys = seriesModel.coordinateSystem;
	if (coordSys && coordSys.type !== "view") return;
	var rect = coordSys.getBoundingRect();
	var nodeData = seriesModel.getData();
	var graph = nodeData.graph;
	var cx = rect.width / 2 + rect.x;
	var cy = rect.height / 2 + rect.y;
	var r = Math.min(rect.width, rect.height) / 2;
	var count$1 = nodeData.count();
	nodeData.setLayout({
		cx,
		cy
	});
	if (!count$1) return;
	if (draggingNode) {
		var _a$1 = coordSys.pointToData(pointer), tempX = _a$1[0], tempY = _a$1[1];
		var v = [tempX - cx, tempY - cy];
		normalize$3(v, v);
		scale$1(v, v, r);
		draggingNode.setLayout([cx + v[0], cy + v[1]], true);
		rotateNodeLabel(draggingNode, seriesModel.get(["circular", "rotateLabel"]), cx, cy);
	}
	_layoutNodesBasedOn[basedOn](seriesModel, graph, nodeData, r, cx, cy, count$1);
	graph.eachEdge(function(edge, index) {
		var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), getCurvenessForEdge(edge, seriesModel, index), 0);
		var p1 = clone$3(edge.node1.getLayout());
		var p2 = clone$3(edge.node2.getLayout());
		var cp1;
		var x12 = (p1[0] + p2[0]) / 2;
		var y12 = (p1[1] + p2[1]) / 2;
		if (+curveness) {
			curveness *= 3;
			cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];
		}
		edge.setLayout([
			p1,
			p2,
			cp1
		]);
	});
}
var _layoutNodesBasedOn = {
	value: function(seriesModel, graph, nodeData, r, cx, cy, count$1) {
		var angle = 0;
		var sum$1 = nodeData.getSum("value");
		var unitAngle = Math.PI * 2 / (sum$1 || count$1);
		graph.eachNode(function(node) {
			var value = node.getValue("value");
			var radianHalf = unitAngle * (sum$1 ? value : 1) / 2;
			angle += radianHalf;
			node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
			angle += radianHalf;
		});
	},
	symbolSize: function(seriesModel, graph, nodeData, r, cx, cy, count$1) {
		var sumRadian = 0;
		_symbolRadiansHalf.length = count$1;
		var nodeScale = getNodeGlobalScale(seriesModel);
		graph.eachNode(function(node) {
			var symbolSize = getSymbolSize(node);
			isNaN(symbolSize) && (symbolSize = 2);
			symbolSize < 0 && (symbolSize = 0);
			symbolSize *= nodeScale;
			var symbolRadianHalf = Math.asin(symbolSize / 2 / r);
			isNaN(symbolRadianHalf) && (symbolRadianHalf = PI$2 / 2);
			_symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
			sumRadian += symbolRadianHalf * 2;
		});
		var halfRemainRadian = (2 * PI$2 - sumRadian) / count$1 / 2;
		var angle = 0;
		graph.eachNode(function(node) {
			var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
			angle += radianHalf;
			(!node.getLayout() || !node.getLayout().fixed) && node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
			angle += radianHalf;
		});
	}
};
function rotateNodeLabel(node, circularRotateLabel, cx, cy) {
	var el = node.getGraphicEl();
	if (!el) return;
	var labelRotate = node.getModel().get(["label", "rotate"]) || 0;
	var symbolPath = el.getSymbolPath();
	if (circularRotateLabel) {
		var pos = node.getLayout();
		var rad = Math.atan2(pos[1] - cy, pos[0] - cx);
		if (rad < 0) rad = Math.PI * 2 + rad;
		var isLeft = pos[0] < cx;
		if (isLeft) rad = rad - Math.PI;
		var textPosition = isLeft ? "left" : "right";
		symbolPath.setTextConfig({
			rotation: -rad,
			position: textPosition,
			origin: "center"
		});
		var emphasisState = symbolPath.ensureState("emphasis");
		extend(emphasisState.textConfig || (emphasisState.textConfig = {}), { position: textPosition });
	} else symbolPath.setTextConfig({ rotation: labelRotate *= Math.PI / 180 });
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/circularLayout.js
function graphCircularLayout(ecModel) {
	ecModel.eachSeriesByType("graph", function(seriesModel) {
		if (seriesModel.get("layout") === "circular") circularLayout(seriesModel, "symbolSize");
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/forceHelper.js
var scaleAndAdd = scaleAndAdd$1;
function forceLayout(inNodes, inEdges, opts) {
	var nodes = inNodes;
	var edges = inEdges;
	var rect = opts.rect;
	var width = rect.width;
	var height = rect.height;
	var center$2 = [rect.x + width / 2, rect.y + height / 2];
	var gravity = opts.gravity == null ? .1 : opts.gravity;
	for (var i$1 = 0; i$1 < nodes.length; i$1++) {
		var n = nodes[i$1];
		if (!n.p) n.p = create$1(width * (Math.random() - .5) + center$2[0], height * (Math.random() - .5) + center$2[1]);
		n.pp = clone$3(n.p);
		n.edges = null;
	}
	var initialFriction = opts.friction == null ? .6 : opts.friction;
	var friction = initialFriction;
	var beforeStepCallback;
	var afterStepCallback;
	return {
		warmUp: function() {
			friction = initialFriction * .8;
		},
		setFixed: function(idx) {
			nodes[idx].fixed = true;
		},
		setUnfixed: function(idx) {
			nodes[idx].fixed = false;
		},
		beforeStep: function(cb) {
			beforeStepCallback = cb;
		},
		afterStep: function(cb) {
			afterStepCallback = cb;
		},
		step: function(cb) {
			beforeStepCallback && beforeStepCallback(nodes, edges);
			var v12 = [];
			var nLen = nodes.length;
			for (var i$2 = 0; i$2 < edges.length; i$2++) {
				var e$1 = edges[i$2];
				if (e$1.ignoreForceLayout) continue;
				var n1 = e$1.n1;
				var n2 = e$1.n2;
				sub(v12, n2.p, n1.p);
				var d = len(v12) - e$1.d;
				var w = n2.w / (n1.w + n2.w);
				if (isNaN(w)) w = 0;
				normalize$3(v12, v12);
				!n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
				!n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
			}
			for (var i$2 = 0; i$2 < nLen; i$2++) {
				var n$1 = nodes[i$2];
				if (!n$1.fixed) {
					sub(v12, center$2, n$1.p);
					scaleAndAdd(n$1.p, n$1.p, v12, gravity * friction);
				}
			}
			for (var i$2 = 0; i$2 < nLen; i$2++) {
				var n1 = nodes[i$2];
				for (var j = i$2 + 1; j < nLen; j++) {
					var n2 = nodes[j];
					sub(v12, n2.p, n1.p);
					var d = len(v12);
					if (d === 0) {
						set$1(v12, Math.random() - .5, Math.random() - .5);
						d = 1;
					}
					var repFact = (n1.rep + n2.rep) / d / d;
					!n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
					!n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
				}
			}
			var v = [];
			for (var i$2 = 0; i$2 < nLen; i$2++) {
				var n$1 = nodes[i$2];
				if (!n$1.fixed) {
					sub(v, n$1.p, n$1.pp);
					scaleAndAdd(n$1.p, n$1.p, v, friction);
					copy$1(n$1.pp, n$1.p);
				}
			}
			friction = friction * .992;
			var finished = friction < .01;
			afterStepCallback && afterStepCallback(nodes, edges, finished);
			cb && cb(finished);
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/forceLayout.js
function graphForceLayout(ecModel) {
	ecModel.eachSeriesByType("graph", function(graphSeries) {
		var coordSys = graphSeries.coordinateSystem;
		if (coordSys && coordSys.type !== "view") return;
		if (graphSeries.get("layout") === "force") {
			var preservedPoints_1 = graphSeries.preservedPoints || {};
			var graph_1 = graphSeries.getGraph();
			var nodeData_1 = graph_1.data;
			var edgeData = graph_1.edgeData;
			var forceModel = graphSeries.getModel("force");
			var initLayout = forceModel.get("initLayout");
			if (graphSeries.preservedPoints) nodeData_1.each(function(idx) {
				var id = nodeData_1.getId(idx);
				nodeData_1.setItemLayout(idx, preservedPoints_1[id] || [NaN, NaN]);
			});
			else if (!initLayout || initLayout === "none") simpleLayout(graphSeries);
			else if (initLayout === "circular") circularLayout(graphSeries, "value");
			var nodeDataExtent_1 = nodeData_1.getDataExtent("value");
			var edgeDataExtent_1 = edgeData.getDataExtent("value");
			var repulsion = forceModel.get("repulsion");
			var edgeLength = forceModel.get("edgeLength");
			var repulsionArr_1 = isArray(repulsion) ? repulsion : [repulsion, repulsion];
			var edgeLengthArr_1 = isArray(edgeLength) ? edgeLength : [edgeLength, edgeLength];
			edgeLengthArr_1 = [edgeLengthArr_1[1], edgeLengthArr_1[0]];
			var nodes_1 = nodeData_1.mapArray("value", function(value, idx) {
				var point = nodeData_1.getItemLayout(idx);
				var rep = linearMap$2(value, nodeDataExtent_1, repulsionArr_1);
				if (isNaN(rep)) rep = (repulsionArr_1[0] + repulsionArr_1[1]) / 2;
				return {
					w: rep,
					rep,
					fixed: nodeData_1.getItemModel(idx).get("fixed"),
					p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
				};
			});
			var forceInstance = forceLayout(nodes_1, edgeData.mapArray("value", function(value, idx) {
				var edge = graph_1.getEdgeByIndex(idx);
				var d = linearMap$2(value, edgeDataExtent_1, edgeLengthArr_1);
				if (isNaN(d)) d = (edgeLengthArr_1[0] + edgeLengthArr_1[1]) / 2;
				var edgeModel = edge.getModel();
				var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);
				return {
					n1: nodes_1[edge.node1.dataIndex],
					n2: nodes_1[edge.node2.dataIndex],
					d,
					curveness,
					ignoreForceLayout: edgeModel.get("ignoreForceLayout")
				};
			}), {
				rect: coordSys.getBoundingRect(),
				gravity: forceModel.get("gravity"),
				friction: forceModel.get("friction")
			});
			forceInstance.beforeStep(function(nodes, edges) {
				for (var i$1 = 0, l = nodes.length; i$1 < l; i$1++) if (nodes[i$1].fixed) copy$1(nodes[i$1].p, graph_1.getNodeByIndex(i$1).getLayout());
			});
			forceInstance.afterStep(function(nodes, edges, stopped) {
				for (var i$1 = 0, l = nodes.length; i$1 < l; i$1++) {
					if (!nodes[i$1].fixed) graph_1.getNodeByIndex(i$1).setLayout(nodes[i$1].p);
					preservedPoints_1[nodeData_1.getId(i$1)] = nodes[i$1].p;
				}
				for (var i$1 = 0, l = edges.length; i$1 < l; i$1++) {
					var e$1 = edges[i$1];
					var edge = graph_1.getEdgeByIndex(i$1);
					var p1 = e$1.n1.p;
					var p2 = e$1.n2.p;
					var points$3 = edge.getLayout();
					points$3 = points$3 ? points$3.slice() : [];
					points$3[0] = points$3[0] || [];
					points$3[1] = points$3[1] || [];
					copy$1(points$3[0], p1);
					copy$1(points$3[1], p2);
					if (+e$1.curveness) points$3[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e$1.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e$1.curveness];
					edge.setLayout(points$3);
				}
			});
			graphSeries.forceLayout = forceInstance;
			graphSeries.preservedPoints = preservedPoints_1;
			forceInstance.step();
		} else graphSeries.forceLayout = null;
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/createView.js
function getViewRect$1(seriesModel, api, aspect) {
	var layoutRef = createBoxLayoutReference(seriesModel, api);
	return applyPreserveAspect(seriesModel, getLayoutRect(extend(seriesModel.getBoxLayoutParams(), { aspect }), layoutRef.refContainer), aspect);
}
function createViewCoordSys(ecModel, api) {
	var viewList = [];
	ecModel.eachSeriesByType("graph", function(seriesModel) {
		injectCoordSysByOption({
			targetModel: seriesModel,
			coordSysType: "view",
			coordSysProvider: createViewCoordSys$1,
			isDefaultDataCoordSys: true
		});
		function createViewCoordSys$1() {
			var data = seriesModel.getData();
			var positions = data.mapArray(function(idx) {
				var itemModel = data.getItemModel(idx);
				return [+itemModel.get("x"), +itemModel.get("y")];
			});
			var min$2 = [];
			var max$2 = [];
			fromPoints(positions, min$2, max$2);
			if (max$2[0] - min$2[0] === 0) {
				max$2[0] += 1;
				min$2[0] -= 1;
			}
			if (max$2[1] - min$2[1] === 0) {
				max$2[1] += 1;
				min$2[1] -= 1;
			}
			var aspect = (max$2[0] - min$2[0]) / (max$2[1] - min$2[1]);
			var viewRect$1 = getViewRect$1(seriesModel, api, aspect);
			if (isNaN(aspect)) {
				min$2 = [viewRect$1.x, viewRect$1.y];
				max$2 = [viewRect$1.x + viewRect$1.width, viewRect$1.y + viewRect$1.height];
			}
			var bbWidth = max$2[0] - min$2[0];
			var bbHeight = max$2[1] - min$2[1];
			var viewCoordSys = new View_default(null, {
				api,
				ecModel
			});
			viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
			viewCoordSys.setBoundingRect(min$2[0], min$2[1], bbWidth, bbHeight);
			viewCoordSys.setViewRect(viewRect$1.x, viewRect$1.y, viewRect$1.width, viewRect$1.height);
			viewCoordSys.setCenter(seriesModel.get("center"));
			viewCoordSys.setZoom(seriesModel.get("zoom"));
			viewList.push(viewCoordSys);
			return viewCoordSys;
		}
	});
	return viewList;
}

//#endregion
//#region node_modules/echarts/lib/chart/helper/LinePath.js
var straightLineProto = Line_default.prototype;
var bezierCurveProto = BezierCurve_default.prototype;
var StraightLineShape = function() {
	function StraightLineShape$1() {
		this.x1 = 0;
		this.y1 = 0;
		this.x2 = 0;
		this.y2 = 0;
		this.percent = 1;
	}
	return StraightLineShape$1;
}();
/** @class */ (function(_super) {
	__extends(CurveShape, _super);
	function CurveShape() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	return CurveShape;
})(StraightLineShape);
function isStraightLine(shape) {
	return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
}
var ECLinePath = function(_super) {
	__extends(ECLinePath$1, _super);
	function ECLinePath$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this.type = "ec-line";
		return _this;
	}
	ECLinePath$1.prototype.getDefaultStyle = function() {
		return {
			stroke: tokens_default.color.neutral99,
			fill: null
		};
	};
	ECLinePath$1.prototype.getDefaultShape = function() {
		return new StraightLineShape();
	};
	ECLinePath$1.prototype.buildPath = function(ctx, shape) {
		if (isStraightLine(shape)) straightLineProto.buildPath.call(this, ctx, shape);
		else bezierCurveProto.buildPath.call(this, ctx, shape);
	};
	ECLinePath$1.prototype.pointAt = function(t) {
		if (isStraightLine(this.shape)) return straightLineProto.pointAt.call(this, t);
		else return bezierCurveProto.pointAt.call(this, t);
	};
	ECLinePath$1.prototype.tangentAt = function(t) {
		var shape = this.shape;
		var p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
		return normalize$3(p, p);
	};
	return ECLinePath$1;
}(Path_default);
var LinePath_default = ECLinePath;

//#endregion
//#region node_modules/echarts/lib/chart/helper/Line.js
var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
function makeSymbolTypeKey(symbolCategory) {
	return "_" + symbolCategory + "Type";
}
function makeSymbolTypeValue(name, lineData, idx) {
	var symbolType = lineData.getItemVisual(idx, name);
	if (!symbolType || symbolType === "none") return symbolType;
	var symbolSize = lineData.getItemVisual(idx, name + "Size");
	var symbolRotate = lineData.getItemVisual(idx, name + "Rotate");
	var symbolOffset = lineData.getItemVisual(idx, name + "Offset");
	var symbolKeepAspect = lineData.getItemVisual(idx, name + "KeepAspect");
	var symbolSizeArr = normalizeSymbolSize(symbolSize);
	var symbolOffsetArr = normalizeSymbolOffset(symbolOffset || 0, symbolSizeArr);
	return symbolType + symbolSizeArr + symbolOffsetArr + (symbolRotate || "") + (symbolKeepAspect || "");
}
/**
* @inner
*/
function createSymbol$1(name, lineData, idx) {
	var symbolType = lineData.getItemVisual(idx, name);
	if (!symbolType || symbolType === "none") return;
	var symbolSize = lineData.getItemVisual(idx, name + "Size");
	var symbolRotate = lineData.getItemVisual(idx, name + "Rotate");
	var symbolOffset = lineData.getItemVisual(idx, name + "Offset");
	var symbolKeepAspect = lineData.getItemVisual(idx, name + "KeepAspect");
	var symbolSizeArr = normalizeSymbolSize(symbolSize);
	var symbolOffsetArr = normalizeSymbolOffset(symbolOffset || 0, symbolSizeArr);
	var symbolPath = createSymbol(symbolType, -symbolSizeArr[0] / 2 + symbolOffsetArr[0], -symbolSizeArr[1] / 2 + symbolOffsetArr[1], symbolSizeArr[0], symbolSizeArr[1], null, symbolKeepAspect);
	symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
	symbolPath.name = name;
	return symbolPath;
}
function createLine(points$3) {
	var line = new LinePath_default({
		name: "line",
		subPixelOptimize: true
	});
	setLinePoints(line.shape, points$3);
	return line;
}
function setLinePoints(targetShape, points$3) {
	targetShape.x1 = points$3[0][0];
	targetShape.y1 = points$3[0][1];
	targetShape.x2 = points$3[1][0];
	targetShape.y2 = points$3[1][1];
	targetShape.percent = 1;
	var cp1 = points$3[2];
	if (cp1) {
		targetShape.cpx1 = cp1[0];
		targetShape.cpy1 = cp1[1];
	} else {
		targetShape.cpx1 = NaN;
		targetShape.cpy1 = NaN;
	}
}
var Line = function(_super) {
	__extends(Line$2, _super);
	function Line$2(lineData, idx, seriesScope) {
		var _this = _super.call(this) || this;
		_this._createLine(lineData, idx, seriesScope);
		return _this;
	}
	Line$2.prototype._createLine = function(lineData, idx, seriesScope) {
		var seriesModel = lineData.hostModel;
		var linePoints = lineData.getItemLayout(idx);
		var z2 = lineData.getItemVisual(idx, "z2");
		var line = createLine(linePoints);
		line.shape.percent = 0;
		initProps(line, {
			z2: retrieve2(z2, 0),
			shape: { percent: 1 }
		}, seriesModel, idx);
		this.add(line);
		each(SYMBOL_CATEGORIES, function(symbolCategory) {
			var symbol = createSymbol$1(symbolCategory, lineData, idx);
			this.add(symbol);
			this[makeSymbolTypeKey(symbolCategory)] = makeSymbolTypeValue(symbolCategory, lineData, idx);
		}, this);
		this._updateCommonStl(lineData, idx, seriesScope);
	};
	Line$2.prototype.updateData = function(lineData, idx, seriesScope) {
		var seriesModel = lineData.hostModel;
		var line = this.childOfName("line");
		var linePoints = lineData.getItemLayout(idx);
		var target = { shape: {} };
		setLinePoints(target.shape, linePoints);
		updateProps(line, target, seriesModel, idx);
		each(SYMBOL_CATEGORIES, function(symbolCategory) {
			var symbolType = makeSymbolTypeValue(symbolCategory, lineData, idx);
			var key$1 = makeSymbolTypeKey(symbolCategory);
			if (this[key$1] !== symbolType) {
				this.remove(this.childOfName(symbolCategory));
				var symbol = createSymbol$1(symbolCategory, lineData, idx);
				this.add(symbol);
			}
			this[key$1] = symbolType;
		}, this);
		this._updateCommonStl(lineData, idx, seriesScope);
	};
	Line$2.prototype.getLinePath = function() {
		return this.childAt(0);
	};
	Line$2.prototype._updateCommonStl = function(lineData, idx, seriesScope) {
		var seriesModel = lineData.hostModel;
		var line = this.childOfName("line");
		var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
		var blurLineStyle = seriesScope && seriesScope.blurLineStyle;
		var selectLineStyle = seriesScope && seriesScope.selectLineStyle;
		var labelStatesModels = seriesScope && seriesScope.labelStatesModels;
		var emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
		var focus = seriesScope && seriesScope.focus;
		var blurScope = seriesScope && seriesScope.blurScope;
		if (!seriesScope || lineData.hasItemOption) {
			var itemModel = lineData.getItemModel(idx);
			var emphasisModel = itemModel.getModel("emphasis");
			emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
			blurLineStyle = itemModel.getModel(["blur", "lineStyle"]).getLineStyle();
			selectLineStyle = itemModel.getModel(["select", "lineStyle"]).getLineStyle();
			emphasisDisabled = emphasisModel.get("disabled");
			focus = emphasisModel.get("focus");
			blurScope = emphasisModel.get("blurScope");
			labelStatesModels = getLabelStatesModels(itemModel);
		}
		var lineStyle = lineData.getItemVisual(idx, "style");
		var visualColor = lineStyle.stroke;
		line.useStyle(lineStyle);
		line.style.fill = null;
		line.style.strokeNoScale = true;
		line.ensureState("emphasis").style = emphasisLineStyle;
		line.ensureState("blur").style = blurLineStyle;
		line.ensureState("select").style = selectLineStyle;
		each(SYMBOL_CATEGORIES, function(symbolCategory) {
			var symbol = this.childOfName(symbolCategory);
			if (symbol) {
				symbol.setColor(visualColor);
				symbol.style.opacity = lineStyle.opacity;
				for (var i$1 = 0; i$1 < SPECIAL_STATES.length; i$1++) {
					var stateName = SPECIAL_STATES[i$1];
					var lineState = line.getState(stateName);
					if (lineState) {
						var lineStateStyle = lineState.style || {};
						var state = symbol.ensureState(stateName);
						var stateStyle = state.style || (state.style = {});
						if (lineStateStyle.stroke != null) stateStyle[symbol.__isEmptyBrush ? "stroke" : "fill"] = lineStateStyle.stroke;
						if (lineStateStyle.opacity != null) stateStyle.opacity = lineStateStyle.opacity;
					}
				}
				symbol.markRedraw();
			}
		}, this);
		var rawVal = seriesModel.getRawValue(idx);
		setLabelStyle(this, labelStatesModels, {
			labelDataIndex: idx,
			labelFetcher: { getFormattedLabel: function(dataIndex, stateName) {
				return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType);
			} },
			inheritColor: visualColor || tokens_default.color.neutral99,
			defaultOpacity: lineStyle.opacity,
			defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal) + ""
		});
		var label = this.getTextContent();
		if (label) {
			var labelNormalModel = labelStatesModels.normal;
			label.__align = label.style.align;
			label.__verticalAlign = label.style.verticalAlign;
			label.__position = labelNormalModel.get("position") || "middle";
			var distance$1 = labelNormalModel.get("distance");
			if (!isArray(distance$1)) distance$1 = [distance$1, distance$1];
			label.__labelDistance = distance$1;
		}
		this.setTextConfig({
			position: null,
			local: true,
			inside: false
		});
		toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
	};
	Line$2.prototype.highlight = function() {
		enterEmphasis(this);
	};
	Line$2.prototype.downplay = function() {
		leaveEmphasis(this);
	};
	Line$2.prototype.updateLayout = function(lineData, idx) {
		this.setLinePoints(lineData.getItemLayout(idx));
	};
	Line$2.prototype.setLinePoints = function(points$3) {
		var linePath = this.childOfName("line");
		setLinePoints(linePath.shape, points$3);
		linePath.dirty();
	};
	Line$2.prototype.beforeUpdate = function() {
		var lineGroup = this;
		var symbolFrom = lineGroup.childOfName("fromSymbol");
		var symbolTo = lineGroup.childOfName("toSymbol");
		var label = lineGroup.getTextContent();
		if (!symbolFrom && !symbolTo && (!label || label.ignore)) return;
		var invScale = 1;
		var parentNode$1 = this.parent;
		while (parentNode$1) {
			if (parentNode$1.scaleX) invScale /= parentNode$1.scaleX;
			parentNode$1 = parentNode$1.parent;
		}
		var line = lineGroup.childOfName("line");
		if (!this.__dirty && !line.__dirty) return;
		var percent = line.shape.percent;
		var fromPos = line.pointAt(0);
		var toPos = line.pointAt(percent);
		var d = sub([], toPos, fromPos);
		normalize$3(d, d);
		function setSymbolRotation(symbol, percent$1) {
			var specifiedRotation = symbol.__specifiedRotation;
			if (specifiedRotation == null) {
				var tangent$1 = line.tangentAt(percent$1);
				symbol.attr("rotation", (percent$1 === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent$1[1], tangent$1[0]));
			} else symbol.attr("rotation", specifiedRotation);
		}
		if (symbolFrom) {
			symbolFrom.setPosition(fromPos);
			setSymbolRotation(symbolFrom, 0);
			symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent;
			symbolFrom.markRedraw();
		}
		if (symbolTo) {
			symbolTo.setPosition(toPos);
			setSymbolRotation(symbolTo, 1);
			symbolTo.scaleX = symbolTo.scaleY = invScale * percent;
			symbolTo.markRedraw();
		}
		if (label && !label.ignore) {
			label.x = label.y = 0;
			label.originX = label.originY = 0;
			var textAlign = void 0;
			var textVerticalAlign = void 0;
			var distance$1 = label.__labelDistance;
			var distanceX = distance$1[0] * invScale;
			var distanceY = distance$1[1] * invScale;
			var halfPercent = percent / 2;
			var tangent = line.tangentAt(halfPercent);
			var n = [tangent[1], -tangent[0]];
			var cp = line.pointAt(halfPercent);
			if (n[1] > 0) {
				n[0] = -n[0];
				n[1] = -n[1];
			}
			var dir$1 = tangent[0] < 0 ? -1 : 1;
			if (label.__position !== "start" && label.__position !== "end") {
				var rotation = -Math.atan2(tangent[1], tangent[0]);
				if (toPos[0] < fromPos[0]) rotation = Math.PI + rotation;
				label.rotation = rotation;
			}
			var dy = void 0;
			switch (label.__position) {
				case "insideStartTop":
				case "insideMiddleTop":
				case "insideEndTop":
				case "middle":
					dy = -distanceY;
					textVerticalAlign = "bottom";
					break;
				case "insideStartBottom":
				case "insideMiddleBottom":
				case "insideEndBottom":
					dy = distanceY;
					textVerticalAlign = "top";
					break;
				default:
					dy = 0;
					textVerticalAlign = "middle";
			}
			switch (label.__position) {
				case "end":
					label.x = d[0] * distanceX + toPos[0];
					label.y = d[1] * distanceY + toPos[1];
					textAlign = d[0] > .8 ? "left" : d[0] < -.8 ? "right" : "center";
					textVerticalAlign = d[1] > .8 ? "top" : d[1] < -.8 ? "bottom" : "middle";
					break;
				case "start":
					label.x = -d[0] * distanceX + fromPos[0];
					label.y = -d[1] * distanceY + fromPos[1];
					textAlign = d[0] > .8 ? "right" : d[0] < -.8 ? "left" : "center";
					textVerticalAlign = d[1] > .8 ? "bottom" : d[1] < -.8 ? "top" : "middle";
					break;
				case "insideStartTop":
				case "insideStart":
				case "insideStartBottom":
					label.x = distanceX * dir$1 + fromPos[0];
					label.y = fromPos[1] + dy;
					textAlign = tangent[0] < 0 ? "right" : "left";
					label.originX = -distanceX * dir$1;
					label.originY = -dy;
					break;
				case "insideMiddleTop":
				case "insideMiddle":
				case "insideMiddleBottom":
				case "middle":
					label.x = cp[0];
					label.y = cp[1] + dy;
					textAlign = "center";
					label.originY = -dy;
					break;
				case "insideEndTop":
				case "insideEnd":
				case "insideEndBottom":
					label.x = -distanceX * dir$1 + toPos[0];
					label.y = toPos[1] + dy;
					textAlign = tangent[0] >= 0 ? "right" : "left";
					label.originX = distanceX * dir$1;
					label.originY = -dy;
					break;
			}
			label.scaleX = label.scaleY = invScale;
			label.setStyle({
				verticalAlign: label.__verticalAlign || textVerticalAlign,
				align: label.__align || textAlign
			});
		}
	};
	return Line$2;
}(Group_default);
var Line_default$1 = Line;

//#endregion
//#region node_modules/echarts/lib/chart/helper/LineDraw.js
var LineDraw = function() {
	function LineDraw$1(LineCtor) {
		this.group = new Group_default();
		this._LineCtor = LineCtor || Line_default$1;
	}
	LineDraw$1.prototype.updateData = function(lineData) {
		var _this = this;
		this._progressiveEls = null;
		var lineDraw = this;
		var group = lineDraw.group;
		var oldLineData = lineDraw._lineData;
		lineDraw._lineData = lineData;
		if (!oldLineData) group.removeAll();
		var seriesScope = makeSeriesScope$1(lineData);
		lineData.diff(oldLineData).add(function(idx) {
			_this._doAdd(lineData, idx, seriesScope);
		}).update(function(newIdx, oldIdx) {
			_this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope);
		}).remove(function(idx) {
			group.remove(oldLineData.getItemGraphicEl(idx));
		}).execute();
	};
	LineDraw$1.prototype.updateLayout = function() {
		var lineData = this._lineData;
		if (!lineData) return;
		lineData.eachItemGraphicEl(function(el, idx) {
			el.updateLayout(lineData, idx);
		}, this);
	};
	LineDraw$1.prototype.incrementalPrepareUpdate = function(lineData) {
		this._seriesScope = makeSeriesScope$1(lineData);
		this._lineData = null;
		this.group.removeAll();
	};
	LineDraw$1.prototype.incrementalUpdate = function(taskParams, lineData) {
		this._progressiveEls = [];
		function updateIncrementalAndHover(el$1) {
			if (!el$1.isGroup && !isEffectObject(el$1)) {
				el$1.incremental = true;
				el$1.ensureState("emphasis").hoverLayer = true;
			}
		}
		for (var idx = taskParams.start; idx < taskParams.end; idx++) if (lineNeedsDraw(lineData.getItemLayout(idx))) {
			var el = new this._LineCtor(lineData, idx, this._seriesScope);
			el.traverse(updateIncrementalAndHover);
			this.group.add(el);
			lineData.setItemGraphicEl(idx, el);
			this._progressiveEls.push(el);
		}
	};
	LineDraw$1.prototype.remove = function() {
		this.group.removeAll();
	};
	LineDraw$1.prototype.eachRendered = function(cb) {
		traverseElements(this._progressiveEls || this.group, cb);
	};
	LineDraw$1.prototype._doAdd = function(lineData, idx, seriesScope) {
		if (!lineNeedsDraw(lineData.getItemLayout(idx))) return;
		var el = new this._LineCtor(lineData, idx, seriesScope);
		lineData.setItemGraphicEl(idx, el);
		this.group.add(el);
	};
	LineDraw$1.prototype._doUpdate = function(oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
		var itemEl = oldLineData.getItemGraphicEl(oldIdx);
		if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
			this.group.remove(itemEl);
			return;
		}
		if (!itemEl) itemEl = new this._LineCtor(newLineData, newIdx, seriesScope);
		else itemEl.updateData(newLineData, newIdx, seriesScope);
		newLineData.setItemGraphicEl(newIdx, itemEl);
		this.group.add(itemEl);
	};
	return LineDraw$1;
}();
function isEffectObject(el) {
	return el.animators && el.animators.length > 0;
}
function makeSeriesScope$1(lineData) {
	var hostModel = lineData.hostModel;
	var emphasisModel = hostModel.getModel("emphasis");
	return {
		lineStyle: hostModel.getModel("lineStyle").getLineStyle(),
		emphasisLineStyle: emphasisModel.getModel(["lineStyle"]).getLineStyle(),
		blurLineStyle: hostModel.getModel(["blur", "lineStyle"]).getLineStyle(),
		selectLineStyle: hostModel.getModel(["select", "lineStyle"]).getLineStyle(),
		emphasisDisabled: emphasisModel.get("disabled"),
		blurScope: emphasisModel.get("blurScope"),
		focus: emphasisModel.get("focus"),
		labelStatesModels: getLabelStatesModels(hostModel)
	};
}
function isPointNaN(pt) {
	return isNaN(pt[0]) || isNaN(pt[1]);
}
function lineNeedsDraw(pts) {
	return pts && !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
}
var LineDraw_default = LineDraw;

//#endregion
//#region node_modules/echarts/lib/chart/graph/adjustEdge.js
var v1 = [];
var v2 = [];
var v3 = [];
var quadraticAt = quadraticAt$1;
var v2DistSquare = distSquare;
var mathAbs = Math.abs;
function intersectCurveCircle(curvePoints, center$2, radius) {
	var p0 = curvePoints[0];
	var p1 = curvePoints[1];
	var p2 = curvePoints[2];
	var d = Infinity;
	var t;
	var radiusSquare = radius * radius;
	var interval = .1;
	for (var _t = .1; _t <= .9; _t += .1) {
		v1[0] = quadraticAt(p0[0], p1[0], p2[0], _t);
		v1[1] = quadraticAt(p0[1], p1[1], p2[1], _t);
		var diff = mathAbs(v2DistSquare(v1, center$2) - radiusSquare);
		if (diff < d) {
			d = diff;
			t = _t;
		}
	}
	for (var i$1 = 0; i$1 < 32; i$1++) {
		var next = t + interval;
		v2[0] = quadraticAt(p0[0], p1[0], p2[0], t);
		v2[1] = quadraticAt(p0[1], p1[1], p2[1], t);
		v3[0] = quadraticAt(p0[0], p1[0], p2[0], next);
		v3[1] = quadraticAt(p0[1], p1[1], p2[1], next);
		var diff = v2DistSquare(v2, center$2) - radiusSquare;
		if (mathAbs(diff) < .01) break;
		var nextDiff = v2DistSquare(v3, center$2) - radiusSquare;
		interval /= 2;
		if (diff < 0) if (nextDiff >= 0) t = t + interval;
		else t = t - interval;
		else if (nextDiff >= 0) t = t - interval;
		else t = t + interval;
	}
	return t;
}
function adjustEdge(graph, scale$3) {
	var tmp0 = [];
	var quadraticSubdivide$1 = quadraticSubdivide;
	var pts = [
		[],
		[],
		[]
	];
	var pts2 = [[], []];
	var v = [];
	scale$3 /= 2;
	graph.eachEdge(function(edge, idx) {
		var linePoints = edge.getLayout();
		var fromSymbol = edge.getVisual("fromSymbol");
		var toSymbol = edge.getVisual("toSymbol");
		if (!linePoints.__original) {
			linePoints.__original = [clone$3(linePoints[0]), clone$3(linePoints[1])];
			if (linePoints[2]) linePoints.__original.push(clone$3(linePoints[2]));
		}
		var originalPoints = linePoints.__original;
		if (linePoints[2] != null) {
			copy$1(pts[0], originalPoints[0]);
			copy$1(pts[1], originalPoints[2]);
			copy$1(pts[2], originalPoints[1]);
			if (fromSymbol && fromSymbol !== "none") {
				var symbolSize = getSymbolSize(edge.node1);
				var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale$3);
				quadraticSubdivide$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
				pts[0][0] = tmp0[3];
				pts[1][0] = tmp0[4];
				quadraticSubdivide$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
				pts[0][1] = tmp0[3];
				pts[1][1] = tmp0[4];
			}
			if (toSymbol && toSymbol !== "none") {
				var symbolSize = getSymbolSize(edge.node2);
				var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale$3);
				quadraticSubdivide$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
				pts[1][0] = tmp0[1];
				pts[2][0] = tmp0[2];
				quadraticSubdivide$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
				pts[1][1] = tmp0[1];
				pts[2][1] = tmp0[2];
			}
			copy$1(linePoints[0], pts[0]);
			copy$1(linePoints[1], pts[2]);
			copy$1(linePoints[2], pts[1]);
		} else {
			copy$1(pts2[0], originalPoints[0]);
			copy$1(pts2[1], originalPoints[1]);
			sub(v, pts2[1], pts2[0]);
			normalize$3(v, v);
			if (fromSymbol && fromSymbol !== "none") {
				var symbolSize = getSymbolSize(edge.node1);
				scaleAndAdd$1(pts2[0], pts2[0], v, symbolSize * scale$3);
			}
			if (toSymbol && toSymbol !== "none") {
				var symbolSize = getSymbolSize(edge.node2);
				scaleAndAdd$1(pts2[1], pts2[1], v, -symbolSize * scale$3);
			}
			copy$1(linePoints[0], pts2[0]);
			copy$1(linePoints[1], pts2[1]);
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/component/helper/thumbnailBridge.js
/**
* @caveat Do not import other `src/component/thumbnail/*` files.
*  This file should be decoupled from them for sake of the size consideration.
*/
/**
* FIXME: This is a temporary implmentation. May need refactor to decouple
*  the direct call from series.graph to thumbnail.
*/
var inner$12 = makeInner();
function getThumbnailBridge(model) {
	if (model) return inner$12(model).bridge;
}
function injectThumbnailBridge(model, thumbnailBridge) {
	if (model) inner$12(model).bridge = thumbnailBridge;
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/GraphView.js
function isViewCoordSys(coordSys) {
	return coordSys.type === "view";
}
var GraphView = function(_super) {
	__extends(GraphView$1, _super);
	function GraphView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = GraphView$1.type;
		return _this;
	}
	GraphView$1.prototype.init = function(ecModel, api) {
		var symbolDraw = new SymbolDraw_default();
		var lineDraw = new LineDraw_default();
		var group = this.group;
		var mainGroup = new Group_default();
		this._controller = new RoamController_default(api.getZr());
		this._controllerHost = { target: mainGroup };
		mainGroup.add(symbolDraw.group);
		mainGroup.add(lineDraw.group);
		group.add(mainGroup);
		this._symbolDraw = symbolDraw;
		this._lineDraw = lineDraw;
		this._mainGroup = mainGroup;
		this._firstRender = true;
	};
	GraphView$1.prototype.render = function(seriesModel, ecModel, api) {
		var _this = this;
		var coordSys = seriesModel.coordinateSystem;
		var isForceLayout = false;
		this._model = seriesModel;
		this._api = api;
		this._active = true;
		var thumbnailInfo = this._getThumbnailInfo();
		if (thumbnailInfo) thumbnailInfo.bridge.reset(api);
		var symbolDraw = this._symbolDraw;
		var lineDraw = this._lineDraw;
		if (isViewCoordSys(coordSys)) {
			var groupNewProp = {
				x: coordSys.x,
				y: coordSys.y,
				scaleX: coordSys.scaleX,
				scaleY: coordSys.scaleY
			};
			if (this._firstRender) this._mainGroup.attr(groupNewProp);
			else updateProps(this._mainGroup, groupNewProp, seriesModel);
		}
		adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
		var data = seriesModel.getData();
		symbolDraw.updateData(data);
		var edgeData = seriesModel.getEdgeData();
		lineDraw.updateData(edgeData);
		this._updateNodeAndLinkScale();
		this._updateController(null, seriesModel, api);
		clearTimeout(this._layoutTimeout);
		var forceLayout$1 = seriesModel.forceLayout;
		var layoutAnimation = seriesModel.get(["force", "layoutAnimation"]);
		if (forceLayout$1) {
			isForceLayout = true;
			this._startForceLayoutIteration(forceLayout$1, api, layoutAnimation);
		}
		var layout$3 = seriesModel.get("layout");
		data.graph.eachNode(function(node) {
			var idx = node.dataIndex;
			var el = node.getGraphicEl();
			var itemModel = node.getModel();
			if (!el) return;
			el.off("drag").off("dragend");
			var draggable = itemModel.get("draggable");
			if (draggable) el.on("drag", function(e$1) {
				switch (layout$3) {
					case "force":
						forceLayout$1.warmUp();
						!_this._layouting && _this._startForceLayoutIteration(forceLayout$1, api, layoutAnimation);
						forceLayout$1.setFixed(idx);
						data.setItemLayout(idx, [el.x, el.y]);
						break;
					case "circular":
						data.setItemLayout(idx, [el.x, el.y]);
						node.setLayout({ fixed: true }, true);
						circularLayout(seriesModel, "symbolSize", node, [e$1.offsetX, e$1.offsetY]);
						_this.updateLayout(seriesModel);
						break;
					case "none":
					default:
						data.setItemLayout(idx, [el.x, el.y]);
						simpleLayoutEdge(seriesModel.getGraph(), seriesModel);
						_this.updateLayout(seriesModel);
						break;
				}
			}).on("dragend", function() {
				if (forceLayout$1) forceLayout$1.setUnfixed(idx);
			});
			el.setDraggable(draggable, !!itemModel.get("cursor"));
			if (itemModel.get(["emphasis", "focus"]) === "adjacency") getECData(el).focus = node.getAdjacentDataIndices();
		});
		data.graph.eachEdge(function(edge) {
			var el = edge.getGraphicEl();
			var focus = edge.getModel().get(["emphasis", "focus"]);
			if (!el) return;
			if (focus === "adjacency") getECData(el).focus = {
				edge: [edge.dataIndex],
				node: [edge.node1.dataIndex, edge.node2.dataIndex]
			};
		});
		var circularRotateLabel = seriesModel.get("layout") === "circular" && seriesModel.get(["circular", "rotateLabel"]);
		var cx = data.getLayout("cx");
		var cy = data.getLayout("cy");
		data.graph.eachNode(function(node) {
			rotateNodeLabel(node, circularRotateLabel, cx, cy);
		});
		this._firstRender = false;
		if (!isForceLayout) this._renderThumbnail(seriesModel, api, this._symbolDraw, this._lineDraw);
	};
	GraphView$1.prototype.dispose = function() {
		this.remove();
		this._controller && this._controller.dispose();
		this._controllerHost = null;
	};
	GraphView$1.prototype._startForceLayoutIteration = function(forceLayout$1, api, layoutAnimation) {
		var self$1 = this;
		var firstRendered = false;
		(function step() {
			forceLayout$1.step(function(stopped) {
				self$1.updateLayout(self$1._model);
				if (stopped || !firstRendered) {
					firstRendered = true;
					self$1._renderThumbnail(self$1._model, api, self$1._symbolDraw, self$1._lineDraw);
				}
				(self$1._layouting = !stopped) && (layoutAnimation ? self$1._layoutTimeout = setTimeout(step, 16) : step());
			});
		})();
	};
	GraphView$1.prototype._updateController = function(clipRect, seriesModel, api) {
		var controller = this._controller;
		var controllerHost = this._controllerHost;
		var coordSys = seriesModel.coordinateSystem;
		if (!isViewCoordSys(coordSys)) {
			controller.disable();
			return;
		}
		controller.enable(seriesModel.get("roam"), {
			api,
			zInfo: { component: seriesModel },
			triggerInfo: {
				roamTrigger: seriesModel.get("roamTrigger"),
				isInSelf: function(e$1, x, y) {
					return coordSys.containPoint([x, y]);
				},
				isInClip: function(e$1, x, y) {
					return !clipRect || clipRect.contain(x, y);
				}
			}
		});
		controllerHost.zoomLimit = seriesModel.get("scaleLimit");
		controllerHost.zoom = coordSys.getZoom();
		controller.off("pan").off("zoom").on("pan", function(e$1) {
			api.dispatchAction({
				seriesId: seriesModel.id,
				type: "graphRoam",
				dx: e$1.dx,
				dy: e$1.dy
			});
		}).on("zoom", function(e$1) {
			api.dispatchAction({
				seriesId: seriesModel.id,
				type: "graphRoam",
				zoom: e$1.scale,
				originX: e$1.originX,
				originY: e$1.originY
			});
		});
	};
	/**
	* A performance shortcut - called by action handler to update the view directly
	* without any data/visual processing (which are assumed to be unchanged), while
	* ensuring consistent behavior between internal and external action triggers.
	*/
	GraphView$1.prototype.updateViewOnPan = function(seriesModel, api, params) {
		if (!this._active) return;
		updateViewOnPan(this._controllerHost, params.dx, params.dy);
		this._updateThumbnailWindow();
	};
	/**
	* A performance shortcut - called by action handler to update the view directly
	* without any data/visual processing (which are assumed to be unchanged), while
	* ensuring consistent behavior between internal and external action triggers.
	*/
	GraphView$1.prototype.updateViewOnZoom = function(seriesModel, api, params) {
		if (!this._active) return;
		updateViewOnZoom(this._controllerHost, params.zoom, params.originX, params.originY);
		this._updateNodeAndLinkScale();
		adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
		this._lineDraw.updateLayout();
		api.updateLabelLayout();
		this._updateThumbnailWindow();
	};
	GraphView$1.prototype._updateNodeAndLinkScale = function() {
		var seriesModel = this._model;
		var data = seriesModel.getData();
		var nodeScale = getNodeGlobalScale(seriesModel);
		data.eachItemGraphicEl(function(el, idx) {
			el && el.setSymbolScale(nodeScale);
		});
	};
	GraphView$1.prototype.updateLayout = function(seriesModel) {
		if (!this._active) return;
		adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
		this._symbolDraw.updateLayout();
		this._lineDraw.updateLayout();
	};
	GraphView$1.prototype.remove = function() {
		this._active = false;
		clearTimeout(this._layoutTimeout);
		this._layouting = false;
		this._layoutTimeout = null;
		this._symbolDraw && this._symbolDraw.remove();
		this._lineDraw && this._lineDraw.remove();
		this._controller && this._controller.disable();
	};
	/**
	* Get thumbnail data structure only if supported.
	*/
	GraphView$1.prototype._getThumbnailInfo = function() {
		var model = this._model;
		var coordSys = model.coordinateSystem;
		if (coordSys.type !== "view") return;
		var bridge = getThumbnailBridge(model);
		if (!bridge) return;
		return {
			bridge,
			coordSys
		};
	};
	GraphView$1.prototype._updateThumbnailWindow = function() {
		var info = this._getThumbnailInfo();
		if (info) info.bridge.updateWindow(info.coordSys.transform, this._api);
	};
	GraphView$1.prototype._renderThumbnail = function(seriesModel, api, symbolDraw, lineDraw) {
		var info = this._getThumbnailInfo();
		if (!info) return;
		var bridgeGroup = new Group_default();
		var symbolNodes = symbolDraw.group.children();
		var lineNodes = lineDraw.group.children();
		var lineGroup = new Group_default();
		var symbolGroup = new Group_default();
		bridgeGroup.add(symbolGroup);
		bridgeGroup.add(lineGroup);
		for (var i$1 = 0; i$1 < symbolNodes.length; i$1++) {
			var node = symbolNodes[i$1];
			var sub$1 = node.children()[0];
			var x = node.x;
			var y = node.y;
			var shape = extend(clone(sub$1.shape), {
				width: sub$1.scaleX,
				height: sub$1.scaleY,
				x: x - sub$1.scaleX / 2,
				y: y - sub$1.scaleY / 2
			});
			var style = clone(sub$1.style);
			var subThumbnail = new sub$1.constructor({
				shape,
				style,
				z2: 151
			});
			symbolGroup.add(subThumbnail);
		}
		for (var i$1 = 0; i$1 < lineNodes.length; i$1++) {
			var node = lineNodes[i$1];
			var line = node.children()[0];
			var style = clone(line.style);
			var shape = clone(line.shape);
			var lineThumbnail = new LinePath_default({
				style,
				shape,
				z2: 151
			});
			lineGroup.add(lineThumbnail);
		}
		info.bridge.renderContent({
			api,
			roamType: seriesModel.get("roam"),
			viewportRect: null,
			group: bridgeGroup,
			targetTrans: info.coordSys.transform
		});
	};
	GraphView$1.type = "graph";
	return GraphView$1;
}(Chart_default);
var GraphView_default = GraphView;

//#endregion
//#region node_modules/echarts/lib/data/Graph.js
function generateNodeKey(id) {
	return "_EC_" + id;
}
var Graph = function() {
	function Graph$1(directed) {
		this.type = "graph";
		this.nodes = [];
		this.edges = [];
		this._nodesMap = {};
		/**
		* @type {Object.<string, module:echarts/data/Graph.Edge>}
		* @private
		*/
		this._edgesMap = {};
		this._directed = directed || false;
	}
	/**
	* If is directed graph
	*/
	Graph$1.prototype.isDirected = function() {
		return this._directed;
	};
	/**
	* Add a new node
	*/
	Graph$1.prototype.addNode = function(id, dataIndex) {
		id = id == null ? "" + dataIndex : "" + id;
		var nodesMap = this._nodesMap;
		if (nodesMap[generateNodeKey(id)]) {
			console.error("Graph nodes have duplicate name or id");
			return;
		}
		var node = new GraphNode(id, dataIndex);
		node.hostGraph = this;
		this.nodes.push(node);
		nodesMap[generateNodeKey(id)] = node;
		return node;
	};
	/**
	* Get node by data index
	*/
	Graph$1.prototype.getNodeByIndex = function(dataIndex) {
		var rawIdx = this.data.getRawIndex(dataIndex);
		return this.nodes[rawIdx];
	};
	/**
	* Get node by id
	*/
	Graph$1.prototype.getNodeById = function(id) {
		return this._nodesMap[generateNodeKey(id)];
	};
	/**
	* Add a new edge
	*/
	Graph$1.prototype.addEdge = function(n1, n2, dataIndex) {
		var nodesMap = this._nodesMap;
		var edgesMap = this._edgesMap;
		if (isNumber(n1)) n1 = this.nodes[n1];
		if (isNumber(n2)) n2 = this.nodes[n2];
		if (!(n1 instanceof GraphNode)) n1 = nodesMap[generateNodeKey(n1)];
		if (!(n2 instanceof GraphNode)) n2 = nodesMap[generateNodeKey(n2)];
		if (!n1 || !n2) return;
		var key$1 = n1.id + "-" + n2.id;
		var edge = new GraphEdge(n1, n2, dataIndex);
		edge.hostGraph = this;
		if (this._directed) {
			n1.outEdges.push(edge);
			n2.inEdges.push(edge);
		}
		n1.edges.push(edge);
		if (n1 !== n2) n2.edges.push(edge);
		this.edges.push(edge);
		edgesMap[key$1] = edge;
		return edge;
	};
	/**
	* Get edge by data index
	*/
	Graph$1.prototype.getEdgeByIndex = function(dataIndex) {
		var rawIdx = this.edgeData.getRawIndex(dataIndex);
		return this.edges[rawIdx];
	};
	/**
	* Get edge by two linked nodes
	*/
	Graph$1.prototype.getEdge = function(n1, n2) {
		if (n1 instanceof GraphNode) n1 = n1.id;
		if (n2 instanceof GraphNode) n2 = n2.id;
		var edgesMap = this._edgesMap;
		if (this._directed) return edgesMap[n1 + "-" + n2];
		else return edgesMap[n1 + "-" + n2] || edgesMap[n2 + "-" + n1];
	};
	/**
	* Iterate all nodes
	*/
	Graph$1.prototype.eachNode = function(cb, context) {
		var nodes = this.nodes;
		var len$1 = nodes.length;
		for (var i$1 = 0; i$1 < len$1; i$1++) if (nodes[i$1].dataIndex >= 0) cb.call(context, nodes[i$1], i$1);
	};
	/**
	* Iterate all edges
	*/
	Graph$1.prototype.eachEdge = function(cb, context) {
		var edges = this.edges;
		var len$1 = edges.length;
		for (var i$1 = 0; i$1 < len$1; i$1++) if (edges[i$1].dataIndex >= 0 && edges[i$1].node1.dataIndex >= 0 && edges[i$1].node2.dataIndex >= 0) cb.call(context, edges[i$1], i$1);
	};
	/**
	* Breadth first traverse
	* Return true to stop traversing
	*/
	Graph$1.prototype.breadthFirstTraverse = function(cb, startNode, direction, context) {
		if (!(startNode instanceof GraphNode)) startNode = this._nodesMap[generateNodeKey(startNode)];
		if (!startNode) return;
		var edgeType = direction === "out" ? "outEdges" : direction === "in" ? "inEdges" : "edges";
		for (var i$1 = 0; i$1 < this.nodes.length; i$1++) this.nodes[i$1].__visited = false;
		if (cb.call(context, startNode, null)) return;
		var queue = [startNode];
		while (queue.length) {
			var currentNode = queue.shift();
			var edges = currentNode[edgeType];
			for (var i$1 = 0; i$1 < edges.length; i$1++) {
				var e$1 = edges[i$1];
				var otherNode = e$1.node1 === currentNode ? e$1.node2 : e$1.node1;
				if (!otherNode.__visited) {
					if (cb.call(context, otherNode, currentNode)) return;
					queue.push(otherNode);
					otherNode.__visited = true;
				}
			}
		}
	};
	Graph$1.prototype.update = function() {
		var data = this.data;
		var edgeData = this.edgeData;
		var nodes = this.nodes;
		var edges = this.edges;
		for (var i$1 = 0, len$1 = nodes.length; i$1 < len$1; i$1++) nodes[i$1].dataIndex = -1;
		for (var i$1 = 0, len$1 = data.count(); i$1 < len$1; i$1++) nodes[data.getRawIndex(i$1)].dataIndex = i$1;
		edgeData.filterSelf(function(idx) {
			var edge = edges[edgeData.getRawIndex(idx)];
			return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
		});
		for (var i$1 = 0, len$1 = edges.length; i$1 < len$1; i$1++) edges[i$1].dataIndex = -1;
		for (var i$1 = 0, len$1 = edgeData.count(); i$1 < len$1; i$1++) edges[edgeData.getRawIndex(i$1)].dataIndex = i$1;
	};
	/**
	* @return {module:echarts/data/Graph}
	*/
	Graph$1.prototype.clone = function() {
		var graph = new Graph$1(this._directed);
		var nodes = this.nodes;
		var edges = this.edges;
		for (var i$1 = 0; i$1 < nodes.length; i$1++) graph.addNode(nodes[i$1].id, nodes[i$1].dataIndex);
		for (var i$1 = 0; i$1 < edges.length; i$1++) {
			var e$1 = edges[i$1];
			graph.addEdge(e$1.node1.id, e$1.node2.id, e$1.dataIndex);
		}
		return graph;
	};
	return Graph$1;
}();
var GraphNode = function() {
	function GraphNode$1(id, dataIndex) {
		this.inEdges = [];
		this.outEdges = [];
		this.edges = [];
		this.dataIndex = -1;
		this.id = id == null ? "" : id;
		this.dataIndex = dataIndex == null ? -1 : dataIndex;
	}
	/**
	* @return {number}
	*/
	GraphNode$1.prototype.degree = function() {
		return this.edges.length;
	};
	/**
	* @return {number}
	*/
	GraphNode$1.prototype.inDegree = function() {
		return this.inEdges.length;
	};
	/**
	* @return {number}
	*/
	GraphNode$1.prototype.outDegree = function() {
		return this.outEdges.length;
	};
	GraphNode$1.prototype.getModel = function(path) {
		if (this.dataIndex < 0) return;
		return this.hostGraph.data.getItemModel(this.dataIndex).getModel(path);
	};
	GraphNode$1.prototype.getAdjacentDataIndices = function() {
		var dataIndices = {
			edge: [],
			node: []
		};
		for (var i$1 = 0; i$1 < this.edges.length; i$1++) {
			var adjacentEdge = this.edges[i$1];
			if (adjacentEdge.dataIndex < 0) continue;
			dataIndices.edge.push(adjacentEdge.dataIndex);
			dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);
		}
		return dataIndices;
	};
	GraphNode$1.prototype.getTrajectoryDataIndices = function() {
		var connectedEdgesMap = createHashMap();
		var connectedNodesMap = createHashMap();
		for (var i$1 = 0, len$1 = this.edges.length; i$1 < len$1; i$1++) {
			var adjacentEdge = this.edges[i$1];
			if (adjacentEdge.dataIndex < 0) continue;
			connectedEdgesMap.set(adjacentEdge.dataIndex, true);
			var sourceNodesQueue = [adjacentEdge.node1];
			var targetNodesQueue = [adjacentEdge.node2];
			var nodeIteratorIndex = 0;
			while (nodeIteratorIndex < sourceNodesQueue.length) {
				var sourceNode = sourceNodesQueue[nodeIteratorIndex];
				nodeIteratorIndex++;
				connectedNodesMap.set(sourceNode.dataIndex, true);
				var sourceNodeInEdges = sourceNode.inEdges;
				for (var j = 0, len_1 = sourceNodeInEdges.length, inEdge = void 0, inEdgeDataIndex = void 0; j < len_1; j++) {
					inEdge = sourceNodeInEdges[j];
					inEdgeDataIndex = inEdge.dataIndex;
					if (inEdgeDataIndex >= 0 && !connectedEdgesMap.hasKey(inEdgeDataIndex)) {
						connectedEdgesMap.set(inEdgeDataIndex, true);
						sourceNodesQueue.push(inEdge.node1);
					}
				}
			}
			nodeIteratorIndex = 0;
			while (nodeIteratorIndex < targetNodesQueue.length) {
				var targetNode = targetNodesQueue[nodeIteratorIndex];
				nodeIteratorIndex++;
				connectedNodesMap.set(targetNode.dataIndex, true);
				var targetNodeOutEdges = targetNode.outEdges;
				for (var j = 0, len_2 = targetNodeOutEdges.length, outEdge = void 0, outEdgeDataIndex = void 0; j < len_2; j++) {
					outEdge = targetNodeOutEdges[j];
					outEdgeDataIndex = outEdge.dataIndex;
					if (outEdgeDataIndex >= 0 && !connectedEdgesMap.hasKey(outEdgeDataIndex)) {
						connectedEdgesMap.set(outEdgeDataIndex, true);
						targetNodesQueue.push(outEdge.node2);
					}
				}
			}
		}
		return {
			edge: connectedEdgesMap.keys(),
			node: connectedNodesMap.keys()
		};
	};
	return GraphNode$1;
}();
var GraphEdge = function() {
	function GraphEdge$1(n1, n2, dataIndex) {
		this.dataIndex = -1;
		this.node1 = n1;
		this.node2 = n2;
		this.dataIndex = dataIndex == null ? -1 : dataIndex;
	}
	GraphEdge$1.prototype.getModel = function(path) {
		if (this.dataIndex < 0) return;
		return this.hostGraph.edgeData.getItemModel(this.dataIndex).getModel(path);
	};
	GraphEdge$1.prototype.getAdjacentDataIndices = function() {
		return {
			edge: [this.dataIndex],
			node: [this.node1.dataIndex, this.node2.dataIndex]
		};
	};
	GraphEdge$1.prototype.getTrajectoryDataIndices = function() {
		var connectedEdgesMap = createHashMap();
		var connectedNodesMap = createHashMap();
		connectedEdgesMap.set(this.dataIndex, true);
		var sourceNodes = [this.node1];
		var targetNodes = [this.node2];
		var nodeIteratorIndex = 0;
		while (nodeIteratorIndex < sourceNodes.length) {
			var sourceNode = sourceNodes[nodeIteratorIndex];
			nodeIteratorIndex++;
			connectedNodesMap.set(sourceNode.dataIndex, true);
			var sourceNodeInEdges = sourceNode.inEdges;
			for (var j = 0, len$1 = sourceNodeInEdges.length, inEdge = void 0, inEdgeDataIndex = void 0; j < len$1; j++) {
				inEdge = sourceNode.inEdges[j];
				inEdgeDataIndex = inEdge.dataIndex;
				if (inEdgeDataIndex >= 0 && !connectedEdgesMap.hasKey(inEdgeDataIndex)) {
					connectedEdgesMap.set(inEdgeDataIndex, true);
					sourceNodes.push(inEdge.node1);
				}
			}
		}
		nodeIteratorIndex = 0;
		while (nodeIteratorIndex < targetNodes.length) {
			var targetNode = targetNodes[nodeIteratorIndex];
			nodeIteratorIndex++;
			connectedNodesMap.set(targetNode.dataIndex, true);
			var targetNodeOutEdges = targetNode.outEdges;
			for (var j = 0, len$1 = targetNodeOutEdges.length, outEdge = void 0, outEdgeDataIndex = void 0; j < len$1; j++) {
				outEdge = targetNode.outEdges[j];
				outEdgeDataIndex = outEdge.dataIndex;
				if (outEdgeDataIndex >= 0 && !connectedEdgesMap.hasKey(outEdgeDataIndex)) {
					connectedEdgesMap.set(outEdgeDataIndex, true);
					targetNodes.push(outEdge.node2);
				}
			}
		}
		return {
			edge: connectedEdgesMap.keys(),
			node: connectedNodesMap.keys()
		};
	};
	return GraphEdge$1;
}();
function createGraphDataProxyMixin(hostName, dataName) {
	return {
		getValue: function(dimension) {
			var data = this[hostName][dataName];
			return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
		},
		setVisual: function(key$1, value) {
			this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key$1, value);
		},
		getVisual: function(key$1) {
			return this[hostName][dataName].getItemVisual(this.dataIndex, key$1);
		},
		setLayout: function(layout$3, merge$1) {
			this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout$3, merge$1);
		},
		getLayout: function() {
			return this[hostName][dataName].getItemLayout(this.dataIndex);
		},
		getGraphicEl: function() {
			return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
		},
		getRawIndex: function() {
			return this[hostName][dataName].getRawIndex(this.dataIndex);
		}
	};
}
mixin(GraphNode, createGraphDataProxyMixin("hostGraph", "data"));
mixin(GraphEdge, createGraphDataProxyMixin("hostGraph", "edgeData"));
var Graph_default = Graph;

//#endregion
//#region node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js
function createGraphFromNodeEdge(nodes, edges, seriesModel, directed, beforeLink) {
	var graph = new Graph_default(directed);
	for (var i$1 = 0; i$1 < nodes.length; i$1++) graph.addNode(retrieve(nodes[i$1].id, nodes[i$1].name, i$1), i$1);
	var linkNameList = [];
	var validEdges = [];
	var linkCount = 0;
	for (var i$1 = 0; i$1 < edges.length; i$1++) {
		var link = edges[i$1];
		var source = link.source;
		var target = link.target;
		if (graph.addEdge(source, target, linkCount)) {
			validEdges.push(link);
			linkNameList.push(retrieve(convertOptionIdName(link.id, null), source + " > " + target));
			linkCount++;
		}
	}
	var coordSys = seriesModel.get("coordinateSystem");
	var nodeData;
	if (coordSys === "cartesian2d" || coordSys === "polar" || coordSys === "matrix") nodeData = createSeriesData_default(nodes, seriesModel);
	else {
		var coordSysCtor = CoordinateSystem_default.get(coordSys);
		var coordDimensions = coordSysCtor ? coordSysCtor.dimensions || [] : [];
		if (indexOf(coordDimensions, "value") < 0) coordDimensions.concat(["value"]);
		var dimensions = prepareSeriesDataSchema(nodes, {
			coordDimensions,
			encodeDefine: seriesModel.getEncode()
		}).dimensions;
		nodeData = new SeriesData_default(dimensions, seriesModel);
		nodeData.initData(nodes);
	}
	var edgeData = new SeriesData_default(["value"], seriesModel);
	edgeData.initData(validEdges, linkNameList);
	beforeLink && beforeLink(nodeData, edgeData);
	linkSeriesData_default({
		mainData: nodeData,
		struct: graph,
		structAttr: "graph",
		datas: {
			node: nodeData,
			edge: edgeData
		},
		datasAttr: {
			node: "data",
			edge: "edgeData"
		}
	});
	graph.update();
	return graph;
}

//#endregion
//#region node_modules/echarts/lib/chart/graph/GraphSeries.js
var GraphSeriesModel = function(_super) {
	__extends(GraphSeriesModel$1, _super);
	function GraphSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = GraphSeriesModel$1.type;
		_this.hasSymbolVisual = true;
		return _this;
	}
	GraphSeriesModel$1.prototype.init = function(option) {
		_super.prototype.init.apply(this, arguments);
		var self$1 = this;
		function getCategoriesData() {
			return self$1._categoriesData;
		}
		this.legendVisualProvider = new LegendVisualProvider_default(getCategoriesData, getCategoriesData);
		this.fillDataTextStyle(option.edges || option.links);
		this._updateCategoriesData();
	};
	GraphSeriesModel$1.prototype.mergeOption = function(option) {
		_super.prototype.mergeOption.apply(this, arguments);
		this.fillDataTextStyle(option.edges || option.links);
		this._updateCategoriesData();
	};
	GraphSeriesModel$1.prototype.mergeDefaultAndTheme = function(option) {
		_super.prototype.mergeDefaultAndTheme.apply(this, arguments);
		defaultEmphasis(option, "edgeLabel", ["show"]);
	};
	GraphSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		var edges = option.edges || option.links || [];
		var nodes = option.data || option.nodes || [];
		var self$1 = this;
		if (nodes && edges) {
			initCurvenessList(this);
			var graph = createGraphFromNodeEdge(nodes, edges, this, true, beforeLink);
			each(graph.edges, function(edge) {
				createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);
			}, this);
			return graph.data;
		}
		function beforeLink(nodeData, edgeData) {
			nodeData.wrapMethod("getItemModel", function(model) {
				var categoryModel = self$1._categoriesModels[model.getShallow("category")];
				if (categoryModel) {
					categoryModel.parentModel = model.parentModel;
					model.parentModel = categoryModel;
				}
				return model;
			});
			var oldGetModel = Model_default.prototype.getModel;
			function newGetModel(path, parentModel) {
				var model = oldGetModel.call(this, path, parentModel);
				model.resolveParentPath = resolveParentPath;
				return model;
			}
			edgeData.wrapMethod("getItemModel", function(model) {
				model.resolveParentPath = resolveParentPath;
				model.getModel = newGetModel;
				return model;
			});
			function resolveParentPath(pathArr) {
				if (pathArr && (pathArr[0] === "label" || pathArr[1] === "label")) {
					var newPathArr = pathArr.slice();
					if (pathArr[0] === "label") newPathArr[0] = "edgeLabel";
					else if (pathArr[1] === "label") newPathArr[1] = "edgeLabel";
					return newPathArr;
				}
				return pathArr;
			}
		}
	};
	GraphSeriesModel$1.prototype.getGraph = function() {
		return this.getData().graph;
	};
	GraphSeriesModel$1.prototype.getEdgeData = function() {
		return this.getGraph().edgeData;
	};
	GraphSeriesModel$1.prototype.getCategoriesData = function() {
		return this._categoriesData;
	};
	GraphSeriesModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		if (dataType === "edge") {
			var nodeData = this.getData();
			var params = this.getDataParams(dataIndex, dataType);
			var edge = nodeData.graph.getEdgeByIndex(dataIndex);
			var sourceName = nodeData.getName(edge.node1.dataIndex);
			var targetName = nodeData.getName(edge.node2.dataIndex);
			var nameArr = [];
			sourceName != null && nameArr.push(sourceName);
			targetName != null && nameArr.push(targetName);
			return createTooltipMarkup("nameValue", {
				name: nameArr.join(" > "),
				value: params.value,
				noValue: params.value == null
			});
		}
		return defaultSeriesFormatTooltip({
			series: this,
			dataIndex,
			multipleSeries
		});
	};
	GraphSeriesModel$1.prototype._updateCategoriesData = function() {
		var categories = map(this.option.categories || [], function(category) {
			return category.value != null ? category : extend({ value: 0 }, category);
		});
		var categoriesData = new SeriesData_default(["value"], this);
		categoriesData.initData(categories);
		this._categoriesData = categoriesData;
		this._categoriesModels = categoriesData.mapArray(function(idx) {
			return categoriesData.getItemModel(idx);
		});
	};
	GraphSeriesModel$1.prototype.setZoom = function(zoom) {
		this.option.zoom = zoom;
	};
	GraphSeriesModel$1.prototype.setCenter = function(center$2) {
		this.option.center = center$2;
	};
	GraphSeriesModel$1.prototype.isAnimationEnabled = function() {
		return _super.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
	};
	GraphSeriesModel$1.type = "series.graph";
	GraphSeriesModel$1.dependencies = [
		"grid",
		"polar",
		"geo",
		"singleAxis",
		"calendar"
	];
	GraphSeriesModel$1.defaultOption = {
		z: 2,
		coordinateSystem: "view",
		legendHoverLink: true,
		layout: null,
		circular: { rotateLabel: false },
		force: {
			initLayout: null,
			repulsion: [0, 50],
			gravity: .1,
			friction: .6,
			edgeLength: 30,
			layoutAnimation: true
		},
		left: "center",
		top: "center",
		symbol: "circle",
		symbolSize: 10,
		edgeSymbol: ["none", "none"],
		edgeSymbolSize: 10,
		edgeLabel: {
			position: "middle",
			distance: 5
		},
		draggable: false,
		roam: false,
		center: null,
		zoom: 1,
		nodeScaleRatio: .6,
		label: {
			show: false,
			formatter: "{b}"
		},
		itemStyle: {},
		lineStyle: {
			color: tokens_default.color.neutral50,
			width: 1,
			opacity: .5
		},
		emphasis: {
			scale: true,
			label: { show: true }
		},
		select: { itemStyle: { borderColor: tokens_default.color.primary } }
	};
	return GraphSeriesModel$1;
}(Series_default);
var GraphSeries_default = GraphSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/graph/install.js
function install$10(registers) {
	registers.registerChartView(GraphView_default);
	registers.registerSeriesModel(GraphSeries_default);
	registers.registerProcessor(categoryFilter);
	registers.registerVisual(categoryVisual);
	registers.registerVisual(graphEdgeVisual);
	registers.registerLayout(graphSimpleLayout);
	registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout);
	registers.registerLayout(graphForceLayout);
	registers.registerCoordinateSystem("graphView", {
		dimensions: View_default.dimensions,
		create: createViewCoordSys
	});
	registers.registerAction({
		type: "focusNodeAdjacency",
		event: "focusNodeAdjacency",
		update: "series:focusNodeAdjacency"
	}, noop);
	registers.registerAction({
		type: "unfocusNodeAdjacency",
		event: "unfocusNodeAdjacency",
		update: "series:unfocusNodeAdjacency"
	}, noop);
	registers.registerAction({
		type: "graphRoam",
		event: "graphRoam",
		update: "none"
	}, function(payload, ecModel, api) {
		ecModel.eachComponent({
			mainType: "series",
			query: payload
		}, function(seriesModel) {
			var graphView = api.getViewOfSeriesModel(seriesModel);
			if (graphView) {
				if (payload.dx != null && payload.dy != null) graphView.updateViewOnPan(seriesModel, api, payload);
				if (payload.zoom != null && payload.originX != null && payload.originY != null) graphView.updateViewOnZoom(seriesModel, api, payload);
			}
			var coordSys = seriesModel.coordinateSystem;
			var res = updateCenterAndZoomInAction(coordSys, payload, seriesModel.get("scaleLimit"));
			seriesModel.setCenter && seriesModel.setCenter(res.center);
			seriesModel.setZoom && seriesModel.setZoom(res.zoom);
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/chord/ChordPiece.js
var ChordPiece = function(_super) {
	__extends(ChordPiece$1, _super);
	function ChordPiece$1(data, idx, startAngle) {
		var _this = _super.call(this) || this;
		getECData(_this).dataType = "node";
		_this.z2 = 2;
		var text = new Text_default();
		_this.setTextContent(text);
		_this.updateData(data, idx, startAngle, true);
		return _this;
	}
	ChordPiece$1.prototype.updateData = function(data, idx, startAngle, firstCreate) {
		var sector = this;
		var node = data.graph.getNodeByIndex(idx);
		var seriesModel = data.hostModel;
		var itemModel = node.getModel();
		var emphasisModel = itemModel.getModel("emphasis");
		var layout$3 = data.getItemLayout(idx);
		var shape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout$3, true), layout$3);
		var el = this;
		if (isNaN(shape.startAngle)) {
			el.setShape(shape);
			return;
		}
		if (firstCreate) el.setShape(shape);
		else updateProps(el, { shape }, seriesModel, idx);
		var sectorShape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout$3, true), layout$3);
		sector.setShape(sectorShape);
		sector.useStyle(data.getItemVisual(idx, "style"));
		setStatesStylesFromModel(sector, itemModel);
		this._updateLabel(seriesModel, itemModel, node);
		data.setItemGraphicEl(idx, el);
		setStatesStylesFromModel(el, itemModel, "itemStyle");
		var focus = emphasisModel.get("focus");
		toggleHoverEmphasis(this, focus === "adjacency" ? node.getAdjacentDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
	};
	ChordPiece$1.prototype._updateLabel = function(seriesModel, itemModel, node) {
		var label = this.getTextContent();
		var layout$3 = node.getLayout();
		var midAngle = (layout$3.startAngle + layout$3.endAngle) / 2;
		var dx = Math.cos(midAngle);
		var dy = Math.sin(midAngle);
		var normalLabelModel = itemModel.getModel("label");
		label.ignore = !normalLabelModel.get("show");
		var labelStateModels = getLabelStatesModels(itemModel);
		var style = node.getVisual("style");
		setLabelStyle(label, labelStateModels, {
			labelFetcher: { getFormattedLabel: function(dataIndex, stateName, dataType, labelDimIndex, formatter, extendParams) {
				return seriesModel.getFormattedLabel(dataIndex, stateName, "node", labelDimIndex, retrieve3(formatter, labelStateModels.normal && labelStateModels.normal.get("formatter"), itemModel.get("name")), extendParams);
			} },
			labelDataIndex: node.dataIndex,
			defaultText: node.dataIndex + "",
			inheritColor: style.fill,
			defaultOpacity: style.opacity,
			defaultOutsidePosition: "startArc"
		});
		var labelPosition = normalLabelModel.get("position") || "outside";
		var labelPadding = normalLabelModel.get("distance") || 0;
		var r;
		if (labelPosition === "outside") r = layout$3.r + labelPadding;
		else r = (layout$3.r + layout$3.r0) / 2;
		this.textConfig = { inside: labelPosition !== "outside" };
		var align = labelPosition !== "outside" ? normalLabelModel.get("align") || "center" : dx > 0 ? "left" : "right";
		var verticalAlign = labelPosition !== "outside" ? normalLabelModel.get("verticalAlign") || "middle" : dy > 0 ? "top" : "bottom";
		label.attr({
			x: dx * r + layout$3.cx,
			y: dy * r + layout$3.cy,
			rotation: 0,
			style: {
				align,
				verticalAlign
			}
		});
	};
	return ChordPiece$1;
}(Sector_default);
var ChordPiece_default = ChordPiece;

//#endregion
//#region node_modules/echarts/lib/chart/chord/ChordEdge.js
var ChordPathShape = function() {
	function ChordPathShape$1() {
		this.s1 = [0, 0];
		this.s2 = [0, 0];
		this.sStartAngle = 0;
		this.sEndAngle = 0;
		this.t1 = [0, 0];
		this.t2 = [0, 0];
		this.tStartAngle = 0;
		this.tEndAngle = 0;
		this.cx = 0;
		this.cy = 0;
		this.r = 0;
		this.clockwise = true;
	}
	return ChordPathShape$1;
}();
var ChordEdge = function(_super) {
	__extends(ChordEdge$1, _super);
	function ChordEdge$1(nodeData, edgeData, edgeIdx, startAngle) {
		var _this = _super.call(this) || this;
		getECData(_this).dataType = "edge";
		_this.updateData(nodeData, edgeData, edgeIdx, startAngle, true);
		return _this;
	}
	ChordEdge$1.prototype.buildPath = function(ctx, shape) {
		ctx.moveTo(shape.s1[0], shape.s1[1]);
		var ratio = .7;
		var clockwise = shape.clockwise;
		ctx.arc(shape.cx, shape.cy, shape.r, shape.sStartAngle, shape.sEndAngle, !clockwise);
		ctx.bezierCurveTo((shape.cx - shape.s2[0]) * ratio + shape.s2[0], (shape.cy - shape.s2[1]) * ratio + shape.s2[1], (shape.cx - shape.t1[0]) * ratio + shape.t1[0], (shape.cy - shape.t1[1]) * ratio + shape.t1[1], shape.t1[0], shape.t1[1]);
		ctx.arc(shape.cx, shape.cy, shape.r, shape.tStartAngle, shape.tEndAngle, !clockwise);
		ctx.bezierCurveTo((shape.cx - shape.t2[0]) * ratio + shape.t2[0], (shape.cy - shape.t2[1]) * ratio + shape.t2[1], (shape.cx - shape.s1[0]) * ratio + shape.s1[0], (shape.cy - shape.s1[1]) * ratio + shape.s1[1], shape.s1[0], shape.s1[1]);
		ctx.closePath();
	};
	ChordEdge$1.prototype.updateData = function(nodeData, edgeData, edgeIdx, startAngle, firstCreate) {
		var seriesModel = nodeData.hostModel;
		var edge = edgeData.graph.getEdgeByIndex(edgeIdx);
		var layout$3 = edge.getLayout();
		var itemModel = edge.node1.getModel();
		var edgeModel = edgeData.getItemModel(edge.dataIndex);
		var lineStyle = edgeModel.getModel("lineStyle");
		var emphasisModel = edgeModel.getModel("emphasis");
		var focus = emphasisModel.get("focus");
		var shape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout$3, true), layout$3);
		var el = this;
		if (isNaN(shape.sStartAngle) || isNaN(shape.tStartAngle)) {
			el.setShape(shape);
			return;
		}
		if (firstCreate) {
			el.setShape(shape);
			applyEdgeFill(el, edge, nodeData, lineStyle);
		} else {
			saveOldStyle(el);
			applyEdgeFill(el, edge, nodeData, lineStyle);
			updateProps(el, { shape }, seriesModel, edgeIdx);
		}
		toggleHoverEmphasis(this, focus === "adjacency" ? edge.getAdjacentDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
		setStatesStylesFromModel(el, edgeModel, "lineStyle");
		edgeData.setItemGraphicEl(edge.dataIndex, el);
	};
	return ChordEdge$1;
}(Path_default);
function applyEdgeFill(edgeShape, edge, nodeData, lineStyleModel) {
	var node1 = edge.node1;
	var node2 = edge.node2;
	var edgeStyle = edgeShape.style;
	edgeShape.setStyle(lineStyleModel.getLineStyle());
	switch (lineStyleModel.get("color")) {
		case "source":
			edgeStyle.fill = nodeData.getItemVisual(node1.dataIndex, "style").fill;
			edgeStyle.decal = node1.getVisual("style").decal;
			break;
		case "target":
			edgeStyle.fill = nodeData.getItemVisual(node2.dataIndex, "style").fill;
			edgeStyle.decal = node2.getVisual("style").decal;
			break;
		case "gradient":
			var sourceColor = nodeData.getItemVisual(node1.dataIndex, "style").fill;
			var targetColor = nodeData.getItemVisual(node2.dataIndex, "style").fill;
			if (isString(sourceColor) && isString(targetColor)) {
				var shape = edgeShape.shape;
				var sMidX = (shape.s1[0] + shape.s2[0]) / 2;
				var sMidY = (shape.s1[1] + shape.s2[1]) / 2;
				var tMidX = (shape.t1[0] + shape.t2[0]) / 2;
				var tMidY = (shape.t1[1] + shape.t2[1]) / 2;
				edgeStyle.fill = new LinearGradient_default(sMidX, sMidY, tMidX, tMidY, [{
					offset: 0,
					color: sourceColor
				}, {
					offset: 1,
					color: targetColor
				}], true);
			}
			break;
	}
}

//#endregion
//#region node_modules/echarts/lib/chart/chord/ChordView.js
var RADIAN$2 = Math.PI / 180;
var ChordView = function(_super) {
	__extends(ChordView$1, _super);
	function ChordView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ChordView$1.type;
		return _this;
	}
	ChordView$1.prototype.init = function(ecModel, api) {};
	ChordView$1.prototype.render = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		var oldData = this._data;
		var group = this.group;
		var startAngle = -seriesModel.get("startAngle") * RADIAN$2;
		data.diff(oldData).add(function(newIdx) {
			if (data.getItemLayout(newIdx)) {
				var el = new ChordPiece_default(data, newIdx, startAngle);
				getECData(el).dataIndex = newIdx;
				group.add(el);
			}
		}).update(function(newIdx, oldIdx) {
			var el = oldData.getItemGraphicEl(oldIdx);
			if (!data.getItemLayout(newIdx)) {
				el && removeElementWithFadeOut(el, seriesModel, oldIdx);
				return;
			}
			if (!el) el = new ChordPiece_default(data, newIdx, startAngle);
			else el.updateData(data, newIdx, startAngle);
			group.add(el);
		}).remove(function(oldIdx) {
			var el = oldData.getItemGraphicEl(oldIdx);
			el && removeElementWithFadeOut(el, seriesModel, oldIdx);
		}).execute();
		if (!oldData) {
			var center$2 = seriesModel.get("center");
			this.group.scaleX = .01;
			this.group.scaleY = .01;
			this.group.originX = parsePercent$1(center$2[0], api.getWidth());
			this.group.originY = parsePercent$1(center$2[1], api.getHeight());
			initProps(this.group, {
				scaleX: 1,
				scaleY: 1
			}, seriesModel);
		}
		this._data = data;
		this.renderEdges(seriesModel, startAngle);
	};
	ChordView$1.prototype.renderEdges = function(seriesModel, startAngle) {
		var nodeData = seriesModel.getData();
		var edgeData = seriesModel.getEdgeData();
		var oldData = this._edgeData;
		var group = this.group;
		edgeData.diff(oldData).add(function(newIdx) {
			var el = new ChordEdge(nodeData, edgeData, newIdx, startAngle);
			getECData(el).dataIndex = newIdx;
			group.add(el);
		}).update(function(newIdx, oldIdx) {
			var el = oldData.getItemGraphicEl(oldIdx);
			el.updateData(nodeData, edgeData, newIdx, startAngle);
			group.add(el);
		}).remove(function(oldIdx) {
			var el = oldData.getItemGraphicEl(oldIdx);
			el && removeElementWithFadeOut(el, seriesModel, oldIdx);
		}).execute();
		this._edgeData = edgeData;
	};
	ChordView$1.prototype.dispose = function() {};
	ChordView$1.type = "chord";
	return ChordView$1;
}(Chart_default);
var ChordView_default = ChordView;

//#endregion
//#region node_modules/echarts/lib/chart/chord/ChordSeries.js
var ChordSeriesModel = function(_super) {
	__extends(ChordSeriesModel$1, _super);
	function ChordSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ChordSeriesModel$1.type;
		return _this;
	}
	ChordSeriesModel$1.prototype.init = function(option) {
		_super.prototype.init.apply(this, arguments);
		this.fillDataTextStyle(option.edges || option.links);
		this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
	};
	ChordSeriesModel$1.prototype.mergeOption = function(option) {
		_super.prototype.mergeOption.apply(this, arguments);
		this.fillDataTextStyle(option.edges || option.links);
	};
	ChordSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		var edges = option.edges || option.links || [];
		var nodes = option.data || option.nodes || [];
		if (nodes && edges) return createGraphFromNodeEdge(nodes, edges, this, true, beforeLink).data;
		function beforeLink(nodeData, edgeData) {
			var oldGetModel = Model_default.prototype.getModel;
			function newGetModel(path, parentModel) {
				var model = oldGetModel.call(this, path, parentModel);
				model.resolveParentPath = resolveParentPath;
				return model;
			}
			edgeData.wrapMethod("getItemModel", function(model) {
				model.resolveParentPath = resolveParentPath;
				model.getModel = newGetModel;
				return model;
			});
			function resolveParentPath(pathArr) {
				if (pathArr && (pathArr[0] === "label" || pathArr[1] === "label")) {
					var newPathArr = pathArr.slice();
					if (pathArr[0] === "label") newPathArr[0] = "edgeLabel";
					else if (pathArr[1] === "label") newPathArr[1] = "edgeLabel";
					return newPathArr;
				}
				return pathArr;
			}
		}
	};
	ChordSeriesModel$1.prototype.getGraph = function() {
		return this.getData().graph;
	};
	ChordSeriesModel$1.prototype.getEdgeData = function() {
		return this.getGraph().edgeData;
	};
	ChordSeriesModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		var params = this.getDataParams(dataIndex, dataType);
		if (dataType === "edge") {
			var nodeData = this.getData();
			var edge = nodeData.graph.getEdgeByIndex(dataIndex);
			var sourceName = nodeData.getName(edge.node1.dataIndex);
			var targetName = nodeData.getName(edge.node2.dataIndex);
			var nameArr = [];
			sourceName != null && nameArr.push(sourceName);
			targetName != null && nameArr.push(targetName);
			return createTooltipMarkup("nameValue", {
				name: nameArr.join(" > "),
				value: params.value,
				noValue: params.value == null
			});
		}
		return createTooltipMarkup("nameValue", {
			name: params.name,
			value: params.value,
			noValue: params.value == null
		});
	};
	ChordSeriesModel$1.prototype.getDataParams = function(dataIndex, dataType) {
		var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);
		if (dataType === "node") {
			var nodeData = this.getData();
			var node = this.getGraph().getNodeByIndex(dataIndex);
			if (params.name == null) params.name = nodeData.getName(dataIndex);
			if (params.value == null) params.value = node.getLayout().value;
		}
		return params;
	};
	ChordSeriesModel$1.type = "series.chord";
	ChordSeriesModel$1.defaultOption = {
		z: 2,
		coordinateSystem: "none",
		legendHoverLink: true,
		colorBy: "data",
		left: 0,
		top: 0,
		right: 0,
		bottom: 0,
		width: null,
		height: null,
		center: ["50%", "50%"],
		radius: ["70%", "80%"],
		clockwise: true,
		startAngle: 90,
		endAngle: "auto",
		minAngle: 0,
		padAngle: 3,
		itemStyle: { borderRadius: [
			0,
			0,
			5,
			5
		] },
		lineStyle: {
			width: 0,
			color: "source",
			opacity: .2
		},
		label: {
			show: true,
			position: "outside",
			distance: 5
		},
		emphasis: {
			focus: "adjacency",
			lineStyle: { opacity: .5 }
		}
	};
	return ChordSeriesModel$1;
}(Series_default);
var ChordSeries_default = ChordSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/chord/chordLayout.js
var RADIAN$1 = Math.PI / 180;
function chordCircularLayout(ecModel, api) {
	ecModel.eachSeriesByType("chord", function(seriesModel) {
		chordLayout(seriesModel, api);
	});
}
function chordLayout(seriesModel, api) {
	var nodeData = seriesModel.getData();
	var nodeGraph = nodeData.graph;
	var edgeData = seriesModel.getEdgeData();
	if (!edgeData.count()) return;
	var _a$1 = getCircleLayout(seriesModel, api), cx = _a$1.cx, cy = _a$1.cy, r = _a$1.r, r0 = _a$1.r0;
	var padAngle = Math.max((seriesModel.get("padAngle") || 0) * RADIAN$1, 0);
	var minAngle = Math.max((seriesModel.get("minAngle") || 0) * RADIAN$1, 0);
	var startAngle = -seriesModel.get("startAngle") * RADIAN$1;
	var endAngle = startAngle + Math.PI * 2;
	var clockwise = seriesModel.get("clockwise");
	var dir$1 = clockwise ? 1 : -1;
	var angles = [startAngle, endAngle];
	normalizeArcAngles(angles, !clockwise);
	var normalizedStartAngle = angles[0];
	var totalAngle = angles[1] - normalizedStartAngle;
	var allZero = nodeData.getSum("value") === 0 && edgeData.getSum("value") === 0;
	var nodeValues = [];
	var renderedNodeCount = 0;
	nodeGraph.eachEdge(function(edge) {
		var value = allZero ? 1 : edge.getValue("value");
		if (allZero && (value > 0 || minAngle)) renderedNodeCount += 2;
		var node1Index = edge.node1.dataIndex;
		var node2Index = edge.node2.dataIndex;
		nodeValues[node1Index] = (nodeValues[node1Index] || 0) + value;
		nodeValues[node2Index] = (nodeValues[node2Index] || 0) + value;
	});
	var nodeValueSum = 0;
	nodeGraph.eachNode(function(node) {
		var dataValue = node.getValue("value");
		if (!isNaN(dataValue)) nodeValues[node.dataIndex] = Math.max(dataValue, nodeValues[node.dataIndex] || 0);
		if (!allZero && (nodeValues[node.dataIndex] > 0 || minAngle)) renderedNodeCount++;
		nodeValueSum += nodeValues[node.dataIndex] || 0;
	});
	if (renderedNodeCount === 0 || nodeValueSum === 0) return;
	if (padAngle * renderedNodeCount >= Math.abs(totalAngle)) padAngle = Math.max(0, (Math.abs(totalAngle) - minAngle * renderedNodeCount) / renderedNodeCount);
	if ((padAngle + minAngle) * renderedNodeCount >= Math.abs(totalAngle)) minAngle = (Math.abs(totalAngle) - padAngle * renderedNodeCount) / renderedNodeCount;
	var unitAngle = (totalAngle - padAngle * renderedNodeCount * dir$1) / nodeValueSum;
	var totalDeficit = 0;
	var totalSurplus = 0;
	var totalSurplusSpan = 0;
	var minSurplus = Infinity;
	nodeGraph.eachNode(function(node) {
		var value = nodeValues[node.dataIndex] || 0;
		var spanAngle = unitAngle * (nodeValueSum ? value : 1) * dir$1;
		if (Math.abs(spanAngle) < minAngle) totalDeficit += minAngle - Math.abs(spanAngle);
		else {
			minSurplus = Math.min(minSurplus, Math.abs(spanAngle) - minAngle);
			totalSurplus += Math.abs(spanAngle) - minAngle;
			totalSurplusSpan += Math.abs(spanAngle);
		}
		node.setLayout({
			angle: spanAngle,
			value
		});
	});
	var surplusAsMuchAsPossible = false;
	if (totalDeficit > totalSurplus) {
		var scale_1 = totalDeficit / totalSurplus;
		nodeGraph.eachNode(function(node) {
			var spanAngle = node.getLayout().angle;
			if (Math.abs(spanAngle) >= minAngle) node.setLayout({
				angle: spanAngle * scale_1,
				ratio: scale_1
			}, true);
			else node.setLayout({
				angle: minAngle,
				ratio: minAngle === 0 ? 1 : spanAngle / minAngle
			}, true);
		});
	} else nodeGraph.eachNode(function(node) {
		if (surplusAsMuchAsPossible) return;
		var spanAngle = node.getLayout().angle;
		if (spanAngle - Math.min(spanAngle / totalSurplusSpan, 1) * totalDeficit < minAngle) surplusAsMuchAsPossible = true;
	});
	var restDeficit = totalDeficit;
	nodeGraph.eachNode(function(node) {
		if (restDeficit <= 0) return;
		var spanAngle = node.getLayout().angle;
		if (spanAngle > minAngle && minAngle > 0) {
			var borrowRatio = surplusAsMuchAsPossible ? 1 : Math.min(spanAngle / totalSurplusSpan, 1);
			var maxBorrowAngle = spanAngle - minAngle;
			var borrowAngle = Math.min(maxBorrowAngle, Math.min(restDeficit, totalDeficit * borrowRatio));
			restDeficit -= borrowAngle;
			node.setLayout({
				angle: spanAngle - borrowAngle,
				ratio: (spanAngle - borrowAngle) / spanAngle
			}, true);
		} else if (minAngle > 0) node.setLayout({
			angle: minAngle,
			ratio: spanAngle === 0 ? 1 : minAngle / spanAngle
		}, true);
	});
	var angle = normalizedStartAngle;
	var edgeAccAngle = [];
	nodeGraph.eachNode(function(node) {
		var spanAngle = Math.max(node.getLayout().angle, minAngle);
		node.setLayout({
			cx,
			cy,
			r0,
			r,
			startAngle: angle,
			endAngle: angle + spanAngle * dir$1,
			clockwise
		}, true);
		edgeAccAngle[node.dataIndex] = angle;
		angle += (spanAngle + padAngle) * dir$1;
	});
	nodeGraph.eachEdge(function(edge) {
		var value = allZero ? 1 : edge.getValue("value");
		var spanAngle = unitAngle * (nodeValueSum ? value : 1) * dir$1;
		var node1Index = edge.node1.dataIndex;
		var sStartAngle = edgeAccAngle[node1Index] || 0;
		var sEndAngle = sStartAngle + Math.abs((edge.node1.getLayout().ratio || 1) * spanAngle) * dir$1;
		var s1 = [cx + r0 * Math.cos(sStartAngle), cy + r0 * Math.sin(sStartAngle)];
		var s2 = [cx + r0 * Math.cos(sEndAngle), cy + r0 * Math.sin(sEndAngle)];
		var node2Index = edge.node2.dataIndex;
		var tStartAngle = edgeAccAngle[node2Index] || 0;
		var tEndAngle = tStartAngle + Math.abs((edge.node2.getLayout().ratio || 1) * spanAngle) * dir$1;
		var t1 = [cx + r0 * Math.cos(tStartAngle), cy + r0 * Math.sin(tStartAngle)];
		var t2 = [cx + r0 * Math.cos(tEndAngle), cy + r0 * Math.sin(tEndAngle)];
		edge.setLayout({
			s1,
			s2,
			sStartAngle,
			sEndAngle,
			t1,
			t2,
			tStartAngle,
			tEndAngle,
			cx,
			cy,
			r: r0,
			value,
			clockwise
		});
		edgeAccAngle[node1Index] = sEndAngle;
		edgeAccAngle[node2Index] = tEndAngle;
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/chord/install.js
function install$11(registers) {
	registers.registerChartView(ChordView_default);
	registers.registerSeriesModel(ChordSeries_default);
	registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, chordCircularLayout);
	registers.registerProcessor(dataFilter$1("chord"));
}

//#endregion
//#region node_modules/echarts/lib/chart/gauge/PointerPath.js
var PointerShape = function() {
	function PointerShape$1() {
		this.angle = 0;
		this.width = 10;
		this.r = 10;
		this.x = 0;
		this.y = 0;
	}
	return PointerShape$1;
}();
var PointerPath = function(_super) {
	__extends(PointerPath$1, _super);
	function PointerPath$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this.type = "pointer";
		return _this;
	}
	PointerPath$1.prototype.getDefaultShape = function() {
		return new PointerShape();
	};
	PointerPath$1.prototype.buildPath = function(ctx, shape) {
		var mathCos$5 = Math.cos;
		var mathSin$5 = Math.sin;
		var r = shape.r;
		var width = shape.width;
		var angle = shape.angle;
		var x = shape.x - mathCos$5(angle) * width * (width >= r / 3 ? 1 : 2);
		var y = shape.y - mathSin$5(angle) * width * (width >= r / 3 ? 1 : 2);
		angle = shape.angle - Math.PI / 2;
		ctx.moveTo(x, y);
		ctx.lineTo(shape.x + mathCos$5(angle) * width, shape.y + mathSin$5(angle) * width);
		ctx.lineTo(shape.x + mathCos$5(shape.angle) * r, shape.y + mathSin$5(shape.angle) * r);
		ctx.lineTo(shape.x - mathCos$5(angle) * width, shape.y - mathSin$5(angle) * width);
		ctx.lineTo(x, y);
	};
	return PointerPath$1;
}(Path_default);
var PointerPath_default = PointerPath;

//#endregion
//#region node_modules/echarts/lib/chart/gauge/GaugeView.js
function parsePosition(seriesModel, api) {
	var center$2 = seriesModel.get("center");
	var width = api.getWidth();
	var height = api.getHeight();
	var size = Math.min(width, height);
	return {
		cx: parsePercent$1(center$2[0], api.getWidth()),
		cy: parsePercent$1(center$2[1], api.getHeight()),
		r: parsePercent$1(seriesModel.get("radius"), size / 2)
	};
}
function formatLabel(value, labelFormatter) {
	var label = value == null ? "" : value + "";
	if (labelFormatter) {
		if (isString(labelFormatter)) label = labelFormatter.replace("{value}", label);
		else if (isFunction(labelFormatter)) label = labelFormatter(value);
	}
	return label;
}
var GaugeView = function(_super) {
	__extends(GaugeView$1, _super);
	function GaugeView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = GaugeView$1.type;
		return _this;
	}
	GaugeView$1.prototype.render = function(seriesModel, ecModel, api) {
		this.group.removeAll();
		var colorList = seriesModel.get([
			"axisLine",
			"lineStyle",
			"color"
		]);
		var posInfo = parsePosition(seriesModel, api);
		this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
		this._data = seriesModel.getData();
	};
	GaugeView$1.prototype.dispose = function() {};
	GaugeView$1.prototype._renderMain = function(seriesModel, ecModel, api, colorList, posInfo) {
		var group = this.group;
		var clockwise = seriesModel.get("clockwise");
		var startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
		var endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
		var axisLineModel = seriesModel.getModel("axisLine");
		var MainPath = axisLineModel.get("roundCap") ? sausage_default : Sector_default;
		var showAxis = axisLineModel.get("show");
		var lineStyleModel = axisLineModel.getModel("lineStyle");
		var axisLineWidth = lineStyleModel.get("width");
		var angles = [startAngle, endAngle];
		normalizeArcAngles(angles, !clockwise);
		startAngle = angles[0];
		endAngle = angles[1];
		var angleRangeSpan = endAngle - startAngle;
		var prevEndAngle = startAngle;
		var sectors = [];
		for (var i$1 = 0; showAxis && i$1 < colorList.length; i$1++) {
			var percent = Math.min(Math.max(colorList[i$1][0], 0), 1);
			endAngle = startAngle + angleRangeSpan * percent;
			var sector = new MainPath({
				shape: {
					startAngle: prevEndAngle,
					endAngle,
					cx: posInfo.cx,
					cy: posInfo.cy,
					clockwise,
					r0: posInfo.r - axisLineWidth,
					r: posInfo.r
				},
				silent: true
			});
			sector.setStyle({ fill: colorList[i$1][1] });
			sector.setStyle(lineStyleModel.getLineStyle(["color", "width"]));
			sectors.push(sector);
			prevEndAngle = endAngle;
		}
		sectors.reverse();
		each(sectors, function(sector$1) {
			return group.add(sector$1);
		});
		var getColor$1 = function(percent$1) {
			if (percent$1 <= 0) return colorList[0][1];
			var i$2;
			for (i$2 = 0; i$2 < colorList.length; i$2++) if (colorList[i$2][0] >= percent$1 && (i$2 === 0 ? 0 : colorList[i$2 - 1][0]) < percent$1) return colorList[i$2][1];
			return colorList[i$2 - 1][1];
		};
		this._renderTicks(seriesModel, ecModel, api, getColor$1, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
		this._renderTitleAndDetail(seriesModel, ecModel, api, getColor$1, posInfo);
		this._renderAnchor(seriesModel, posInfo);
		this._renderPointer(seriesModel, ecModel, api, getColor$1, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
	};
	GaugeView$1.prototype._renderTicks = function(seriesModel, ecModel, api, getColor$1, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
		var group = this.group;
		var cx = posInfo.cx;
		var cy = posInfo.cy;
		var r = posInfo.r;
		var minVal = +seriesModel.get("min");
		var maxVal = +seriesModel.get("max");
		var splitLineModel = seriesModel.getModel("splitLine");
		var tickModel = seriesModel.getModel("axisTick");
		var labelModel = seriesModel.getModel("axisLabel");
		var splitNumber = seriesModel.get("splitNumber");
		var subSplitNumber = tickModel.get("splitNumber");
		var splitLineLen = parsePercent$1(splitLineModel.get("length"), r);
		var tickLen = parsePercent$1(tickModel.get("length"), r);
		var angle = startAngle;
		var step = (endAngle - startAngle) / splitNumber;
		var subStep = step / subSplitNumber;
		var splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
		var tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
		var splitLineDistance = splitLineModel.get("distance");
		var unitX;
		var unitY;
		for (var i$1 = 0; i$1 <= splitNumber; i$1++) {
			unitX = Math.cos(angle);
			unitY = Math.sin(angle);
			if (splitLineModel.get("show")) {
				var distance$1 = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;
				var splitLine = new Line_default({
					shape: {
						x1: unitX * (r - distance$1) + cx,
						y1: unitY * (r - distance$1) + cy,
						x2: unitX * (r - splitLineLen - distance$1) + cx,
						y2: unitY * (r - splitLineLen - distance$1) + cy
					},
					style: splitLineStyle,
					silent: true
				});
				if (splitLineStyle.stroke === "auto") splitLine.setStyle({ stroke: getColor$1(i$1 / splitNumber) });
				group.add(splitLine);
			}
			if (labelModel.get("show")) {
				var distance$1 = labelModel.get("distance") + splitLineDistance;
				var label = formatLabel(round(i$1 / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
				var autoColor = getColor$1(i$1 / splitNumber);
				var textStyleX = unitX * (r - splitLineLen - distance$1) + cx;
				var textStyleY = unitY * (r - splitLineLen - distance$1) + cy;
				var rotateType = labelModel.get("rotate");
				var rotate$1 = 0;
				if (rotateType === "radial") {
					rotate$1 = -angle + 2 * Math.PI;
					if (rotate$1 > Math.PI / 2) rotate$1 += Math.PI;
				} else if (rotateType === "tangential") rotate$1 = -angle - Math.PI / 2;
				else if (isNumber(rotateType)) rotate$1 = rotateType * Math.PI / 180;
				if (rotate$1 === 0) group.add(new Text_default({
					style: createTextStyle(labelModel, {
						text: label,
						x: textStyleX,
						y: textStyleY,
						verticalAlign: unitY < -.8 ? "top" : unitY > .8 ? "bottom" : "middle",
						align: unitX < -.4 ? "left" : unitX > .4 ? "right" : "center"
					}, { inheritColor: autoColor }),
					silent: true
				}));
				else group.add(new Text_default({
					style: createTextStyle(labelModel, {
						text: label,
						x: textStyleX,
						y: textStyleY,
						verticalAlign: "middle",
						align: "center"
					}, { inheritColor: autoColor }),
					silent: true,
					originX: textStyleX,
					originY: textStyleY,
					rotation: rotate$1
				}));
			}
			if (tickModel.get("show") && i$1 !== splitNumber) {
				var distance$1 = tickModel.get("distance");
				distance$1 = distance$1 ? distance$1 + axisLineWidth : axisLineWidth;
				for (var j = 0; j <= subSplitNumber; j++) {
					unitX = Math.cos(angle);
					unitY = Math.sin(angle);
					var tickLine = new Line_default({
						shape: {
							x1: unitX * (r - distance$1) + cx,
							y1: unitY * (r - distance$1) + cy,
							x2: unitX * (r - tickLen - distance$1) + cx,
							y2: unitY * (r - tickLen - distance$1) + cy
						},
						silent: true,
						style: tickLineStyle
					});
					if (tickLineStyle.stroke === "auto") tickLine.setStyle({ stroke: getColor$1((i$1 + j / subSplitNumber) / splitNumber) });
					group.add(tickLine);
					angle += subStep;
				}
				angle -= subStep;
			} else angle += step;
		}
	};
	GaugeView$1.prototype._renderPointer = function(seriesModel, ecModel, api, getColor$1, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
		var group = this.group;
		var oldData = this._data;
		var oldProgressData = this._progressEls;
		var progressList = [];
		var showPointer$1 = seriesModel.get(["pointer", "show"]);
		var progressModel = seriesModel.getModel("progress");
		var showProgress = progressModel.get("show");
		var data = seriesModel.getData();
		var valueDim = data.mapDimension("value");
		var minVal = +seriesModel.get("min");
		var maxVal = +seriesModel.get("max");
		var valueExtent = [minVal, maxVal];
		var angleExtent = [startAngle, endAngle];
		function createPointer(idx, angle) {
			var pointerModel = data.getItemModel(idx).getModel("pointer");
			var pointerWidth = parsePercent$1(pointerModel.get("width"), posInfo.r);
			var pointerLength = parsePercent$1(pointerModel.get("length"), posInfo.r);
			var pointerStr = seriesModel.get(["pointer", "icon"]);
			var pointerOffset = pointerModel.get("offsetCenter");
			var pointerOffsetX = parsePercent$1(pointerOffset[0], posInfo.r);
			var pointerOffsetY = parsePercent$1(pointerOffset[1], posInfo.r);
			var pointerKeepAspect = pointerModel.get("keepAspect");
			var pointer;
			if (pointerStr) pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);
			else pointer = new PointerPath_default({ shape: {
				angle: -Math.PI / 2,
				width: pointerWidth,
				r: pointerLength,
				x: pointerOffsetX,
				y: pointerOffsetY
			} });
			pointer.rotation = -(angle + Math.PI / 2);
			pointer.x = posInfo.cx;
			pointer.y = posInfo.cy;
			return pointer;
		}
		function createProgress(idx, endAngle$1) {
			var ProgressPath = progressModel.get("roundCap") ? sausage_default : Sector_default;
			var isOverlap = progressModel.get("overlap");
			var progressWidth = isOverlap ? progressModel.get("width") : axisLineWidth / data.count();
			var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;
			var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;
			var progress = new ProgressPath({ shape: {
				startAngle,
				endAngle: endAngle$1,
				cx: posInfo.cx,
				cy: posInfo.cy,
				clockwise,
				r0,
				r
			} });
			isOverlap && (progress.z2 = linearMap$2(data.get(valueDim, idx), [minVal, maxVal], [100, 0], true));
			return progress;
		}
		if (showProgress || showPointer$1) {
			data.diff(oldData).add(function(idx) {
				var val = data.get(valueDim, idx);
				if (showPointer$1) {
					var pointer = createPointer(idx, startAngle);
					initProps(pointer, { rotation: -((isNaN(+val) ? angleExtent[0] : linearMap$2(val, valueExtent, angleExtent, true)) + Math.PI / 2) }, seriesModel);
					group.add(pointer);
					data.setItemGraphicEl(idx, pointer);
				}
				if (showProgress) {
					var progress = createProgress(idx, startAngle);
					var isClip = progressModel.get("clip");
					initProps(progress, { shape: { endAngle: linearMap$2(val, valueExtent, angleExtent, isClip) } }, seriesModel);
					group.add(progress);
					setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);
					progressList[idx] = progress;
				}
			}).update(function(newIdx, oldIdx) {
				var val = data.get(valueDim, newIdx);
				if (showPointer$1) {
					var previousPointer = oldData.getItemGraphicEl(oldIdx);
					var previousRotate = previousPointer ? previousPointer.rotation : startAngle;
					var pointer = createPointer(newIdx, previousRotate);
					pointer.rotation = previousRotate;
					updateProps(pointer, { rotation: -((isNaN(+val) ? angleExtent[0] : linearMap$2(val, valueExtent, angleExtent, true)) + Math.PI / 2) }, seriesModel);
					group.add(pointer);
					data.setItemGraphicEl(newIdx, pointer);
				}
				if (showProgress) {
					var previousProgress = oldProgressData[oldIdx];
					var progress = createProgress(newIdx, previousProgress ? previousProgress.shape.endAngle : startAngle);
					var isClip = progressModel.get("clip");
					updateProps(progress, { shape: { endAngle: linearMap$2(val, valueExtent, angleExtent, isClip) } }, seriesModel);
					group.add(progress);
					setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);
					progressList[newIdx] = progress;
				}
			}).execute();
			data.each(function(idx) {
				var itemModel = data.getItemModel(idx);
				var emphasisModel = itemModel.getModel("emphasis");
				var focus = emphasisModel.get("focus");
				var blurScope = emphasisModel.get("blurScope");
				var emphasisDisabled = emphasisModel.get("disabled");
				if (showPointer$1) {
					var pointer = data.getItemGraphicEl(idx);
					var symbolStyle = data.getItemVisual(idx, "style");
					var visualColor = symbolStyle.fill;
					if (pointer instanceof Image_default) {
						var pathStyle = pointer.style;
						pointer.useStyle(extend({
							image: pathStyle.image,
							x: pathStyle.x,
							y: pathStyle.y,
							width: pathStyle.width,
							height: pathStyle.height
						}, symbolStyle));
					} else {
						pointer.useStyle(symbolStyle);
						pointer.type !== "pointer" && pointer.setColor(visualColor);
					}
					pointer.setStyle(itemModel.getModel(["pointer", "itemStyle"]).getItemStyle());
					if (pointer.style.fill === "auto") pointer.setStyle("fill", getColor$1(linearMap$2(data.get(valueDim, idx), valueExtent, [0, 1], true)));
					pointer.z2EmphasisLift = 0;
					setStatesStylesFromModel(pointer, itemModel);
					toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);
				}
				if (showProgress) {
					var progress = progressList[idx];
					progress.useStyle(data.getItemVisual(idx, "style"));
					progress.setStyle(itemModel.getModel(["progress", "itemStyle"]).getItemStyle());
					progress.z2EmphasisLift = 0;
					setStatesStylesFromModel(progress, itemModel);
					toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);
				}
			});
			this._progressEls = progressList;
		}
	};
	GaugeView$1.prototype._renderAnchor = function(seriesModel, posInfo) {
		var anchorModel = seriesModel.getModel("anchor");
		if (anchorModel.get("show")) {
			var anchorSize = anchorModel.get("size");
			var anchorType = anchorModel.get("icon");
			var offsetCenter = anchorModel.get("offsetCenter");
			var anchorKeepAspect = anchorModel.get("keepAspect");
			var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent$1(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent$1(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);
			anchor.z2 = anchorModel.get("showAbove") ? 1 : 0;
			anchor.setStyle(anchorModel.getModel("itemStyle").getItemStyle());
			this.group.add(anchor);
		}
	};
	GaugeView$1.prototype._renderTitleAndDetail = function(seriesModel, ecModel, api, getColor$1, posInfo) {
		var _this = this;
		var data = seriesModel.getData();
		var valueDim = data.mapDimension("value");
		var minVal = +seriesModel.get("min");
		var maxVal = +seriesModel.get("max");
		var contentGroup = new Group_default();
		var newTitleEls = [];
		var newDetailEls = [];
		var hasAnimation = seriesModel.isAnimationEnabled();
		var showPointerAbove = seriesModel.get(["pointer", "showAbove"]);
		data.diff(this._data).add(function(idx) {
			newTitleEls[idx] = new Text_default({ silent: true });
			newDetailEls[idx] = new Text_default({ silent: true });
		}).update(function(idx, oldIdx) {
			newTitleEls[idx] = _this._titleEls[oldIdx];
			newDetailEls[idx] = _this._detailEls[oldIdx];
		}).execute();
		data.each(function(idx) {
			var itemModel = data.getItemModel(idx);
			var value = data.get(valueDim, idx);
			var itemGroup = new Group_default();
			var autoColor = getColor$1(linearMap$2(value, [minVal, maxVal], [0, 1], true));
			var itemTitleModel = itemModel.getModel("title");
			if (itemTitleModel.get("show")) {
				var titleOffsetCenter = itemTitleModel.get("offsetCenter");
				var titleX = posInfo.cx + parsePercent$1(titleOffsetCenter[0], posInfo.r);
				var titleY = posInfo.cy + parsePercent$1(titleOffsetCenter[1], posInfo.r);
				var labelEl = newTitleEls[idx];
				labelEl.attr({
					z2: showPointerAbove ? 0 : 2,
					style: createTextStyle(itemTitleModel, {
						x: titleX,
						y: titleY,
						text: data.getName(idx),
						align: "center",
						verticalAlign: "middle"
					}, { inheritColor: autoColor })
				});
				itemGroup.add(labelEl);
			}
			var itemDetailModel = itemModel.getModel("detail");
			if (itemDetailModel.get("show")) {
				var detailOffsetCenter = itemDetailModel.get("offsetCenter");
				var detailX = posInfo.cx + parsePercent$1(detailOffsetCenter[0], posInfo.r);
				var detailY = posInfo.cy + parsePercent$1(detailOffsetCenter[1], posInfo.r);
				var width = parsePercent$1(itemDetailModel.get("width"), posInfo.r);
				var height = parsePercent$1(itemDetailModel.get("height"), posInfo.r);
				var detailColor = seriesModel.get(["progress", "show"]) ? data.getItemVisual(idx, "style").fill : autoColor;
				var labelEl = newDetailEls[idx];
				var formatter_1 = itemDetailModel.get("formatter");
				labelEl.attr({
					z2: showPointerAbove ? 0 : 2,
					style: createTextStyle(itemDetailModel, {
						x: detailX,
						y: detailY,
						text: formatLabel(value, formatter_1),
						width: isNaN(width) ? null : width,
						height: isNaN(height) ? null : height,
						align: "center",
						verticalAlign: "middle"
					}, { inheritColor: detailColor })
				});
				setLabelValueAnimation(labelEl, { normal: itemDetailModel }, value, function(value$1) {
					return formatLabel(value$1, formatter_1);
				});
				hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, { getFormattedLabel: function(labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {
					return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);
				} });
				itemGroup.add(labelEl);
			}
			contentGroup.add(itemGroup);
		});
		this.group.add(contentGroup);
		this._titleEls = newTitleEls;
		this._detailEls = newDetailEls;
	};
	GaugeView$1.type = "gauge";
	return GaugeView$1;
}(Chart_default);
var GaugeView_default = GaugeView;

//#endregion
//#region node_modules/echarts/lib/chart/gauge/GaugeSeries.js
var GaugeSeriesModel = function(_super) {
	__extends(GaugeSeriesModel$1, _super);
	function GaugeSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = GaugeSeriesModel$1.type;
		_this.visualStyleAccessPath = "itemStyle";
		return _this;
	}
	GaugeSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		return createSeriesDataSimply(this, ["value"]);
	};
	GaugeSeriesModel$1.type = "series.gauge";
	GaugeSeriesModel$1.defaultOption = {
		z: 2,
		colorBy: "data",
		center: ["50%", "50%"],
		legendHoverLink: true,
		radius: "75%",
		startAngle: 225,
		endAngle: -45,
		clockwise: true,
		min: 0,
		max: 100,
		splitNumber: 10,
		axisLine: {
			show: true,
			roundCap: false,
			lineStyle: {
				color: [[1, tokens_default.color.neutral10]],
				width: 10
			}
		},
		progress: {
			show: false,
			overlap: true,
			width: 10,
			roundCap: false,
			clip: true
		},
		splitLine: {
			show: true,
			length: 10,
			distance: 10,
			lineStyle: {
				color: tokens_default.color.axisTick,
				width: 3,
				type: "solid"
			}
		},
		axisTick: {
			show: true,
			splitNumber: 5,
			length: 6,
			distance: 10,
			lineStyle: {
				color: tokens_default.color.axisTickMinor,
				width: 1,
				type: "solid"
			}
		},
		axisLabel: {
			show: true,
			distance: 15,
			color: tokens_default.color.axisLabel,
			fontSize: 12,
			rotate: 0
		},
		pointer: {
			icon: null,
			offsetCenter: [0, 0],
			show: true,
			showAbove: true,
			length: "60%",
			width: 6,
			keepAspect: false
		},
		anchor: {
			show: false,
			showAbove: false,
			size: 6,
			icon: "circle",
			offsetCenter: [0, 0],
			keepAspect: false,
			itemStyle: {
				color: tokens_default.color.neutral00,
				borderWidth: 0,
				borderColor: tokens_default.color.theme[0]
			}
		},
		title: {
			show: true,
			offsetCenter: [0, "20%"],
			color: tokens_default.color.secondary,
			fontSize: 16,
			valueAnimation: false
		},
		detail: {
			show: true,
			backgroundColor: tokens_default.color.transparent,
			borderWidth: 0,
			borderColor: tokens_default.color.neutral40,
			width: 100,
			height: null,
			padding: [5, 10],
			offsetCenter: [0, "40%"],
			color: tokens_default.color.primary,
			fontSize: 30,
			fontWeight: "bold",
			lineHeight: 30,
			valueAnimation: false
		}
	};
	return GaugeSeriesModel$1;
}(Series_default);
var GaugeSeries_default = GaugeSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/gauge/install.js
function install$12(registers) {
	registers.registerChartView(GaugeView_default);
	registers.registerSeriesModel(GaugeSeries_default);
}

//#endregion
//#region node_modules/echarts/lib/chart/funnel/FunnelView.js
var opacityAccessPath$1 = ["itemStyle", "opacity"];
/**
* Piece of pie including Sector, Label, LabelLine
*/
var FunnelPiece = function(_super) {
	__extends(FunnelPiece$1, _super);
	function FunnelPiece$1(data, idx) {
		var _this = _super.call(this) || this;
		var polygon = _this;
		var labelLine = new Polyline_default();
		var text = new Text_default();
		polygon.setTextContent(text);
		_this.setTextGuideLine(labelLine);
		_this.updateData(data, idx, true);
		return _this;
	}
	FunnelPiece$1.prototype.updateData = function(data, idx, firstCreate) {
		var polygon = this;
		var seriesModel = data.hostModel;
		var itemModel = data.getItemModel(idx);
		var layout$3 = data.getItemLayout(idx);
		var emphasisModel = itemModel.getModel("emphasis");
		var opacity = itemModel.get(opacityAccessPath$1);
		opacity = opacity == null ? 1 : opacity;
		if (!firstCreate) saveOldStyle(polygon);
		polygon.useStyle(data.getItemVisual(idx, "style"));
		polygon.style.lineJoin = "round";
		if (firstCreate) {
			polygon.setShape({ points: layout$3.points });
			polygon.style.opacity = 0;
			initProps(polygon, { style: { opacity } }, seriesModel, idx);
		} else updateProps(polygon, {
			style: { opacity },
			shape: { points: layout$3.points }
		}, seriesModel, idx);
		setStatesStylesFromModel(polygon, itemModel);
		this._updateLabel(data, idx);
		toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
	};
	FunnelPiece$1.prototype._updateLabel = function(data, idx) {
		var polygon = this;
		var labelLine = this.getTextGuideLine();
		var labelText = polygon.getTextContent();
		var seriesModel = data.hostModel;
		var itemModel = data.getItemModel(idx);
		var labelLayout$1 = data.getItemLayout(idx).label;
		var style = data.getItemVisual(idx, "style");
		var visualColor = style.fill;
		setLabelStyle(labelText, getLabelStatesModels(itemModel), {
			labelFetcher: data.hostModel,
			labelDataIndex: idx,
			defaultOpacity: style.opacity,
			defaultText: data.getName(idx)
		}, { normal: {
			align: labelLayout$1.textAlign,
			verticalAlign: labelLayout$1.verticalAlign
		} });
		var overrideColor = itemModel.getModel("label").get("color") === "inherit" ? visualColor : null;
		polygon.setTextConfig({
			local: true,
			inside: !!labelLayout$1.inside,
			insideStroke: overrideColor,
			outsideFill: overrideColor
		});
		var linePoints = labelLayout$1.linePoints;
		labelLine.setShape({ points: linePoints });
		polygon.textGuideLineConfig = { anchor: linePoints ? new Point_default(linePoints[0][0], linePoints[0][1]) : null };
		updateProps(labelText, { style: {
			x: labelLayout$1.x,
			y: labelLayout$1.y
		} }, seriesModel, idx);
		labelText.attr({
			rotation: labelLayout$1.rotation,
			originX: labelLayout$1.x,
			originY: labelLayout$1.y,
			z2: 10
		});
		setLabelLineStyle(polygon, getLabelLineStatesModels(itemModel), { stroke: visualColor });
	};
	return FunnelPiece$1;
}(Polygon_default);
var FunnelView = function(_super) {
	__extends(FunnelView$1, _super);
	function FunnelView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = FunnelView$1.type;
		_this.ignoreLabelLineUpdate = true;
		return _this;
	}
	FunnelView$1.prototype.render = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		var oldData = this._data;
		var group = this.group;
		data.diff(oldData).add(function(idx) {
			var funnelPiece = new FunnelPiece(data, idx);
			data.setItemGraphicEl(idx, funnelPiece);
			group.add(funnelPiece);
		}).update(function(newIdx, oldIdx) {
			var piece = oldData.getItemGraphicEl(oldIdx);
			piece.updateData(data, newIdx);
			group.add(piece);
			data.setItemGraphicEl(newIdx, piece);
		}).remove(function(idx) {
			var piece = oldData.getItemGraphicEl(idx);
			removeElementWithFadeOut(piece, seriesModel, idx);
		}).execute();
		this._data = data;
	};
	FunnelView$1.prototype.remove = function() {
		this.group.removeAll();
		this._data = null;
	};
	FunnelView$1.prototype.dispose = function() {};
	FunnelView$1.type = "funnel";
	return FunnelView$1;
}(Chart_default);
var FunnelView_default = FunnelView;

//#endregion
//#region node_modules/echarts/lib/chart/funnel/FunnelSeries.js
var FunnelSeriesModel = function(_super) {
	__extends(FunnelSeriesModel$1, _super);
	function FunnelSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = FunnelSeriesModel$1.type;
		return _this;
	}
	FunnelSeriesModel$1.prototype.init = function(option) {
		_super.prototype.init.apply(this, arguments);
		this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
		this._defaultLabelLine(option);
	};
	FunnelSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		return createSeriesDataSimply(this, {
			coordDimensions: ["value"],
			encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
		});
	};
	FunnelSeriesModel$1.prototype._defaultLabelLine = function(option) {
		defaultEmphasis(option, "labelLine", ["show"]);
		var labelLineNormalOpt = option.labelLine;
		var labelLineEmphasisOpt = option.emphasis.labelLine;
		labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
		labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
	};
	FunnelSeriesModel$1.prototype.getDataParams = function(dataIndex) {
		var data = this.getData();
		var params = _super.prototype.getDataParams.call(this, dataIndex);
		var valueDim = data.mapDimension("value");
		var sum$1 = data.getSum(valueDim);
		params.percent = !sum$1 ? 0 : +(data.get(valueDim, dataIndex) / sum$1 * 100).toFixed(2);
		params.$vars.push("percent");
		return params;
	};
	FunnelSeriesModel$1.type = "series.funnel";
	FunnelSeriesModel$1.defaultOption = {
		coordinateSystemUsage: "box",
		z: 2,
		legendHoverLink: true,
		colorBy: "data",
		left: 80,
		top: 60,
		right: 80,
		bottom: 65,
		minSize: "0%",
		maxSize: "100%",
		sort: "descending",
		orient: "vertical",
		gap: 0,
		funnelAlign: "center",
		label: {
			show: true,
			position: "outer"
		},
		labelLine: {
			show: true,
			length: 20,
			lineStyle: { width: 1 }
		},
		itemStyle: {
			borderColor: tokens_default.color.neutral00,
			borderWidth: 1
		},
		emphasis: { label: { show: true } },
		select: { itemStyle: { borderColor: tokens_default.color.primary } }
	};
	return FunnelSeriesModel$1;
}(Series_default);
var FunnelSeries_default = FunnelSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/funnel/funnelLayout.js
function getSortedIndices(data, sort$3) {
	var valueDim = data.mapDimension("value");
	var valueArr = data.mapArray(valueDim, function(val) {
		return val;
	});
	var indices = [];
	var isAscending = sort$3 === "ascending";
	for (var i$1 = 0, len$1 = data.count(); i$1 < len$1; i$1++) indices[i$1] = i$1;
	if (isFunction(sort$3)) indices.sort(sort$3);
	else if (sort$3 !== "none") indices.sort(function(a, b) {
		return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
	});
	return indices;
}
function labelLayout(data) {
	var orient = data.hostModel.get("orient");
	data.each(function(idx) {
		var itemModel = data.getItemModel(idx);
		var labelPosition = itemModel.getModel("label").get("position");
		var labelLineModel = itemModel.getModel("labelLine");
		var layout$3 = data.getItemLayout(idx);
		var points$3 = layout$3.points;
		var isLabelInside = labelPosition === "inner" || labelPosition === "inside" || labelPosition === "center" || labelPosition === "insideLeft" || labelPosition === "insideRight";
		var textAlign;
		var textX;
		var textY;
		var linePoints;
		if (isLabelInside) {
			if (labelPosition === "insideLeft") {
				textX = (points$3[0][0] + points$3[3][0]) / 2 + 5;
				textY = (points$3[0][1] + points$3[3][1]) / 2;
				textAlign = "left";
			} else if (labelPosition === "insideRight") {
				textX = (points$3[1][0] + points$3[2][0]) / 2 - 5;
				textY = (points$3[1][1] + points$3[2][1]) / 2;
				textAlign = "right";
			} else {
				textX = (points$3[0][0] + points$3[1][0] + points$3[2][0] + points$3[3][0]) / 4;
				textY = (points$3[0][1] + points$3[1][1] + points$3[2][1] + points$3[3][1]) / 4;
				textAlign = "center";
			}
			linePoints = [[textX, textY], [textX, textY]];
		} else {
			var x1 = void 0;
			var y1 = void 0;
			var x2 = void 0;
			var y2 = void 0;
			var labelLineLen = labelLineModel.get("length");
			if (orient === "vertical" && ["top", "bottom"].indexOf(labelPosition) > -1) {
				labelPosition = "left";
				console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.");
			}
			if (orient === "horizontal" && ["left", "right"].indexOf(labelPosition) > -1) {
				labelPosition = "bottom";
				console.warn("Position error: Funnel chart on horizontal orient dose not support left and right.");
			}
			if (labelPosition === "left") {
				x1 = (points$3[3][0] + points$3[0][0]) / 2;
				y1 = (points$3[3][1] + points$3[0][1]) / 2;
				x2 = x1 - labelLineLen;
				textX = x2 - 5;
				textAlign = "right";
			} else if (labelPosition === "right") {
				x1 = (points$3[1][0] + points$3[2][0]) / 2;
				y1 = (points$3[1][1] + points$3[2][1]) / 2;
				x2 = x1 + labelLineLen;
				textX = x2 + 5;
				textAlign = "left";
			} else if (labelPosition === "top") {
				x1 = (points$3[3][0] + points$3[0][0]) / 2;
				y1 = (points$3[3][1] + points$3[0][1]) / 2;
				y2 = y1 - labelLineLen;
				textY = y2 - 5;
				textAlign = "center";
			} else if (labelPosition === "bottom") {
				x1 = (points$3[1][0] + points$3[2][0]) / 2;
				y1 = (points$3[1][1] + points$3[2][1]) / 2;
				y2 = y1 + labelLineLen;
				textY = y2 + 5;
				textAlign = "center";
			} else if (labelPosition === "rightTop") {
				x1 = orient === "horizontal" ? points$3[3][0] : points$3[1][0];
				y1 = orient === "horizontal" ? points$3[3][1] : points$3[1][1];
				if (orient === "horizontal") {
					y2 = y1 - labelLineLen;
					textY = y2 - 5;
					textAlign = "center";
				} else {
					x2 = x1 + labelLineLen;
					textX = x2 + 5;
					textAlign = "top";
				}
			} else if (labelPosition === "rightBottom") {
				x1 = points$3[2][0];
				y1 = points$3[2][1];
				if (orient === "horizontal") {
					y2 = y1 + labelLineLen;
					textY = y2 + 5;
					textAlign = "center";
				} else {
					x2 = x1 + labelLineLen;
					textX = x2 + 5;
					textAlign = "bottom";
				}
			} else if (labelPosition === "leftTop") {
				x1 = points$3[0][0];
				y1 = orient === "horizontal" ? points$3[0][1] : points$3[1][1];
				if (orient === "horizontal") {
					y2 = y1 - labelLineLen;
					textY = y2 - 5;
					textAlign = "center";
				} else {
					x2 = x1 - labelLineLen;
					textX = x2 - 5;
					textAlign = "right";
				}
			} else if (labelPosition === "leftBottom") {
				x1 = orient === "horizontal" ? points$3[1][0] : points$3[3][0];
				y1 = orient === "horizontal" ? points$3[1][1] : points$3[2][1];
				if (orient === "horizontal") {
					y2 = y1 + labelLineLen;
					textY = y2 + 5;
					textAlign = "center";
				} else {
					x2 = x1 - labelLineLen;
					textX = x2 - 5;
					textAlign = "right";
				}
			} else {
				x1 = (points$3[1][0] + points$3[2][0]) / 2;
				y1 = (points$3[1][1] + points$3[2][1]) / 2;
				if (orient === "horizontal") {
					y2 = y1 + labelLineLen;
					textY = y2 + 5;
					textAlign = "center";
				} else {
					x2 = x1 + labelLineLen;
					textX = x2 + 5;
					textAlign = "left";
				}
			}
			if (orient === "horizontal") {
				x2 = x1;
				textX = x2;
			} else {
				y2 = y1;
				textY = y2;
			}
			linePoints = [[x1, y1], [x2, y2]];
		}
		layout$3.label = {
			linePoints,
			x: textX,
			y: textY,
			verticalAlign: "middle",
			textAlign,
			inside: isLabelInside
		};
	});
}
function funnelLayout(ecModel, api) {
	ecModel.eachSeriesByType("funnel", function(seriesModel) {
		var data = seriesModel.getData();
		var valueDim = data.mapDimension("value");
		var sort$3 = seriesModel.get("sort");
		var layoutRef = createBoxLayoutReference(seriesModel, api);
		var viewRect$1 = getLayoutRect(seriesModel.getBoxLayoutParams(), layoutRef.refContainer);
		var orient = seriesModel.get("orient");
		var viewWidth = viewRect$1.width;
		var viewHeight = viewRect$1.height;
		var indices = getSortedIndices(data, sort$3);
		var x = viewRect$1.x;
		var y = viewRect$1.y;
		var sizeExtent = orient === "horizontal" ? [parsePercent$1(seriesModel.get("minSize"), viewHeight), parsePercent$1(seriesModel.get("maxSize"), viewHeight)] : [parsePercent$1(seriesModel.get("minSize"), viewWidth), parsePercent$1(seriesModel.get("maxSize"), viewWidth)];
		var dataExtent = data.getDataExtent(valueDim);
		var min$2 = seriesModel.get("min");
		var max$2 = seriesModel.get("max");
		if (min$2 == null) min$2 = Math.min(dataExtent[0], 0);
		if (max$2 == null) max$2 = dataExtent[1];
		var funnelAlign = seriesModel.get("funnelAlign");
		var gap = seriesModel.get("gap");
		var itemSize = ((orient === "horizontal" ? viewWidth : viewHeight) - gap * (data.count() - 1)) / data.count();
		var getLinePoints = function(idx$1, offset) {
			if (orient === "horizontal") {
				var itemHeight = linearMap$2(data.get(valueDim, idx$1) || 0, [min$2, max$2], sizeExtent, true);
				var y0 = void 0;
				switch (funnelAlign) {
					case "top":
						y0 = y;
						break;
					case "center":
						y0 = y + (viewHeight - itemHeight) / 2;
						break;
					case "bottom":
						y0 = y + (viewHeight - itemHeight);
						break;
				}
				return [[offset, y0], [offset, y0 + itemHeight]];
			}
			var itemWidth = linearMap$2(data.get(valueDim, idx$1) || 0, [min$2, max$2], sizeExtent, true);
			var x0;
			switch (funnelAlign) {
				case "left":
					x0 = x;
					break;
				case "center":
					x0 = x + (viewWidth - itemWidth) / 2;
					break;
				case "right":
					x0 = x + viewWidth - itemWidth;
					break;
			}
			return [[x0, offset], [x0 + itemWidth, offset]];
		};
		if (sort$3 === "ascending") {
			itemSize = -itemSize;
			gap = -gap;
			if (orient === "horizontal") x += viewWidth;
			else y += viewHeight;
			indices = indices.reverse();
		}
		for (var i$1 = 0; i$1 < indices.length; i$1++) {
			var idx = indices[i$1];
			var nextIdx = indices[i$1 + 1];
			var itemModel = data.getItemModel(idx);
			if (orient === "horizontal") {
				var width = itemModel.get(["itemStyle", "width"]);
				if (width == null) width = itemSize;
				else {
					width = parsePercent$1(width, viewWidth);
					if (sort$3 === "ascending") width = -width;
				}
				var start$1 = getLinePoints(idx, x);
				var end$1 = getLinePoints(nextIdx, x + width);
				x += width + gap;
				data.setItemLayout(idx, { points: start$1.concat(end$1.slice().reverse()) });
			} else {
				var height = itemModel.get(["itemStyle", "height"]);
				if (height == null) height = itemSize;
				else {
					height = parsePercent$1(height, viewHeight);
					if (sort$3 === "ascending") height = -height;
				}
				var start$1 = getLinePoints(idx, y);
				var end$1 = getLinePoints(nextIdx, y + height);
				y += height + gap;
				data.setItemLayout(idx, { points: start$1.concat(end$1.slice().reverse()) });
			}
		}
		labelLayout(data);
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/funnel/install.js
function install$13(registers) {
	registers.registerChartView(FunnelView_default);
	registers.registerSeriesModel(FunnelSeries_default);
	registers.registerLayout(funnelLayout);
	registers.registerProcessor(dataFilter$1("funnel"));
}

//#endregion
//#region node_modules/echarts/lib/chart/parallel/ParallelView.js
var DEFAULT_SMOOTH = .3;
var ParallelView$1 = function(_super) {
	__extends(ParallelView$2, _super);
	function ParallelView$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ParallelView$2.type;
		_this._dataGroup = new Group_default();
		_this._initialized = false;
		return _this;
	}
	ParallelView$2.prototype.init = function() {
		this.group.add(this._dataGroup);
	};
	/**
	* @override
	*/
	ParallelView$2.prototype.render = function(seriesModel, ecModel, api, payload) {
		this._progressiveEls = null;
		var dataGroup = this._dataGroup;
		var data = seriesModel.getData();
		var oldData = this._data;
		var coordSys = seriesModel.coordinateSystem;
		var dimensions = coordSys.dimensions;
		var seriesScope = makeSeriesScope(seriesModel);
		data.diff(oldData).add(add$1).update(update).remove(remove).execute();
		function add$1(newDataIndex) {
			updateElCommon(addEl(data, dataGroup, newDataIndex, dimensions, coordSys), data, newDataIndex, seriesScope);
		}
		function update(newDataIndex, oldDataIndex) {
			var line = oldData.getItemGraphicEl(oldDataIndex);
			var points$3 = createLinePoints(data, newDataIndex, dimensions, coordSys);
			data.setItemGraphicEl(newDataIndex, line);
			updateProps(line, { shape: { points: points$3 } }, seriesModel, newDataIndex);
			saveOldStyle(line);
			updateElCommon(line, data, newDataIndex, seriesScope);
		}
		function remove(oldDataIndex) {
			var line = oldData.getItemGraphicEl(oldDataIndex);
			dataGroup.remove(line);
		}
		if (!this._initialized) {
			this._initialized = true;
			var clipPath = createGridClipShape$2(coordSys, seriesModel, function() {
				setTimeout(function() {
					dataGroup.removeClipPath();
				});
			});
			dataGroup.setClipPath(clipPath);
		}
		this._data = data;
	};
	ParallelView$2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
		this._initialized = true;
		this._data = null;
		this._dataGroup.removeAll();
	};
	ParallelView$2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
		var data = seriesModel.getData();
		var coordSys = seriesModel.coordinateSystem;
		var dimensions = coordSys.dimensions;
		var seriesScope = makeSeriesScope(seriesModel);
		var progressiveEls = this._progressiveEls = [];
		for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
			var line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
			line.incremental = true;
			updateElCommon(line, data, dataIndex, seriesScope);
			progressiveEls.push(line);
		}
	};
	ParallelView$2.prototype.remove = function() {
		this._dataGroup && this._dataGroup.removeAll();
		this._data = null;
	};
	ParallelView$2.type = "parallel";
	return ParallelView$2;
}(Chart_default);
function createGridClipShape$2(coordSys, seriesModel, cb) {
	var parallelModel = coordSys.model;
	var rect = coordSys.getRect();
	var rectEl = new Rect_default({ shape: {
		x: rect.x,
		y: rect.y,
		width: rect.width,
		height: rect.height
	} });
	var dim = parallelModel.get("layout") === "horizontal" ? "width" : "height";
	rectEl.setShape(dim, 0);
	initProps(rectEl, { shape: {
		width: rect.width,
		height: rect.height
	} }, seriesModel, cb);
	return rectEl;
}
function createLinePoints(data, dataIndex, dimensions, coordSys) {
	var points$3 = [];
	for (var i$1 = 0; i$1 < dimensions.length; i$1++) {
		var dimName = dimensions[i$1];
		var value = data.get(data.mapDimension(dimName), dataIndex);
		if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) points$3.push(coordSys.dataToPoint(value, dimName));
	}
	return points$3;
}
function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
	var points$3 = createLinePoints(data, dataIndex, dimensions, coordSys);
	var line = new Polyline_default({
		shape: { points: points$3 },
		z2: 10
	});
	dataGroup.add(line);
	data.setItemGraphicEl(dataIndex, line);
	return line;
}
function makeSeriesScope(seriesModel) {
	var smooth = seriesModel.get("smooth", true);
	smooth === true && (smooth = DEFAULT_SMOOTH);
	smooth = numericToNumber(smooth);
	eqNaN(smooth) && (smooth = 0);
	return { smooth };
}
function updateElCommon(el, data, dataIndex, seriesScope) {
	el.useStyle(data.getItemVisual(dataIndex, "style"));
	el.style.fill = null;
	el.setShape("smooth", seriesScope.smooth);
	var itemModel = data.getItemModel(dataIndex);
	var emphasisModel = itemModel.getModel("emphasis");
	setStatesStylesFromModel(el, itemModel, "lineStyle");
	toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function isEmptyValue(val, axisType) {
	return axisType === "category" ? val == null : val == null || isNaN(val);
}
var ParallelView_default = ParallelView$1;

//#endregion
//#region node_modules/echarts/lib/chart/parallel/ParallelSeries.js
var ParallelSeriesModel = function(_super) {
	__extends(ParallelSeriesModel$1, _super);
	function ParallelSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ParallelSeriesModel$1.type;
		_this.visualStyleAccessPath = "lineStyle";
		_this.visualDrawType = "stroke";
		return _this;
	}
	ParallelSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		return createSeriesData_default(null, this, { useEncodeDefaulter: bind(makeDefaultEncode, null, this) });
	};
	/**
	* User can get data raw indices on 'axisAreaSelected' event received.
	*
	* @return Raw indices
	*/
	ParallelSeriesModel$1.prototype.getRawIndicesByActiveState = function(activeState) {
		var coordSys = this.coordinateSystem;
		var data = this.getData();
		var indices = [];
		coordSys.eachActiveState(data, function(theActiveState, dataIndex) {
			if (activeState === theActiveState) indices.push(data.getRawIndex(dataIndex));
		});
		return indices;
	};
	ParallelSeriesModel$1.type = "series.parallel";
	ParallelSeriesModel$1.dependencies = ["parallel"];
	ParallelSeriesModel$1.defaultOption = {
		z: 2,
		coordinateSystem: "parallel",
		parallelIndex: 0,
		label: { show: false },
		inactiveOpacity: .05,
		activeOpacity: 1,
		lineStyle: {
			width: 1,
			opacity: .45,
			type: "solid"
		},
		emphasis: { label: { show: false } },
		progressive: 500,
		smooth: false,
		animationEasing: "linear"
	};
	return ParallelSeriesModel$1;
}(Series_default);
function makeDefaultEncode(seriesModel) {
	var parallelModel = seriesModel.ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
	if (!parallelModel) return;
	var encodeDefine = {};
	each(parallelModel.dimensions, function(axisDim) {
		encodeDefine[axisDim] = convertDimNameToNumber(axisDim);
	});
	return encodeDefine;
}
function convertDimNameToNumber(dimName) {
	return +dimName.replace("dim", "");
}
var ParallelSeries_default = ParallelSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/parallel/parallelVisual.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var opacityAccessPath = ["lineStyle", "opacity"];
var parallelVisual = {
	seriesType: "parallel",
	reset: function(seriesModel, ecModel) {
		var coordSys = seriesModel.coordinateSystem;
		var opacityMap = {
			normal: seriesModel.get(["lineStyle", "opacity"]),
			active: seriesModel.get("activeOpacity"),
			inactive: seriesModel.get("inactiveOpacity")
		};
		return { progress: function(params, data) {
			coordSys.eachActiveState(data, function(activeState, dataIndex) {
				var opacity = opacityMap[activeState];
				if (activeState === "normal" && data.hasItemOption) {
					var itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath, true);
					itemOpacity != null && (opacity = itemOpacity);
				}
				var existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
				existsStyle.opacity = opacity;
			}, params.start, params.end);
		} };
	}
};
var parallelVisual_default = parallelVisual;

//#endregion
//#region node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js
function parallelPreprocessor(option) {
	createParallelIfNeeded(option);
	mergeAxisOptionFromParallel(option);
}
/**
* Create a parallel coordinate if not exists.
* @inner
*/
function createParallelIfNeeded(option) {
	if (option.parallel) return;
	var hasParallelSeries = false;
	each(option.series, function(seriesOpt) {
		if (seriesOpt && seriesOpt.type === "parallel") hasParallelSeries = true;
	});
	if (hasParallelSeries) option.parallel = [{}];
}
/**
* Merge aixs definition from parallel option (if exists) to axis option.
* @inner
*/
function mergeAxisOptionFromParallel(option) {
	var axes = normalizeToArray(option.parallelAxis);
	each(axes, function(axisOption) {
		if (!isObject(axisOption)) return;
		var parallelIndex = axisOption.parallelIndex || 0;
		var parallelOption = normalizeToArray(option.parallel)[parallelIndex];
		if (parallelOption && parallelOption.parallelAxisDefault) merge(axisOption, parallelOption.parallelAxisDefault, false);
	});
}

//#endregion
//#region node_modules/echarts/lib/component/parallel/ParallelView.js
var CLICK_THRESHOLD = 5;
var ParallelView = function(_super) {
	__extends(ParallelView$2, _super);
	function ParallelView$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ParallelView$2.type;
		return _this;
	}
	ParallelView$2.prototype.render = function(parallelModel, ecModel, api) {
		this._model = parallelModel;
		this._api = api;
		if (!this._handlers) {
			this._handlers = {};
			each(handlers$1, function(handler, eventName) {
				api.getZr().on(eventName, this._handlers[eventName] = bind(handler, this));
			}, this);
		}
		createOrUpdate(this, "_throttledDispatchExpand", parallelModel.get("axisExpandRate"), "fixRate");
	};
	ParallelView$2.prototype.dispose = function(ecModel, api) {
		clear(this, "_throttledDispatchExpand");
		each(this._handlers, function(handler, eventName) {
			api.getZr().off(eventName, handler);
		});
		this._handlers = null;
	};
	/**
	* @internal
	* @param {Object} [opt] If null, cancel the last action triggering for debounce.
	*/
	ParallelView$2.prototype._throttledDispatchExpand = function(opt) {
		this._dispatchExpand(opt);
	};
	/**
	* @internal
	*/
	ParallelView$2.prototype._dispatchExpand = function(opt) {
		opt && this._api.dispatchAction(extend({ type: "parallelAxisExpand" }, opt));
	};
	ParallelView$2.type = "parallel";
	return ParallelView$2;
}(Component_default$1);
var handlers$1 = {
	mousedown: function(e$1) {
		if (checkTrigger(this, "click")) this._mouseDownPoint = [e$1.offsetX, e$1.offsetY];
	},
	mouseup: function(e$1) {
		var mouseDownPoint = this._mouseDownPoint;
		if (checkTrigger(this, "click") && mouseDownPoint) {
			var point = [e$1.offsetX, e$1.offsetY];
			if (Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2) > CLICK_THRESHOLD) return;
			var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e$1.offsetX, e$1.offsetY]);
			result.behavior !== "none" && this._dispatchExpand({ axisExpandWindow: result.axisExpandWindow });
		}
		this._mouseDownPoint = null;
	},
	mousemove: function(e$1) {
		if (this._mouseDownPoint || !checkTrigger(this, "mousemove")) return;
		var model = this._model;
		var result = model.coordinateSystem.getSlidedAxisExpandWindow([e$1.offsetX, e$1.offsetY]);
		var behavior = result.behavior;
		behavior === "jump" && this._throttledDispatchExpand.debounceNextCall(model.get("axisExpandDebounce"));
		this._throttledDispatchExpand(behavior === "none" ? null : {
			axisExpandWindow: result.axisExpandWindow,
			animation: behavior === "jump" ? null : { duration: 0 }
		});
	}
};
function checkTrigger(view, triggerOn) {
	var model = view._model;
	return model.get("axisExpandable") && model.get("axisExpandTriggerOn") === triggerOn;
}
var ParallelView_default$1 = ParallelView;

//#endregion
//#region node_modules/echarts/lib/coord/parallel/ParallelModel.js
var ParallelModel = function(_super) {
	__extends(ParallelModel$1, _super);
	function ParallelModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ParallelModel$1.type;
		return _this;
	}
	ParallelModel$1.prototype.init = function() {
		_super.prototype.init.apply(this, arguments);
		this.mergeOption({});
	};
	ParallelModel$1.prototype.mergeOption = function(newOption) {
		var thisOption = this.option;
		newOption && merge(thisOption, newOption, true);
		this._initDimensions();
	};
	/**
	* Whether series or axis is in this coordinate system.
	*/
	ParallelModel$1.prototype.contains = function(model, ecModel) {
		var parallelIndex = model.get("parallelIndex");
		return parallelIndex != null && ecModel.getComponent("parallel", parallelIndex) === this;
	};
	ParallelModel$1.prototype.setAxisExpand = function(opt) {
		each([
			"axisExpandable",
			"axisExpandCenter",
			"axisExpandCount",
			"axisExpandWidth",
			"axisExpandWindow"
		], function(name) {
			if (opt.hasOwnProperty(name)) this.option[name] = opt[name];
		}, this);
	};
	ParallelModel$1.prototype._initDimensions = function() {
		var dimensions = this.dimensions = [];
		var parallelAxisIndex = this.parallelAxisIndex = [];
		var axisModels = filter(this.ecModel.queryComponents({ mainType: "parallelAxis" }), function(axisModel) {
			return (axisModel.get("parallelIndex") || 0) === this.componentIndex;
		}, this);
		each(axisModels, function(axisModel) {
			dimensions.push("dim" + axisModel.get("dim"));
			parallelAxisIndex.push(axisModel.componentIndex);
		});
	};
	ParallelModel$1.type = "parallel";
	ParallelModel$1.dependencies = ["parallelAxis"];
	ParallelModel$1.layoutMode = "box";
	ParallelModel$1.defaultOption = {
		z: 0,
		left: 80,
		top: 60,
		right: 80,
		bottom: 60,
		layout: "horizontal",
		axisExpandable: false,
		axisExpandCenter: null,
		axisExpandCount: 0,
		axisExpandWidth: 50,
		axisExpandRate: 17,
		axisExpandDebounce: 50,
		axisExpandSlideTriggerArea: [
			-.15,
			.05,
			.4
		],
		axisExpandTriggerOn: "click",
		parallelAxisDefault: null
	};
	return ParallelModel$1;
}(Component_default);
var ParallelModel_default = ParallelModel;

//#endregion
//#region node_modules/echarts/lib/coord/parallel/ParallelAxis.js
var ParallelAxis = function(_super) {
	__extends(ParallelAxis$1, _super);
	function ParallelAxis$1(dim, scale$3, coordExtent, axisType, axisIndex) {
		var _this = _super.call(this, dim, scale$3, coordExtent) || this;
		_this.type = axisType || "value";
		_this.axisIndex = axisIndex;
		return _this;
	}
	ParallelAxis$1.prototype.isHorizontal = function() {
		return this.coordinateSystem.getModel().get("layout") !== "horizontal";
	};
	return ParallelAxis$1;
}(Axis_default);
var ParallelAxis_default = ParallelAxis;

//#endregion
//#region node_modules/echarts/lib/component/helper/sliderMove.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Calculate slider move result.
* Usage:
* (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as
* maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.
* (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.
*
* @param delta Move length.
* @param handleEnds handleEnds[0] can be bigger then handleEnds[1].
*              handleEnds will be modified in this method.
* @param extent handleEnds is restricted by extent.
*              extent[0] should less or equals than extent[1].
* @param handleIndex Can be 'all', means that both move the two handleEnds.
* @param minSpan The range of dataZoom can not be smaller than that.
*              If not set, handle0 and cross handle1. If set as a non-negative
*              number (including `0`), handles will push each other when reaching
*              the minSpan.
* @param maxSpan The range of dataZoom can not be larger than that.
* @return The input handleEnds.
*/
function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
	delta = delta || 0;
	var extentSpan = extent[1] - extent[0];
	if (minSpan != null) minSpan = restrict$1(minSpan, [0, extentSpan]);
	if (maxSpan != null) maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
	if (handleIndex === "all") {
		var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
		handleSpan = restrict$1(handleSpan, [0, extentSpan]);
		minSpan = maxSpan = restrict$1(handleSpan, [minSpan, maxSpan]);
		handleIndex = 0;
	}
	handleEnds[0] = restrict$1(handleEnds[0], extent);
	handleEnds[1] = restrict$1(handleEnds[1], extent);
	var originalDistSign = getSpanSign(handleEnds, handleIndex);
	handleEnds[handleIndex] += delta;
	var extentMinSpan = minSpan || 0;
	var realExtent = extent.slice();
	originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
	handleEnds[handleIndex] = restrict$1(handleEnds[handleIndex], realExtent);
	var currDistSign = getSpanSign(handleEnds, handleIndex);
	if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
	currDistSign = getSpanSign(handleEnds, handleIndex);
	if (maxSpan != null && currDistSign.span > maxSpan) handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
	return handleEnds;
}
function getSpanSign(handleEnds, handleIndex) {
	var dist$2 = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
	return {
		span: Math.abs(dist$2),
		sign: dist$2 > 0 ? -1 : dist$2 < 0 ? 1 : handleIndex ? -1 : 1
	};
}
function restrict$1(value, extend$1) {
	return Math.min(extend$1[1] != null ? extend$1[1] : Infinity, Math.max(extend$1[0] != null ? extend$1[0] : -Infinity, value));
}

//#endregion
//#region node_modules/echarts/lib/coord/parallel/Parallel.js
var each$11 = each;
var mathMin$3 = Math.min;
var mathMax$3 = Math.max;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var round$2 = round;
var PI$1 = Math.PI;
var Parallel = function() {
	function Parallel$1(parallelModel, ecModel, api) {
		this.type = "parallel";
		/**
		* key: dimension
		*/
		this._axesMap = createHashMap();
		/**
		* key: dimension
		* value: {position: [], rotation, }
		*/
		this._axesLayout = {};
		this.dimensions = parallelModel.dimensions;
		this._model = parallelModel;
		this._init(parallelModel, ecModel, api);
	}
	Parallel$1.prototype._init = function(parallelModel, ecModel, api) {
		var dimensions = parallelModel.dimensions;
		var parallelAxisIndex = parallelModel.parallelAxisIndex;
		each$11(dimensions, function(dim, idx) {
			var axisIndex = parallelAxisIndex[idx];
			var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
			var axis = this._axesMap.set(dim, new ParallelAxis_default(dim, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisIndex));
			axis.onBand = axis.type === "category" && axisModel.get("boundaryGap");
			axis.inverse = axisModel.get("inverse");
			axisModel.axis = axis;
			axis.model = axisModel;
			axis.coordinateSystem = axisModel.coordinateSystem = this;
		}, this);
	};
	/**
	* Update axis scale after data processed
	*/
	Parallel$1.prototype.update = function(ecModel, api) {
		this._updateAxesFromSeries(this._model, ecModel);
	};
	Parallel$1.prototype.containPoint = function(point) {
		var layoutInfo = this._makeLayoutInfo();
		var axisBase = layoutInfo.axisBase;
		var layoutBase = layoutInfo.layoutBase;
		var pixelDimIndex = layoutInfo.pixelDimIndex;
		var pAxis = point[1 - pixelDimIndex];
		var pLayout = point[pixelDimIndex];
		return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
	};
	Parallel$1.prototype.getModel = function() {
		return this._model;
	};
	/**
	* Update properties from series
	*/
	Parallel$1.prototype._updateAxesFromSeries = function(parallelModel, ecModel) {
		ecModel.eachSeries(function(seriesModel) {
			if (!parallelModel.contains(seriesModel, ecModel)) return;
			var data = seriesModel.getData();
			each$11(this.dimensions, function(dim) {
				var axis = this._axesMap.get(dim);
				axis.scale.unionExtentFromData(data, data.mapDimension(dim));
				niceScaleExtent(axis.scale, axis.model);
			}, this);
		}, this);
	};
	/**
	* Resize the parallel coordinate system.
	*/
	Parallel$1.prototype.resize = function(parallelModel, api) {
		var refContainer = createBoxLayoutReference(parallelModel, api).refContainer;
		this._rect = getLayoutRect(parallelModel.getBoxLayoutParams(), refContainer);
		this._layoutAxes();
	};
	Parallel$1.prototype.getRect = function() {
		return this._rect;
	};
	Parallel$1.prototype._makeLayoutInfo = function() {
		var parallelModel = this._model;
		var rect = this._rect;
		var xy = ["x", "y"];
		var wh = ["width", "height"];
		var layout$3 = parallelModel.get("layout");
		var pixelDimIndex = layout$3 === "horizontal" ? 0 : 1;
		var layoutLength = rect[wh[pixelDimIndex]];
		var layoutExtent = [0, layoutLength];
		var axisCount = this.dimensions.length;
		var axisExpandWidth = restrict(parallelModel.get("axisExpandWidth"), layoutExtent);
		var axisExpandCount = restrict(parallelModel.get("axisExpandCount") || 0, [0, axisCount]);
		var axisExpandable = parallelModel.get("axisExpandable") && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;
		var axisExpandWindow = parallelModel.get("axisExpandWindow");
		var winSize;
		if (!axisExpandWindow) {
			winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
			axisExpandWindow = [axisExpandWidth * (parallelModel.get("axisExpandCenter") || mathFloor(axisCount / 2)) - winSize / 2];
			axisExpandWindow[1] = axisExpandWindow[0] + winSize;
		} else {
			winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
			axisExpandWindow[1] = axisExpandWindow[0] + winSize;
		}
		var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);
		axisCollapseWidth < 3 && (axisCollapseWidth = 0);
		var winInnerIndices = [mathFloor(round$2(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round$2(axisExpandWindow[1] / axisExpandWidth, 1)) - 1];
		var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
		return {
			layout: layout$3,
			pixelDimIndex,
			layoutBase: rect[xy[pixelDimIndex]],
			layoutLength,
			axisBase: rect[xy[1 - pixelDimIndex]],
			axisLength: rect[wh[1 - pixelDimIndex]],
			axisExpandable,
			axisExpandWidth,
			axisCollapseWidth,
			axisExpandWindow,
			axisCount,
			winInnerIndices,
			axisExpandWindow0Pos
		};
	};
	Parallel$1.prototype._layoutAxes = function() {
		var rect = this._rect;
		var axes = this._axesMap;
		var dimensions = this.dimensions;
		var layoutInfo = this._makeLayoutInfo();
		var layout$3 = layoutInfo.layout;
		axes.each(function(axis) {
			var axisExtent = [0, layoutInfo.axisLength];
			var idx = axis.inverse ? 1 : 0;
			axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
		});
		each$11(dimensions, function(dim, idx) {
			var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
			var positionTable = {
				horizontal: {
					x: posInfo.position,
					y: layoutInfo.axisLength
				},
				vertical: {
					x: 0,
					y: posInfo.position
				}
			};
			var rotationTable = {
				horizontal: PI$1 / 2,
				vertical: 0
			};
			var position$1 = [positionTable[layout$3].x + rect.x, positionTable[layout$3].y + rect.y];
			var rotation = rotationTable[layout$3];
			var transform = create$2();
			rotate(transform, transform, rotation);
			translate(transform, transform, position$1);
			this._axesLayout[dim] = {
				position: position$1,
				rotation,
				transform,
				axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
				axisLabelShow: posInfo.axisLabelShow,
				nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
				tickDirection: 1,
				labelDirection: 1
			};
		}, this);
	};
	/**
	* Get axis by dim.
	*/
	Parallel$1.prototype.getAxis = function(dim) {
		return this._axesMap.get(dim);
	};
	/**
	* Convert a dim value of a single item of series data to Point.
	*/
	Parallel$1.prototype.dataToPoint = function(value, dim) {
		return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
	};
	/**
	* Travel data for one time, get activeState of each data item.
	* @param start the start dataIndex that travel from.
	* @param end the next dataIndex of the last dataIndex will be travel.
	*/
	Parallel$1.prototype.eachActiveState = function(data, callback, start$1, end$1) {
		start$1 ??= 0;
		end$1 ??= data.count();
		var axesMap = this._axesMap;
		var dimensions = this.dimensions;
		var dataDimensions = [];
		var axisModels = [];
		each(dimensions, function(axisDim) {
			dataDimensions.push(data.mapDimension(axisDim));
			axisModels.push(axesMap.get(axisDim).model);
		});
		var hasActiveSet = this.hasAxisBrushed();
		for (var dataIndex = start$1; dataIndex < end$1; dataIndex++) {
			var activeState = void 0;
			if (!hasActiveSet) activeState = "normal";
			else {
				activeState = "active";
				var values = data.getValues(dataDimensions, dataIndex);
				for (var j = 0, lenj = dimensions.length; j < lenj; j++) if (axisModels[j].getActiveState(values[j]) === "inactive") {
					activeState = "inactive";
					break;
				}
			}
			callback(activeState, dataIndex);
		}
	};
	/**
	* Whether has any activeSet.
	*/
	Parallel$1.prototype.hasAxisBrushed = function() {
		var dimensions = this.dimensions;
		var axesMap = this._axesMap;
		var hasActiveSet = false;
		for (var j = 0, lenj = dimensions.length; j < lenj; j++) if (axesMap.get(dimensions[j]).model.getActiveState() !== "normal") hasActiveSet = true;
		return hasActiveSet;
	};
	/**
	* Convert coords of each axis to Point.
	*  Return point. For example: [10, 20]
	*/
	Parallel$1.prototype.axisCoordToPoint = function(coord, dim) {
		var axisLayout = this._axesLayout[dim];
		return applyTransform$1([coord, 0], axisLayout.transform);
	};
	/**
	* Get axis layout.
	*/
	Parallel$1.prototype.getAxisLayout = function(dim) {
		return clone(this._axesLayout[dim]);
	};
	/**
	* @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.
	*/
	Parallel$1.prototype.getSlidedAxisExpandWindow = function(point) {
		var layoutInfo = this._makeLayoutInfo();
		var pixelDimIndex = layoutInfo.pixelDimIndex;
		var axisExpandWindow = layoutInfo.axisExpandWindow.slice();
		var winSize = axisExpandWindow[1] - axisExpandWindow[0];
		var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];
		if (!this.containPoint(point)) return {
			behavior: "none",
			axisExpandWindow
		};
		var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;
		var delta;
		var behavior = "slide";
		var axisCollapseWidth = layoutInfo.axisCollapseWidth;
		var triggerArea = this._model.get("axisExpandSlideTriggerArea");
		var useJump = triggerArea[0] != null;
		if (axisCollapseWidth) {
			if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
				behavior = "jump";
				delta = pointCoord - winSize * triggerArea[2];
			} else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
				behavior = "jump";
				delta = pointCoord - winSize * (1 - triggerArea[2]);
			} else (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
			delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
			delta ? sliderMove(delta, axisExpandWindow, extent, "all") : behavior = "none";
		} else {
			var winSize2 = axisExpandWindow[1] - axisExpandWindow[0];
			axisExpandWindow = [mathMax$3(0, extent[1] * pointCoord / winSize2 - winSize2 / 2)];
			axisExpandWindow[1] = mathMin$3(extent[1], axisExpandWindow[0] + winSize2);
			axisExpandWindow[0] = axisExpandWindow[1] - winSize2;
		}
		return {
			axisExpandWindow,
			behavior
		};
	};
	return Parallel$1;
}();
function restrict(len$1, extent) {
	return mathMin$3(mathMax$3(len$1, extent[0]), extent[1]);
}
function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
	var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
	return {
		position: step * axisIndex,
		axisNameAvailableWidth: step,
		axisLabelShow: true
	};
}
function layoutAxisWithExpand(axisIndex, layoutInfo) {
	var layoutLength = layoutInfo.layoutLength;
	var axisExpandWidth = layoutInfo.axisExpandWidth;
	var axisCount = layoutInfo.axisCount;
	var axisCollapseWidth = layoutInfo.axisCollapseWidth;
	var winInnerIndices = layoutInfo.winInnerIndices;
	var position$1;
	var axisNameAvailableWidth = axisCollapseWidth;
	var axisLabelShow = false;
	var nameTruncateMaxWidth;
	if (axisIndex < winInnerIndices[0]) {
		position$1 = axisIndex * axisCollapseWidth;
		nameTruncateMaxWidth = axisCollapseWidth;
	} else if (axisIndex <= winInnerIndices[1]) {
		position$1 = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
		axisNameAvailableWidth = axisExpandWidth;
		axisLabelShow = true;
	} else {
		position$1 = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
		nameTruncateMaxWidth = axisCollapseWidth;
	}
	return {
		position: position$1,
		axisNameAvailableWidth,
		axisLabelShow,
		nameTruncateMaxWidth
	};
}
var Parallel_default = Parallel;

//#endregion
//#region node_modules/echarts/lib/coord/parallel/parallelCreator.js
function createParallelCoordSys(ecModel, api) {
	var coordSysList = [];
	ecModel.eachComponent("parallel", function(parallelModel, idx) {
		var coordSys = new Parallel_default(parallelModel, ecModel, api);
		coordSys.name = "parallel_" + idx;
		coordSys.resize(parallelModel, api);
		parallelModel.coordinateSystem = coordSys;
		coordSys.model = parallelModel;
		coordSysList.push(coordSys);
	});
	ecModel.eachSeries(function(seriesModel) {
		if (seriesModel.get("coordinateSystem") === "parallel") seriesModel.coordinateSystem = seriesModel.getReferringComponents("parallel", SINGLE_REFERRING).models[0].coordinateSystem;
	});
	return coordSysList;
}
var parallelCoordSysCreator = { create: createParallelCoordSys };
var parallelCreator_default = parallelCoordSysCreator;

//#endregion
//#region node_modules/echarts/lib/coord/parallel/AxisModel.js
var ParallelAxisModel = function(_super) {
	__extends(ParallelAxisModel$1, _super);
	function ParallelAxisModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ParallelAxisModel$1.type;
		/**
		* @readOnly
		*/
		_this.activeIntervals = [];
		return _this;
	}
	ParallelAxisModel$1.prototype.getAreaSelectStyle = function() {
		return makeStyleMapper([
			["fill", "color"],
			["lineWidth", "borderWidth"],
			["stroke", "borderColor"],
			["width", "width"],
			["opacity", "opacity"]
		])(this.getModel("areaSelectStyle"));
	};
	/**
	* The code of this feature is put on AxisModel but not ParallelAxis,
	* because axisModel can be alive after echarts updating but instance of
	* ParallelAxis having been disposed. this._activeInterval should be kept
	* when action dispatched (i.e. legend click).
	*
	* @param intervals `interval.length === 0` means set all active.
	*/
	ParallelAxisModel$1.prototype.setActiveIntervals = function(intervals) {
		var activeIntervals = this.activeIntervals = clone(intervals);
		if (activeIntervals) for (var i$1 = activeIntervals.length - 1; i$1 >= 0; i$1--) asc$1(activeIntervals[i$1]);
	};
	/**
	* @param value When only attempting detect whether 'no activeIntervals set',
	*        `value` is not needed to be input.
	*/
	ParallelAxisModel$1.prototype.getActiveState = function(value) {
		var activeIntervals = this.activeIntervals;
		if (!activeIntervals.length) return "normal";
		if (value == null || isNaN(+value)) return "inactive";
		if (activeIntervals.length === 1) {
			var interval = activeIntervals[0];
			if (interval[0] <= value && value <= interval[1]) return "active";
		} else for (var i$1 = 0, len$1 = activeIntervals.length; i$1 < len$1; i$1++) if (activeIntervals[i$1][0] <= value && value <= activeIntervals[i$1][1]) return "active";
		return "inactive";
	};
	return ParallelAxisModel$1;
}(Component_default);
mixin(ParallelAxisModel, AxisModelCommonMixin);
var AxisModel_default$1 = ParallelAxisModel;

//#endregion
//#region node_modules/echarts/lib/component/helper/BrushController.js
var BRUSH_PANEL_GLOBAL = true;
var mathMin$2 = Math.min;
var mathMax$2 = Math.max;
var mathPow = Math.pow;
var COVER_Z = 1e4;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = "globalPan";
var DIRECTION_MAP = {
	w: [0, 0],
	e: [0, 1],
	n: [1, 0],
	s: [1, 1]
};
var CURSOR_MAP = {
	w: "ew",
	e: "ew",
	n: "ns",
	s: "ns",
	ne: "nesw",
	sw: "nesw",
	nw: "nwse",
	se: "nwse"
};
var DEFAULT_BRUSH_OPT = {
	brushStyle: {
		lineWidth: 2,
		stroke: tokens_default.color.backgroundTint,
		fill: tokens_default.color.borderTint
	},
	transformable: true,
	brushMode: "single",
	removeOnClick: false
};
var baseUID = 0;
/**
* params:
*     areas: Array.<Array>, coord relates to container group,
*                             If no container specified, to global.
*     opt {
*         isEnd: boolean,
*         removeOnClick: boolean
*     }
*/
var BrushController = function(_super) {
	__extends(BrushController$1, _super);
	function BrushController$1(zr) {
		var _this = _super.call(this) || this;
		/**
		* @internal
		*/
		_this._track = [];
		/**
		* @internal
		*/
		_this._covers = [];
		_this._handlers = {};
		assert(zr);
		_this._zr = zr;
		_this.group = new Group_default();
		_this._uid = "brushController_" + baseUID++;
		each(pointerHandlers, function(handler, eventName) {
			this._handlers[eventName] = bind(handler, this);
		}, _this);
		return _this;
	}
	/**
	* If set to `false`, select disabled.
	*/
	BrushController$1.prototype.enableBrush = function(brushOption) {
		assert(this._mounted);
		this._brushType && this._doDisableBrush();
		brushOption.brushType && this._doEnableBrush(brushOption);
		return this;
	};
	BrushController$1.prototype._doEnableBrush = function(brushOption) {
		var zr = this._zr;
		if (!this._enableGlobalPan) take(zr, MUTEX_RESOURCE_KEY, this._uid);
		each(this._handlers, function(handler, eventName) {
			zr.on(eventName, handler);
		});
		this._brushType = brushOption.brushType;
		this._brushOption = merge(clone(DEFAULT_BRUSH_OPT), brushOption, true);
	};
	BrushController$1.prototype._doDisableBrush = function() {
		var zr = this._zr;
		release(zr, MUTEX_RESOURCE_KEY, this._uid);
		each(this._handlers, function(handler, eventName) {
			zr.off(eventName, handler);
		});
		this._brushType = this._brushOption = null;
	};
	/**
	* @param panelOpts If not pass, it is global brush.
	*/
	BrushController$1.prototype.setPanels = function(panelOpts) {
		if (panelOpts && panelOpts.length) {
			var panels_1 = this._panels = {};
			each(panelOpts, function(panelOpts$1) {
				panels_1[panelOpts$1.panelId] = clone(panelOpts$1);
			});
		} else this._panels = null;
		return this;
	};
	BrushController$1.prototype.mount = function(opt) {
		opt = opt || {};
		this._mounted = true;
		this._enableGlobalPan = opt.enableGlobalPan;
		var thisGroup = this.group;
		this._zr.add(thisGroup);
		thisGroup.attr({
			x: opt.x || 0,
			y: opt.y || 0,
			rotation: opt.rotation || 0,
			scaleX: opt.scaleX || 1,
			scaleY: opt.scaleY || 1
		});
		this._transform = thisGroup.getLocalTransform();
		return this;
	};
	/**
	* Update covers.
	* @param coverConfigList
	*        If coverConfigList is null/undefined, all covers removed.
	*/
	BrushController$1.prototype.updateCovers = function(coverConfigList) {
		assert(this._mounted);
		coverConfigList = map(coverConfigList, function(coverConfig) {
			return merge(clone(DEFAULT_BRUSH_OPT), coverConfig, true);
		});
		var tmpIdPrefix = "\0-brush-index-";
		var oldCovers = this._covers;
		var newCovers = this._covers = [];
		var controller = this;
		var creatingCover = this._creatingCover;
		new DataDiffer_default(oldCovers, coverConfigList, oldGetKey, getKey$1).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
		return this;
		function getKey$1(brushOption, index) {
			return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + "-" + brushOption.brushType;
		}
		function oldGetKey(cover, index) {
			return getKey$1(cover.__brushOption, index);
		}
		function addOrUpdate(newIndex, oldIndex) {
			var newBrushInternal = coverConfigList[newIndex];
			if (oldIndex != null && oldCovers[oldIndex] === creatingCover) newCovers[newIndex] = oldCovers[oldIndex];
			else updateCoverAfterCreation(controller, newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal)));
		}
		function remove(oldIndex) {
			if (oldCovers[oldIndex] !== creatingCover) controller.group.remove(oldCovers[oldIndex]);
		}
	};
	BrushController$1.prototype.unmount = function() {
		if (!this._mounted) return;
		this.enableBrush(false);
		clearCovers(this);
		this._zr.remove(this.group);
		this._mounted = false;
		return this;
	};
	BrushController$1.prototype.dispose = function() {
		this.unmount();
		this.off();
	};
	return BrushController$1;
}(Eventful_default);
function createCover(controller, brushOption) {
	var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
	cover.__brushOption = brushOption;
	updateZ$3(cover, brushOption);
	controller.group.add(cover);
	return cover;
}
function endCreating(controller, creatingCover) {
	var coverRenderer = getCoverRenderer(creatingCover);
	if (coverRenderer.endCreating) {
		coverRenderer.endCreating(controller, creatingCover);
		updateZ$3(creatingCover, creatingCover.__brushOption);
	}
	return creatingCover;
}
function updateCoverShape(controller, cover) {
	var brushOption = cover.__brushOption;
	getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}
function updateZ$3(cover, brushOption) {
	var z = brushOption.z;
	z ??= COVER_Z;
	cover.traverse(function(el) {
		el.z = z;
		el.z2 = z;
	});
}
function updateCoverAfterCreation(controller, cover) {
	getCoverRenderer(cover).updateCommon(controller, cover);
	updateCoverShape(controller, cover);
}
function getCoverRenderer(cover) {
	return coverRenderers[cover.__brushOption.brushType];
}
function getPanelByPoint(controller, e$1, localCursorPoint) {
	var panels = controller._panels;
	if (!panels) return BRUSH_PANEL_GLOBAL;
	var panel;
	var transform = controller._transform;
	each(panels, function(pn) {
		pn.isTargetByCursor(e$1, localCursorPoint, transform) && (panel = pn);
	});
	return panel;
}
function getPanelByCover(controller, cover) {
	var panels = controller._panels;
	if (!panels) return BRUSH_PANEL_GLOBAL;
	var panelId = cover.__brushOption.panelId;
	return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;
}
function clearCovers(controller) {
	var covers = controller._covers;
	var originalLength = covers.length;
	each(covers, function(cover) {
		controller.group.remove(cover);
	}, controller);
	covers.length = 0;
	return !!originalLength;
}
function trigger(controller, opt) {
	var areas = map(controller._covers, function(cover) {
		var brushOption = cover.__brushOption;
		var range = clone(brushOption.range);
		return {
			brushType: brushOption.brushType,
			panelId: brushOption.panelId,
			range
		};
	});
	controller.trigger("brush", {
		areas,
		isEnd: !!opt.isEnd,
		removeOnClick: !!opt.removeOnClick
	});
}
function shouldShowCover(controller) {
	var track = controller._track;
	if (!track.length) return false;
	var p2 = track[track.length - 1];
	var p1 = track[0];
	var dx = p2[0] - p1[0];
	var dy = p2[1] - p1[1];
	return mathPow(dx * dx + dy * dy, .5) > UNSELECT_THRESHOLD;
}
function getTrackEnds(track) {
	var tail = track.length - 1;
	tail < 0 && (tail = 0);
	return [track[0], track[tail]];
}
function createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {
	var cover = new Group_default();
	cover.add(new Rect_default({
		name: "main",
		style: makeStyle(brushOption),
		silent: true,
		draggable: true,
		cursor: "move",
		drift: curry(driftRect, rectRangeConverter, controller, cover, [
			"n",
			"s",
			"w",
			"e"
		]),
		ondragend: curry(trigger, controller, { isEnd: true })
	}));
	each(edgeNameSequences, function(nameSequence) {
		cover.add(new Rect_default({
			name: nameSequence.join(""),
			style: { opacity: 0 },
			draggable: true,
			silent: true,
			invisible: true,
			drift: curry(driftRect, rectRangeConverter, controller, cover, nameSequence),
			ondragend: curry(trigger, controller, { isEnd: true })
		}));
	});
	return cover;
}
function updateBaseRect(controller, cover, localRange, brushOption) {
	var lineWidth = brushOption.brushStyle.lineWidth || 0;
	var handleSize = mathMax$2(lineWidth, MIN_RESIZE_LINE_WIDTH);
	var x = localRange[0][0];
	var y = localRange[1][0];
	var xa = x - lineWidth / 2;
	var ya = y - lineWidth / 2;
	var x2 = localRange[0][1];
	var y2 = localRange[1][1];
	var x2a = x2 - handleSize + lineWidth / 2;
	var y2a = y2 - handleSize + lineWidth / 2;
	var width = x2 - x;
	var height = y2 - y;
	var widtha = width + lineWidth;
	var heighta = height + lineWidth;
	updateRectShape(controller, cover, "main", x, y, width, height);
	if (brushOption.transformable) {
		updateRectShape(controller, cover, "w", xa, ya, handleSize, heighta);
		updateRectShape(controller, cover, "e", x2a, ya, handleSize, heighta);
		updateRectShape(controller, cover, "n", xa, ya, widtha, handleSize);
		updateRectShape(controller, cover, "s", xa, y2a, widtha, handleSize);
		updateRectShape(controller, cover, "nw", xa, ya, handleSize, handleSize);
		updateRectShape(controller, cover, "ne", x2a, ya, handleSize, handleSize);
		updateRectShape(controller, cover, "sw", xa, y2a, handleSize, handleSize);
		updateRectShape(controller, cover, "se", x2a, y2a, handleSize, handleSize);
	}
}
function updateCommon$1(controller, cover) {
	var brushOption = cover.__brushOption;
	var transformable = brushOption.transformable;
	var mainEl = cover.childAt(0);
	mainEl.useStyle(makeStyle(brushOption));
	mainEl.attr({
		silent: !transformable,
		cursor: transformable ? "move" : "default"
	});
	each([
		["w"],
		["e"],
		["n"],
		["s"],
		["s", "e"],
		["s", "w"],
		["n", "e"],
		["n", "w"]
	], function(nameSequence) {
		var el = cover.childOfName(nameSequence.join(""));
		var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);
		el && el.attr({
			silent: !transformable,
			invisible: !transformable,
			cursor: transformable ? CURSOR_MAP[globalDir] + "-resize" : null
		});
	});
}
function updateRectShape(controller, cover, name, x, y, w, h) {
	var el = cover.childOfName(name);
	el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
}
function makeStyle(brushOption) {
	return defaults({ strokeNoScale: true }, brushOption.brushStyle);
}
function formatRectRange(x, y, x2, y2) {
	var min$2 = [mathMin$2(x, x2), mathMin$2(y, y2)];
	var max$2 = [mathMax$2(x, x2), mathMax$2(y, y2)];
	return [[min$2[0], max$2[0]], [min$2[1], max$2[1]]];
}
function getTransform(controller) {
	return getTransform$1(controller.group);
}
function getGlobalDirection1(controller, localDirName) {
	return {
		left: "w",
		right: "e",
		top: "n",
		bottom: "s"
	}[transformDirection({
		w: "left",
		e: "right",
		n: "top",
		s: "bottom"
	}[localDirName], getTransform(controller))];
}
function getGlobalDirection2(controller, localDirNameSeq) {
	var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];
	(globalDir[0] === "e" || globalDir[0] === "w") && globalDir.reverse();
	return globalDir.join("");
}
function driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {
	var brushOption = cover.__brushOption;
	var rectRange = rectRangeConverter.toRectRange(brushOption.range);
	var localDelta = toLocalDelta(controller, dx, dy);
	each(dirNameSequence, function(dirName) {
		var ind = DIRECTION_MAP[dirName];
		rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
	});
	brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
	updateCoverAfterCreation(controller, cover);
	trigger(controller, { isEnd: false });
}
function driftPolygon(controller, cover, dx, dy) {
	var range = cover.__brushOption.range;
	var localDelta = toLocalDelta(controller, dx, dy);
	each(range, function(point) {
		point[0] += localDelta[0];
		point[1] += localDelta[1];
	});
	updateCoverAfterCreation(controller, cover);
	trigger(controller, { isEnd: false });
}
function toLocalDelta(controller, dx, dy) {
	var thisGroup = controller.group;
	var localD = thisGroup.transformCoordToLocal(dx, dy);
	var localZero = thisGroup.transformCoordToLocal(0, 0);
	return [localD[0] - localZero[0], localD[1] - localZero[1]];
}
function clipByPanel(controller, cover, data) {
	var panel = getPanelByCover(controller, cover);
	return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone(data);
}
function pointsToRect(points$3) {
	var xmin = mathMin$2(points$3[0][0], points$3[1][0]);
	var ymin = mathMin$2(points$3[0][1], points$3[1][1]);
	var xmax = mathMax$2(points$3[0][0], points$3[1][0]);
	var ymax = mathMax$2(points$3[0][1], points$3[1][1]);
	return {
		x: xmin,
		y: ymin,
		width: xmax - xmin,
		height: ymax - ymin
	};
}
function resetCursor(controller, e$1, localCursorPoint) {
	if (!controller._brushType || isOutsideZrArea(controller, e$1.offsetX, e$1.offsetY)) return;
	var zr = controller._zr;
	var covers = controller._covers;
	var currPanel = getPanelByPoint(controller, e$1, localCursorPoint);
	if (!controller._dragging) for (var i$1 = 0; i$1 < covers.length; i$1++) {
		var brushOption = covers[i$1].__brushOption;
		if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i$1], localCursorPoint[0], localCursorPoint[1])) return;
	}
	currPanel && zr.setCursorStyle("crosshair");
}
function preventDefault(e$1) {
	var rawE = e$1.event;
	rawE.preventDefault && rawE.preventDefault();
}
function mainShapeContain(cover, x, y) {
	return cover.childOfName("main").contain(x, y);
}
function updateCoverByMouse(controller, e$1, localCursorPoint, isEnd) {
	var creatingCover = controller._creatingCover;
	var panel = controller._creatingPanel;
	var thisBrushOption = controller._brushOption;
	var eventParams;
	controller._track.push(localCursorPoint.slice());
	if (shouldShowCover(controller) || creatingCover) {
		if (panel && !creatingCover) {
			thisBrushOption.brushMode === "single" && clearCovers(controller);
			var brushOption = clone(thisBrushOption);
			brushOption.brushType = determineBrushType(brushOption.brushType, panel);
			brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;
			creatingCover = controller._creatingCover = createCover(controller, brushOption);
			controller._covers.push(creatingCover);
		}
		if (creatingCover) {
			var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
			var coverBrushOption = creatingCover.__brushOption;
			coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
			if (isEnd) {
				endCreating(controller, creatingCover);
				coverRenderer.updateCommon(controller, creatingCover);
			}
			updateCoverShape(controller, creatingCover);
			eventParams = { isEnd };
		}
	} else if (isEnd && thisBrushOption.brushMode === "single" && thisBrushOption.removeOnClick) {
		if (getPanelByPoint(controller, e$1, localCursorPoint) && clearCovers(controller)) eventParams = {
			isEnd,
			removeOnClick: true
		};
	}
	return eventParams;
}
function determineBrushType(brushType, panel) {
	if (brushType === "auto") {
		assert(panel && panel.defaultBrushType, "MUST have defaultBrushType when brushType is \"atuo\"");
		return panel.defaultBrushType;
	}
	return brushType;
}
var pointerHandlers = {
	mousedown: function(e$1) {
		if (this._dragging) handleDragEnd(this, e$1);
		else if (!e$1.target || !e$1.target.draggable) {
			preventDefault(e$1);
			var localCursorPoint = this.group.transformCoordToLocal(e$1.offsetX, e$1.offsetY);
			this._creatingCover = null;
			if (this._creatingPanel = getPanelByPoint(this, e$1, localCursorPoint)) {
				this._dragging = true;
				this._track = [localCursorPoint.slice()];
			}
		}
	},
	mousemove: function(e$1) {
		var x = e$1.offsetX;
		var y = e$1.offsetY;
		var localCursorPoint = this.group.transformCoordToLocal(x, y);
		resetCursor(this, e$1, localCursorPoint);
		if (this._dragging) {
			preventDefault(e$1);
			var eventParams = updateCoverByMouse(this, e$1, localCursorPoint, false);
			eventParams && trigger(this, eventParams);
		}
	},
	mouseup: function(e$1) {
		handleDragEnd(this, e$1);
	}
};
function handleDragEnd(controller, e$1) {
	if (controller._dragging) {
		preventDefault(e$1);
		var x = e$1.offsetX;
		var y = e$1.offsetY;
		var eventParams = updateCoverByMouse(controller, e$1, controller.group.transformCoordToLocal(x, y), true);
		controller._dragging = false;
		controller._track = [];
		controller._creatingCover = null;
		eventParams && trigger(controller, eventParams);
	}
}
function isOutsideZrArea(controller, x, y) {
	var zr = controller._zr;
	return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();
}
/**
* key: brushType
*/
var coverRenderers = {
	lineX: getLineRenderer(0),
	lineY: getLineRenderer(1),
	rect: {
		createCover: function(controller, brushOption) {
			function returnInput(range) {
				return range;
			}
			return createBaseRectCover({
				toRectRange: returnInput,
				fromRectRange: returnInput
			}, controller, brushOption, [
				["w"],
				["e"],
				["n"],
				["s"],
				["s", "e"],
				["s", "w"],
				["n", "e"],
				["n", "w"]
			]);
		},
		getCreatingRange: function(localTrack) {
			var ends = getTrackEnds(localTrack);
			return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
		},
		updateCoverShape: function(controller, cover, localRange, brushOption) {
			updateBaseRect(controller, cover, localRange, brushOption);
		},
		updateCommon: updateCommon$1,
		contain: mainShapeContain
	},
	polygon: {
		createCover: function(controller, brushOption) {
			var cover = new Group_default();
			cover.add(new Polyline_default({
				name: "main",
				style: makeStyle(brushOption),
				silent: true
			}));
			return cover;
		},
		getCreatingRange: function(localTrack) {
			return localTrack;
		},
		endCreating: function(controller, cover) {
			cover.remove(cover.childAt(0));
			cover.add(new Polygon_default({
				name: "main",
				draggable: true,
				drift: curry(driftPolygon, controller, cover),
				ondragend: curry(trigger, controller, { isEnd: true })
			}));
		},
		updateCoverShape: function(controller, cover, localRange, brushOption) {
			cover.childAt(0).setShape({ points: clipByPanel(controller, cover, localRange) });
		},
		updateCommon: updateCommon$1,
		contain: mainShapeContain
	}
};
function getLineRenderer(xyIndex) {
	return {
		createCover: function(controller, brushOption) {
			return createBaseRectCover({
				toRectRange: function(range) {
					var rectRange = [range, [0, 100]];
					xyIndex && rectRange.reverse();
					return rectRange;
				},
				fromRectRange: function(rectRange) {
					return rectRange[xyIndex];
				}
			}, controller, brushOption, [[["w"], ["e"]], [["n"], ["s"]]][xyIndex]);
		},
		getCreatingRange: function(localTrack) {
			var ends = getTrackEnds(localTrack);
			return [mathMin$2(ends[0][xyIndex], ends[1][xyIndex]), mathMax$2(ends[0][xyIndex], ends[1][xyIndex])];
		},
		updateCoverShape: function(controller, cover, localRange, brushOption) {
			var otherExtent;
			var panel = getPanelByCover(controller, cover);
			if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) otherExtent = panel.getLinearBrushOtherExtent(xyIndex);
			else {
				var zr = controller._zr;
				otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
			}
			var rectRange = [localRange, otherExtent];
			xyIndex && rectRange.reverse();
			updateBaseRect(controller, cover, rectRange, brushOption);
		},
		updateCommon: updateCommon$1,
		contain: mainShapeContain
	};
}
var BrushController_default = BrushController;

//#endregion
//#region node_modules/echarts/lib/component/helper/brushHelper.js
function makeRectPanelClipPath(rect) {
	rect = normalizeRect(rect);
	return function(localPoints) {
		return clipPointsByRect(localPoints, rect);
	};
}
function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
	rect = normalizeRect(rect);
	return function(xyIndex) {
		var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
		var brushWidth = idx ? rect.width : rect.height;
		var base$1 = idx ? rect.x : rect.y;
		return [base$1, base$1 + (brushWidth || 0)];
	};
}
function makeRectIsTargetByCursor(rect, api, targetModel) {
	var boundingRect = normalizeRect(rect);
	return function(e$1, localCursorPoint) {
		return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e$1, api, targetModel);
	};
}
function normalizeRect(rect) {
	return BoundingRect_default.create(rect);
}

//#endregion
//#region node_modules/echarts/lib/component/axis/ParallelAxisView.js
var ParallelAxisView = function(_super) {
	__extends(ParallelAxisView$1, _super);
	function ParallelAxisView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ParallelAxisView$1.type;
		return _this;
	}
	ParallelAxisView$1.prototype.init = function(ecModel, api) {
		_super.prototype.init.apply(this, arguments);
		(this._brushController = new BrushController_default(api.getZr())).on("brush", bind(this._onBrush, this));
	};
	ParallelAxisView$1.prototype.render = function(axisModel, ecModel, api, payload) {
		if (fromAxisAreaSelect(axisModel, ecModel, payload)) return;
		this.axisModel = axisModel;
		this.api = api;
		this.group.removeAll();
		var oldAxisGroup = this._axisGroup;
		this._axisGroup = new Group_default();
		this.group.add(this._axisGroup);
		if (!axisModel.get("show")) return;
		var coordSysModel = getCoordSysModel(axisModel, ecModel);
		var coordSys = coordSysModel.coordinateSystem;
		var areaSelectStyle = axisModel.getAreaSelectStyle();
		var areaWidth = areaSelectStyle.width;
		var dim = axisModel.axis.dim;
		var axisLayout = coordSys.getAxisLayout(dim);
		var builderOpt = extend({ strokeContainThreshold: areaWidth }, axisLayout);
		var axisBuilder = new AxisBuilder_default(axisModel, api, builderOpt);
		axisBuilder.build();
		this._axisGroup.add(axisBuilder.group);
		this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);
		groupTransition(oldAxisGroup, this._axisGroup, axisModel);
	};
	ParallelAxisView$1.prototype._refreshBrushController = function(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
		var extent = axisModel.axis.getExtent();
		var extentLen = extent[1] - extent[0];
		var extra = Math.min(30, Math.abs(extentLen) * .1);
		var rect = BoundingRect_default.create({
			x: extent[0],
			y: -areaWidth / 2,
			width: extentLen,
			height: areaWidth
		});
		rect.x -= extra;
		rect.width += 2 * extra;
		this._brushController.mount({
			enableGlobalPan: true,
			rotation: builderOpt.rotation,
			x: builderOpt.position[0],
			y: builderOpt.position[1]
		}).setPanels([{
			panelId: "pl",
			clipPath: makeRectPanelClipPath(rect),
			isTargetByCursor: makeRectIsTargetByCursor(rect, api, coordSysModel),
			getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect, 0)
		}]).enableBrush({
			brushType: "lineX",
			brushStyle: areaSelectStyle,
			removeOnClick: true
		}).updateCovers(getCoverInfoList(axisModel));
	};
	ParallelAxisView$1.prototype._onBrush = function(eventParam) {
		var coverInfoList = eventParam.areas;
		var axisModel = this.axisModel;
		var axis = axisModel.axis;
		var intervals = map(coverInfoList, function(coverInfo) {
			return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];
		});
		if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) this.api.dispatchAction({
			type: "axisAreaSelect",
			parallelAxisId: axisModel.id,
			intervals
		});
	};
	ParallelAxisView$1.prototype.dispose = function() {
		this._brushController.dispose();
	};
	ParallelAxisView$1.type = "parallelAxis";
	return ParallelAxisView$1;
}(Component_default$1);
function fromAxisAreaSelect(axisModel, ecModel, payload) {
	return payload && payload.type === "axisAreaSelect" && ecModel.findComponents({
		mainType: "parallelAxis",
		query: payload
	})[0] === axisModel;
}
function getCoverInfoList(axisModel) {
	var axis = axisModel.axis;
	return map(axisModel.activeIntervals, function(interval) {
		return {
			brushType: "lineX",
			panelId: "pl",
			range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
		};
	});
}
function getCoordSysModel(axisModel, ecModel) {
	return ecModel.getComponent("parallel", axisModel.get("parallelIndex"));
}
var ParallelAxisView_default = ParallelAxisView;

//#endregion
//#region node_modules/echarts/lib/component/axis/parallelAxisAction.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var actionInfo = {
	type: "axisAreaSelect",
	event: "axisAreaSelected"
};
function installParallelActions(registers) {
	registers.registerAction(actionInfo, function(payload, ecModel) {
		ecModel.eachComponent({
			mainType: "parallelAxis",
			query: payload
		}, function(parallelAxisModel) {
			parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
		});
	});
	/**
	* @payload
	*/
	registers.registerAction("parallelAxisExpand", function(payload, ecModel) {
		ecModel.eachComponent({
			mainType: "parallel",
			query: payload
		}, function(parallelModel) {
			parallelModel.setAxisExpand(payload);
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/component/parallel/install.js
var defaultAxisOption = {
	type: "value",
	areaSelectStyle: {
		width: 20,
		borderWidth: 1,
		borderColor: "rgba(160,197,232)",
		color: "rgba(160,197,232)",
		opacity: .3
	},
	realtime: true,
	z: 10
};
function install$29(registers) {
	registers.registerComponentView(ParallelView_default$1);
	registers.registerComponentModel(ParallelModel_default);
	registers.registerCoordinateSystem("parallel", parallelCreator_default);
	registers.registerPreprocessor(parallelPreprocessor);
	registers.registerComponentModel(AxisModel_default$1);
	registers.registerComponentView(ParallelAxisView_default);
	axisModelCreator(registers, "parallel", AxisModel_default$1, defaultAxisOption);
	installParallelActions(registers);
}

//#endregion
//#region node_modules/echarts/lib/chart/parallel/install.js
function install$14(registers) {
	use(install$29);
	registers.registerChartView(ParallelView_default);
	registers.registerSeriesModel(ParallelSeries_default);
	registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, parallelVisual_default);
}

//#endregion
//#region node_modules/echarts/lib/chart/sankey/SankeyView.js
var SankeyPathShape = function() {
	function SankeyPathShape$1() {
		this.x1 = 0;
		this.y1 = 0;
		this.x2 = 0;
		this.y2 = 0;
		this.cpx1 = 0;
		this.cpy1 = 0;
		this.cpx2 = 0;
		this.cpy2 = 0;
		this.extent = 0;
	}
	return SankeyPathShape$1;
}();
var SankeyPath = function(_super) {
	__extends(SankeyPath$1, _super);
	function SankeyPath$1(opts) {
		return _super.call(this, opts) || this;
	}
	SankeyPath$1.prototype.getDefaultShape = function() {
		return new SankeyPathShape();
	};
	SankeyPath$1.prototype.buildPath = function(ctx, shape) {
		var extent = shape.extent;
		ctx.moveTo(shape.x1, shape.y1);
		ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);
		if (shape.orient === "vertical") {
			ctx.lineTo(shape.x2 + extent, shape.y2);
			ctx.bezierCurveTo(shape.cpx2 + extent, shape.cpy2, shape.cpx1 + extent, shape.cpy1, shape.x1 + extent, shape.y1);
		} else {
			ctx.lineTo(shape.x2, shape.y2 + extent);
			ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent, shape.cpx1, shape.cpy1 + extent, shape.x1, shape.y1 + extent);
		}
		ctx.closePath();
	};
	SankeyPath$1.prototype.highlight = function() {
		enterEmphasis(this);
	};
	SankeyPath$1.prototype.downplay = function() {
		leaveEmphasis(this);
	};
	return SankeyPath$1;
}(Path_default);
var SankeyView = function(_super) {
	__extends(SankeyView$1, _super);
	function SankeyView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SankeyView$1.type;
		_this._mainGroup = new Group_default();
		_this._focusAdjacencyDisabled = false;
		return _this;
	}
	SankeyView$1.prototype.init = function(ecModel, api) {
		this._controller = new RoamController_default(api.getZr());
		this._controllerHost = { target: this.group };
		this.group.add(this._mainGroup);
	};
	SankeyView$1.prototype.render = function(seriesModel, ecModel, api) {
		var sankeyView = this;
		var graph = seriesModel.getGraph();
		var mainGroup = this._mainGroup;
		var layoutInfo = seriesModel.layoutInfo;
		var width = layoutInfo.width;
		var height = layoutInfo.height;
		var nodeData = seriesModel.getData();
		var edgeData = seriesModel.getData("edge");
		var orient = seriesModel.get("orient");
		this._model = seriesModel;
		mainGroup.removeAll();
		mainGroup.x = layoutInfo.x;
		mainGroup.y = layoutInfo.y;
		this._updateViewCoordSys(seriesModel, api);
		updateController(seriesModel, api, mainGroup, this._controller, this._controllerHost, null);
		graph.eachEdge(function(edge) {
			var curve = new SankeyPath();
			var ecData = getECData(curve);
			ecData.dataIndex = edge.dataIndex;
			ecData.seriesIndex = seriesModel.seriesIndex;
			ecData.dataType = "edge";
			var edgeModel = edge.getModel();
			var lineStyleModel = edgeModel.getModel("lineStyle");
			var curvature = lineStyleModel.get("curveness");
			var n1Layout = edge.node1.getLayout();
			var node1Model = edge.node1.getModel();
			var dragX1 = node1Model.get("localX");
			var dragY1 = node1Model.get("localY");
			var n2Layout = edge.node2.getLayout();
			var node2Model = edge.node2.getModel();
			var dragX2 = node2Model.get("localX");
			var dragY2 = node2Model.get("localY");
			var edgeLayout = edge.getLayout();
			var x1;
			var y1;
			var x2;
			var y2;
			var cpx1;
			var cpy1;
			var cpx2;
			var cpy2;
			curve.shape.extent = Math.max(1, edgeLayout.dy);
			curve.shape.orient = orient;
			if (orient === "vertical") {
				x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
				y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
				x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
				y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
				cpx1 = x1;
				cpy1 = y1 * (1 - curvature) + y2 * curvature;
				cpx2 = x2;
				cpy2 = y1 * curvature + y2 * (1 - curvature);
			} else {
				x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
				y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
				x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
				y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
				cpx1 = x1 * (1 - curvature) + x2 * curvature;
				cpy1 = y1;
				cpx2 = x1 * curvature + x2 * (1 - curvature);
				cpy2 = y2;
			}
			curve.setShape({
				x1,
				y1,
				x2,
				y2,
				cpx1,
				cpy1,
				cpx2,
				cpy2
			});
			curve.useStyle(lineStyleModel.getItemStyle());
			applyCurveStyle(curve.style, orient, edge);
			var defaultEdgeLabelText = "" + edgeModel.get("value");
			var edgeLabelStateModels = getLabelStatesModels(edgeModel, "edgeLabel");
			setLabelStyle(curve, edgeLabelStateModels, {
				labelFetcher: { getFormattedLabel: function(dataIndex, stateName, dataType, labelDimIndex, formatter, extendParams) {
					return seriesModel.getFormattedLabel(dataIndex, stateName, "edge", labelDimIndex, retrieve3(formatter, edgeLabelStateModels.normal && edgeLabelStateModels.normal.get("formatter"), defaultEdgeLabelText), extendParams);
				} },
				labelDataIndex: edge.dataIndex,
				defaultText: defaultEdgeLabelText
			});
			curve.setTextConfig({ position: "inside" });
			var emphasisModel = edgeModel.getModel("emphasis");
			setStatesStylesFromModel(curve, edgeModel, "lineStyle", function(model) {
				var style = model.getItemStyle();
				applyCurveStyle(style, orient, edge);
				return style;
			});
			mainGroup.add(curve);
			edgeData.setItemGraphicEl(edge.dataIndex, curve);
			var focus = emphasisModel.get("focus");
			toggleHoverEmphasis(curve, focus === "adjacency" ? edge.getAdjacentDataIndices() : focus === "trajectory" ? edge.getTrajectoryDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
		});
		graph.eachNode(function(node) {
			var layout$3 = node.getLayout();
			var itemModel = node.getModel();
			var dragX = itemModel.get("localX");
			var dragY = itemModel.get("localY");
			var emphasisModel = itemModel.getModel("emphasis");
			var borderRadius = itemModel.get(["itemStyle", "borderRadius"]) || 0;
			var rect = new Rect_default({
				shape: {
					x: dragX != null ? dragX * width : layout$3.x,
					y: dragY != null ? dragY * height : layout$3.y,
					width: layout$3.dx,
					height: layout$3.dy,
					r: borderRadius
				},
				style: itemModel.getModel("itemStyle").getItemStyle(),
				z2: 10
			});
			setLabelStyle(rect, getLabelStatesModels(itemModel), {
				labelFetcher: { getFormattedLabel: function(dataIndex, stateName) {
					return seriesModel.getFormattedLabel(dataIndex, stateName, "node");
				} },
				labelDataIndex: node.dataIndex,
				defaultText: node.id
			});
			rect.disableLabelAnimation = true;
			rect.setStyle("fill", node.getVisual("color"));
			rect.setStyle("decal", node.getVisual("style").decal);
			setStatesStylesFromModel(rect, itemModel);
			mainGroup.add(rect);
			nodeData.setItemGraphicEl(node.dataIndex, rect);
			getECData(rect).dataType = "node";
			var focus = emphasisModel.get("focus");
			toggleHoverEmphasis(rect, focus === "adjacency" ? node.getAdjacentDataIndices() : focus === "trajectory" ? node.getTrajectoryDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
		});
		nodeData.eachItemGraphicEl(function(el, dataIndex) {
			if (nodeData.getItemModel(dataIndex).get("draggable")) {
				el.drift = function(dx, dy) {
					sankeyView._focusAdjacencyDisabled = true;
					this.shape.x += dx;
					this.shape.y += dy;
					this.dirty();
					api.dispatchAction({
						type: "dragNode",
						seriesId: seriesModel.id,
						dataIndex: nodeData.getRawIndex(dataIndex),
						localX: this.shape.x / width,
						localY: this.shape.y / height
					});
				};
				el.ondragend = function() {
					sankeyView._focusAdjacencyDisabled = false;
				};
				el.draggable = true;
				el.cursor = "move";
			}
		});
		if (!this._data && seriesModel.isAnimationEnabled()) mainGroup.setClipPath(createGridClipShape$1(mainGroup.getBoundingRect(), seriesModel, function() {
			mainGroup.removeClipPath();
		}));
		this._data = seriesModel.getData();
	};
	SankeyView$1.prototype.dispose = function() {
		this._controller && this._controller.dispose();
		this._controllerHost = null;
	};
	SankeyView$1.prototype._updateViewCoordSys = function(seriesModel, api) {
		var layoutInfo = seriesModel.layoutInfo;
		var width = layoutInfo.width;
		var height = layoutInfo.height;
		var viewCoordSys = seriesModel.coordinateSystem = new View_default(null, {
			api,
			ecModel: seriesModel.ecModel
		});
		viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
		viewCoordSys.setBoundingRect(0, 0, width, height);
		viewCoordSys.setCenter(seriesModel.get("center"));
		viewCoordSys.setZoom(seriesModel.get("zoom"));
		this._controllerHost.target.attr({
			x: viewCoordSys.x,
			y: viewCoordSys.y,
			scaleX: viewCoordSys.scaleX,
			scaleY: viewCoordSys.scaleY
		});
	};
	SankeyView$1.type = "sankey";
	return SankeyView$1;
}(Chart_default);
/**
* Special color, use source node color or target node color
* @param curveProps curve's style to parse
* @param orient direction
* @param edge current curve data
*/
function applyCurveStyle(curveProps, orient, edge) {
	switch (curveProps.fill) {
		case "source":
			curveProps.fill = edge.node1.getVisual("color");
			curveProps.decal = edge.node1.getVisual("style").decal;
			break;
		case "target":
			curveProps.fill = edge.node2.getVisual("color");
			curveProps.decal = edge.node2.getVisual("style").decal;
			break;
		case "gradient":
			var sourceColor = edge.node1.getVisual("color");
			var targetColor = edge.node2.getVisual("color");
			if (isString(sourceColor) && isString(targetColor)) curveProps.fill = new LinearGradient_default(0, 0, +(orient === "horizontal"), +(orient === "vertical"), [{
				color: sourceColor,
				offset: 0
			}, {
				color: targetColor,
				offset: 1
			}]);
	}
}
function createGridClipShape$1(rect, seriesModel, cb) {
	var rectEl = new Rect_default({ shape: {
		x: rect.x - 10,
		y: rect.y - 10,
		width: 0,
		height: rect.height + 20
	} });
	initProps(rectEl, { shape: { width: rect.width + 20 } }, seriesModel, cb);
	return rectEl;
}
var SankeyView_default = SankeyView;

//#endregion
//#region node_modules/echarts/lib/chart/sankey/SankeySeries.js
var SankeySeriesModel = function(_super) {
	__extends(SankeySeriesModel$1, _super);
	function SankeySeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SankeySeriesModel$1.type;
		return _this;
	}
	/**
	* Init a graph data structure from data in option series
	*/
	SankeySeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		var links = option.edges || option.links || [];
		var nodes = option.data || option.nodes || [];
		var levels = option.levels || [];
		this.levelModels = [];
		var levelModels = this.levelModels;
		for (var i$1 = 0; i$1 < levels.length; i$1++) if (levels[i$1].depth != null && levels[i$1].depth >= 0) levelModels[levels[i$1].depth] = new Model_default(levels[i$1], this, ecModel);
		else throw new Error("levels[i].depth is mandatory and should be natural number");
		return createGraphFromNodeEdge(nodes, links, this, true, beforeLink).data;
		function beforeLink(nodeData, edgeData) {
			nodeData.wrapMethod("getItemModel", function(model, idx) {
				var seriesModel = model.parentModel;
				var layout$3 = seriesModel.getData().getItemLayout(idx);
				if (layout$3) {
					var nodeDepth = layout$3.depth;
					var levelModel = seriesModel.levelModels[nodeDepth];
					if (levelModel) model.parentModel = levelModel;
				}
				return model;
			});
			edgeData.wrapMethod("getItemModel", function(model, idx) {
				var seriesModel = model.parentModel;
				var layout$3 = seriesModel.getGraph().getEdgeByIndex(idx).node1.getLayout();
				if (layout$3) {
					var depth = layout$3.depth;
					var levelModel = seriesModel.levelModels[depth];
					if (levelModel) model.parentModel = levelModel;
				}
				return model;
			});
		}
	};
	SankeySeriesModel$1.prototype.setNodePosition = function(dataIndex, localPosition) {
		var dataItem = (this.option.data || this.option.nodes)[dataIndex];
		dataItem.localX = localPosition[0];
		dataItem.localY = localPosition[1];
	};
	SankeySeriesModel$1.prototype.setCenter = function(center$2) {
		this.option.center = center$2;
	};
	SankeySeriesModel$1.prototype.setZoom = function(zoom) {
		this.option.zoom = zoom;
	};
	/**
	* Return the graphic data structure
	*
	* @return graphic data structure
	*/
	SankeySeriesModel$1.prototype.getGraph = function() {
		return this.getData().graph;
	};
	/**
	* Get edge data of graphic data structure
	*
	* @return data structure of list
	*/
	SankeySeriesModel$1.prototype.getEdgeData = function() {
		return this.getGraph().edgeData;
	};
	SankeySeriesModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		function noValue(val) {
			return isNaN(val) || val == null;
		}
		if (dataType === "edge") {
			var params = this.getDataParams(dataIndex, dataType);
			var rawDataOpt = params.data;
			var edgeValue = params.value;
			return createTooltipMarkup("nameValue", {
				name: rawDataOpt.source + " -- " + rawDataOpt.target,
				value: edgeValue,
				noValue: noValue(edgeValue)
			});
		} else {
			var value = this.getGraph().getNodeByIndex(dataIndex).getLayout().value;
			var name_1 = this.getDataParams(dataIndex, dataType).data.name;
			return createTooltipMarkup("nameValue", {
				name: name_1 != null ? name_1 + "" : null,
				value,
				noValue: noValue(value)
			});
		}
	};
	SankeySeriesModel$1.prototype.optionUpdated = function() {};
	SankeySeriesModel$1.prototype.getDataParams = function(dataIndex, dataType) {
		var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);
		if (params.value == null && dataType === "node") params.value = this.getGraph().getNodeByIndex(dataIndex).getLayout().value;
		return params;
	};
	SankeySeriesModel$1.type = "series.sankey";
	SankeySeriesModel$1.layoutMode = "box";
	SankeySeriesModel$1.defaultOption = {
		z: 2,
		coordinateSystemUsage: "box",
		left: "5%",
		top: "5%",
		right: "20%",
		bottom: "5%",
		orient: "horizontal",
		nodeWidth: 20,
		nodeGap: 8,
		draggable: true,
		layoutIterations: 32,
		roam: false,
		roamTrigger: "global",
		center: null,
		zoom: 1,
		label: {
			show: true,
			position: "right",
			fontSize: 12
		},
		edgeLabel: {
			show: false,
			fontSize: 12
		},
		levels: [],
		nodeAlign: "justify",
		lineStyle: {
			color: tokens_default.color.neutral50,
			opacity: .2,
			curveness: .5
		},
		emphasis: {
			label: { show: true },
			lineStyle: { opacity: .5 }
		},
		select: { itemStyle: { borderColor: tokens_default.color.primary } },
		animationEasing: "linear",
		animationDuration: 1e3
	};
	return SankeySeriesModel$1;
}(Series_default);
var SankeySeries_default = SankeySeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/sankey/sankeyLayout.js
function sankeyLayout(ecModel, api) {
	ecModel.eachSeriesByType("sankey", function(seriesModel) {
		var nodeWidth = seriesModel.get("nodeWidth");
		var nodeGap = seriesModel.get("nodeGap");
		var refContainer = createBoxLayoutReference(seriesModel, api).refContainer;
		var layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), refContainer);
		seriesModel.layoutInfo = layoutInfo;
		var width = layoutInfo.width;
		var height = layoutInfo.height;
		var graph = seriesModel.getGraph();
		var nodes = graph.nodes;
		var edges = graph.edges;
		computeNodeValues(nodes);
		layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, filter(nodes, function(node) {
			return node.getLayout().value === 0;
		}).length !== 0 ? 0 : seriesModel.get("layoutIterations"), seriesModel.get("orient"), seriesModel.get("nodeAlign"));
	});
}
function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
	computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);
	computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);
	computeEdgeDepths(nodes, orient);
}
/**
* Compute the value of each node by summing the associated edge's value
*/
function computeNodeValues(nodes) {
	each(nodes, function(node) {
		var value1 = sum(node.outEdges, getEdgeValue);
		var value2 = sum(node.inEdges, getEdgeValue);
		var nodeRawValue = node.getValue() || 0;
		var value = Math.max(value1, value2, nodeRawValue);
		node.setLayout({ value }, true);
	});
}
/**
* Compute the x-position for each node.
*
* Here we use Kahn algorithm to detect cycle when we traverse
* the node to computer the initial x position.
*/
function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
	var remainEdges = [];
	var indegreeArr = [];
	var zeroIndegrees = [];
	var nextTargetNode = [];
	var x = 0;
	for (var i$1 = 0; i$1 < edges.length; i$1++) remainEdges[i$1] = 1;
	for (var i$1 = 0; i$1 < nodes.length; i$1++) {
		indegreeArr[i$1] = nodes[i$1].inEdges.length;
		if (indegreeArr[i$1] === 0) zeroIndegrees.push(nodes[i$1]);
	}
	var maxNodeDepth = -1;
	while (zeroIndegrees.length) {
		for (var idx = 0; idx < zeroIndegrees.length; idx++) {
			var node = zeroIndegrees[idx];
			var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
			var isItemDepth = item.depth != null && item.depth >= 0;
			if (isItemDepth && item.depth > maxNodeDepth) maxNodeDepth = item.depth;
			node.setLayout({ depth: isItemDepth ? item.depth : x }, true);
			orient === "vertical" ? node.setLayout({ dy: nodeWidth }, true) : node.setLayout({ dx: nodeWidth }, true);
			for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
				var edge = node.outEdges[edgeIdx];
				var indexEdge = edges.indexOf(edge);
				remainEdges[indexEdge] = 0;
				var targetNode = edge.node2;
				var nodeIndex = nodes.indexOf(targetNode);
				if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) nextTargetNode.push(targetNode);
			}
		}
		++x;
		zeroIndegrees = nextTargetNode;
		nextTargetNode = [];
	}
	for (var i$1 = 0; i$1 < remainEdges.length; i$1++) if (remainEdges[i$1] === 1) throw new Error("Sankey is a DAG, the original data has cycle!");
	var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;
	if (nodeAlign && nodeAlign !== "left") adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);
	scaleNodeBreadths(nodes, orient === "vertical" ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth, orient);
}
function isNodeDepth(node) {
	var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
	return item.depth != null && item.depth >= 0;
}
function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {
	if (nodeAlign === "right") {
		var nextSourceNode = [];
		var remainNodes = nodes;
		var nodeHeight = 0;
		while (remainNodes.length) {
			for (var i$1 = 0; i$1 < remainNodes.length; i$1++) {
				var node = remainNodes[i$1];
				node.setLayout({ skNodeHeight: nodeHeight }, true);
				for (var j = 0; j < node.inEdges.length; j++) {
					var edge = node.inEdges[j];
					if (nextSourceNode.indexOf(edge.node1) < 0) nextSourceNode.push(edge.node1);
				}
			}
			remainNodes = nextSourceNode;
			nextSourceNode = [];
			++nodeHeight;
		}
		each(nodes, function(node$1) {
			if (!isNodeDepth(node$1)) node$1.setLayout({ depth: Math.max(0, maxDepth - node$1.getLayout().skNodeHeight) }, true);
		});
	} else if (nodeAlign === "justify") moveSinksRight(nodes, maxDepth);
}
/**
* All the node without outEgdes are assigned maximum x-position and
*     be aligned in the last column.
*
* @param nodes.  node of sankey view.
* @param maxDepth.  use to assign to node without outEdges as x-position.
*/
function moveSinksRight(nodes, maxDepth) {
	each(nodes, function(node) {
		if (!isNodeDepth(node) && !node.outEdges.length) node.setLayout({ depth: maxDepth }, true);
	});
}
/**
* Scale node x-position to the width
*
* @param nodes  node of sankey view
* @param kx   multiple used to scale nodes
*/
function scaleNodeBreadths(nodes, kx, orient) {
	each(nodes, function(node) {
		var nodeDepth = node.getLayout().depth * kx;
		orient === "vertical" ? node.setLayout({ y: nodeDepth }, true) : node.setLayout({ x: nodeDepth }, true);
	});
}
/**
* Using Gauss-Seidel iterations method to compute the node depth(y-position)
*
* @param nodes  node of sankey view
* @param edges  edge of sankey view
* @param height  the whole height of the area to draw the view
* @param nodeGap  the vertical distance between two nodes
*     in the same column.
* @param iterations  the number of iterations for the algorithm
*/
function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {
	var nodesByBreadth = prepareNodesByBreadth(nodes, orient);
	initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);
	resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
	for (var alpha = 1; iterations > 0; iterations--) {
		alpha *= .99;
		relaxRightToLeft(nodesByBreadth, alpha, orient);
		resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
		relaxLeftToRight(nodesByBreadth, alpha, orient);
		resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
	}
}
function prepareNodesByBreadth(nodes, orient) {
	var nodesByBreadth = [];
	var keyAttr = orient === "vertical" ? "y" : "x";
	var groupResult = groupData(nodes, function(node) {
		return node.getLayout()[keyAttr];
	});
	groupResult.keys.sort(function(a, b) {
		return a - b;
	});
	each(groupResult.keys, function(key$1) {
		nodesByBreadth.push(groupResult.buckets.get(key$1));
	});
	return nodesByBreadth;
}
/**
* Compute the original y-position for each node
*/
function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {
	var minKy = Infinity;
	each(nodesByBreadth, function(nodes) {
		var n = nodes.length;
		var sum$1 = 0;
		each(nodes, function(node) {
			sum$1 += node.getLayout().value;
		});
		var ky = orient === "vertical" ? (width - (n - 1) * nodeGap) / sum$1 : (height - (n - 1) * nodeGap) / sum$1;
		if (ky < minKy) minKy = ky;
	});
	each(nodesByBreadth, function(nodes) {
		each(nodes, function(node, i$1) {
			var nodeDy = node.getLayout().value * minKy;
			if (orient === "vertical") {
				node.setLayout({ x: i$1 }, true);
				node.setLayout({ dx: nodeDy }, true);
			} else {
				node.setLayout({ y: i$1 }, true);
				node.setLayout({ dy: nodeDy }, true);
			}
		});
	});
	each(edges, function(edge) {
		var edgeDy = +edge.getValue() * minKy;
		edge.setLayout({ dy: edgeDy }, true);
	});
}
/**
* Resolve the collision of initialized depth (y-position)
*/
function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {
	var keyAttr = orient === "vertical" ? "x" : "y";
	each(nodesByBreadth, function(nodes) {
		nodes.sort(function(a, b) {
			return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
		});
		var nodeX;
		var node;
		var dy;
		var y0 = 0;
		var n = nodes.length;
		var nodeDyAttr = orient === "vertical" ? "dx" : "dy";
		for (var i$1 = 0; i$1 < n; i$1++) {
			node = nodes[i$1];
			dy = y0 - node.getLayout()[keyAttr];
			if (dy > 0) {
				nodeX = node.getLayout()[keyAttr] + dy;
				orient === "vertical" ? node.setLayout({ x: nodeX }, true) : node.setLayout({ y: nodeX }, true);
			}
			y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
		}
		var viewWidth = orient === "vertical" ? width : height;
		dy = y0 - nodeGap - viewWidth;
		if (dy > 0) {
			nodeX = node.getLayout()[keyAttr] - dy;
			orient === "vertical" ? node.setLayout({ x: nodeX }, true) : node.setLayout({ y: nodeX }, true);
			y0 = nodeX;
			for (var i$1 = n - 2; i$1 >= 0; --i$1) {
				node = nodes[i$1];
				dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;
				if (dy > 0) {
					nodeX = node.getLayout()[keyAttr] - dy;
					orient === "vertical" ? node.setLayout({ x: nodeX }, true) : node.setLayout({ y: nodeX }, true);
				}
				y0 = node.getLayout()[keyAttr];
			}
		}
	});
}
/**
* Change the y-position of the nodes, except most the right side nodes
* @param nodesByBreadth
* @param alpha  parameter used to adjust the nodes y-position
*/
function relaxRightToLeft(nodesByBreadth, alpha, orient) {
	each(nodesByBreadth.slice().reverse(), function(nodes) {
		each(nodes, function(node) {
			if (node.outEdges.length) {
				var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue);
				if (isNaN(y)) {
					var len$1 = node.outEdges.length;
					y = len$1 ? sum(node.outEdges, centerTarget, orient) / len$1 : 0;
				}
				if (orient === "vertical") {
					var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
					node.setLayout({ x: nodeX }, true);
				} else {
					var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
					node.setLayout({ y: nodeY }, true);
				}
			}
		});
	});
}
function weightedTarget(edge, orient) {
	return center(edge.node2, orient) * edge.getValue();
}
function centerTarget(edge, orient) {
	return center(edge.node2, orient);
}
function weightedSource(edge, orient) {
	return center(edge.node1, orient) * edge.getValue();
}
function centerSource(edge, orient) {
	return center(edge.node1, orient);
}
function center(node, orient) {
	return orient === "vertical" ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
}
function getEdgeValue(edge) {
	return edge.getValue();
}
function sum(array, cb, orient) {
	var sum$1 = 0;
	var len$1 = array.length;
	var i$1 = -1;
	while (++i$1 < len$1) {
		var value = +cb(array[i$1], orient);
		if (!isNaN(value)) sum$1 += value;
	}
	return sum$1;
}
/**
* Change the y-position of the nodes, except most the left side nodes
*/
function relaxLeftToRight(nodesByBreadth, alpha, orient) {
	each(nodesByBreadth, function(nodes) {
		each(nodes, function(node) {
			if (node.inEdges.length) {
				var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue);
				if (isNaN(y)) {
					var len$1 = node.inEdges.length;
					y = len$1 ? sum(node.inEdges, centerSource, orient) / len$1 : 0;
				}
				if (orient === "vertical") {
					var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
					node.setLayout({ x: nodeX }, true);
				} else {
					var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
					node.setLayout({ y: nodeY }, true);
				}
			}
		});
	});
}
/**
* Compute the depth(y-position) of each edge
*/
function computeEdgeDepths(nodes, orient) {
	var keyAttr = orient === "vertical" ? "x" : "y";
	each(nodes, function(node) {
		node.outEdges.sort(function(a, b) {
			return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
		});
		node.inEdges.sort(function(a, b) {
			return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
		});
	});
	each(nodes, function(node) {
		var sy = 0;
		var ty = 0;
		each(node.outEdges, function(edge) {
			edge.setLayout({ sy }, true);
			sy += edge.getLayout().dy;
		});
		each(node.inEdges, function(edge) {
			edge.setLayout({ ty }, true);
			ty += edge.getLayout().dy;
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/sankey/sankeyVisual.js
function sankeyVisual(ecModel) {
	ecModel.eachSeriesByType("sankey", function(seriesModel) {
		var graph = seriesModel.getGraph();
		var nodes = graph.nodes;
		var edges = graph.edges;
		if (nodes.length) {
			var minValue_1 = Infinity;
			var maxValue_1 = -Infinity;
			each(nodes, function(node) {
				var nodeValue = node.getLayout().value;
				if (nodeValue < minValue_1) minValue_1 = nodeValue;
				if (nodeValue > maxValue_1) maxValue_1 = nodeValue;
			});
			each(nodes, function(node) {
				var mapValueToColor = new VisualMapping_default({
					type: "color",
					mappingMethod: "linear",
					dataExtent: [minValue_1, maxValue_1],
					visual: seriesModel.get("color")
				}).mapValueToVisual(node.getLayout().value);
				var customColor = node.getModel().get(["itemStyle", "color"]);
				if (customColor != null) {
					node.setVisual("color", customColor);
					node.setVisual("style", { fill: customColor });
				} else {
					node.setVisual("color", mapValueToColor);
					node.setVisual("style", { fill: mapValueToColor });
				}
			});
		}
		if (edges.length) each(edges, function(edge) {
			var edgeStyle = edge.getModel().get("lineStyle");
			edge.setVisual("style", edgeStyle);
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/sankey/install.js
function install$15(registers) {
	registers.registerChartView(SankeyView_default);
	registers.registerSeriesModel(SankeySeries_default);
	registers.registerLayout(sankeyLayout);
	registers.registerVisual(sankeyVisual);
	registers.registerAction({
		type: "dragNode",
		event: "dragnode",
		update: "update"
	}, function(payload, ecModel) {
		ecModel.eachComponent({
			mainType: "series",
			subType: "sankey",
			query: payload
		}, function(seriesModel) {
			seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
		});
	});
	registers.registerAction({
		type: "sankeyRoam",
		event: "sankeyRoam",
		update: "none"
	}, function(payload, ecModel, api) {
		ecModel.eachComponent({
			mainType: "series",
			subType: "sankey",
			query: payload
		}, function(seriesModel) {
			var coordSys = seriesModel.coordinateSystem;
			var res = updateCenterAndZoomInAction(coordSys, payload, seriesModel.get("scaleLimit"));
			seriesModel.setCenter(res.center);
			seriesModel.setZoom(res.zoom);
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js
var WhiskerBoxCommonMixin = function() {
	function WhiskerBoxCommonMixin$1() {}
	/**
	* @private
	*/
	WhiskerBoxCommonMixin$1.prototype._hasEncodeRule = function(key$1) {
		var encodeRules = this.getEncode();
		return encodeRules && encodeRules.get(key$1) != null;
	};
	/**
	* @override
	*/
	WhiskerBoxCommonMixin$1.prototype.getInitialData = function(option, ecModel) {
		var ordinalMeta;
		var xAxisModel = ecModel.getComponent("xAxis", this.get("xAxisIndex"));
		var yAxisModel = ecModel.getComponent("yAxis", this.get("yAxisIndex"));
		var xAxisType = xAxisModel.get("type");
		var yAxisType = yAxisModel.get("type");
		var addOrdinal;
		if (xAxisType === "category") {
			option.layout = "horizontal";
			ordinalMeta = xAxisModel.getOrdinalMeta();
			addOrdinal = !this._hasEncodeRule("x");
		} else if (yAxisType === "category") {
			option.layout = "vertical";
			ordinalMeta = yAxisModel.getOrdinalMeta();
			addOrdinal = !this._hasEncodeRule("y");
		} else option.layout = option.layout || "horizontal";
		var coordDims = ["x", "y"];
		var baseAxisDimIndex = option.layout === "horizontal" ? 0 : 1;
		var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
		var otherAxisDim = coordDims[1 - baseAxisDimIndex];
		var axisModels = [xAxisModel, yAxisModel];
		var baseAxisType = axisModels[baseAxisDimIndex].get("type");
		var otherAxisType = axisModels[1 - baseAxisDimIndex].get("type");
		var data = option.data;
		if (data && addOrdinal) {
			var newOptionData_1 = [];
			each(data, function(item, index) {
				var newItem;
				if (isArray(item)) {
					newItem = item.slice();
					item.unshift(index);
				} else if (isArray(item.value)) {
					newItem = extend({}, item);
					newItem.value = newItem.value.slice();
					item.value.unshift(index);
				} else newItem = item;
				newOptionData_1.push(newItem);
			});
			option.data = newOptionData_1;
		}
		var defaultValueDimensions = this.defaultValueDimensions;
		var coordDimensions = [{
			name: baseAxisDim,
			type: getDimensionTypeByAxis(baseAxisType),
			ordinalMeta,
			otherDims: {
				tooltip: false,
				itemName: 0
			},
			dimsDef: ["base"]
		}, {
			name: otherAxisDim,
			type: getDimensionTypeByAxis(otherAxisType),
			dimsDef: defaultValueDimensions.slice()
		}];
		return createSeriesDataSimply(this, {
			coordDimensions,
			dimensionsCount: defaultValueDimensions.length + 1,
			encodeDefaulter: curry(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
		});
	};
	/**
	* If horizontal, base axis is x, otherwise y.
	* @override
	*/
	WhiskerBoxCommonMixin$1.prototype.getBaseAxis = function() {
		var dim = this._baseAxisDim;
		return this.ecModel.getComponent(dim + "Axis", this.get(dim + "AxisIndex")).axis;
	};
	return WhiskerBoxCommonMixin$1;
}();

//#endregion
//#region node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js
var BoxplotSeriesModel = function(_super) {
	__extends(BoxplotSeriesModel$1, _super);
	function BoxplotSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = BoxplotSeriesModel$1.type;
		/**
		* @see <https://en.wikipedia.org/wiki/Box_plot>
		* The meanings of 'min' and 'max' depend on user,
		* and echarts do not need to know it.
		* @readOnly
		*/
		_this.defaultValueDimensions = [
			{
				name: "min",
				defaultTooltip: true
			},
			{
				name: "Q1",
				defaultTooltip: true
			},
			{
				name: "median",
				defaultTooltip: true
			},
			{
				name: "Q3",
				defaultTooltip: true
			},
			{
				name: "max",
				defaultTooltip: true
			}
		];
		_this.visualDrawType = "stroke";
		return _this;
	}
	BoxplotSeriesModel$1.type = "series.boxplot";
	BoxplotSeriesModel$1.dependencies = [
		"xAxis",
		"yAxis",
		"grid"
	];
	BoxplotSeriesModel$1.defaultOption = {
		z: 2,
		coordinateSystem: "cartesian2d",
		legendHoverLink: true,
		layout: null,
		boxWidth: [7, 50],
		itemStyle: {
			color: tokens_default.color.neutral00,
			borderWidth: 1
		},
		emphasis: {
			scale: true,
			itemStyle: {
				borderWidth: 2,
				shadowBlur: 5,
				shadowOffsetX: 1,
				shadowOffsetY: 1,
				shadowColor: tokens_default.color.shadow
			}
		},
		animationDuration: 800
	};
	return BoxplotSeriesModel$1;
}(Series_default);
mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, true);
var BoxplotSeries_default = BoxplotSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/boxplot/BoxplotView.js
var BoxplotView = function(_super) {
	__extends(BoxplotView$1, _super);
	function BoxplotView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = BoxplotView$1.type;
		return _this;
	}
	BoxplotView$1.prototype.render = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		var group = this.group;
		var oldData = this._data;
		if (!this._data) group.removeAll();
		var constDim = seriesModel.get("layout") === "horizontal" ? 1 : 0;
		data.diff(oldData).add(function(newIdx) {
			if (data.hasValue(newIdx)) {
				var symbolEl = createNormalBox$1(data.getItemLayout(newIdx), data, newIdx, constDim, true);
				data.setItemGraphicEl(newIdx, symbolEl);
				group.add(symbolEl);
			}
		}).update(function(newIdx, oldIdx) {
			var symbolEl = oldData.getItemGraphicEl(oldIdx);
			if (!data.hasValue(newIdx)) {
				group.remove(symbolEl);
				return;
			}
			var itemLayout = data.getItemLayout(newIdx);
			if (!symbolEl) symbolEl = createNormalBox$1(itemLayout, data, newIdx, constDim);
			else {
				saveOldStyle(symbolEl);
				updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
			}
			group.add(symbolEl);
			data.setItemGraphicEl(newIdx, symbolEl);
		}).remove(function(oldIdx) {
			var el = oldData.getItemGraphicEl(oldIdx);
			el && group.remove(el);
		}).execute();
		this._data = data;
	};
	BoxplotView$1.prototype.remove = function(ecModel) {
		var group = this.group;
		var data = this._data;
		this._data = null;
		data && data.eachItemGraphicEl(function(el) {
			el && group.remove(el);
		});
	};
	BoxplotView$1.type = "boxplot";
	return BoxplotView$1;
}(Chart_default);
var BoxPathShape = function() {
	function BoxPathShape$1() {}
	return BoxPathShape$1;
}();
var BoxPath = function(_super) {
	__extends(BoxPath$1, _super);
	function BoxPath$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this.type = "boxplotBoxPath";
		return _this;
	}
	BoxPath$1.prototype.getDefaultShape = function() {
		return new BoxPathShape();
	};
	BoxPath$1.prototype.buildPath = function(ctx, shape) {
		var ends = shape.points;
		var i$1 = 0;
		ctx.moveTo(ends[i$1][0], ends[i$1][1]);
		i$1++;
		for (; i$1 < 4; i$1++) ctx.lineTo(ends[i$1][0], ends[i$1][1]);
		ctx.closePath();
		for (; i$1 < ends.length; i$1++) {
			ctx.moveTo(ends[i$1][0], ends[i$1][1]);
			i$1++;
			ctx.lineTo(ends[i$1][0], ends[i$1][1]);
		}
	};
	return BoxPath$1;
}(Path_default);
function createNormalBox$1(itemLayout, data, dataIndex, constDim, isInit) {
	var ends = itemLayout.ends;
	var el = new BoxPath({ shape: { points: isInit ? transInit$1(ends, constDim, itemLayout) : ends } });
	updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
	return el;
}
function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
	var seriesModel = data.hostModel;
	var updateMethod = graphic_exports$1[isInit ? "initProps" : "updateProps"];
	updateMethod(el, { shape: { points: itemLayout.ends } }, seriesModel, dataIndex);
	el.useStyle(data.getItemVisual(dataIndex, "style"));
	el.style.strokeNoScale = true;
	el.z2 = 100;
	var itemModel = data.getItemModel(dataIndex);
	var emphasisModel = itemModel.getModel("emphasis");
	setStatesStylesFromModel(el, itemModel);
	toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function transInit$1(points$3, dim, itemLayout) {
	return map(points$3, function(point) {
		point = point.slice();
		point[dim] = itemLayout.initBaseline;
		return point;
	});
}
var BoxplotView_default = BoxplotView;

//#endregion
//#region node_modules/echarts/lib/chart/boxplot/boxplotLayout.js
var each$10 = each;
function boxplotLayout(ecModel) {
	each$10(groupSeriesByAxis(ecModel), function(groupItem) {
		var seriesModels = groupItem.seriesModels;
		if (!seriesModels.length) return;
		calculateBase(groupItem);
		each$10(seriesModels, function(seriesModel, idx) {
			layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
		});
	});
}
/**
* Group series by axis.
*/
function groupSeriesByAxis(ecModel) {
	var result = [];
	var axisList = [];
	ecModel.eachSeriesByType("boxplot", function(seriesModel) {
		var baseAxis = seriesModel.getBaseAxis();
		var idx = indexOf(axisList, baseAxis);
		if (idx < 0) {
			idx = axisList.length;
			axisList[idx] = baseAxis;
			result[idx] = {
				axis: baseAxis,
				seriesModels: []
			};
		}
		result[idx].seriesModels.push(seriesModel);
	});
	return result;
}
/**
* Calculate offset and box width for each series.
*/
function calculateBase(groupItem) {
	var baseAxis = groupItem.axis;
	var seriesModels = groupItem.seriesModels;
	var seriesCount = seriesModels.length;
	var boxWidthList = groupItem.boxWidthList = [];
	var boxOffsetList = groupItem.boxOffsetList = [];
	var boundList = [];
	var bandWidth;
	if (baseAxis.type === "category") bandWidth = baseAxis.getBandWidth();
	else {
		var maxDataCount_1 = 0;
		each$10(seriesModels, function(seriesModel) {
			maxDataCount_1 = Math.max(maxDataCount_1, seriesModel.getData().count());
		});
		var extent = baseAxis.getExtent();
		bandWidth = Math.abs(extent[1] - extent[0]) / maxDataCount_1;
	}
	each$10(seriesModels, function(seriesModel) {
		var boxWidthBound = seriesModel.get("boxWidth");
		if (!isArray(boxWidthBound)) boxWidthBound = [boxWidthBound, boxWidthBound];
		boundList.push([parsePercent$1(boxWidthBound[0], bandWidth) || 0, parsePercent$1(boxWidthBound[1], bandWidth) || 0]);
	});
	var availableWidth = bandWidth * .8 - 2;
	var boxGap = availableWidth / seriesCount * .3;
	var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
	var base$1 = boxWidth / 2 - availableWidth / 2;
	each$10(seriesModels, function(seriesModel, idx) {
		boxOffsetList.push(base$1);
		base$1 += boxGap + boxWidth;
		boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
	});
}
/**
* Calculate points location for each series.
*/
function layoutSingleSeries(seriesModel, offset, boxWidth) {
	var coordSys = seriesModel.coordinateSystem;
	var data = seriesModel.getData();
	var halfWidth = boxWidth / 2;
	var cDimIdx = seriesModel.get("layout") === "horizontal" ? 0 : 1;
	var vDimIdx = 1 - cDimIdx;
	var coordDims = ["x", "y"];
	var cDim = data.mapDimension(coordDims[cDimIdx]);
	var vDims = data.mapDimensionsAll(coordDims[vDimIdx]);
	if (cDim == null || vDims.length < 5) return;
	for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
		var axisDimVal = data.get(cDim, dataIndex);
		var median = getPoint(axisDimVal, vDims[2], dataIndex);
		var end1 = getPoint(axisDimVal, vDims[0], dataIndex);
		var end2 = getPoint(axisDimVal, vDims[1], dataIndex);
		var end4 = getPoint(axisDimVal, vDims[3], dataIndex);
		var end5 = getPoint(axisDimVal, vDims[4], dataIndex);
		var ends = [];
		addBodyEnd(ends, end2, false);
		addBodyEnd(ends, end4, true);
		ends.push(end1, end2, end5, end4);
		layEndLine(ends, end1);
		layEndLine(ends, end5);
		layEndLine(ends, median);
		data.setItemLayout(dataIndex, {
			initBaseline: median[vDimIdx],
			ends
		});
	}
	function getPoint(axisDimVal$1, dim, dataIndex$1) {
		var val = data.get(dim, dataIndex$1);
		var p = [];
		p[cDimIdx] = axisDimVal$1;
		p[vDimIdx] = val;
		var point;
		if (isNaN(axisDimVal$1) || isNaN(val)) point = [NaN, NaN];
		else {
			point = coordSys.dataToPoint(p);
			point[cDimIdx] += offset;
		}
		return point;
	}
	function addBodyEnd(ends$1, point, start$1) {
		var point1 = point.slice();
		var point2 = point.slice();
		point1[cDimIdx] += halfWidth;
		point2[cDimIdx] -= halfWidth;
		start$1 ? ends$1.push(point1, point2) : ends$1.push(point2, point1);
	}
	function layEndLine(ends$1, endCenter) {
		var from = endCenter.slice();
		var to = endCenter.slice();
		from[cDimIdx] -= halfWidth;
		to[cDimIdx] += halfWidth;
		ends$1.push(from, to);
	}
}

//#endregion
//#region node_modules/echarts/lib/chart/boxplot/prepareBoxplotData.js
/**
* See:
*  <https://en.wikipedia.org/wiki/Box_plot#cite_note-frigge_hoaglin_iglewicz-2>
*  <http://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/boxplot.stats.html>
*
* Helper method for preparing data.
*
* @param rawData like
*        [
*            [12,232,443], (raw data set for the first box)
*            [3843,5545,1232], (raw data set for the second box)
*            ...
*        ]
* @param opt.boundIQR=1.5 Data less than min bound is outlier.
*      default 1.5, means Q1 - 1.5 * (Q3 - Q1).
*      If 'none'/0 passed, min bound will not be used.
*/
function prepareBoxplotData(rawData, opt) {
	opt = opt || {};
	var boxData = [];
	var outliers = [];
	var boundIQR = opt.boundIQR;
	var useExtreme = boundIQR === "none" || boundIQR === 0;
	for (var i$1 = 0; i$1 < rawData.length; i$1++) {
		var ascList = asc$1(rawData[i$1].slice());
		var Q1 = quantile(ascList, .25);
		var Q2 = quantile(ascList, .5);
		var Q3 = quantile(ascList, .75);
		var min$2 = ascList[0];
		var max$2 = ascList[ascList.length - 1];
		var bound = (boundIQR == null ? 1.5 : boundIQR) * (Q3 - Q1);
		var low = useExtreme ? min$2 : Math.max(min$2, Q1 - bound);
		var high = useExtreme ? max$2 : Math.min(max$2, Q3 + bound);
		var itemNameFormatter = opt.itemNameFormatter;
		var itemName = isFunction(itemNameFormatter) ? itemNameFormatter({ value: i$1 }) : isString(itemNameFormatter) ? itemNameFormatter.replace("{value}", i$1 + "") : i$1 + "";
		boxData.push([
			itemName,
			low,
			Q1,
			Q2,
			Q3,
			high
		]);
		for (var j = 0; j < ascList.length; j++) {
			var dataItem = ascList[j];
			if (dataItem < low || dataItem > high) {
				var outlier = [itemName, dataItem];
				outliers.push(outlier);
			}
		}
	}
	return {
		boxData,
		outliers
	};
}

//#endregion
//#region node_modules/echarts/lib/chart/boxplot/boxplotTransform.js
var boxplotTransform = {
	type: "echarts:boxplot",
	transform: function transform(params) {
		var upstream = params.upstream;
		if (upstream.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {
			var errMsg = "";
			errMsg = makePrintable("source data is not applicable for this boxplot transform. Expect number[][].");
			throwError(errMsg);
		}
		var result = prepareBoxplotData(upstream.getRawData(), params.config);
		return [{
			dimensions: [
				"ItemName",
				"Low",
				"Q1",
				"Q2",
				"Q3",
				"High"
			],
			data: result.boxData
		}, { data: result.outliers }];
	}
};

//#endregion
//#region node_modules/echarts/lib/chart/boxplot/install.js
function install$16(registers) {
	registers.registerSeriesModel(BoxplotSeries_default);
	registers.registerChartView(BoxplotView_default);
	registers.registerLayout(boxplotLayout);
	registers.registerTransform(boxplotTransform);
}

//#endregion
//#region node_modules/echarts/lib/chart/candlestick/candlestickVisual.js
var positiveBorderColorQuery = ["itemStyle", "borderColor"];
var negativeBorderColorQuery = ["itemStyle", "borderColor0"];
var dojiBorderColorQuery = ["itemStyle", "borderColorDoji"];
var positiveColorQuery = ["itemStyle", "color"];
var negativeColorQuery = ["itemStyle", "color0"];
function getColor(sign, model) {
	return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);
}
function getBorderColor(sign, model) {
	return model.get(sign === 0 ? dojiBorderColorQuery : sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
}
var candlestickVisual = {
	seriesType: "candlestick",
	plan: createRenderPlanner(),
	performRawSeries: true,
	reset: function(seriesModel, ecModel) {
		if (ecModel.isSeriesFiltered(seriesModel)) return;
		return !seriesModel.pipelineContext.large && { progress: function(params, data) {
			var dataIndex;
			while ((dataIndex = params.next()) != null) {
				var itemModel = data.getItemModel(dataIndex);
				var sign = data.getItemLayout(dataIndex).sign;
				var style = itemModel.getItemStyle();
				style.fill = getColor(sign, itemModel);
				style.stroke = getBorderColor(sign, itemModel) || style.fill;
				extend(data.ensureUniqueItemVisual(dataIndex, "style"), style);
			}
		} };
	}
};
var candlestickVisual_default = candlestickVisual;

//#endregion
//#region node_modules/echarts/lib/chart/candlestick/CandlestickView.js
var SKIP_PROPS = ["color", "borderColor"];
var CandlestickView = function(_super) {
	__extends(CandlestickView$1, _super);
	function CandlestickView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = CandlestickView$1.type;
		return _this;
	}
	CandlestickView$1.prototype.render = function(seriesModel, ecModel, api) {
		this.group.removeClipPath();
		this._progressiveEls = null;
		this._updateDrawMode(seriesModel);
		this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
	};
	CandlestickView$1.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
		this._clear();
		this._updateDrawMode(seriesModel);
	};
	CandlestickView$1.prototype.incrementalRender = function(params, seriesModel, ecModel, api) {
		this._progressiveEls = [];
		this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
	};
	CandlestickView$1.prototype.eachRendered = function(cb) {
		traverseElements(this._progressiveEls || this.group, cb);
	};
	CandlestickView$1.prototype._updateDrawMode = function(seriesModel) {
		var isLargeDraw = seriesModel.pipelineContext.large;
		if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
			this._isLargeDraw = isLargeDraw;
			this._clear();
		}
	};
	CandlestickView$1.prototype._renderNormal = function(seriesModel) {
		var data = seriesModel.getData();
		var oldData = this._data;
		var group = this.group;
		var isSimpleBox = data.getLayout("isSimpleBox");
		var needsClip = seriesModel.get("clip", true);
		var coord = seriesModel.coordinateSystem;
		var clipArea = coord.getArea && coord.getArea();
		if (!this._data) group.removeAll();
		data.diff(oldData).add(function(newIdx) {
			if (data.hasValue(newIdx)) {
				var itemLayout = data.getItemLayout(newIdx);
				if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) return;
				var el = createNormalBox(itemLayout, newIdx, true);
				initProps(el, { shape: { points: itemLayout.ends } }, seriesModel, newIdx);
				setBoxCommon(el, data, newIdx, isSimpleBox);
				group.add(el);
				data.setItemGraphicEl(newIdx, el);
			}
		}).update(function(newIdx, oldIdx) {
			var el = oldData.getItemGraphicEl(oldIdx);
			if (!data.hasValue(newIdx)) {
				group.remove(el);
				return;
			}
			var itemLayout = data.getItemLayout(newIdx);
			if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
				group.remove(el);
				return;
			}
			if (!el) el = createNormalBox(itemLayout, newIdx);
			else {
				updateProps(el, { shape: { points: itemLayout.ends } }, seriesModel, newIdx);
				saveOldStyle(el);
			}
			setBoxCommon(el, data, newIdx, isSimpleBox);
			group.add(el);
			data.setItemGraphicEl(newIdx, el);
		}).remove(function(oldIdx) {
			var el = oldData.getItemGraphicEl(oldIdx);
			el && group.remove(el);
		}).execute();
		this._data = data;
	};
	CandlestickView$1.prototype._renderLarge = function(seriesModel) {
		this._clear();
		createLarge(seriesModel, this.group);
		var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
		if (clipPath) this.group.setClipPath(clipPath);
		else this.group.removeClipPath();
	};
	CandlestickView$1.prototype._incrementalRenderNormal = function(params, seriesModel) {
		var data = seriesModel.getData();
		var isSimpleBox = data.getLayout("isSimpleBox");
		var dataIndex;
		while ((dataIndex = params.next()) != null) {
			var el = createNormalBox(data.getItemLayout(dataIndex), dataIndex);
			setBoxCommon(el, data, dataIndex, isSimpleBox);
			el.incremental = true;
			this.group.add(el);
			this._progressiveEls.push(el);
		}
	};
	CandlestickView$1.prototype._incrementalRenderLarge = function(params, seriesModel) {
		createLarge(seriesModel, this.group, this._progressiveEls, true);
	};
	CandlestickView$1.prototype.remove = function(ecModel) {
		this._clear();
	};
	CandlestickView$1.prototype._clear = function() {
		this.group.removeAll();
		this._data = null;
	};
	CandlestickView$1.type = "candlestick";
	return CandlestickView$1;
}(Chart_default);
var NormalBoxPathShape = function() {
	function NormalBoxPathShape$1() {}
	return NormalBoxPathShape$1;
}();
var NormalBoxPath = function(_super) {
	__extends(NormalBoxPath$1, _super);
	function NormalBoxPath$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this.type = "normalCandlestickBox";
		return _this;
	}
	NormalBoxPath$1.prototype.getDefaultShape = function() {
		return new NormalBoxPathShape();
	};
	NormalBoxPath$1.prototype.buildPath = function(ctx, shape) {
		var ends = shape.points;
		if (this.__simpleBox) {
			ctx.moveTo(ends[4][0], ends[4][1]);
			ctx.lineTo(ends[6][0], ends[6][1]);
		} else {
			ctx.moveTo(ends[0][0], ends[0][1]);
			ctx.lineTo(ends[1][0], ends[1][1]);
			ctx.lineTo(ends[2][0], ends[2][1]);
			ctx.lineTo(ends[3][0], ends[3][1]);
			ctx.closePath();
			ctx.moveTo(ends[4][0], ends[4][1]);
			ctx.lineTo(ends[5][0], ends[5][1]);
			ctx.moveTo(ends[6][0], ends[6][1]);
			ctx.lineTo(ends[7][0], ends[7][1]);
		}
	};
	return NormalBoxPath$1;
}(Path_default);
function createNormalBox(itemLayout, dataIndex, isInit) {
	var ends = itemLayout.ends;
	return new NormalBoxPath({
		shape: { points: isInit ? transInit(ends, itemLayout) : ends },
		z2: 100
	});
}
function isNormalBoxClipped(clipArea, itemLayout) {
	var clipped = true;
	for (var i$1 = 0; i$1 < itemLayout.ends.length; i$1++) if (clipArea.contain(itemLayout.ends[i$1][0], itemLayout.ends[i$1][1])) {
		clipped = false;
		break;
	}
	return clipped;
}
function setBoxCommon(el, data, dataIndex, isSimpleBox) {
	var itemModel = data.getItemModel(dataIndex);
	el.useStyle(data.getItemVisual(dataIndex, "style"));
	el.style.strokeNoScale = true;
	el.__simpleBox = isSimpleBox;
	setStatesStylesFromModel(el, itemModel);
	var sign = data.getItemLayout(dataIndex).sign;
	each(el.states, function(state, stateName) {
		var stateModel = itemModel.getModel(stateName);
		var color$2 = getColor(sign, stateModel);
		var borderColor = getBorderColor(sign, stateModel) || color$2;
		var stateStyle = state.style || (state.style = {});
		color$2 && (stateStyle.fill = color$2);
		borderColor && (stateStyle.stroke = borderColor);
	});
	var emphasisModel = itemModel.getModel("emphasis");
	toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function transInit(points$3, itemLayout) {
	return map(points$3, function(point) {
		point = point.slice();
		point[1] = itemLayout.initBaseline;
		return point;
	});
}
var LargeBoxPathShape = function() {
	function LargeBoxPathShape$1() {}
	return LargeBoxPathShape$1;
}();
var LargeBoxPath = function(_super) {
	__extends(LargeBoxPath$1, _super);
	function LargeBoxPath$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this.type = "largeCandlestickBox";
		return _this;
	}
	LargeBoxPath$1.prototype.getDefaultShape = function() {
		return new LargeBoxPathShape();
	};
	LargeBoxPath$1.prototype.buildPath = function(ctx, shape) {
		var points$3 = shape.points;
		for (var i$1 = 0; i$1 < points$3.length;) if (this.__sign === points$3[i$1++]) {
			var x = points$3[i$1++];
			ctx.moveTo(x, points$3[i$1++]);
			ctx.lineTo(x, points$3[i$1++]);
		} else i$1 += 3;
	};
	return LargeBoxPath$1;
}(Path_default);
function createLarge(seriesModel, group, progressiveEls, incremental) {
	var data = seriesModel.getData();
	var largePoints = data.getLayout("largePoints");
	var elP = new LargeBoxPath({
		shape: { points: largePoints },
		__sign: 1,
		ignoreCoarsePointer: true
	});
	group.add(elP);
	var elN = new LargeBoxPath({
		shape: { points: largePoints },
		__sign: -1,
		ignoreCoarsePointer: true
	});
	group.add(elN);
	var elDoji = new LargeBoxPath({
		shape: { points: largePoints },
		__sign: 0,
		ignoreCoarsePointer: true
	});
	group.add(elDoji);
	setLargeStyle(1, elP, seriesModel, data);
	setLargeStyle(-1, elN, seriesModel, data);
	setLargeStyle(0, elDoji, seriesModel, data);
	if (incremental) {
		elP.incremental = true;
		elN.incremental = true;
	}
	if (progressiveEls) progressiveEls.push(elP, elN);
}
function setLargeStyle(sign, el, seriesModel, data) {
	var borderColor = getBorderColor(sign, seriesModel) || getColor(sign, seriesModel);
	var itemStyle = seriesModel.getModel("itemStyle").getItemStyle(SKIP_PROPS);
	el.useStyle(itemStyle);
	el.style.fill = null;
	el.style.stroke = borderColor;
}
var CandlestickView_default = CandlestickView;

//#endregion
//#region node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js
var CandlestickSeriesModel = function(_super) {
	__extends(CandlestickSeriesModel$1, _super);
	function CandlestickSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = CandlestickSeriesModel$1.type;
		_this.defaultValueDimensions = [
			{
				name: "open",
				defaultTooltip: true
			},
			{
				name: "close",
				defaultTooltip: true
			},
			{
				name: "lowest",
				defaultTooltip: true
			},
			{
				name: "highest",
				defaultTooltip: true
			}
		];
		return _this;
	}
	/**
	* Get dimension for shadow in dataZoom
	* @return dimension name
	*/
	CandlestickSeriesModel$1.prototype.getShadowDim = function() {
		return "open";
	};
	CandlestickSeriesModel$1.prototype.brushSelector = function(dataIndex, data, selectors) {
		var itemLayout = data.getItemLayout(dataIndex);
		return itemLayout && selectors.rect(itemLayout.brushRect);
	};
	CandlestickSeriesModel$1.type = "series.candlestick";
	CandlestickSeriesModel$1.dependencies = [
		"xAxis",
		"yAxis",
		"grid"
	];
	CandlestickSeriesModel$1.defaultOption = {
		z: 2,
		coordinateSystem: "cartesian2d",
		legendHoverLink: true,
		layout: null,
		clip: true,
		itemStyle: {
			color: "#eb5454",
			color0: "#47b262",
			borderColor: "#eb5454",
			borderColor0: "#47b262",
			borderColorDoji: null,
			borderWidth: 1
		},
		emphasis: { itemStyle: { borderWidth: 2 } },
		barMaxWidth: null,
		barMinWidth: null,
		barWidth: null,
		large: true,
		largeThreshold: 600,
		progressive: 3e3,
		progressiveThreshold: 1e4,
		progressiveChunkMode: "mod",
		animationEasing: "linear",
		animationDuration: 300
	};
	return CandlestickSeriesModel$1;
}(Series_default);
mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, true);
var CandlestickSeries_default = CandlestickSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/candlestick/preprocessor.js
function candlestickPreprocessor(option) {
	if (!option || !isArray(option.series)) return;
	each(option.series, function(seriesItem) {
		if (isObject(seriesItem) && seriesItem.type === "k") seriesItem.type = "candlestick";
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/candlestick/candlestickLayout.js
var candlestickLayout = {
	seriesType: "candlestick",
	plan: createRenderPlanner(),
	reset: function(seriesModel) {
		var coordSys = seriesModel.coordinateSystem;
		var data = seriesModel.getData();
		var candleWidth = calculateCandleWidth(seriesModel, data);
		var cDimIdx = 0;
		var vDimIdx = 1;
		var coordDims = ["x", "y"];
		var cDimI = data.getDimensionIndex(data.mapDimension(coordDims[cDimIdx]));
		var vDimsI = map(data.mapDimensionsAll(coordDims[vDimIdx]), data.getDimensionIndex, data);
		var openDimI = vDimsI[0];
		var closeDimI = vDimsI[1];
		var lowestDimI = vDimsI[2];
		var highestDimI = vDimsI[3];
		data.setLayout({
			candleWidth,
			isSimpleBox: candleWidth <= 1.3
		});
		if (cDimI < 0 || vDimsI.length < 4) return;
		return { progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress };
		function normalProgress(params, data$1) {
			var dataIndex;
			var store = data$1.getStore();
			while ((dataIndex = params.next()) != null) {
				var axisDimVal = store.get(cDimI, dataIndex);
				var openVal = store.get(openDimI, dataIndex);
				var closeVal = store.get(closeDimI, dataIndex);
				var lowestVal = store.get(lowestDimI, dataIndex);
				var highestVal = store.get(highestDimI, dataIndex);
				var ocLow = Math.min(openVal, closeVal);
				var ocHigh = Math.max(openVal, closeVal);
				var ocLowPoint = getPoint(ocLow, axisDimVal);
				var ocHighPoint = getPoint(ocHigh, axisDimVal);
				var lowestPoint = getPoint(lowestVal, axisDimVal);
				var highestPoint = getPoint(highestVal, axisDimVal);
				var ends = [];
				addBodyEnd(ends, ocHighPoint, 0);
				addBodyEnd(ends, ocLowPoint, 1);
				ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
				var hasDojiColor = !!data$1.getItemModel(dataIndex).get(["itemStyle", "borderColorDoji"]);
				data$1.setItemLayout(dataIndex, {
					sign: getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor),
					initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
					ends,
					brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
				});
			}
			function getPoint(val, axisDimVal$1) {
				var p = [];
				p[cDimIdx] = axisDimVal$1;
				p[vDimIdx] = val;
				return isNaN(axisDimVal$1) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);
			}
			function addBodyEnd(ends$1, point, start$1) {
				var point1 = point.slice();
				var point2 = point.slice();
				point1[cDimIdx] = subPixelOptimize$1(point1[cDimIdx] + candleWidth / 2, 1, false);
				point2[cDimIdx] = subPixelOptimize$1(point2[cDimIdx] - candleWidth / 2, 1, true);
				start$1 ? ends$1.push(point1, point2) : ends$1.push(point2, point1);
			}
			function makeBrushRect(lowestVal$1, highestVal$1, axisDimVal$1) {
				var pmin = getPoint(lowestVal$1, axisDimVal$1);
				var pmax = getPoint(highestVal$1, axisDimVal$1);
				pmin[cDimIdx] -= candleWidth / 2;
				pmax[cDimIdx] -= candleWidth / 2;
				return {
					x: pmin[0],
					y: pmin[1],
					width: vDimIdx ? candleWidth : pmax[0] - pmin[0],
					height: vDimIdx ? pmax[1] - pmin[1] : candleWidth
				};
			}
			function subPixelOptimizePoint(point) {
				point[cDimIdx] = subPixelOptimize$1(point[cDimIdx], 1);
				return point;
			}
		}
		function largeProgress(params, data$1) {
			var points$3 = createFloat32Array(params.count * 4);
			var offset = 0;
			var point;
			var tmpIn = [];
			var tmpOut = [];
			var dataIndex;
			var store = data$1.getStore();
			var hasDojiColor = !!seriesModel.get(["itemStyle", "borderColorDoji"]);
			while ((dataIndex = params.next()) != null) {
				var axisDimVal = store.get(cDimI, dataIndex);
				var openVal = store.get(openDimI, dataIndex);
				var closeVal = store.get(closeDimI, dataIndex);
				var lowestVal = store.get(lowestDimI, dataIndex);
				var highestVal = store.get(highestDimI, dataIndex);
				if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
					points$3[offset++] = NaN;
					offset += 3;
					continue;
				}
				points$3[offset++] = getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor);
				tmpIn[cDimIdx] = axisDimVal;
				tmpIn[vDimIdx] = lowestVal;
				point = coordSys.dataToPoint(tmpIn, null, tmpOut);
				points$3[offset++] = point ? point[0] : NaN;
				points$3[offset++] = point ? point[1] : NaN;
				tmpIn[vDimIdx] = highestVal;
				point = coordSys.dataToPoint(tmpIn, null, tmpOut);
				points$3[offset++] = point ? point[1] : NaN;
			}
			data$1.setLayout("largePoints", points$3);
		}
	}
};
/**
* Get the sign of a single data.
*
* @returns 0 for doji with hasDojiColor: true,
*          1 for positive,
*          -1 for negative.
*/
function getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor) {
	var sign;
	if (openVal > closeVal) sign = -1;
	else if (openVal < closeVal) sign = 1;
	else sign = hasDojiColor ? 0 : dataIndex > 0 ? store.get(closeDimI, dataIndex - 1) <= closeVal ? 1 : -1 : 1;
	return sign;
}
function calculateCandleWidth(seriesModel, data) {
	var baseAxis = seriesModel.getBaseAxis();
	var extent;
	var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());
	var barMaxWidth = parsePercent$1(retrieve2(seriesModel.get("barMaxWidth"), bandWidth), bandWidth);
	var barMinWidth = parsePercent$1(retrieve2(seriesModel.get("barMinWidth"), 1), bandWidth);
	var barWidth = seriesModel.get("barWidth");
	return barWidth != null ? parsePercent$1(barWidth, bandWidth) : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
}
var candlestickLayout_default = candlestickLayout;

//#endregion
//#region node_modules/echarts/lib/chart/candlestick/install.js
function install$17(registers) {
	registers.registerChartView(CandlestickView_default);
	registers.registerSeriesModel(CandlestickSeries_default);
	registers.registerPreprocessor(candlestickPreprocessor);
	registers.registerVisual(candlestickVisual_default);
	registers.registerLayout(candlestickLayout_default);
}

//#endregion
//#region node_modules/echarts/lib/chart/helper/EffectSymbol.js
function updateRipplePath(rippleGroup, effectCfg) {
	var color$2 = effectCfg.rippleEffectColor || effectCfg.color;
	rippleGroup.eachChild(function(ripplePath) {
		ripplePath.attr({
			z: effectCfg.z,
			zlevel: effectCfg.zlevel,
			style: {
				stroke: effectCfg.brushType === "stroke" ? color$2 : null,
				fill: effectCfg.brushType === "fill" ? color$2 : null
			}
		});
	});
}
var EffectSymbol = function(_super) {
	__extends(EffectSymbol$1, _super);
	function EffectSymbol$1(data, idx) {
		var _this = _super.call(this) || this;
		var symbol = new Symbol_default(data, idx);
		var rippleGroup = new Group_default();
		_this.add(symbol);
		_this.add(rippleGroup);
		_this.updateData(data, idx);
		return _this;
	}
	EffectSymbol$1.prototype.stopEffectAnimation = function() {
		this.childAt(1).removeAll();
	};
	EffectSymbol$1.prototype.startEffectAnimation = function(effectCfg) {
		var symbolType = effectCfg.symbolType;
		var color$2 = effectCfg.color;
		var rippleNumber = effectCfg.rippleNumber;
		var rippleGroup = this.childAt(1);
		for (var i$1 = 0; i$1 < rippleNumber; i$1++) {
			var ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color$2);
			ripplePath.attr({
				style: { strokeNoScale: true },
				z2: 99,
				silent: true,
				scaleX: .5,
				scaleY: .5
			});
			var delay = -i$1 / rippleNumber * effectCfg.period + effectCfg.effectOffset;
			ripplePath.animate("", true).when(effectCfg.period, {
				scaleX: effectCfg.rippleScale / 2,
				scaleY: effectCfg.rippleScale / 2
			}).delay(delay).start();
			ripplePath.animateStyle(true).when(effectCfg.period, { opacity: 0 }).delay(delay).start();
			rippleGroup.add(ripplePath);
		}
		updateRipplePath(rippleGroup, effectCfg);
	};
	/**
	* Update effect symbol
	*/
	EffectSymbol$1.prototype.updateEffectAnimation = function(effectCfg) {
		var oldEffectCfg = this._effectCfg;
		var rippleGroup = this.childAt(1);
		var DIFFICULT_PROPS = [
			"symbolType",
			"period",
			"rippleScale",
			"rippleNumber"
		];
		for (var i$1 = 0; i$1 < DIFFICULT_PROPS.length; i$1++) {
			var propName = DIFFICULT_PROPS[i$1];
			if (oldEffectCfg[propName] !== effectCfg[propName]) {
				this.stopEffectAnimation();
				this.startEffectAnimation(effectCfg);
				return;
			}
		}
		updateRipplePath(rippleGroup, effectCfg);
	};
	/**
	* Highlight symbol
	*/
	EffectSymbol$1.prototype.highlight = function() {
		enterEmphasis(this);
	};
	/**
	* Downplay symbol
	*/
	EffectSymbol$1.prototype.downplay = function() {
		leaveEmphasis(this);
	};
	EffectSymbol$1.prototype.getSymbolType = function() {
		var symbol = this.childAt(0);
		return symbol && symbol.getSymbolType();
	};
	/**
	* Update symbol properties
	*/
	EffectSymbol$1.prototype.updateData = function(data, idx) {
		var _this = this;
		var seriesModel = data.hostModel;
		this.childAt(0).updateData(data, idx);
		var rippleGroup = this.childAt(1);
		var itemModel = data.getItemModel(idx);
		var symbolType = data.getItemVisual(idx, "symbol");
		var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
		var symbolStyle = data.getItemVisual(idx, "style");
		var color$2 = symbolStyle && symbolStyle.fill;
		var emphasisModel = itemModel.getModel("emphasis");
		rippleGroup.setScale(symbolSize);
		rippleGroup.traverse(function(ripplePath) {
			ripplePath.setStyle("fill", color$2);
		});
		var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
		if (symbolOffset) {
			rippleGroup.x = symbolOffset[0];
			rippleGroup.y = symbolOffset[1];
		}
		rippleGroup.rotation = (data.getItemVisual(idx, "symbolRotate") || 0) * Math.PI / 180 || 0;
		var effectCfg = {};
		effectCfg.showEffectOn = seriesModel.get("showEffectOn");
		effectCfg.rippleScale = itemModel.get(["rippleEffect", "scale"]);
		effectCfg.brushType = itemModel.get(["rippleEffect", "brushType"]);
		effectCfg.period = itemModel.get(["rippleEffect", "period"]) * 1e3;
		effectCfg.effectOffset = idx / data.count();
		effectCfg.z = seriesModel.getShallow("z") || 0;
		effectCfg.zlevel = seriesModel.getShallow("zlevel") || 0;
		effectCfg.symbolType = symbolType;
		effectCfg.color = color$2;
		effectCfg.rippleEffectColor = itemModel.get(["rippleEffect", "color"]);
		effectCfg.rippleNumber = itemModel.get(["rippleEffect", "number"]);
		if (effectCfg.showEffectOn === "render") {
			this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
			this._effectCfg = effectCfg;
		} else {
			this._effectCfg = null;
			this.stopEffectAnimation();
			this.onHoverStateChange = function(toState) {
				if (toState === "emphasis") {
					if (effectCfg.showEffectOn !== "render") _this.startEffectAnimation(effectCfg);
				} else if (toState === "normal") {
					if (effectCfg.showEffectOn !== "render") _this.stopEffectAnimation();
				}
			};
		}
		this._effectCfg = effectCfg;
		toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
	};
	EffectSymbol$1.prototype.fadeOut = function(cb) {
		cb && cb();
	};
	return EffectSymbol$1;
}(Group_default);
var EffectSymbol_default = EffectSymbol;

//#endregion
//#region node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js
var EffectScatterView = function(_super) {
	__extends(EffectScatterView$1, _super);
	function EffectScatterView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = EffectScatterView$1.type;
		return _this;
	}
	EffectScatterView$1.prototype.init = function() {
		this._symbolDraw = new SymbolDraw_default(EffectSymbol_default);
	};
	EffectScatterView$1.prototype.render = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		var effectSymbolDraw = this._symbolDraw;
		effectSymbolDraw.updateData(data, { clipShape: this._getClipShape(seriesModel) });
		this.group.add(effectSymbolDraw.group);
	};
	EffectScatterView$1.prototype._getClipShape = function(seriesModel) {
		var coordSys = seriesModel.coordinateSystem;
		var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
		return seriesModel.get("clip", true) ? clipArea : null;
	};
	EffectScatterView$1.prototype.updateTransform = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		this.group.dirty();
		var res = pointsLayout("").reset(seriesModel, ecModel, api);
		if (res.progress) res.progress({
			start: 0,
			end: data.count(),
			count: data.count()
		}, data);
		this._symbolDraw.updateLayout();
	};
	EffectScatterView$1.prototype._updateGroupTransform = function(seriesModel) {
		var coordSys = seriesModel.coordinateSystem;
		if (coordSys && coordSys.getRoamTransform) {
			this.group.transform = clone$4(coordSys.getRoamTransform());
			this.group.decomposeTransform();
		}
	};
	EffectScatterView$1.prototype.remove = function(ecModel, api) {
		this._symbolDraw && this._symbolDraw.remove(true);
	};
	EffectScatterView$1.type = "effectScatter";
	return EffectScatterView$1;
}(Chart_default);
var EffectScatterView_default = EffectScatterView;

//#endregion
//#region node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js
var EffectScatterSeriesModel = function(_super) {
	__extends(EffectScatterSeriesModel$1, _super);
	function EffectScatterSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = EffectScatterSeriesModel$1.type;
		_this.hasSymbolVisual = true;
		return _this;
	}
	EffectScatterSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		return createSeriesData_default(null, this, { useEncodeDefaulter: true });
	};
	EffectScatterSeriesModel$1.prototype.brushSelector = function(dataIndex, data, selectors) {
		return selectors.point(data.getItemLayout(dataIndex));
	};
	EffectScatterSeriesModel$1.type = "series.effectScatter";
	EffectScatterSeriesModel$1.dependencies = ["grid", "polar"];
	EffectScatterSeriesModel$1.defaultOption = {
		coordinateSystem: "cartesian2d",
		z: 2,
		legendHoverLink: true,
		effectType: "ripple",
		progressive: 0,
		showEffectOn: "render",
		clip: true,
		rippleEffect: {
			period: 4,
			scale: 2.5,
			brushType: "fill",
			number: 3
		},
		universalTransition: { divideShape: "clone" },
		symbolSize: 10
	};
	return EffectScatterSeriesModel$1;
}(Series_default);
var EffectScatterSeries_default = EffectScatterSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/effectScatter/install.js
function install$18(registers) {
	registers.registerChartView(EffectScatterView_default);
	registers.registerSeriesModel(EffectScatterSeries_default);
	registers.registerLayout(pointsLayout("effectScatter"));
}

//#endregion
//#region node_modules/echarts/lib/chart/helper/EffectLine.js
var EffectLine = function(_super) {
	__extends(EffectLine$1, _super);
	function EffectLine$1(lineData, idx, seriesScope) {
		var _this = _super.call(this) || this;
		_this.add(_this.createLine(lineData, idx, seriesScope));
		_this._updateEffectSymbol(lineData, idx);
		return _this;
	}
	EffectLine$1.prototype.createLine = function(lineData, idx, seriesScope) {
		return new Line_default$1(lineData, idx, seriesScope);
	};
	EffectLine$1.prototype._updateEffectSymbol = function(lineData, idx) {
		var effectModel = lineData.getItemModel(idx).getModel("effect");
		var size = effectModel.get("symbolSize");
		var symbolType = effectModel.get("symbol");
		if (!isArray(size)) size = [size, size];
		var lineStyle = lineData.getItemVisual(idx, "style");
		var color$2 = effectModel.get("color") || lineStyle && lineStyle.stroke;
		var symbol = this.childAt(1);
		if (this._symbolType !== symbolType) {
			this.remove(symbol);
			symbol = createSymbol(symbolType, -.5, -.5, 1, 1, color$2);
			symbol.z2 = 100;
			symbol.culling = true;
			this.add(symbol);
		}
		if (!symbol) return;
		symbol.setStyle("shadowColor", color$2);
		symbol.setStyle(effectModel.getItemStyle(["color"]));
		symbol.scaleX = size[0];
		symbol.scaleY = size[1];
		symbol.setColor(color$2);
		this._symbolType = symbolType;
		this._symbolScale = size;
		this._updateEffectAnimation(lineData, effectModel, idx);
	};
	EffectLine$1.prototype._updateEffectAnimation = function(lineData, effectModel, idx) {
		var symbol = this.childAt(1);
		if (!symbol) return;
		var points$3 = lineData.getItemLayout(idx);
		var period = effectModel.get("period") * 1e3;
		var loop = effectModel.get("loop");
		var roundTrip = effectModel.get("roundTrip");
		var constantSpeed = effectModel.get("constantSpeed");
		var delayExpr = retrieve(effectModel.get("delay"), function(idx$1) {
			return idx$1 / lineData.count() * period / 3;
		});
		symbol.ignore = true;
		this._updateAnimationPoints(symbol, points$3);
		if (constantSpeed > 0) period = this._getLineLength(symbol) / constantSpeed * 1e3;
		if (period !== this._period || loop !== this._loop || roundTrip !== this._roundTrip) {
			symbol.stopAnimation();
			var delayNum = void 0;
			if (isFunction(delayExpr)) delayNum = delayExpr(idx);
			else delayNum = delayExpr;
			if (symbol.__t > 0) delayNum = -period * symbol.__t;
			this._animateSymbol(symbol, period, delayNum, loop, roundTrip);
		}
		this._period = period;
		this._loop = loop;
		this._roundTrip = roundTrip;
	};
	EffectLine$1.prototype._animateSymbol = function(symbol, period, delayNum, loop, roundTrip) {
		if (period > 0) {
			symbol.__t = 0;
			var self_1 = this;
			var animator = symbol.animate("", loop).when(roundTrip ? period * 2 : period, { __t: roundTrip ? 2 : 1 }).delay(delayNum).during(function() {
				self_1._updateSymbolPosition(symbol);
			});
			if (!loop) animator.done(function() {
				self_1.remove(symbol);
			});
			animator.start();
		}
	};
	EffectLine$1.prototype._getLineLength = function(symbol) {
		return dist$1(symbol.__p1, symbol.__cp1) + dist$1(symbol.__cp1, symbol.__p2);
	};
	EffectLine$1.prototype._updateAnimationPoints = function(symbol, points$3) {
		symbol.__p1 = points$3[0];
		symbol.__p2 = points$3[1];
		symbol.__cp1 = points$3[2] || [(points$3[0][0] + points$3[1][0]) / 2, (points$3[0][1] + points$3[1][1]) / 2];
	};
	EffectLine$1.prototype.updateData = function(lineData, idx, seriesScope) {
		this.childAt(0).updateData(lineData, idx, seriesScope);
		this._updateEffectSymbol(lineData, idx);
	};
	EffectLine$1.prototype._updateSymbolPosition = function(symbol) {
		var p1 = symbol.__p1;
		var p2 = symbol.__p2;
		var cp1 = symbol.__cp1;
		var t = symbol.__t < 1 ? symbol.__t : 2 - symbol.__t;
		var pos = [symbol.x, symbol.y];
		var lastPos = pos.slice();
		var quadraticAt$2 = quadraticAt$1;
		var quadraticDerivativeAt$1 = quadraticDerivativeAt;
		pos[0] = quadraticAt$2(p1[0], cp1[0], p2[0], t);
		pos[1] = quadraticAt$2(p1[1], cp1[1], p2[1], t);
		var tx = symbol.__t < 1 ? quadraticDerivativeAt$1(p1[0], cp1[0], p2[0], t) : quadraticDerivativeAt$1(p2[0], cp1[0], p1[0], 1 - t);
		var ty = symbol.__t < 1 ? quadraticDerivativeAt$1(p1[1], cp1[1], p2[1], t) : quadraticDerivativeAt$1(p2[1], cp1[1], p1[1], 1 - t);
		symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
		if (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") if (symbol.__lastT !== void 0 && symbol.__lastT < symbol.__t) {
			symbol.scaleY = dist$1(lastPos, pos) * 1.05;
			if (t === 1) {
				pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
				pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
			}
		} else if (symbol.__lastT === 1) symbol.scaleY = 2 * dist$1(p1, pos);
		else symbol.scaleY = this._symbolScale[1];
		symbol.__lastT = symbol.__t;
		symbol.ignore = false;
		symbol.x = pos[0];
		symbol.y = pos[1];
	};
	EffectLine$1.prototype.updateLayout = function(lineData, idx) {
		this.childAt(0).updateLayout(lineData, idx);
		var effectModel = lineData.getItemModel(idx).getModel("effect");
		this._updateEffectAnimation(lineData, effectModel, idx);
	};
	return EffectLine$1;
}(Group_default);
var EffectLine_default = EffectLine;

//#endregion
//#region node_modules/echarts/lib/chart/helper/Polyline.js
var Polyline = function(_super) {
	__extends(Polyline$2, _super);
	function Polyline$2(lineData, idx, seriesScope) {
		var _this = _super.call(this) || this;
		_this._createPolyline(lineData, idx, seriesScope);
		return _this;
	}
	Polyline$2.prototype._createPolyline = function(lineData, idx, seriesScope) {
		var points$3 = lineData.getItemLayout(idx);
		var line = new Polyline_default({ shape: { points: points$3 } });
		this.add(line);
		this._updateCommonStl(lineData, idx, seriesScope);
	};
	Polyline$2.prototype.updateData = function(lineData, idx, seriesScope) {
		var seriesModel = lineData.hostModel;
		var line = this.childAt(0);
		var target = { shape: { points: lineData.getItemLayout(idx) } };
		updateProps(line, target, seriesModel, idx);
		this._updateCommonStl(lineData, idx, seriesScope);
	};
	Polyline$2.prototype._updateCommonStl = function(lineData, idx, seriesScope) {
		var line = this.childAt(0);
		var itemModel = lineData.getItemModel(idx);
		var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
		var focus = seriesScope && seriesScope.focus;
		var blurScope = seriesScope && seriesScope.blurScope;
		var emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
		if (!seriesScope || lineData.hasItemOption) {
			var emphasisModel = itemModel.getModel("emphasis");
			emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
			emphasisDisabled = emphasisModel.get("disabled");
			focus = emphasisModel.get("focus");
			blurScope = emphasisModel.get("blurScope");
		}
		line.useStyle(lineData.getItemVisual(idx, "style"));
		line.style.fill = null;
		line.style.strokeNoScale = true;
		var lineEmphasisState = line.ensureState("emphasis");
		lineEmphasisState.style = emphasisLineStyle;
		toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
	};
	Polyline$2.prototype.updateLayout = function(lineData, idx) {
		this.childAt(0).setShape("points", lineData.getItemLayout(idx));
	};
	return Polyline$2;
}(Group_default);
var Polyline_default$1 = Polyline;

//#endregion
//#region node_modules/echarts/lib/chart/helper/EffectPolyline.js
var EffectPolyline = function(_super) {
	__extends(EffectPolyline$1, _super);
	function EffectPolyline$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this._lastFrame = 0;
		_this._lastFramePercent = 0;
		return _this;
	}
	EffectPolyline$1.prototype.createLine = function(lineData, idx, seriesScope) {
		return new Polyline_default$1(lineData, idx, seriesScope);
	};
	EffectPolyline$1.prototype._updateAnimationPoints = function(symbol, points$3) {
		this._points = points$3;
		var accLenArr = [0];
		var len$1 = 0;
		for (var i$1 = 1; i$1 < points$3.length; i$1++) {
			var p1 = points$3[i$1 - 1];
			var p2 = points$3[i$1];
			len$1 += dist$1(p1, p2);
			accLenArr.push(len$1);
		}
		if (len$1 === 0) {
			this._length = 0;
			return;
		}
		for (var i$1 = 0; i$1 < accLenArr.length; i$1++) accLenArr[i$1] /= len$1;
		this._offsets = accLenArr;
		this._length = len$1;
	};
	EffectPolyline$1.prototype._getLineLength = function() {
		return this._length;
	};
	EffectPolyline$1.prototype._updateSymbolPosition = function(symbol) {
		var t = symbol.__t < 1 ? symbol.__t : 2 - symbol.__t;
		var points$3 = this._points;
		var offsets = this._offsets;
		var len$1 = points$3.length;
		if (!offsets) return;
		var lastFrame = this._lastFrame;
		var frame;
		if (t < this._lastFramePercent) {
			for (frame = Math.min(lastFrame + 1, len$1 - 1); frame >= 0; frame--) if (offsets[frame] <= t) break;
			frame = Math.min(frame, len$1 - 2);
		} else {
			for (frame = lastFrame; frame < len$1; frame++) if (offsets[frame] > t) break;
			frame = Math.min(frame - 1, len$1 - 2);
		}
		var p = (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]);
		var p0 = points$3[frame];
		var p1 = points$3[frame + 1];
		symbol.x = p0[0] * (1 - p) + p * p1[0];
		symbol.y = p0[1] * (1 - p) + p * p1[1];
		var tx = symbol.__t < 1 ? p1[0] - p0[0] : p0[0] - p1[0];
		var ty = symbol.__t < 1 ? p1[1] - p0[1] : p0[1] - p1[1];
		symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
		this._lastFrame = frame;
		this._lastFramePercent = t;
		symbol.ignore = false;
	};
	return EffectPolyline$1;
}(EffectLine_default);
var EffectPolyline_default = EffectPolyline;

//#endregion
//#region node_modules/echarts/lib/chart/helper/LargeLineDraw.js
var LargeLinesPathShape = function() {
	function LargeLinesPathShape$1() {
		this.polyline = false;
		this.curveness = 0;
		this.segs = [];
	}
	return LargeLinesPathShape$1;
}();
var LargeLinesPath = function(_super) {
	__extends(LargeLinesPath$1, _super);
	function LargeLinesPath$1(opts) {
		var _this = _super.call(this, opts) || this;
		_this._off = 0;
		_this.hoverDataIdx = -1;
		return _this;
	}
	LargeLinesPath$1.prototype.reset = function() {
		this.notClear = false;
		this._off = 0;
	};
	LargeLinesPath$1.prototype.getDefaultStyle = function() {
		return {
			stroke: tokens_default.color.neutral99,
			fill: null
		};
	};
	LargeLinesPath$1.prototype.getDefaultShape = function() {
		return new LargeLinesPathShape();
	};
	LargeLinesPath$1.prototype.buildPath = function(ctx, shape) {
		var segs = shape.segs;
		var curveness = shape.curveness;
		var i$1;
		if (shape.polyline) for (i$1 = this._off; i$1 < segs.length;) {
			var count$1 = segs[i$1++];
			if (count$1 > 0) {
				ctx.moveTo(segs[i$1++], segs[i$1++]);
				for (var k$1 = 1; k$1 < count$1; k$1++) ctx.lineTo(segs[i$1++], segs[i$1++]);
			}
		}
		else for (i$1 = this._off; i$1 < segs.length;) {
			var x0 = segs[i$1++];
			var y0 = segs[i$1++];
			var x1 = segs[i$1++];
			var y1 = segs[i$1++];
			ctx.moveTo(x0, y0);
			if (curveness > 0) {
				var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
				var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
				ctx.quadraticCurveTo(x2, y2, x1, y1);
			} else ctx.lineTo(x1, y1);
		}
		if (this.incremental) {
			this._off = i$1;
			this.notClear = true;
		}
	};
	LargeLinesPath$1.prototype.findDataIndex = function(x, y) {
		var shape = this.shape;
		var segs = shape.segs;
		var curveness = shape.curveness;
		var lineWidth = this.style.lineWidth;
		if (shape.polyline) {
			var dataIndex = 0;
			for (var i$1 = 0; i$1 < segs.length;) {
				var count$1 = segs[i$1++];
				if (count$1 > 0) {
					var x0 = segs[i$1++];
					var y0 = segs[i$1++];
					for (var k$1 = 1; k$1 < count$1; k$1++) {
						var x1 = segs[i$1++];
						var y1 = segs[i$1++];
						if (containStroke$4(x0, y0, x1, y1, lineWidth, x, y)) return dataIndex;
					}
				}
				dataIndex++;
			}
		} else {
			var dataIndex = 0;
			for (var i$1 = 0; i$1 < segs.length;) {
				var x0 = segs[i$1++];
				var y0 = segs[i$1++];
				var x1 = segs[i$1++];
				var y1 = segs[i$1++];
				if (curveness > 0) {
					var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
					var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
					if (containStroke$2(x0, y0, x2, y2, x1, y1, lineWidth, x, y)) return dataIndex;
				} else if (containStroke$4(x0, y0, x1, y1, lineWidth, x, y)) return dataIndex;
				dataIndex++;
			}
		}
		return -1;
	};
	LargeLinesPath$1.prototype.contain = function(x, y) {
		var localPos = this.transformCoordToLocal(x, y);
		var rect = this.getBoundingRect();
		x = localPos[0];
		y = localPos[1];
		if (rect.contain(x, y)) return (this.hoverDataIdx = this.findDataIndex(x, y)) >= 0;
		this.hoverDataIdx = -1;
		return false;
	};
	LargeLinesPath$1.prototype.getBoundingRect = function() {
		var rect = this._rect;
		if (!rect) {
			var points$3 = this.shape.segs;
			var minX = Infinity;
			var minY = Infinity;
			var maxX = -Infinity;
			var maxY = -Infinity;
			for (var i$1 = 0; i$1 < points$3.length;) {
				var x = points$3[i$1++];
				var y = points$3[i$1++];
				minX = Math.min(x, minX);
				maxX = Math.max(x, maxX);
				minY = Math.min(y, minY);
				maxY = Math.max(y, maxY);
			}
			rect = this._rect = new BoundingRect_default(minX, minY, maxX, maxY);
		}
		return rect;
	};
	return LargeLinesPath$1;
}(Path_default);
var LargeLineDraw = function() {
	function LargeLineDraw$1() {
		this.group = new Group_default();
	}
	/**
	* Update symbols draw by new data
	*/
	LargeLineDraw$1.prototype.updateData = function(data) {
		this._clear();
		var lineEl = this._create();
		lineEl.setShape({ segs: data.getLayout("linesPoints") });
		this._setCommon(lineEl, data);
	};
	/**
	* @override
	*/
	LargeLineDraw$1.prototype.incrementalPrepareUpdate = function(data) {
		this.group.removeAll();
		this._clear();
	};
	/**
	* @override
	*/
	LargeLineDraw$1.prototype.incrementalUpdate = function(taskParams, data) {
		var lastAdded = this._newAdded[0];
		var linePoints = data.getLayout("linesPoints");
		var oldSegs = lastAdded && lastAdded.shape.segs;
		if (oldSegs && oldSegs.length < 2e4) {
			var oldLen = oldSegs.length;
			var newSegs = new Float32Array(oldLen + linePoints.length);
			newSegs.set(oldSegs);
			newSegs.set(linePoints, oldLen);
			lastAdded.setShape({ segs: newSegs });
		} else {
			this._newAdded = [];
			var lineEl = this._create();
			lineEl.incremental = true;
			lineEl.setShape({ segs: linePoints });
			this._setCommon(lineEl, data);
			lineEl.__startIndex = taskParams.start;
		}
	};
	/**
	* @override
	*/
	LargeLineDraw$1.prototype.remove = function() {
		this._clear();
	};
	LargeLineDraw$1.prototype.eachRendered = function(cb) {
		this._newAdded[0] && cb(this._newAdded[0]);
	};
	LargeLineDraw$1.prototype._create = function() {
		var lineEl = new LargeLinesPath({
			cursor: "default",
			ignoreCoarsePointer: true
		});
		this._newAdded.push(lineEl);
		this.group.add(lineEl);
		return lineEl;
	};
	LargeLineDraw$1.prototype._setCommon = function(lineEl, data, isIncremental) {
		var hostModel = data.hostModel;
		lineEl.setShape({
			polyline: hostModel.get("polyline"),
			curveness: hostModel.get(["lineStyle", "curveness"])
		});
		lineEl.useStyle(hostModel.getModel("lineStyle").getLineStyle());
		lineEl.style.strokeNoScale = true;
		var style = data.getVisual("style");
		if (style && style.stroke) lineEl.setStyle("stroke", style.stroke);
		lineEl.setStyle("fill", null);
		var ecData = getECData(lineEl);
		ecData.seriesIndex = hostModel.seriesIndex;
		lineEl.on("mousemove", function(e$1) {
			ecData.dataIndex = null;
			var dataIndex = lineEl.hoverDataIdx;
			if (dataIndex > 0) ecData.dataIndex = dataIndex + lineEl.__startIndex;
		});
	};
	LargeLineDraw$1.prototype._clear = function() {
		this._newAdded = [];
		this.group.removeAll();
	};
	return LargeLineDraw$1;
}();
var LargeLineDraw_default = LargeLineDraw;

//#endregion
//#region node_modules/echarts/lib/chart/lines/linesLayout.js
var linesLayout = {
	seriesType: "lines",
	plan: createRenderPlanner(),
	reset: function(seriesModel) {
		var coordSys = seriesModel.coordinateSystem;
		if (!coordSys) {
			error("The lines series must have a coordinate system.");
			return;
		}
		var isPolyline = seriesModel.get("polyline");
		var isLarge = seriesModel.pipelineContext.large;
		return { progress: function(params, lineData) {
			var lineCoords = [];
			if (isLarge) {
				var points$3 = void 0;
				var segCount = params.end - params.start;
				if (isPolyline) {
					var totalCoordsCount = 0;
					for (var i$1 = params.start; i$1 < params.end; i$1++) totalCoordsCount += seriesModel.getLineCoordsCount(i$1);
					points$3 = new Float32Array(segCount + totalCoordsCount * 2);
				} else points$3 = new Float32Array(segCount * 4);
				var offset = 0;
				var pt = [];
				for (var i$1 = params.start; i$1 < params.end; i$1++) {
					var len$1 = seriesModel.getLineCoords(i$1, lineCoords);
					if (isPolyline) points$3[offset++] = len$1;
					for (var k$1 = 0; k$1 < len$1; k$1++) {
						pt = coordSys.dataToPoint(lineCoords[k$1], false, pt);
						points$3[offset++] = pt[0];
						points$3[offset++] = pt[1];
					}
				}
				lineData.setLayout("linesPoints", points$3);
			} else for (var i$1 = params.start; i$1 < params.end; i$1++) {
				var itemModel = lineData.getItemModel(i$1);
				var len$1 = seriesModel.getLineCoords(i$1, lineCoords);
				var pts = [];
				if (isPolyline) for (var j = 0; j < len$1; j++) pts.push(coordSys.dataToPoint(lineCoords[j]));
				else {
					pts[0] = coordSys.dataToPoint(lineCoords[0]);
					pts[1] = coordSys.dataToPoint(lineCoords[1]);
					var curveness = itemModel.get(["lineStyle", "curveness"]);
					if (+curveness) pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];
				}
				lineData.setItemLayout(i$1, pts);
			}
		} };
	}
};
var linesLayout_default = linesLayout;

//#endregion
//#region node_modules/echarts/lib/chart/lines/LinesView.js
var LinesView = function(_super) {
	__extends(LinesView$1, _super);
	function LinesView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = LinesView$1.type;
		return _this;
	}
	LinesView$1.prototype.render = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		var lineDraw = this._updateLineDraw(data, seriesModel);
		var zlevel = seriesModel.get("zlevel");
		var trailLength = seriesModel.get(["effect", "trailLength"]);
		var zr = api.getZr();
		var isSvg = zr.painter.getType() === "svg";
		if (!isSvg) zr.painter.getLayer(zlevel).clear(true);
		if (this._lastZlevel != null && !isSvg) zr.configLayer(this._lastZlevel, { motionBlur: false });
		if (this._showEffect(seriesModel) && trailLength > 0) if (!isSvg) zr.configLayer(zlevel, {
			motionBlur: true,
			lastFrameAlpha: Math.max(Math.min(trailLength / 10 + .9, 1), 0)
		});
		else console.warn("SVG render mode doesn't support lines with trail effect");
		lineDraw.updateData(data);
		var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
		if (clipPath) this.group.setClipPath(clipPath);
		else this.group.removeClipPath();
		this._lastZlevel = zlevel;
		this._finished = true;
	};
	LinesView$1.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		this._updateLineDraw(data, seriesModel).incrementalPrepareUpdate(data);
		this._clearLayer(api);
		this._finished = false;
	};
	LinesView$1.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
		this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());
		this._finished = taskParams.end === seriesModel.getData().count();
	};
	LinesView$1.prototype.eachRendered = function(cb) {
		this._lineDraw && this._lineDraw.eachRendered(cb);
	};
	LinesView$1.prototype.updateTransform = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		var pipelineContext = seriesModel.pipelineContext;
		if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) return { update: true };
		else {
			var res = linesLayout_default.reset(seriesModel, ecModel, api);
			if (res.progress) res.progress({
				start: 0,
				end: data.count(),
				count: data.count()
			}, data);
			this._lineDraw.updateLayout();
			this._clearLayer(api);
		}
	};
	LinesView$1.prototype._updateLineDraw = function(data, seriesModel) {
		var lineDraw = this._lineDraw;
		var hasEffect = this._showEffect(seriesModel);
		var isPolyline = !!seriesModel.get("polyline");
		var isLargeDraw = seriesModel.pipelineContext.large;
		if (hasEffect && isLargeDraw) console.warn("Large lines not support effect");
		if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
			if (lineDraw) lineDraw.remove();
			lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw_default() : new LineDraw_default(isPolyline ? hasEffect ? EffectPolyline_default : Polyline_default$1 : hasEffect ? EffectLine_default : Line_default$1);
			this._hasEffet = hasEffect;
			this._isPolyline = isPolyline;
			this._isLargeDraw = isLargeDraw;
		}
		this.group.add(lineDraw.group);
		return lineDraw;
	};
	LinesView$1.prototype._showEffect = function(seriesModel) {
		return !!seriesModel.get(["effect", "show"]);
	};
	LinesView$1.prototype._clearLayer = function(api) {
		var zr = api.getZr();
		if (!(zr.painter.getType() === "svg") && this._lastZlevel != null) zr.painter.getLayer(this._lastZlevel).clear(true);
	};
	LinesView$1.prototype.remove = function(ecModel, api) {
		this._lineDraw && this._lineDraw.remove();
		this._lineDraw = null;
		this._clearLayer(api);
	};
	LinesView$1.prototype.dispose = function(ecModel, api) {
		this.remove(ecModel, api);
	};
	LinesView$1.type = "lines";
	return LinesView$1;
}(Chart_default);
var LinesView_default = LinesView;

//#endregion
//#region node_modules/echarts/lib/chart/lines/LinesSeries.js
var Uint32Arr = typeof Uint32Array === "undefined" ? Array : Uint32Array;
var Float64Arr = typeof Float64Array === "undefined" ? Array : Float64Array;
function compatEc2(seriesOpt) {
	var data = seriesOpt.data;
	if (data && data[0] && data[0][0] && data[0][0].coord) {
		console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }");
		seriesOpt.data = map(data, function(itemOpt) {
			var target = { coords: [itemOpt[0].coord, itemOpt[1].coord] };
			if (itemOpt[0].name) target.fromName = itemOpt[0].name;
			if (itemOpt[1].name) target.toName = itemOpt[1].name;
			return mergeAll([
				target,
				itemOpt[0],
				itemOpt[1]
			]);
		});
	}
}
var LinesSeriesModel = function(_super) {
	__extends(LinesSeriesModel$1, _super);
	function LinesSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = LinesSeriesModel$1.type;
		_this.visualStyleAccessPath = "lineStyle";
		_this.visualDrawType = "stroke";
		return _this;
	}
	LinesSeriesModel$1.prototype.init = function(option) {
		option.data = option.data || [];
		compatEc2(option);
		var result = this._processFlatCoordsArray(option.data);
		this._flatCoords = result.flatCoords;
		this._flatCoordsOffset = result.flatCoordsOffset;
		if (result.flatCoords) option.data = new Float32Array(result.count);
		_super.prototype.init.apply(this, arguments);
	};
	LinesSeriesModel$1.prototype.mergeOption = function(option) {
		compatEc2(option);
		if (option.data) {
			var result = this._processFlatCoordsArray(option.data);
			this._flatCoords = result.flatCoords;
			this._flatCoordsOffset = result.flatCoordsOffset;
			if (result.flatCoords) option.data = new Float32Array(result.count);
		}
		_super.prototype.mergeOption.apply(this, arguments);
	};
	LinesSeriesModel$1.prototype.appendData = function(params) {
		var result = this._processFlatCoordsArray(params.data);
		if (result.flatCoords) {
			if (!this._flatCoords) {
				this._flatCoords = result.flatCoords;
				this._flatCoordsOffset = result.flatCoordsOffset;
			} else {
				this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
				this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
			}
			params.data = new Float32Array(result.count);
		}
		this.getRawData().appendData(params.data);
	};
	LinesSeriesModel$1.prototype._getCoordsFromItemModel = function(idx) {
		var itemModel = this.getData().getItemModel(idx);
		var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
		if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) throw new Error("Invalid coords " + JSON.stringify(coords) + ". Lines must have 2d coords array in data item.");
		return coords;
	};
	LinesSeriesModel$1.prototype.getLineCoordsCount = function(idx) {
		if (this._flatCoordsOffset) return this._flatCoordsOffset[idx * 2 + 1];
		else return this._getCoordsFromItemModel(idx).length;
	};
	LinesSeriesModel$1.prototype.getLineCoords = function(idx, out$1) {
		if (this._flatCoordsOffset) {
			var offset = this._flatCoordsOffset[idx * 2];
			var len$1 = this._flatCoordsOffset[idx * 2 + 1];
			for (var i$1 = 0; i$1 < len$1; i$1++) {
				out$1[i$1] = out$1[i$1] || [];
				out$1[i$1][0] = this._flatCoords[offset + i$1 * 2];
				out$1[i$1][1] = this._flatCoords[offset + i$1 * 2 + 1];
			}
			return len$1;
		} else {
			var coords = this._getCoordsFromItemModel(idx);
			for (var i$1 = 0; i$1 < coords.length; i$1++) {
				out$1[i$1] = out$1[i$1] || [];
				out$1[i$1][0] = coords[i$1][0];
				out$1[i$1][1] = coords[i$1][1];
			}
			return coords.length;
		}
	};
	LinesSeriesModel$1.prototype._processFlatCoordsArray = function(data) {
		var startOffset = 0;
		if (this._flatCoords) startOffset = this._flatCoords.length;
		if (isNumber(data[0])) {
			var len$1 = data.length;
			var coordsOffsetAndLenStorage = new Uint32Arr(len$1);
			var coordsStorage = new Float64Arr(len$1);
			var coordsCursor = 0;
			var offsetCursor = 0;
			var dataCount = 0;
			for (var i$1 = 0; i$1 < len$1;) {
				dataCount++;
				var count$1 = data[i$1++];
				coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
				coordsOffsetAndLenStorage[offsetCursor++] = count$1;
				for (var k$1 = 0; k$1 < count$1; k$1++) {
					var x = data[i$1++];
					var y = data[i$1++];
					coordsStorage[coordsCursor++] = x;
					coordsStorage[coordsCursor++] = y;
					if (i$1 > len$1) throw new Error("Invalid data format.");
				}
			}
			return {
				flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
				flatCoords: coordsStorage,
				count: dataCount
			};
		}
		return {
			flatCoordsOffset: null,
			flatCoords: null,
			count: data.length
		};
	};
	LinesSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		if (!CoordinateSystem_default.get(option.coordinateSystem)) throw new Error("Unknown coordinate system " + option.coordinateSystem);
		var lineData = new SeriesData_default(["value"], this);
		lineData.hasItemOption = false;
		lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
			if (dataItem instanceof Array) return NaN;
			else {
				lineData.hasItemOption = true;
				var value = dataItem.value;
				if (value != null) return value instanceof Array ? value[dimIndex] : value;
			}
		});
		return lineData;
	};
	LinesSeriesModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		var itemModel = this.getData().getItemModel(dataIndex);
		var name = itemModel.get("name");
		if (name) return name;
		var fromName = itemModel.get("fromName");
		var toName = itemModel.get("toName");
		var nameArr = [];
		fromName != null && nameArr.push(fromName);
		toName != null && nameArr.push(toName);
		return createTooltipMarkup("nameValue", { name: nameArr.join(" > ") });
	};
	LinesSeriesModel$1.prototype.preventIncremental = function() {
		return !!this.get(["effect", "show"]);
	};
	LinesSeriesModel$1.prototype.getProgressive = function() {
		var progressive = this.option.progressive;
		if (progressive == null) return this.option.large ? 1e4 : this.get("progressive");
		return progressive;
	};
	LinesSeriesModel$1.prototype.getProgressiveThreshold = function() {
		var progressiveThreshold = this.option.progressiveThreshold;
		if (progressiveThreshold == null) return this.option.large ? 2e4 : this.get("progressiveThreshold");
		return progressiveThreshold;
	};
	LinesSeriesModel$1.prototype.getZLevelKey = function() {
		var effectModel = this.getModel("effect");
		var trailLength = effectModel.get("trailLength");
		return this.getData().count() > this.getProgressiveThreshold() ? this.id : effectModel.get("show") && trailLength > 0 ? trailLength + "" : "";
	};
	LinesSeriesModel$1.type = "series.lines";
	LinesSeriesModel$1.dependencies = [
		"grid",
		"polar",
		"geo",
		"calendar"
	];
	LinesSeriesModel$1.defaultOption = {
		coordinateSystem: "geo",
		z: 2,
		legendHoverLink: true,
		xAxisIndex: 0,
		yAxisIndex: 0,
		symbol: ["none", "none"],
		symbolSize: [10, 10],
		geoIndex: 0,
		effect: {
			show: false,
			period: 4,
			constantSpeed: 0,
			symbol: "circle",
			symbolSize: 3,
			loop: true,
			trailLength: .2
		},
		large: false,
		largeThreshold: 2e3,
		polyline: false,
		clip: true,
		label: {
			show: false,
			position: "end"
		},
		lineStyle: { opacity: .5 }
	};
	return LinesSeriesModel$1;
}(Series_default);
var LinesSeries_default = LinesSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/lines/linesVisual.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function normalize(a) {
	if (!(a instanceof Array)) a = [a, a];
	return a;
}
var linesVisual = {
	seriesType: "lines",
	reset: function(seriesModel) {
		var symbolType = normalize(seriesModel.get("symbol"));
		var symbolSize = normalize(seriesModel.get("symbolSize"));
		var data = seriesModel.getData();
		data.setVisual("fromSymbol", symbolType && symbolType[0]);
		data.setVisual("toSymbol", symbolType && symbolType[1]);
		data.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
		data.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
		function dataEach(data$1, idx) {
			var itemModel = data$1.getItemModel(idx);
			var symbolType$1 = normalize(itemModel.getShallow("symbol", true));
			var symbolSize$1 = normalize(itemModel.getShallow("symbolSize", true));
			symbolType$1[0] && data$1.setItemVisual(idx, "fromSymbol", symbolType$1[0]);
			symbolType$1[1] && data$1.setItemVisual(idx, "toSymbol", symbolType$1[1]);
			symbolSize$1[0] && data$1.setItemVisual(idx, "fromSymbolSize", symbolSize$1[0]);
			symbolSize$1[1] && data$1.setItemVisual(idx, "toSymbolSize", symbolSize$1[1]);
		}
		return { dataEach: data.hasItemOption ? dataEach : null };
	}
};
var linesVisual_default = linesVisual;

//#endregion
//#region node_modules/echarts/lib/chart/lines/install.js
function install$19(registers) {
	registers.registerChartView(LinesView_default);
	registers.registerSeriesModel(LinesSeries_default);
	registers.registerLayout(linesLayout_default);
	registers.registerVisual(linesVisual_default);
}

//#endregion
//#region node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js
var GRADIENT_LEVELS = 256;
var HeatmapLayer = function() {
	function HeatmapLayer$1() {
		this.blurSize = 30;
		this.pointSize = 20;
		this.maxOpacity = 1;
		this.minOpacity = 0;
		this._gradientPixels = {
			inRange: null,
			outOfRange: null
		};
		this.canvas = platformApi.createCanvas();
	}
	/**
	* Renders Heatmap and returns the rendered canvas
	* @param data array of data, each has x, y, value
	* @param width canvas width
	* @param height canvas height
	*/
	HeatmapLayer$1.prototype.update = function(data, width, height, normalize$4, colorFunc, isInRange) {
		var brush$2 = this._getBrush();
		var gradientInRange = this._getGradient(colorFunc, "inRange");
		var gradientOutOfRange = this._getGradient(colorFunc, "outOfRange");
		var r = this.pointSize + this.blurSize;
		var canvas = this.canvas;
		var ctx = canvas.getContext("2d");
		var len$1 = data.length;
		canvas.width = width;
		canvas.height = height;
		for (var i$1 = 0; i$1 < len$1; ++i$1) {
			var p = data[i$1];
			var x = p[0];
			var y = p[1];
			var value = p[2];
			var alpha = normalize$4(value);
			ctx.globalAlpha = alpha;
			ctx.drawImage(brush$2, x - r, y - r);
		}
		if (!canvas.width || !canvas.height) return canvas;
		var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
		var pixels = imageData.data;
		var offset = 0;
		var pixelLen = pixels.length;
		var minOpacity = this.minOpacity;
		var diffOpacity = this.maxOpacity - minOpacity;
		while (offset < pixelLen) {
			var alpha = pixels[offset + 3] / 256;
			var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
			if (alpha > 0) {
				var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
				alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
				pixels[offset++] = gradient[gradientOffset];
				pixels[offset++] = gradient[gradientOffset + 1];
				pixels[offset++] = gradient[gradientOffset + 2];
				pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
			} else offset += 4;
		}
		ctx.putImageData(imageData, 0, 0);
		return canvas;
	};
	/**
	* get canvas of a black circle brush used for canvas to draw later
	*/
	HeatmapLayer$1.prototype._getBrush = function() {
		var brushCanvas = this._brushCanvas || (this._brushCanvas = platformApi.createCanvas());
		var r = this.pointSize + this.blurSize;
		var d = r * 2;
		brushCanvas.width = d;
		brushCanvas.height = d;
		var ctx = brushCanvas.getContext("2d");
		ctx.clearRect(0, 0, d, d);
		ctx.shadowOffsetX = d;
		ctx.shadowBlur = this.blurSize;
		ctx.shadowColor = tokens_default.color.neutral99;
		ctx.beginPath();
		ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
		ctx.closePath();
		ctx.fill();
		return brushCanvas;
	};
	/**
	* get gradient color map
	* @private
	*/
	HeatmapLayer$1.prototype._getGradient = function(colorFunc, state) {
		var gradientPixels = this._gradientPixels;
		var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
		var color$2 = [
			0,
			0,
			0,
			0
		];
		var off = 0;
		for (var i$1 = 0; i$1 < 256; i$1++) {
			colorFunc[state](i$1 / 255, true, color$2);
			pixelsSingleState[off++] = color$2[0];
			pixelsSingleState[off++] = color$2[1];
			pixelsSingleState[off++] = color$2[2];
			pixelsSingleState[off++] = color$2[3];
		}
		return pixelsSingleState;
	};
	return HeatmapLayer$1;
}();
var HeatmapLayer_default = HeatmapLayer;

//#endregion
//#region node_modules/echarts/lib/chart/heatmap/HeatmapView.js
function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
	var dataSpan = dataExtent[1] - dataExtent[0];
	pieceList = map(pieceList, function(piece) {
		return { interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan] };
	});
	var len$1 = pieceList.length;
	var lastIndex = 0;
	return function(val) {
		var i$1;
		for (i$1 = lastIndex; i$1 < len$1; i$1++) {
			var interval = pieceList[i$1].interval;
			if (interval[0] <= val && val <= interval[1]) {
				lastIndex = i$1;
				break;
			}
		}
		if (i$1 === len$1) for (i$1 = lastIndex - 1; i$1 >= 0; i$1--) {
			var interval = pieceList[i$1].interval;
			if (interval[0] <= val && val <= interval[1]) {
				lastIndex = i$1;
				break;
			}
		}
		return i$1 >= 0 && i$1 < len$1 && selected[i$1];
	};
}
function getIsInContinuousRange(dataExtent, range) {
	var dataSpan = dataExtent[1] - dataExtent[0];
	range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
	return function(val) {
		return val >= range[0] && val <= range[1];
	};
}
function isGeoCoordSys(coordSys) {
	var dimensions = coordSys.dimensions;
	return dimensions[0] === "lng" && dimensions[1] === "lat";
}
var HeatmapView = function(_super) {
	__extends(HeatmapView$1, _super);
	function HeatmapView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = HeatmapView$1.type;
		return _this;
	}
	HeatmapView$1.prototype.render = function(seriesModel, ecModel, api) {
		var visualMapOfThisSeries;
		ecModel.eachComponent("visualMap", function(visualMap) {
			visualMap.eachTargetSeries(function(targetSeries) {
				if (targetSeries === seriesModel) visualMapOfThisSeries = visualMap;
			});
		});
		if (!visualMapOfThisSeries) throw new Error("Heatmap must use with visualMap");
		this._progressiveEls = null;
		this.group.removeAll();
		var coordSys = seriesModel.coordinateSystem;
		if (coordSys.type === "cartesian2d" || coordSys.type === "calendar" || coordSys.type === "matrix") this._renderOnGridLike(seriesModel, api, 0, seriesModel.getData().count());
		else if (isGeoCoordSys(coordSys)) this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
	};
	HeatmapView$1.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
		this.group.removeAll();
	};
	HeatmapView$1.prototype.incrementalRender = function(params, seriesModel, ecModel, api) {
		var coordSys = seriesModel.coordinateSystem;
		if (coordSys) if (isGeoCoordSys(coordSys)) this.render(seriesModel, ecModel, api);
		else {
			this._progressiveEls = [];
			this._renderOnGridLike(seriesModel, api, params.start, params.end, true);
		}
	};
	HeatmapView$1.prototype.eachRendered = function(cb) {
		traverseElements(this._progressiveEls || this.group, cb);
	};
	HeatmapView$1.prototype._renderOnGridLike = function(seriesModel, api, start$1, end$1, incremental) {
		var coordSys = seriesModel.coordinateSystem;
		var isCartesian2d = isCoordinateSystemType(coordSys, "cartesian2d");
		var isMatrix = isCoordinateSystemType(coordSys, "matrix");
		var width;
		var height;
		var xAxisExtent;
		var yAxisExtent;
		if (isCartesian2d) {
			var xAxis = coordSys.getAxis("x");
			var yAxis = coordSys.getAxis("y");
			if (!(xAxis.type === "category" && yAxis.type === "category")) throw new Error("Heatmap on cartesian must have two category axes");
			if (!(xAxis.onBand && yAxis.onBand)) throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
			width = xAxis.getBandWidth() + .5;
			height = yAxis.getBandWidth() + .5;
			xAxisExtent = xAxis.scale.getExtent();
			yAxisExtent = yAxis.scale.getExtent();
		}
		var group = this.group;
		var data = seriesModel.getData();
		var emphasisStyle = seriesModel.getModel(["emphasis", "itemStyle"]).getItemStyle();
		var blurStyle = seriesModel.getModel(["blur", "itemStyle"]).getItemStyle();
		var selectStyle = seriesModel.getModel(["select", "itemStyle"]).getItemStyle();
		var borderRadius = seriesModel.get(["itemStyle", "borderRadius"]);
		var labelStatesModels = getLabelStatesModels(seriesModel);
		var emphasisModel = seriesModel.getModel("emphasis");
		var focus = emphasisModel.get("focus");
		var blurScope = emphasisModel.get("blurScope");
		var emphasisDisabled = emphasisModel.get("disabled");
		var dataDims = isCartesian2d || isMatrix ? [
			data.mapDimension("x"),
			data.mapDimension("y"),
			data.mapDimension("value")
		] : [data.mapDimension("time"), data.mapDimension("value")];
		for (var idx = start$1; idx < end$1; idx++) {
			var rect = void 0;
			var style = data.getItemVisual(idx, "style");
			if (isCartesian2d) {
				var dataDimX = data.get(dataDims[0], idx);
				var dataDimY = data.get(dataDims[1], idx);
				if (isNaN(data.get(dataDims[2], idx)) || isNaN(dataDimX) || isNaN(dataDimY) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) continue;
				var point = coordSys.dataToPoint([dataDimX, dataDimY]);
				rect = new Rect_default({
					shape: {
						x: point[0] - width / 2,
						y: point[1] - height / 2,
						width,
						height
					},
					style
				});
			} else if (isMatrix) {
				var shape = coordSys.dataToLayout([data.get(dataDims[0], idx), data.get(dataDims[1], idx)]).rect;
				if (eqNaN(shape.x)) continue;
				rect = new Rect_default({
					z2: 1,
					shape,
					style
				});
			} else {
				if (isNaN(data.get(dataDims[1], idx))) continue;
				var layout$3 = coordSys.dataToLayout([data.get(dataDims[0], idx)]);
				var shape = layout$3.contentRect || layout$3.rect;
				if (eqNaN(shape.x) || eqNaN(shape.y)) continue;
				rect = new Rect_default({
					z2: 1,
					shape,
					style
				});
			}
			if (data.hasItemOption) {
				var itemModel = data.getItemModel(idx);
				var emphasisModel_1 = itemModel.getModel("emphasis");
				emphasisStyle = emphasisModel_1.getModel("itemStyle").getItemStyle();
				blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
				selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
				borderRadius = itemModel.get(["itemStyle", "borderRadius"]);
				focus = emphasisModel_1.get("focus");
				blurScope = emphasisModel_1.get("blurScope");
				emphasisDisabled = emphasisModel_1.get("disabled");
				labelStatesModels = getLabelStatesModels(itemModel);
			}
			rect.shape.r = borderRadius;
			var rawValue = seriesModel.getRawValue(idx);
			var defaultText = "-";
			if (rawValue && rawValue[2] != null) defaultText = rawValue[2] + "";
			setLabelStyle(rect, labelStatesModels, {
				labelFetcher: seriesModel,
				labelDataIndex: idx,
				defaultOpacity: style.opacity,
				defaultText
			});
			rect.ensureState("emphasis").style = emphasisStyle;
			rect.ensureState("blur").style = blurStyle;
			rect.ensureState("select").style = selectStyle;
			toggleHoverEmphasis(rect, focus, blurScope, emphasisDisabled);
			rect.incremental = incremental;
			if (incremental) rect.states.emphasis.hoverLayer = true;
			group.add(rect);
			data.setItemGraphicEl(idx, rect);
			if (this._progressiveEls) this._progressiveEls.push(rect);
		}
	};
	HeatmapView$1.prototype._renderOnGeo = function(geo, seriesModel, visualMapModel, api) {
		var inRangeVisuals = visualMapModel.targetVisuals.inRange;
		var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
		var data = seriesModel.getData();
		var hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer_default();
		hmLayer.blurSize = seriesModel.get("blurSize");
		hmLayer.pointSize = seriesModel.get("pointSize");
		hmLayer.minOpacity = seriesModel.get("minOpacity");
		hmLayer.maxOpacity = seriesModel.get("maxOpacity");
		var rect = geo.getViewRect().clone();
		var roamTransform = geo.getRoamTransform();
		rect.applyTransform(roamTransform);
		var x = Math.max(rect.x, 0);
		var y = Math.max(rect.y, 0);
		var x2 = Math.min(rect.width + rect.x, api.getWidth());
		var y2 = Math.min(rect.height + rect.y, api.getHeight());
		var width = x2 - x;
		var height = y2 - y;
		var dims = [
			data.mapDimension("lng"),
			data.mapDimension("lat"),
			data.mapDimension("value")
		];
		var points$3 = data.mapArray(dims, function(lng, lat, value) {
			var pt = geo.dataToPoint([lng, lat]);
			pt[0] -= x;
			pt[1] -= y;
			pt.push(value);
			return pt;
		});
		var dataExtent = visualMapModel.getExtent();
		var isInRange = visualMapModel.type === "visualMap.continuous" ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
		hmLayer.update(points$3, width, height, inRangeVisuals.color.getNormalizer(), {
			inRange: inRangeVisuals.color.getColorMapper(),
			outOfRange: outOfRangeVisuals.color.getColorMapper()
		}, isInRange);
		var img = new Image_default({
			style: {
				width,
				height,
				x,
				y,
				image: hmLayer.canvas
			},
			silent: true
		});
		this.group.add(img);
	};
	HeatmapView$1.type = "heatmap";
	return HeatmapView$1;
}(Chart_default);
var HeatmapView_default = HeatmapView;

//#endregion
//#region node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js
var HeatmapSeriesModel = function(_super) {
	__extends(HeatmapSeriesModel$1, _super);
	function HeatmapSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = HeatmapSeriesModel$1.type;
		return _this;
	}
	HeatmapSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		return createSeriesData_default(null, this, { generateCoord: "value" });
	};
	HeatmapSeriesModel$1.prototype.preventIncremental = function() {
		var coordSysCreator = CoordinateSystem_default.get(this.get("coordinateSystem"));
		if (coordSysCreator && coordSysCreator.dimensions) return coordSysCreator.dimensions[0] === "lng" && coordSysCreator.dimensions[1] === "lat";
	};
	HeatmapSeriesModel$1.type = "series.heatmap";
	HeatmapSeriesModel$1.dependencies = [
		"grid",
		"geo",
		"calendar",
		"matrix"
	];
	HeatmapSeriesModel$1.defaultOption = {
		coordinateSystem: "cartesian2d",
		z: 2,
		geoIndex: 0,
		blurSize: 30,
		pointSize: 20,
		maxOpacity: 1,
		minOpacity: 0,
		select: { itemStyle: { borderColor: tokens_default.color.primary } }
	};
	return HeatmapSeriesModel$1;
}(Series_default);
var HeatmapSeries_default = HeatmapSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/heatmap/install.js
function install$20(registers) {
	registers.registerChartView(HeatmapView_default);
	registers.registerSeriesModel(HeatmapSeries_default);
}

//#endregion
//#region node_modules/echarts/lib/chart/bar/PictorialBarView.js
var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"];
var LAYOUT_ATTRS = [{
	xy: "x",
	wh: "width",
	index: 0,
	posDesc: ["left", "right"]
}, {
	xy: "y",
	wh: "height",
	index: 1,
	posDesc: ["top", "bottom"]
}];
var pathForLineWidth = new Circle_default();
var PictorialBarView = function(_super) {
	__extends(PictorialBarView$1, _super);
	function PictorialBarView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = PictorialBarView$1.type;
		return _this;
	}
	PictorialBarView$1.prototype.render = function(seriesModel, ecModel, api) {
		var group = this.group;
		var data = seriesModel.getData();
		var oldData = this._data;
		var cartesian = seriesModel.coordinateSystem;
		var isHorizontal = cartesian.getBaseAxis().isHorizontal();
		var coordSysRect = cartesian.master.getRect();
		var opt = {
			ecSize: {
				width: api.getWidth(),
				height: api.getHeight()
			},
			seriesModel,
			coordSys: cartesian,
			coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
			isHorizontal,
			valueDim: LAYOUT_ATTRS[+isHorizontal],
			categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]
		};
		data.diff(oldData).add(function(dataIndex) {
			if (!data.hasValue(dataIndex)) return;
			var symbolMeta = getSymbolMeta(data, dataIndex, getItemModel(data, dataIndex), opt);
			var bar = createBar(data, opt, symbolMeta);
			data.setItemGraphicEl(dataIndex, bar);
			group.add(bar);
			updateCommon(bar, opt, symbolMeta);
		}).update(function(newIndex, oldIndex) {
			var bar = oldData.getItemGraphicEl(oldIndex);
			if (!data.hasValue(newIndex)) {
				group.remove(bar);
				return;
			}
			var symbolMeta = getSymbolMeta(data, newIndex, getItemModel(data, newIndex), opt);
			var pictorialShapeStr = getShapeStr(data, symbolMeta);
			if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
				group.remove(bar);
				data.setItemGraphicEl(newIndex, null);
				bar = null;
			}
			if (bar) updateBar(bar, opt, symbolMeta);
			else bar = createBar(data, opt, symbolMeta, true);
			data.setItemGraphicEl(newIndex, bar);
			bar.__pictorialSymbolMeta = symbolMeta;
			group.add(bar);
			updateCommon(bar, opt, symbolMeta);
		}).remove(function(dataIndex) {
			var bar = oldData.getItemGraphicEl(dataIndex);
			bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
		}).execute();
		var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
		if (clipPath) group.setClipPath(clipPath);
		else group.removeClipPath();
		this._data = data;
		return this.group;
	};
	PictorialBarView$1.prototype.remove = function(ecModel, api) {
		var group = this.group;
		var data = this._data;
		if (ecModel.get("animation")) {
			if (data) data.eachItemGraphicEl(function(bar) {
				removeBar(data, getECData(bar).dataIndex, ecModel, bar);
			});
		} else group.removeAll();
	};
	PictorialBarView$1.type = "pictorialBar";
	return PictorialBarView$1;
}(Chart_default);
function getSymbolMeta(data, dataIndex, itemModel, opt) {
	var layout$3 = data.getItemLayout(dataIndex);
	var symbolRepeat = itemModel.get("symbolRepeat");
	var symbolClip = itemModel.get("symbolClip");
	var symbolPosition = itemModel.get("symbolPosition") || "start";
	var rotation = (itemModel.get("symbolRotate") || 0) * Math.PI / 180 || 0;
	var symbolPatternSize = itemModel.get("symbolPatternSize") || 2;
	var isAnimationEnabled$1 = itemModel.isAnimationEnabled();
	var symbolMeta = {
		dataIndex,
		layout: layout$3,
		itemModel,
		symbolType: data.getItemVisual(dataIndex, "symbol") || "circle",
		style: data.getItemVisual(dataIndex, "style"),
		symbolClip,
		symbolRepeat,
		symbolRepeatDirection: itemModel.get("symbolRepeatDirection"),
		symbolPatternSize,
		rotation,
		animationModel: isAnimationEnabled$1 ? itemModel : null,
		hoverScale: isAnimationEnabled$1 && itemModel.get(["emphasis", "scale"]),
		z2: itemModel.getShallow("z", true) || 0
	};
	prepareBarLength(itemModel, symbolRepeat, layout$3, opt, symbolMeta);
	prepareSymbolSize(data, dataIndex, layout$3, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
	prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
	var symbolSize = symbolMeta.symbolSize;
	prepareLayoutInfo(itemModel, symbolSize, layout$3, symbolRepeat, symbolClip, normalizeSymbolOffset(itemModel.get("symbolOffset"), symbolSize), symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
	return symbolMeta;
}
function prepareBarLength(itemModel, symbolRepeat, layout$3, opt, outputSymbolMeta) {
	var valueDim = opt.valueDim;
	var symbolBoundingData = itemModel.get("symbolBoundingData");
	var valueAxis$1 = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
	var zeroPx = valueAxis$1.toGlobalCoord(valueAxis$1.dataToCoord(0));
	var pxSignIdx = 1 - +(layout$3[valueDim.wh] <= 0);
	var boundingLength;
	if (isArray(symbolBoundingData)) {
		var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis$1, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis$1, symbolBoundingData[1]) - zeroPx];
		symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
		boundingLength = symbolBoundingExtent[pxSignIdx];
	} else if (symbolBoundingData != null) boundingLength = convertToCoordOnAxis(valueAxis$1, symbolBoundingData) - zeroPx;
	else if (symbolRepeat) boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
	else boundingLength = layout$3[valueDim.wh];
	outputSymbolMeta.boundingLength = boundingLength;
	if (symbolRepeat) outputSymbolMeta.repeatCutLength = layout$3[valueDim.wh];
	var isXAxis = valueDim.xy === "x";
	var isInverse = valueAxis$1.inverse;
	outputSymbolMeta.pxSign = isXAxis && !isInverse || !isXAxis && isInverse ? boundingLength >= 0 ? 1 : -1 : boundingLength > 0 ? 1 : -1;
}
function convertToCoordOnAxis(axis, value) {
	return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
}
function prepareSymbolSize(data, dataIndex, layout$3, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {
	var valueDim = opt.valueDim;
	var categoryDim = opt.categoryDim;
	var categorySize = Math.abs(layout$3[categoryDim.wh]);
	var symbolSize = data.getItemVisual(dataIndex, "symbolSize");
	var parsedSymbolSize;
	if (isArray(symbolSize)) parsedSymbolSize = symbolSize.slice();
	else if (symbolSize == null) parsedSymbolSize = ["100%", "100%"];
	else parsedSymbolSize = [symbolSize, symbolSize];
	parsedSymbolSize[categoryDim.index] = parsePercent$1(parsedSymbolSize[categoryDim.index], categorySize);
	parsedSymbolSize[valueDim.index] = parsePercent$1(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
	outputSymbolMeta.symbolSize = parsedSymbolSize;
	var symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize];
	symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
}
function prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {
	var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
	if (valueLineWidth) {
		pathForLineWidth.attr({
			scaleX: symbolScale[0],
			scaleY: symbolScale[1],
			rotation
		});
		pathForLineWidth.updateTransform();
		valueLineWidth /= pathForLineWidth.getLineScale();
		valueLineWidth *= symbolScale[opt.valueDim.index];
	}
	outputSymbolMeta.valueLineWidth = valueLineWidth || 0;
}
function prepareLayoutInfo(itemModel, symbolSize, layout$3, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {
	var categoryDim = opt.categoryDim;
	var valueDim = opt.valueDim;
	var pxSign = outputSymbolMeta.pxSign;
	var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
	var pathLen = unitLength;
	if (symbolRepeat) {
		var absBoundingLength = Math.abs(boundingLength);
		var symbolMargin = retrieve(itemModel.get("symbolMargin"), "15%") + "";
		var hasEndGap = false;
		if (symbolMargin.lastIndexOf("!") === symbolMargin.length - 1) {
			hasEndGap = true;
			symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
		}
		var symbolMarginNumeric = parsePercent$1(symbolMargin, symbolSize[valueDim.index]);
		var uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0);
		var endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
		var repeatSpecified = isNumeric(symbolRepeat);
		var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);
		symbolMarginNumeric = (absBoundingLength - repeatTimes * unitLength) / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1));
		uLenWithMargin = unitLength + symbolMarginNumeric * 2;
		endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
		if (!repeatSpecified && symbolRepeat !== "fixed") repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
		pathLen = repeatTimes * uLenWithMargin - endFix;
		outputSymbolMeta.repeatTimes = repeatTimes;
		outputSymbolMeta.symbolMargin = symbolMarginNumeric;
	}
	var sizeFix = pxSign * (pathLen / 2);
	var pathPosition = outputSymbolMeta.pathPosition = [];
	pathPosition[categoryDim.index] = layout$3[categoryDim.wh] / 2;
	pathPosition[valueDim.index] = symbolPosition === "start" ? sizeFix : symbolPosition === "end" ? boundingLength - sizeFix : boundingLength / 2;
	if (symbolOffset) {
		pathPosition[0] += symbolOffset[0];
		pathPosition[1] += symbolOffset[1];
	}
	var bundlePosition = outputSymbolMeta.bundlePosition = [];
	bundlePosition[categoryDim.index] = layout$3[categoryDim.xy];
	bundlePosition[valueDim.index] = layout$3[valueDim.xy];
	var barRectShape = outputSymbolMeta.barRectShape = extend({}, layout$3);
	barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout$3[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
	barRectShape[categoryDim.wh] = layout$3[categoryDim.wh];
	var clipShape = outputSymbolMeta.clipShape = {};
	clipShape[categoryDim.xy] = -layout$3[categoryDim.xy];
	clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
	clipShape[valueDim.xy] = 0;
	clipShape[valueDim.wh] = layout$3[valueDim.wh];
}
function createPath(symbolMeta) {
	var symbolPatternSize = symbolMeta.symbolPatternSize;
	var path = createSymbol(symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);
	path.attr({ culling: true });
	path.type !== "image" && path.setStyle({ strokeNoScale: true });
	return path;
}
function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
	var bundle = bar.__pictorialBundle;
	var symbolSize = symbolMeta.symbolSize;
	var valueLineWidth = symbolMeta.valueLineWidth;
	var pathPosition = symbolMeta.pathPosition;
	var valueDim = opt.valueDim;
	var repeatTimes = symbolMeta.repeatTimes || 0;
	var index = 0;
	var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
	eachPath(bar, function(path$1) {
		path$1.__pictorialAnimationIndex = index;
		path$1.__pictorialRepeatTimes = repeatTimes;
		if (index < repeatTimes) updateAttr(path$1, null, makeTarget(index), symbolMeta, isUpdate);
		else updateAttr(path$1, null, {
			scaleX: 0,
			scaleY: 0
		}, symbolMeta, isUpdate, function() {
			bundle.remove(path$1);
		});
		index++;
	});
	for (; index < repeatTimes; index++) {
		var path = createPath(symbolMeta);
		path.__pictorialAnimationIndex = index;
		path.__pictorialRepeatTimes = repeatTimes;
		bundle.add(path);
		var target = makeTarget(index);
		updateAttr(path, {
			x: target.x,
			y: target.y,
			scaleX: 0,
			scaleY: 0
		}, {
			scaleX: target.scaleX,
			scaleY: target.scaleY,
			rotation: target.rotation
		}, symbolMeta, isUpdate);
	}
	function makeTarget(index$1) {
		var position$1 = pathPosition.slice();
		var pxSign = symbolMeta.pxSign;
		var i$1 = index$1;
		if (symbolMeta.symbolRepeatDirection === "start" ? pxSign > 0 : pxSign < 0) i$1 = repeatTimes - 1 - index$1;
		position$1[valueDim.index] = unit * (i$1 - repeatTimes / 2 + .5) + pathPosition[valueDim.index];
		return {
			x: position$1[0],
			y: position$1[1],
			scaleX: symbolMeta.symbolScale[0],
			scaleY: symbolMeta.symbolScale[1],
			rotation: symbolMeta.rotation
		};
	}
}
function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
	var bundle = bar.__pictorialBundle;
	var mainPath = bar.__pictorialMainPath;
	if (!mainPath) {
		mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
		bundle.add(mainPath);
		updateAttr(mainPath, {
			x: symbolMeta.pathPosition[0],
			y: symbolMeta.pathPosition[1],
			scaleX: 0,
			scaleY: 0,
			rotation: symbolMeta.rotation
		}, {
			scaleX: symbolMeta.symbolScale[0],
			scaleY: symbolMeta.symbolScale[1]
		}, symbolMeta, isUpdate);
	} else updateAttr(mainPath, null, {
		x: symbolMeta.pathPosition[0],
		y: symbolMeta.pathPosition[1],
		scaleX: symbolMeta.symbolScale[0],
		scaleY: symbolMeta.symbolScale[1],
		rotation: symbolMeta.rotation
	}, symbolMeta, isUpdate);
}
function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
	var rectShape = extend({}, symbolMeta.barRectShape);
	var barRect = bar.__pictorialBarRect;
	if (!barRect) {
		barRect = bar.__pictorialBarRect = new Rect_default({
			z2: 2,
			shape: rectShape,
			silent: true,
			style: {
				stroke: "transparent",
				fill: "transparent",
				lineWidth: 0
			}
		});
		barRect.disableMorphing = true;
		bar.add(barRect);
	} else updateAttr(barRect, null, { shape: rectShape }, symbolMeta, isUpdate);
}
function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
	if (symbolMeta.symbolClip) {
		var clipPath = bar.__pictorialClipPath;
		var clipShape = extend({}, symbolMeta.clipShape);
		var valueDim = opt.valueDim;
		var animationModel = symbolMeta.animationModel;
		var dataIndex = symbolMeta.dataIndex;
		if (clipPath) updateProps(clipPath, { shape: clipShape }, animationModel, dataIndex);
		else {
			clipShape[valueDim.wh] = 0;
			clipPath = new Rect_default({ shape: clipShape });
			bar.__pictorialBundle.setClipPath(clipPath);
			bar.__pictorialClipPath = clipPath;
			var target = {};
			target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
			graphic_exports$1[isUpdate ? "updateProps" : "initProps"](clipPath, { shape: target }, animationModel, dataIndex);
		}
	}
}
function getItemModel(data, dataIndex) {
	var itemModel = data.getItemModel(dataIndex);
	itemModel.getAnimationDelayParams = getAnimationDelayParams;
	itemModel.isAnimationEnabled = isAnimationEnabled;
	return itemModel;
}
function getAnimationDelayParams(path) {
	return {
		index: path.__pictorialAnimationIndex,
		count: path.__pictorialRepeatTimes
	};
}
function isAnimationEnabled() {
	return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function createBar(data, opt, symbolMeta, isUpdate) {
	var bar = new Group_default();
	var bundle = new Group_default();
	bar.add(bundle);
	bar.__pictorialBundle = bundle;
	bundle.x = symbolMeta.bundlePosition[0];
	bundle.y = symbolMeta.bundlePosition[1];
	if (symbolMeta.symbolRepeat) createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
	else createOrUpdateSingleSymbol(bar, opt, symbolMeta);
	createOrUpdateBarRect(bar, symbolMeta, isUpdate);
	createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
	bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
	bar.__pictorialSymbolMeta = symbolMeta;
	return bar;
}
function updateBar(bar, opt, symbolMeta) {
	var animationModel = symbolMeta.animationModel;
	var dataIndex = symbolMeta.dataIndex;
	var bundle = bar.__pictorialBundle;
	updateProps(bundle, {
		x: symbolMeta.bundlePosition[0],
		y: symbolMeta.bundlePosition[1]
	}, animationModel, dataIndex);
	if (symbolMeta.symbolRepeat) createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
	else createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
	createOrUpdateBarRect(bar, symbolMeta, true);
	createOrUpdateClip(bar, opt, symbolMeta, true);
}
function removeBar(data, dataIndex, animationModel, bar) {
	var labelRect = bar.__pictorialBarRect;
	labelRect && labelRect.removeTextContent();
	var paths = [];
	eachPath(bar, function(path) {
		paths.push(path);
	});
	bar.__pictorialMainPath && paths.push(bar.__pictorialMainPath);
	bar.__pictorialClipPath && (animationModel = null);
	each(paths, function(path) {
		removeElement(path, {
			scaleX: 0,
			scaleY: 0
		}, animationModel, dataIndex, function() {
			bar.parent && bar.parent.remove(bar);
		});
	});
	data.setItemGraphicEl(dataIndex, null);
}
function getShapeStr(data, symbolMeta) {
	return [
		data.getItemVisual(symbolMeta.dataIndex, "symbol") || "none",
		!!symbolMeta.symbolRepeat,
		!!symbolMeta.symbolClip
	].join(":");
}
function eachPath(bar, cb, context) {
	each(bar.__pictorialBundle.children(), function(el) {
		el !== bar.__pictorialBarRect && cb.call(context, el);
	});
}
function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
	immediateAttrs && el.attr(immediateAttrs);
	if (symbolMeta.symbolClip && !isUpdate) animationAttrs && el.attr(animationAttrs);
	else animationAttrs && graphic_exports$1[isUpdate ? "updateProps" : "initProps"](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
}
function updateCommon(bar, opt, symbolMeta) {
	var dataIndex = symbolMeta.dataIndex;
	var itemModel = symbolMeta.itemModel;
	var emphasisModel = itemModel.getModel("emphasis");
	var emphasisStyle = emphasisModel.getModel("itemStyle").getItemStyle();
	var blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
	var selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
	var cursorStyle = itemModel.getShallow("cursor");
	var focus = emphasisModel.get("focus");
	var blurScope = emphasisModel.get("blurScope");
	var hoverScale = emphasisModel.get("scale");
	eachPath(bar, function(path) {
		if (path instanceof Image_default) {
			var pathStyle = path.style;
			path.useStyle(extend({
				image: pathStyle.image,
				x: pathStyle.x,
				y: pathStyle.y,
				width: pathStyle.width,
				height: pathStyle.height
			}, symbolMeta.style));
		} else path.useStyle(symbolMeta.style);
		var emphasisState = path.ensureState("emphasis");
		emphasisState.style = emphasisStyle;
		if (hoverScale) {
			emphasisState.scaleX = path.scaleX * 1.1;
			emphasisState.scaleY = path.scaleY * 1.1;
		}
		path.ensureState("blur").style = blurStyle;
		path.ensureState("select").style = selectStyle;
		cursorStyle && (path.cursor = cursorStyle);
		path.z2 = symbolMeta.z2;
	});
	var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
	var barRect = bar.__pictorialBarRect;
	barRect.ignoreClip = true;
	setLabelStyle(barRect, getLabelStatesModels(itemModel), {
		labelFetcher: opt.seriesModel,
		labelDataIndex: dataIndex,
		defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),
		inheritColor: symbolMeta.style.fill,
		defaultOpacity: symbolMeta.style.opacity,
		defaultOutsidePosition: barPositionOutside
	});
	toggleHoverEmphasis(bar, focus, blurScope, emphasisModel.get("disabled"));
}
function toIntTimes(times) {
	var roundedTimes = Math.round(times);
	return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
}
var PictorialBarView_default = PictorialBarView;

//#endregion
//#region node_modules/echarts/lib/chart/bar/PictorialBarSeries.js
var PictorialBarSeriesModel = function(_super) {
	__extends(PictorialBarSeriesModel$1, _super);
	function PictorialBarSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = PictorialBarSeriesModel$1.type;
		_this.hasSymbolVisual = true;
		_this.defaultSymbol = "roundRect";
		return _this;
	}
	PictorialBarSeriesModel$1.prototype.getInitialData = function(option) {
		option.stack = null;
		return _super.prototype.getInitialData.apply(this, arguments);
	};
	PictorialBarSeriesModel$1.type = "series.pictorialBar";
	PictorialBarSeriesModel$1.dependencies = ["grid"];
	PictorialBarSeriesModel$1.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
		symbol: "circle",
		symbolSize: null,
		symbolRotate: null,
		symbolPosition: null,
		symbolOffset: null,
		symbolMargin: null,
		symbolRepeat: false,
		symbolRepeatDirection: "end",
		symbolClip: false,
		symbolBoundingData: null,
		symbolPatternSize: 400,
		barGap: "-100%",
		clip: false,
		progressive: 0,
		emphasis: { scale: false },
		select: { itemStyle: { borderColor: tokens_default.color.primary } }
	});
	return PictorialBarSeriesModel$1;
}(BaseBarSeries_default);
var PictorialBarSeries_default = PictorialBarSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/bar/installPictorialBar.js
function install$21(registers) {
	registers.registerChartView(PictorialBarView_default);
	registers.registerSeriesModel(PictorialBarSeries_default);
	registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout$1, "pictorialBar"));
	registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("pictorialBar"));
}

//#endregion
//#region node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js
var ThemeRiverView = function(_super) {
	__extends(ThemeRiverView$1, _super);
	function ThemeRiverView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ThemeRiverView$1.type;
		_this._layers = [];
		return _this;
	}
	ThemeRiverView$1.prototype.render = function(seriesModel, ecModel, api) {
		var data = seriesModel.getData();
		var self$1 = this;
		var group = this.group;
		var layersSeries = seriesModel.getLayerSeries();
		var layoutInfo = data.getLayout("layoutInfo");
		var rect = layoutInfo.rect;
		var boundaryGap = layoutInfo.boundaryGap;
		group.x = 0;
		group.y = rect.y + boundaryGap[0];
		function keyGetter(item) {
			return item.name;
		}
		var dataDiffer = new DataDiffer_default(this._layersSeries || [], layersSeries, keyGetter, keyGetter);
		var newLayersGroups = [];
		dataDiffer.add(bind(process, this, "add")).update(bind(process, this, "update")).remove(bind(process, this, "remove")).execute();
		function process(status, idx, oldIdx) {
			var oldLayersGroups = self$1._layers;
			if (status === "remove") {
				group.remove(oldLayersGroups[idx]);
				return;
			}
			var points0 = [];
			var points1 = [];
			var style;
			var indices = layersSeries[idx].indices;
			var j = 0;
			for (; j < indices.length; j++) {
				var layout$3 = data.getItemLayout(indices[j]);
				var x = layout$3.x;
				var y0 = layout$3.y0;
				var y = layout$3.y;
				points0.push(x, y0);
				points1.push(x, y0 + y);
				style = data.getItemVisual(indices[j], "style");
			}
			var polygon;
			var textLayout = data.getItemLayout(indices[0]);
			var margin = seriesModel.getModel("label").get("margin");
			var emphasisModel = seriesModel.getModel("emphasis");
			if (status === "add") {
				var layerGroup = newLayersGroups[idx] = new Group_default();
				polygon = new ECPolygon({
					shape: {
						points: points0,
						stackedOnPoints: points1,
						smooth: .4,
						stackedOnSmooth: .4,
						smoothConstraint: false
					},
					z2: 0
				});
				layerGroup.add(polygon);
				group.add(layerGroup);
				if (seriesModel.isAnimationEnabled()) polygon.setClipPath(createGridClipShape(polygon.getBoundingRect(), seriesModel, function() {
					polygon.removeClipPath();
				}));
			} else {
				var layerGroup = oldLayersGroups[oldIdx];
				polygon = layerGroup.childAt(0);
				group.add(layerGroup);
				newLayersGroups[idx] = layerGroup;
				updateProps(polygon, { shape: {
					points: points0,
					stackedOnPoints: points1
				} }, seriesModel);
				saveOldStyle(polygon);
			}
			setLabelStyle(polygon, getLabelStatesModels(seriesModel), {
				labelDataIndex: indices[j - 1],
				defaultText: data.getName(indices[j - 1]),
				inheritColor: style.fill
			}, { normal: { verticalAlign: "middle" } });
			polygon.setTextConfig({
				position: null,
				local: true
			});
			var labelEl = polygon.getTextContent();
			if (labelEl) {
				labelEl.x = textLayout.x - margin;
				labelEl.y = textLayout.y0 + textLayout.y / 2;
			}
			polygon.useStyle(style);
			data.setItemGraphicEl(idx, polygon);
			setStatesStylesFromModel(polygon, seriesModel);
			toggleHoverEmphasis(polygon, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
		}
		this._layersSeries = layersSeries;
		this._layers = newLayersGroups;
	};
	ThemeRiverView$1.type = "themeRiver";
	return ThemeRiverView$1;
}(Chart_default);
function createGridClipShape(rect, seriesModel, cb) {
	var rectEl = new Rect_default({ shape: {
		x: rect.x - 10,
		y: rect.y - 10,
		width: 0,
		height: rect.height + 20
	} });
	initProps(rectEl, { shape: {
		x: rect.x - 50,
		width: rect.width + 100,
		height: rect.height + 20
	} }, seriesModel, cb);
	return rectEl;
}
var ThemeRiverView_default = ThemeRiverView;

//#endregion
//#region node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js
var DATA_NAME_INDEX = 2;
var ThemeRiverSeriesModel = function(_super) {
	__extends(ThemeRiverSeriesModel$1, _super);
	function ThemeRiverSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ThemeRiverSeriesModel$1.type;
		return _this;
	}
	/**
	* @override
	*/
	ThemeRiverSeriesModel$1.prototype.init = function(option) {
		_super.prototype.init.apply(this, arguments);
		this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
	};
	/**
	* If there is no value of a certain point in the time for some event,set it value to 0.
	*
	* @param {Array} data  initial data in the option
	* @return {Array}
	*/
	ThemeRiverSeriesModel$1.prototype.fixData = function(data) {
		var rawDataLength = data.length;
		/**
		* Make sure every layer data get the same keys.
		* The value index tells which layer has visited.
		* {
		*  2014/01/01: -1
		* }
		*/
		var timeValueKeys = {};
		var groupResult = groupData(data, function(item) {
			if (!timeValueKeys.hasOwnProperty(item[0] + "")) timeValueKeys[item[0] + ""] = -1;
			return item[2];
		});
		var layerData = [];
		groupResult.buckets.each(function(items, key$1) {
			layerData.push({
				name: key$1,
				dataList: items
			});
		});
		var layerNum = layerData.length;
		for (var k$1 = 0; k$1 < layerNum; ++k$1) {
			var name_1 = layerData[k$1].name;
			for (var j = 0; j < layerData[k$1].dataList.length; ++j) {
				var timeValue = layerData[k$1].dataList[j][0] + "";
				timeValueKeys[timeValue] = k$1;
			}
			for (var timeValue in timeValueKeys) if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k$1) {
				timeValueKeys[timeValue] = k$1;
				data[rawDataLength] = [
					timeValue,
					0,
					name_1
				];
				rawDataLength++;
			}
		}
		return data;
	};
	/**
	* @override
	* @param  option  the initial option that user gave
	* @param  ecModel  the model object for themeRiver option
	*/
	ThemeRiverSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		var axisType = this.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0].get("type");
		var filterData = filter(option.data, function(dataItem) {
			return dataItem[2] !== void 0;
		});
		var data = this.fixData(filterData || []);
		var nameList = [];
		var nameMap = this.nameMap = createHashMap();
		var count$1 = 0;
		for (var i$1 = 0; i$1 < data.length; ++i$1) {
			nameList.push(data[i$1][DATA_NAME_INDEX]);
			if (!nameMap.get(data[i$1][DATA_NAME_INDEX])) {
				nameMap.set(data[i$1][DATA_NAME_INDEX], count$1);
				count$1++;
			}
		}
		var dimensions = prepareSeriesDataSchema(data, {
			coordDimensions: ["single"],
			dimensionsDefine: [
				{
					name: "time",
					type: getDimensionTypeByAxis(axisType)
				},
				{
					name: "value",
					type: "float"
				},
				{
					name: "name",
					type: "ordinal"
				}
			],
			encodeDefine: {
				single: 0,
				value: 1,
				itemName: 2
			}
		}).dimensions;
		var list = new SeriesData_default(dimensions, this);
		list.initData(data);
		return list;
	};
	/**
	* The raw data is divided into multiple layers and each layer
	*     has same name.
	*/
	ThemeRiverSeriesModel$1.prototype.getLayerSeries = function() {
		var data = this.getData();
		var lenCount = data.count();
		var indexArr = [];
		for (var i$1 = 0; i$1 < lenCount; ++i$1) indexArr[i$1] = i$1;
		var timeDim = data.mapDimension("single");
		var groupResult = groupData(indexArr, function(index) {
			return data.get("name", index);
		});
		var layerSeries = [];
		groupResult.buckets.each(function(items, key$1) {
			items.sort(function(index1, index2) {
				return data.get(timeDim, index1) - data.get(timeDim, index2);
			});
			layerSeries.push({
				name: key$1,
				indices: items
			});
		});
		return layerSeries;
	};
	/**
	* Get data indices for show tooltip content
	*/
	ThemeRiverSeriesModel$1.prototype.getAxisTooltipData = function(dim, value, baseAxis) {
		if (!isArray(dim)) dim = dim ? [dim] : [];
		var data = this.getData();
		var layerSeries = this.getLayerSeries();
		var indices = [];
		var layerNum = layerSeries.length;
		var nestestValue;
		for (var i$1 = 0; i$1 < layerNum; ++i$1) {
			var minDist = Number.MAX_VALUE;
			var nearestIdx = -1;
			var pointNum = layerSeries[i$1].indices.length;
			for (var j = 0; j < pointNum; ++j) {
				var theValue = data.get(dim[0], layerSeries[i$1].indices[j]);
				var dist$2 = Math.abs(theValue - value);
				if (dist$2 <= minDist) {
					nestestValue = theValue;
					minDist = dist$2;
					nearestIdx = layerSeries[i$1].indices[j];
				}
			}
			indices.push(nearestIdx);
		}
		return {
			dataIndices: indices,
			nestestValue
		};
	};
	ThemeRiverSeriesModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		var data = this.getData();
		return createTooltipMarkup("nameValue", {
			name: data.getName(dataIndex),
			value: data.get(data.mapDimension("value"), dataIndex)
		});
	};
	ThemeRiverSeriesModel$1.type = "series.themeRiver";
	ThemeRiverSeriesModel$1.dependencies = ["singleAxis"];
	ThemeRiverSeriesModel$1.defaultOption = {
		z: 2,
		colorBy: "data",
		coordinateSystem: "singleAxis",
		boundaryGap: ["10%", "10%"],
		singleAxisIndex: 0,
		animationEasing: "linear",
		label: {
			margin: 4,
			show: true,
			position: "left",
			fontSize: 11
		},
		emphasis: { label: { show: true } }
	};
	return ThemeRiverSeriesModel$1;
}(Series_default);
var ThemeRiverSeries_default = ThemeRiverSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js
function themeRiverLayout(ecModel, api) {
	ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
		var data = seriesModel.getData();
		var single = seriesModel.coordinateSystem;
		var layoutInfo = {};
		var rect = single.getRect();
		layoutInfo.rect = rect;
		var boundaryGap = seriesModel.get("boundaryGap");
		var axis = single.getAxis();
		layoutInfo.boundaryGap = boundaryGap;
		if (axis.orient === "horizontal") {
			boundaryGap[0] = parsePercent$1(boundaryGap[0], rect.height);
			boundaryGap[1] = parsePercent$1(boundaryGap[1], rect.height);
			doThemeRiverLayout(data, seriesModel, rect.height - boundaryGap[0] - boundaryGap[1]);
		} else {
			boundaryGap[0] = parsePercent$1(boundaryGap[0], rect.width);
			boundaryGap[1] = parsePercent$1(boundaryGap[1], rect.width);
			doThemeRiverLayout(data, seriesModel, rect.width - boundaryGap[0] - boundaryGap[1]);
		}
		data.setLayout("layoutInfo", layoutInfo);
	});
}
/**
* The layout information about themeriver
*
* @param data  data in the series
* @param seriesModel  the model object of themeRiver series
* @param height  value used to compute every series height
*/
function doThemeRiverLayout(data, seriesModel, height) {
	if (!data.count()) return;
	var coordSys = seriesModel.coordinateSystem;
	var layerSeries = seriesModel.getLayerSeries();
	var timeDim = data.mapDimension("single");
	var valueDim = data.mapDimension("value");
	var layerPoints = map(layerSeries, function(singleLayer) {
		return map(singleLayer.indices, function(idx) {
			var pt = coordSys.dataToPoint(data.get(timeDim, idx));
			pt[1] = data.get(valueDim, idx);
			return pt;
		});
	});
	var base$1 = computeBaseline(layerPoints);
	var baseLine = base$1.y0;
	var ky = height / base$1.max;
	var n = layerSeries.length;
	var m$1 = layerSeries[0].indices.length;
	var baseY0;
	for (var j = 0; j < m$1; ++j) {
		baseY0 = baseLine[j] * ky;
		data.setItemLayout(layerSeries[0].indices[j], {
			layerIndex: 0,
			x: layerPoints[0][j][0],
			y0: baseY0,
			y: layerPoints[0][j][1] * ky
		});
		for (var i$1 = 1; i$1 < n; ++i$1) {
			baseY0 += layerPoints[i$1 - 1][j][1] * ky;
			data.setItemLayout(layerSeries[i$1].indices[j], {
				layerIndex: i$1,
				x: layerPoints[i$1][j][0],
				y0: baseY0,
				y: layerPoints[i$1][j][1] * ky
			});
		}
	}
}
/**
* Compute the baseLine of the rawdata
* Inspired by Lee Byron's paper Stacked Graphs - Geometry & Aesthetics
*
* @param  data  the points in each layer
*/
function computeBaseline(data) {
	var layerNum = data.length;
	var pointNum = data[0].length;
	var sums = [];
	var y0 = [];
	var max$2 = 0;
	for (var i$1 = 0; i$1 < pointNum; ++i$1) {
		var temp = 0;
		for (var j = 0; j < layerNum; ++j) temp += data[j][i$1][1];
		if (temp > max$2) max$2 = temp;
		sums.push(temp);
	}
	for (var k$1 = 0; k$1 < pointNum; ++k$1) y0[k$1] = (max$2 - sums[k$1]) / 2;
	max$2 = 0;
	for (var l = 0; l < pointNum; ++l) {
		var sum$1 = sums[l] + y0[l];
		if (sum$1 > max$2) max$2 = sum$1;
	}
	return {
		y0,
		max: max$2
	};
}

//#endregion
//#region node_modules/echarts/lib/chart/themeRiver/install.js
function install$22(registers) {
	registers.registerChartView(ThemeRiverView_default);
	registers.registerSeriesModel(ThemeRiverSeries_default);
	registers.registerLayout(themeRiverLayout);
	registers.registerProcessor(dataFilter$1("themeRiver"));
}

//#endregion
//#region node_modules/echarts/lib/chart/sunburst/SunburstPiece.js
var DEFAULT_SECTOR_Z = 2;
var DEFAULT_TEXT_Z = 4;
/**
* Sunburstce of Sunburst including Sector, Label, LabelLine
*/
var SunburstPiece = function(_super) {
	__extends(SunburstPiece$1, _super);
	function SunburstPiece$1(node, seriesModel, ecModel, api) {
		var _this = _super.call(this) || this;
		_this.z2 = DEFAULT_SECTOR_Z;
		_this.textConfig = { inside: true };
		getECData(_this).seriesIndex = seriesModel.seriesIndex;
		var text = new Text_default({
			z2: DEFAULT_TEXT_Z,
			silent: node.getModel().get(["label", "silent"])
		});
		_this.setTextContent(text);
		_this.updateData(true, node, seriesModel, ecModel, api);
		return _this;
	}
	SunburstPiece$1.prototype.updateData = function(firstCreate, node, seriesModel, ecModel, api) {
		this.node = node;
		node.piece = this;
		seriesModel = seriesModel || this._seriesModel;
		ecModel = ecModel || this._ecModel;
		var sector = this;
		getECData(sector).dataIndex = node.dataIndex;
		var itemModel = node.getModel();
		var emphasisModel = itemModel.getModel("emphasis");
		var layout$3 = node.getLayout();
		var sectorShape = extend({}, layout$3);
		sectorShape.label = null;
		var normalStyle = node.getVisual("style");
		normalStyle.lineJoin = "bevel";
		var decal = node.getVisual("decal");
		if (decal) normalStyle.decal = createOrUpdatePatternFromDecal(decal, api);
		var cornerRadius = getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true);
		extend(sectorShape, cornerRadius);
		each(SPECIAL_STATES, function(stateName) {
			var state = sector.ensureState(stateName);
			var itemStyleModel = itemModel.getModel([stateName, "itemStyle"]);
			state.style = itemStyleModel.getItemStyle();
			var cornerRadius$1 = getSectorCornerRadius(itemStyleModel, sectorShape);
			if (cornerRadius$1) state.shape = cornerRadius$1;
		});
		if (firstCreate) {
			sector.setShape(sectorShape);
			sector.shape.r = layout$3.r0;
			initProps(sector, { shape: { r: layout$3.r } }, seriesModel, node.dataIndex);
		} else {
			updateProps(sector, { shape: sectorShape }, seriesModel);
			saveOldStyle(sector);
		}
		sector.useStyle(normalStyle);
		this._updateLabel(seriesModel);
		var cursorStyle = itemModel.getShallow("cursor");
		cursorStyle && sector.attr("cursor", cursorStyle);
		this._seriesModel = seriesModel || this._seriesModel;
		this._ecModel = ecModel || this._ecModel;
		var focus = emphasisModel.get("focus");
		var focusOrIndices = focus === "relative" ? concatArray(node.getAncestorsIndices(), node.getDescendantIndices()) : focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : focus;
		toggleHoverEmphasis(this, focusOrIndices, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
	};
	SunburstPiece$1.prototype._updateLabel = function(seriesModel) {
		var _this = this;
		var itemModel = this.node.getModel();
		var normalLabelModel = itemModel.getModel("label");
		var layout$3 = this.node.getLayout();
		var angle = layout$3.endAngle - layout$3.startAngle;
		var midAngle = (layout$3.startAngle + layout$3.endAngle) / 2;
		var dx = Math.cos(midAngle);
		var dy = Math.sin(midAngle);
		var sector = this;
		var label = sector.getTextContent();
		var dataIndex = this.node.dataIndex;
		var labelMinAngle = normalLabelModel.get("minAngle") / 180 * Math.PI;
		label.ignore = !(normalLabelModel.get("show") && !(labelMinAngle != null && Math.abs(angle) < labelMinAngle));
		each(DISPLAY_STATES, function(stateName) {
			var labelStateModel = stateName === "normal" ? itemModel.getModel("label") : itemModel.getModel([stateName, "label"]);
			var isNormal = stateName === "normal";
			var state = isNormal ? label : label.ensureState(stateName);
			var text = seriesModel.getFormattedLabel(dataIndex, stateName);
			if (isNormal) text = text || _this.node.name;
			state.style = createTextStyle(labelStateModel, {}, null, stateName !== "normal", true);
			if (text) state.style.text = text;
			var isShown = labelStateModel.get("show");
			if (isShown != null && !isNormal) state.ignore = !isShown;
			var labelPosition = getLabelAttr(labelStateModel, "position");
			var sectorState = isNormal ? sector : sector.states[stateName];
			var labelColor = sectorState.style.fill;
			sectorState.textConfig = {
				outsideFill: labelStateModel.get("color") === "inherit" ? labelColor : null,
				inside: labelPosition !== "outside"
			};
			var r;
			var labelPadding = getLabelAttr(labelStateModel, "distance") || 0;
			var textAlign = getLabelAttr(labelStateModel, "align");
			var rotateType = getLabelAttr(labelStateModel, "rotate");
			var flipStartAngle = Math.PI * .5;
			var flipEndAngle = Math.PI * 1.5;
			var midAngleNormal = normalizeRadian(rotateType === "tangential" ? Math.PI / 2 - midAngle : midAngle);
			var needsFlip = midAngleNormal > flipStartAngle && !isRadianAroundZero(midAngleNormal - flipStartAngle) && midAngleNormal < flipEndAngle;
			if (labelPosition === "outside") {
				r = layout$3.r + labelPadding;
				textAlign = needsFlip ? "right" : "left";
			} else if (!textAlign || textAlign === "center") {
				if (angle === 2 * Math.PI && layout$3.r0 === 0) r = 0;
				else r = (layout$3.r + layout$3.r0) / 2;
				textAlign = "center";
			} else if (textAlign === "left") {
				r = layout$3.r0 + labelPadding;
				textAlign = needsFlip ? "right" : "left";
			} else if (textAlign === "right") {
				r = layout$3.r - labelPadding;
				textAlign = needsFlip ? "left" : "right";
			}
			state.style.align = textAlign;
			state.style.verticalAlign = getLabelAttr(labelStateModel, "verticalAlign") || "middle";
			state.x = r * dx + layout$3.cx;
			state.y = r * dy + layout$3.cy;
			var rotate$1 = 0;
			if (rotateType === "radial") rotate$1 = normalizeRadian(-midAngle) + (needsFlip ? Math.PI : 0);
			else if (rotateType === "tangential") rotate$1 = normalizeRadian(Math.PI / 2 - midAngle) + (needsFlip ? Math.PI : 0);
			else if (isNumber(rotateType)) rotate$1 = rotateType * Math.PI / 180;
			state.rotation = normalizeRadian(rotate$1);
		});
		function getLabelAttr(model, name) {
			var stateAttr = model.get(name);
			if (stateAttr == null) return normalLabelModel.get(name);
			return stateAttr;
		}
		label.dirtyStyle();
	};
	return SunburstPiece$1;
}(Sector_default);
var SunburstPiece_default = SunburstPiece;

//#endregion
//#region node_modules/echarts/lib/chart/sunburst/sunburstAction.js
var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
var HIGHLIGHT_ACTION = "sunburstHighlight";
var UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
function installSunburstAction(registers) {
	registers.registerAction({
		type: ROOT_TO_NODE_ACTION,
		update: "updateView"
	}, function(payload, ecModel) {
		ecModel.eachComponent({
			mainType: "series",
			subType: "sunburst",
			query: payload
		}, handleRootToNode);
		function handleRootToNode(model, index) {
			var targetInfo = retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model);
			if (targetInfo) {
				var originViewRoot = model.getViewRoot();
				if (originViewRoot) payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
				model.resetViewRoot(targetInfo.node);
			}
		}
	});
	registers.registerAction({
		type: HIGHLIGHT_ACTION,
		update: "none"
	}, function(payload, ecModel, api) {
		payload = extend({}, payload);
		ecModel.eachComponent({
			mainType: "series",
			subType: "sunburst",
			query: payload
		}, handleHighlight);
		function handleHighlight(model) {
			var targetInfo = retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model);
			if (targetInfo) payload.dataIndex = targetInfo.node.dataIndex;
		}
		deprecateReplaceLog("sunburstHighlight", "highlight");
		api.dispatchAction(extend(payload, { type: "highlight" }));
	});
	registers.registerAction({
		type: UNHIGHLIGHT_ACTION,
		update: "updateView"
	}, function(payload, ecModel, api) {
		payload = extend({}, payload);
		deprecateReplaceLog("sunburstUnhighlight", "downplay");
		api.dispatchAction(extend(payload, { type: "downplay" }));
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/sunburst/SunburstView.js
var SunburstView = function(_super) {
	__extends(SunburstView$1, _super);
	function SunburstView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SunburstView$1.type;
		return _this;
	}
	SunburstView$1.prototype.render = function(seriesModel, ecModel, api, payload) {
		var self$1 = this;
		this.seriesModel = seriesModel;
		this.api = api;
		this.ecModel = ecModel;
		var data = seriesModel.getData();
		var virtualRoot = data.tree.root;
		var newRoot = seriesModel.getViewRoot();
		var group = this.group;
		var renderLabelForZeroData = seriesModel.get("renderLabelForZeroData");
		var newChildren = [];
		newRoot.eachNode(function(node) {
			newChildren.push(node);
		});
		dualTravel(newChildren, this._oldChildren || []);
		renderRollUp(virtualRoot, newRoot);
		this._initEvents();
		this._oldChildren = newChildren;
		function dualTravel(newChildren$1, oldChildren) {
			if (newChildren$1.length === 0 && oldChildren.length === 0) return;
			new DataDiffer_default(oldChildren, newChildren$1, getKey$1, getKey$1).add(processNode).update(processNode).remove(curry(processNode, null)).execute();
			function getKey$1(node) {
				return node.getId();
			}
			function processNode(newIdx, oldIdx) {
				doRenderNode(newIdx == null ? null : newChildren$1[newIdx], oldIdx == null ? null : oldChildren[oldIdx]);
			}
		}
		function doRenderNode(newNode, oldNode) {
			if (!renderLabelForZeroData && newNode && !newNode.getValue()) newNode = null;
			if (newNode !== virtualRoot && oldNode !== virtualRoot) {
				if (oldNode && oldNode.piece) if (newNode) {
					oldNode.piece.updateData(false, newNode, seriesModel, ecModel, api);
					data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
				} else removeNode$1(oldNode);
				else if (newNode) {
					var piece = new SunburstPiece_default(newNode, seriesModel, ecModel, api);
					group.add(piece);
					data.setItemGraphicEl(newNode.dataIndex, piece);
				}
			}
		}
		function removeNode$1(node) {
			if (!node) return;
			if (node.piece) {
				group.remove(node.piece);
				node.piece = null;
			}
		}
		function renderRollUp(virtualRoot$1, viewRoot) {
			if (viewRoot.depth > 0) {
				if (self$1.virtualPiece) self$1.virtualPiece.updateData(false, virtualRoot$1, seriesModel, ecModel, api);
				else {
					self$1.virtualPiece = new SunburstPiece_default(virtualRoot$1, seriesModel, ecModel, api);
					group.add(self$1.virtualPiece);
				}
				viewRoot.piece.off("click");
				self$1.virtualPiece.on("click", function(e$1) {
					self$1._rootToNode(viewRoot.parentNode);
				});
			} else if (self$1.virtualPiece) {
				group.remove(self$1.virtualPiece);
				self$1.virtualPiece = null;
			}
		}
	};
	/**
	* @private
	*/
	SunburstView$1.prototype._initEvents = function() {
		var _this = this;
		this.group.off("click");
		this.group.on("click", function(e$1) {
			var targetFound = false;
			_this.seriesModel.getViewRoot().eachNode(function(node) {
				if (!targetFound && node.piece && node.piece === e$1.target) {
					var nodeClick = node.getModel().get("nodeClick");
					if (nodeClick === "rootToNode") _this._rootToNode(node);
					else if (nodeClick === "link") {
						var itemModel = node.getModel();
						var link = itemModel.get("link");
						if (link) windowOpen(link, itemModel.get("target", true) || "_blank");
					}
					targetFound = true;
				}
			});
		});
	};
	/**
	* @private
	*/
	SunburstView$1.prototype._rootToNode = function(node) {
		if (node !== this.seriesModel.getViewRoot()) this.api.dispatchAction({
			type: ROOT_TO_NODE_ACTION,
			from: this.uid,
			seriesId: this.seriesModel.id,
			targetNode: node
		});
	};
	/**
	* @implement
	*/
	SunburstView$1.prototype.containPoint = function(point, seriesModel) {
		var itemLayout = seriesModel.getData().getItemLayout(0);
		if (itemLayout) {
			var dx = point[0] - itemLayout.cx;
			var dy = point[1] - itemLayout.cy;
			var radius = Math.sqrt(dx * dx + dy * dy);
			return radius <= itemLayout.r && radius >= itemLayout.r0;
		}
	};
	SunburstView$1.type = "sunburst";
	return SunburstView$1;
}(Chart_default);
var SunburstView_default = SunburstView;

//#endregion
//#region node_modules/echarts/lib/chart/sunburst/SunburstSeries.js
var SunburstSeriesModel = function(_super) {
	__extends(SunburstSeriesModel$1, _super);
	function SunburstSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SunburstSeriesModel$1.type;
		_this.ignoreStyleOnData = true;
		return _this;
	}
	SunburstSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		var root = {
			name: option.name,
			children: option.data
		};
		completeTreeValue(root);
		var levelModels = this._levelModels = map(option.levels || [], function(levelDefine) {
			return new Model_default(levelDefine, this, ecModel);
		}, this);
		var tree = Tree_default.createTree(root, this, beforeLink);
		function beforeLink(nodeData) {
			nodeData.wrapMethod("getItemModel", function(model, idx) {
				var levelModel = levelModels[tree.getNodeByDataIndex(idx).depth];
				levelModel && (model.parentModel = levelModel);
				return model;
			});
		}
		return tree.data;
	};
	SunburstSeriesModel$1.prototype.optionUpdated = function() {
		this.resetViewRoot();
	};
	SunburstSeriesModel$1.prototype.getDataParams = function(dataIndex) {
		var params = _super.prototype.getDataParams.apply(this, arguments);
		params.treePathInfo = wrapTreePathInfo(this.getData().tree.getNodeByDataIndex(dataIndex), this);
		return params;
	};
	SunburstSeriesModel$1.prototype.getLevelModel = function(node) {
		return this._levelModels && this._levelModels[node.depth];
	};
	SunburstSeriesModel$1.prototype.getViewRoot = function() {
		return this._viewRoot;
	};
	SunburstSeriesModel$1.prototype.resetViewRoot = function(viewRoot) {
		viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
		var root = this.getRawData().tree.root;
		if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) this._viewRoot = root;
	};
	SunburstSeriesModel$1.prototype.enableAriaDecal = function() {
		enableAriaDecalForTree(this);
	};
	SunburstSeriesModel$1.type = "series.sunburst";
	SunburstSeriesModel$1.defaultOption = {
		z: 2,
		center: ["50%", "50%"],
		radius: [0, "75%"],
		clockwise: true,
		startAngle: 90,
		minAngle: 0,
		stillShowZeroSum: true,
		nodeClick: "rootToNode",
		renderLabelForZeroData: false,
		label: {
			rotate: "radial",
			show: true,
			opacity: 1,
			align: "center",
			position: "inside",
			distance: 5,
			silent: true
		},
		itemStyle: {
			borderWidth: 1,
			borderColor: "white",
			borderType: "solid",
			shadowBlur: 0,
			shadowColor: "rgba(0, 0, 0, 0.2)",
			shadowOffsetX: 0,
			shadowOffsetY: 0,
			opacity: 1
		},
		emphasis: { focus: "descendant" },
		blur: {
			itemStyle: { opacity: .2 },
			label: { opacity: .1 }
		},
		animationType: "expansion",
		animationDuration: 1e3,
		animationDurationUpdate: 500,
		data: [],
		sort: "desc"
	};
	return SunburstSeriesModel$1;
}(Series_default);
function completeTreeValue(dataNode) {
	var sum$1 = 0;
	each(dataNode.children, function(child) {
		completeTreeValue(child);
		var childValue = child.value;
		isArray(childValue) && (childValue = childValue[0]);
		sum$1 += childValue;
	});
	var thisValue = dataNode.value;
	if (isArray(thisValue)) thisValue = thisValue[0];
	if (thisValue == null || isNaN(thisValue)) thisValue = sum$1;
	if (thisValue < 0) thisValue = 0;
	isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
var SunburstSeries_default = SunburstSeriesModel;

//#endregion
//#region node_modules/echarts/lib/chart/sunburst/sunburstLayout.js
var RADIAN = Math.PI / 180;
function sunburstLayout(seriesType$1, ecModel, api) {
	ecModel.eachSeriesByType(seriesType$1, function(seriesModel) {
		var center$2 = seriesModel.get("center");
		var radius = seriesModel.get("radius");
		if (!isArray(radius)) radius = [0, radius];
		if (!isArray(center$2)) center$2 = [center$2, center$2];
		var width = api.getWidth();
		var height = api.getHeight();
		var size = Math.min(width, height);
		var cx = parsePercent$1(center$2[0], width);
		var cy = parsePercent$1(center$2[1], height);
		var r0 = parsePercent$1(radius[0], size / 2);
		var r = parsePercent$1(radius[1], size / 2);
		var startAngle = -seriesModel.get("startAngle") * RADIAN;
		var minAngle = seriesModel.get("minAngle") * RADIAN;
		var virtualRoot = seriesModel.getData().tree.root;
		var treeRoot = seriesModel.getViewRoot();
		var rootDepth = treeRoot.depth;
		var sort$3 = seriesModel.get("sort");
		if (sort$3 != null) initChildren(treeRoot, sort$3);
		var validDataCount = 0;
		each(treeRoot.children, function(child) {
			!isNaN(child.getValue()) && validDataCount++;
		});
		var sum$1 = treeRoot.getValue();
		var unitRadian = Math.PI / (sum$1 || validDataCount) * 2;
		var renderRollupNode = treeRoot.depth > 0;
		var levels = treeRoot.height - (renderRollupNode ? -1 : 1);
		var rPerLevel = (r - r0) / (levels || 1);
		var clockwise = seriesModel.get("clockwise");
		var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
		var dir$1 = clockwise ? 1 : -1;
		/**
		* Render a tree
		* @return increased angle
		*/
		var renderNode$1 = function(node, startAngle$1) {
			if (!node) return;
			var endAngle = startAngle$1;
			if (node !== virtualRoot) {
				var value = node.getValue();
				var angle$1 = sum$1 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
				if (angle$1 < minAngle) angle$1 = minAngle;
				endAngle = startAngle$1 + dir$1 * angle$1;
				var depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
				var rStart$1 = r0 + rPerLevel * depth;
				var rEnd$1 = r0 + rPerLevel * (depth + 1);
				var levelModel = seriesModel.getLevelModel(node);
				if (levelModel) {
					var r0_1 = levelModel.get("r0", true);
					var r_1 = levelModel.get("r", true);
					var radius_1 = levelModel.get("radius", true);
					if (radius_1 != null) {
						r0_1 = radius_1[0];
						r_1 = radius_1[1];
					}
					r0_1 != null && (rStart$1 = parsePercent$1(r0_1, size / 2));
					r_1 != null && (rEnd$1 = parsePercent$1(r_1, size / 2));
				}
				node.setLayout({
					angle: angle$1,
					startAngle: startAngle$1,
					endAngle,
					clockwise,
					cx,
					cy,
					r0: rStart$1,
					r: rEnd$1
				});
			}
			if (node.children && node.children.length) {
				var siblingAngle_1 = 0;
				each(node.children, function(node$1) {
					siblingAngle_1 += renderNode$1(node$1, startAngle$1 + siblingAngle_1);
				});
			}
			return endAngle - startAngle$1;
		};
		if (renderRollupNode) {
			var rStart = r0;
			var rEnd = r0 + rPerLevel;
			var angle = Math.PI * 2;
			virtualRoot.setLayout({
				angle,
				startAngle,
				endAngle: startAngle + angle,
				clockwise,
				cx,
				cy,
				r0: rStart,
				r: rEnd
			});
		}
		renderNode$1(treeRoot, startAngle);
	});
}
/**
* Init node children by order and update visual
*/
function initChildren(node, sortOrder) {
	var children = node.children || [];
	node.children = sort(children, sortOrder);
	if (children.length) each(node.children, function(child) {
		initChildren(child, sortOrder);
	});
}
/**
* Sort children nodes
*
* @param {TreeNode[]}               children children of node to be sorted
* @param {string | function | null} sort sort method
*                                   See SunburstSeries.js for details.
*/
function sort(children, sortOrder) {
	if (isFunction(sortOrder)) {
		var sortTargets = map(children, function(child, idx) {
			var value = child.getValue();
			return {
				params: {
					depth: child.depth,
					height: child.height,
					dataIndex: child.dataIndex,
					getValue: function() {
						return value;
					}
				},
				index: idx
			};
		});
		sortTargets.sort(function(a, b) {
			return sortOrder(a.params, b.params);
		});
		return map(sortTargets, function(target) {
			return children[target.index];
		});
	} else {
		var isAsc_1 = sortOrder === "asc";
		return children.sort(function(a, b) {
			var diff = (a.getValue() - b.getValue()) * (isAsc_1 ? 1 : -1);
			return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc_1 ? -1 : 1) : diff;
		});
	}
}

//#endregion
//#region node_modules/echarts/lib/chart/sunburst/sunburstVisual.js
function sunburstVisual(ecModel) {
	var paletteScope = {};
	function pickColor(node, seriesModel, treeHeight) {
		if (node.depth === 0) return tokens_default.color.neutral50;
		var current = node;
		while (current && current.depth > 1) current = current.parentNode;
		var color$2 = seriesModel.getColorFromPalette(current.name || current.dataIndex + "", paletteScope);
		if (node.depth > 1 && isString(color$2)) color$2 = lift(color$2, (node.depth - 1) / (treeHeight - 1) * .5);
		return color$2;
	}
	ecModel.eachSeriesByType("sunburst", function(seriesModel) {
		var data = seriesModel.getData();
		var tree = data.tree;
		tree.eachNode(function(node) {
			var style = node.getModel().getModel("itemStyle").getItemStyle();
			if (!style.fill) style.fill = pickColor(node, seriesModel, tree.root.height);
			extend(data.ensureUniqueItemVisual(node.dataIndex, "style"), style);
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/sunburst/install.js
function install$23(registers) {
	registers.registerChartView(SunburstView_default);
	registers.registerSeriesModel(SunburstSeries_default);
	registers.registerLayout(curry(sunburstLayout, "sunburst"));
	registers.registerProcessor(curry(dataFilter$1, "sunburst"));
	registers.registerVisual(sunburstVisual);
	installSunburstAction(registers);
}

//#endregion
//#region node_modules/echarts/lib/chart/custom/CustomSeries.js
var STYLE_VISUAL_TYPE = {
	color: "fill",
	borderColor: "stroke"
};
var NON_STYLE_VISUAL_PROPS = {
	symbol: 1,
	symbolSize: 1,
	symbolKeepAspect: 1,
	legendIcon: 1,
	visualMeta: 1,
	liftZ: 1,
	decal: 1
};
var customInnerStore = makeInner();
var CustomSeriesModel = function(_super) {
	__extends(CustomSeriesModel$1, _super);
	function CustomSeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = CustomSeriesModel$1.type;
		return _this;
	}
	CustomSeriesModel$1.prototype.optionUpdated = function() {
		this.currentZLevel = this.get("zlevel", true);
		this.currentZ = this.get("z", true);
	};
	CustomSeriesModel$1.prototype.getInitialData = function(option, ecModel) {
		return createSeriesData_default(null, this);
	};
	CustomSeriesModel$1.prototype.getDataParams = function(dataIndex, dataType, el) {
		var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);
		el && (params.info = customInnerStore(el).info);
		return params;
	};
	CustomSeriesModel$1.type = "series.custom";
	CustomSeriesModel$1.dependencies = [
		"grid",
		"polar",
		"geo",
		"singleAxis",
		"calendar",
		"matrix"
	];
	CustomSeriesModel$1.defaultOption = {
		coordinateSystem: "cartesian2d",
		z: 2,
		legendHoverLink: true,
		clip: false
	};
	return CustomSeriesModel$1;
}(Series_default);
var CustomSeries_default = CustomSeriesModel;

//#endregion
//#region node_modules/echarts/lib/coord/cartesian/prepareCustom.js
function dataToCoordSize$3(dataSize, dataItem) {
	dataItem = dataItem || [0, 0];
	return map(["x", "y"], function(dim, dimIdx) {
		var axis = this.getAxis(dim);
		var val = dataItem[dimIdx];
		var halfSize = dataSize[dimIdx] / 2;
		return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
	}, this);
}
function cartesianPrepareCustom(coordSys) {
	var rect = coordSys.master.getRect();
	return {
		coordSys: {
			type: "cartesian2d",
			x: rect.x,
			y: rect.y,
			width: rect.width,
			height: rect.height
		},
		api: {
			coord: function(data) {
				return coordSys.dataToPoint(data);
			},
			size: bind(dataToCoordSize$3, coordSys)
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/coord/geo/prepareCustom.js
function dataToCoordSize$2(dataSize, dataItem) {
	dataItem = dataItem || [0, 0];
	return map([0, 1], function(dimIdx) {
		var val = dataItem[dimIdx];
		var halfSize = dataSize[dimIdx] / 2;
		var p1 = [];
		var p2 = [];
		p1[dimIdx] = val - halfSize;
		p2[dimIdx] = val + halfSize;
		p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
		return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
	}, this);
}
function geoPrepareCustom(coordSys) {
	var rect = coordSys.getBoundingRect();
	return {
		coordSys: {
			type: "geo",
			x: rect.x,
			y: rect.y,
			width: rect.width,
			height: rect.height,
			zoom: coordSys.getZoom()
		},
		api: {
			coord: function(data) {
				return coordSys.dataToPoint(data);
			},
			size: bind(dataToCoordSize$2, coordSys)
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/coord/single/prepareCustom.js
function dataToCoordSize$1(dataSize, dataItem) {
	var axis = this.getAxis();
	var val = dataItem instanceof Array ? dataItem[0] : dataItem;
	var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
	return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
}
function singlePrepareCustom(coordSys) {
	var rect = coordSys.getRect();
	return {
		coordSys: {
			type: "singleAxis",
			x: rect.x,
			y: rect.y,
			width: rect.width,
			height: rect.height
		},
		api: {
			coord: function(val) {
				return coordSys.dataToPoint(val);
			},
			size: bind(dataToCoordSize$1, coordSys)
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/coord/polar/prepareCustom.js
function dataToCoordSize(dataSize, dataItem) {
	dataItem = dataItem || [0, 0];
	return map(["Radius", "Angle"], function(dim, dimIdx) {
		var getterName = "get" + dim + "Axis";
		var axis = this[getterName]();
		var val = dataItem[dimIdx];
		var halfSize = dataSize[dimIdx] / 2;
		var result = axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
		if (dim === "Angle") result = result * Math.PI / 180;
		return result;
	}, this);
}
function polarPrepareCustom(coordSys) {
	var radiusAxis = coordSys.getRadiusAxis();
	var angleAxis = coordSys.getAngleAxis();
	var radius = radiusAxis.getExtent();
	radius[0] > radius[1] && radius.reverse();
	return {
		coordSys: {
			type: "polar",
			cx: coordSys.cx,
			cy: coordSys.cy,
			r: radius[1],
			r0: radius[0]
		},
		api: {
			coord: function(data) {
				var radius$1 = radiusAxis.dataToRadius(data[0]);
				var angle = angleAxis.dataToAngle(data[1]);
				var coord = coordSys.coordToPoint([radius$1, angle]);
				coord.push(radius$1, angle * Math.PI / 180);
				return coord;
			},
			size: bind(dataToCoordSize, coordSys)
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/coord/calendar/prepareCustom.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function calendarPrepareCustom(coordSys) {
	var rect = coordSys.getRect();
	var rangeInfo = coordSys.getRangeInfo();
	return {
		coordSys: {
			type: "calendar",
			x: rect.x,
			y: rect.y,
			width: rect.width,
			height: rect.height,
			cellWidth: coordSys.getCellWidth(),
			cellHeight: coordSys.getCellHeight(),
			rangeInfo: {
				start: rangeInfo.start,
				end: rangeInfo.end,
				weeks: rangeInfo.weeks,
				dayCount: rangeInfo.allDay
			}
		},
		api: {
			coord: function(data, clamp$1) {
				return coordSys.dataToPoint(data, clamp$1);
			},
			layout: function(data, clamp$1) {
				return coordSys.dataToLayout(data, clamp$1);
			}
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/coord/matrix/prepareCustom.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function matrixPrepareCustom(coordSys) {
	var rect = coordSys.getRect();
	return {
		coordSys: {
			type: "matrix",
			x: rect.x,
			y: rect.y,
			width: rect.width,
			height: rect.height
		},
		api: {
			coord: function(data, opt) {
				return coordSys.dataToPoint(data, opt);
			},
			layout: function(data, opt) {
				return coordSys.dataToLayout(data, opt);
			}
		}
	};
}

//#endregion
//#region node_modules/echarts/lib/util/styleCompat.js
var deprecatedLogs = {};
/**
* Whether need to call `convertEC4CompatibleStyle`.
*/
function isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {
	return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== "tspan" && (elType === "text" || hasOwn(style, "text")));
}
/**
* `EC4CompatibleStyle` is style that might be in echarts4 format or echarts5 format.
* @param hostStyle The properties might be modified.
* @return If be text el, `textContentStyle` and `textConfig` will not be returned.
*         Otherwise a `textContentStyle` and `textConfig` will be created, whose props area
*         retried from the `hostStyle`.
*/
function convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {
	var srcStyle = hostStyle;
	var textConfig;
	var textContent;
	var textContentStyle;
	if (elType === "text") textContentStyle = srcStyle;
	else {
		textContentStyle = {};
		hasOwn(srcStyle, "text") && (textContentStyle.text = srcStyle.text);
		hasOwn(srcStyle, "rich") && (textContentStyle.rich = srcStyle.rich);
		hasOwn(srcStyle, "textFill") && (textContentStyle.fill = srcStyle.textFill);
		hasOwn(srcStyle, "textStroke") && (textContentStyle.stroke = srcStyle.textStroke);
		hasOwn(srcStyle, "fontFamily") && (textContentStyle.fontFamily = srcStyle.fontFamily);
		hasOwn(srcStyle, "fontSize") && (textContentStyle.fontSize = srcStyle.fontSize);
		hasOwn(srcStyle, "fontStyle") && (textContentStyle.fontStyle = srcStyle.fontStyle);
		hasOwn(srcStyle, "fontWeight") && (textContentStyle.fontWeight = srcStyle.fontWeight);
		textContent = {
			type: "text",
			style: textContentStyle,
			silent: true
		};
		textConfig = {};
		var hasOwnPos = hasOwn(srcStyle, "textPosition");
		if (isNormal) textConfig.position = hasOwnPos ? srcStyle.textPosition : "inside";
		else hasOwnPos && (textConfig.position = srcStyle.textPosition);
		hasOwn(srcStyle, "textPosition") && (textConfig.position = srcStyle.textPosition);
		hasOwn(srcStyle, "textOffset") && (textConfig.offset = srcStyle.textOffset);
		hasOwn(srcStyle, "textRotation") && (textConfig.rotation = srcStyle.textRotation);
		hasOwn(srcStyle, "textDistance") && (textConfig.distance = srcStyle.textDistance);
	}
	convertEC4CompatibleRichItem(textContentStyle, hostStyle);
	each(textContentStyle.rich, function(richItem) {
		convertEC4CompatibleRichItem(richItem, richItem);
	});
	return {
		textConfig,
		textContent
	};
}
/**
* The result will be set to `out`.
*/
function convertEC4CompatibleRichItem(out$1, richItem) {
	if (!richItem) return;
	richItem.font = richItem.textFont || richItem.font;
	hasOwn(richItem, "textStrokeWidth") && (out$1.lineWidth = richItem.textStrokeWidth);
	hasOwn(richItem, "textAlign") && (out$1.align = richItem.textAlign);
	hasOwn(richItem, "textVerticalAlign") && (out$1.verticalAlign = richItem.textVerticalAlign);
	hasOwn(richItem, "textLineHeight") && (out$1.lineHeight = richItem.textLineHeight);
	hasOwn(richItem, "textWidth") && (out$1.width = richItem.textWidth);
	hasOwn(richItem, "textHeight") && (out$1.height = richItem.textHeight);
	hasOwn(richItem, "textBackgroundColor") && (out$1.backgroundColor = richItem.textBackgroundColor);
	hasOwn(richItem, "textPadding") && (out$1.padding = richItem.textPadding);
	hasOwn(richItem, "textBorderColor") && (out$1.borderColor = richItem.textBorderColor);
	hasOwn(richItem, "textBorderWidth") && (out$1.borderWidth = richItem.textBorderWidth);
	hasOwn(richItem, "textBorderRadius") && (out$1.borderRadius = richItem.textBorderRadius);
	hasOwn(richItem, "textBoxShadowColor") && (out$1.shadowColor = richItem.textBoxShadowColor);
	hasOwn(richItem, "textBoxShadowBlur") && (out$1.shadowBlur = richItem.textBoxShadowBlur);
	hasOwn(richItem, "textBoxShadowOffsetX") && (out$1.shadowOffsetX = richItem.textBoxShadowOffsetX);
	hasOwn(richItem, "textBoxShadowOffsetY") && (out$1.shadowOffsetY = richItem.textBoxShadowOffsetY);
}
/**
* Convert to pure echarts4 format style.
* `itemStyle` will be modified, added with ec4 style properties from
* `textStyle` and `textConfig`.
*
* [Caveat]: For simplicity, `insideRollback` in ec4 does not compat, where
* `styleEmphasis: {textFill: 'red'}` will remove the normal auto added stroke.
*/
function convertToEC4StyleForCustomSerise(itemStl, txStl, txCfg) {
	var out$1 = itemStl;
	out$1.textPosition = out$1.textPosition || txCfg.position || "inside";
	txCfg.offset != null && (out$1.textOffset = txCfg.offset);
	txCfg.rotation != null && (out$1.textRotation = txCfg.rotation);
	txCfg.distance != null && (out$1.textDistance = txCfg.distance);
	var isInside = out$1.textPosition.indexOf("inside") >= 0;
	var hostFill = itemStl.fill || tokens_default.color.neutral99;
	convertToEC4RichItem(out$1, txStl);
	var textFillNotSet = out$1.textFill == null;
	if (isInside) {
		if (textFillNotSet) {
			out$1.textFill = txCfg.insideFill || tokens_default.color.neutral00;
			!out$1.textStroke && txCfg.insideStroke && (out$1.textStroke = txCfg.insideStroke);
			!out$1.textStroke && (out$1.textStroke = hostFill);
			out$1.textStrokeWidth ??= 2;
		}
	} else {
		if (textFillNotSet) out$1.textFill = itemStl.fill || txCfg.outsideFill || tokens_default.color.neutral00;
		!out$1.textStroke && txCfg.outsideStroke && (out$1.textStroke = txCfg.outsideStroke);
	}
	out$1.text = txStl.text;
	out$1.rich = txStl.rich;
	each(txStl.rich, function(richItem) {
		convertToEC4RichItem(richItem, richItem);
	});
	return out$1;
}
function convertToEC4RichItem(out$1, richItem) {
	if (!richItem) return;
	hasOwn(richItem, "fill") && (out$1.textFill = richItem.fill);
	hasOwn(richItem, "stroke") && (out$1.textStroke = richItem.fill);
	hasOwn(richItem, "lineWidth") && (out$1.textStrokeWidth = richItem.lineWidth);
	hasOwn(richItem, "font") && (out$1.font = richItem.font);
	hasOwn(richItem, "fontStyle") && (out$1.fontStyle = richItem.fontStyle);
	hasOwn(richItem, "fontWeight") && (out$1.fontWeight = richItem.fontWeight);
	hasOwn(richItem, "fontSize") && (out$1.fontSize = richItem.fontSize);
	hasOwn(richItem, "fontFamily") && (out$1.fontFamily = richItem.fontFamily);
	hasOwn(richItem, "align") && (out$1.textAlign = richItem.align);
	hasOwn(richItem, "verticalAlign") && (out$1.textVerticalAlign = richItem.verticalAlign);
	hasOwn(richItem, "lineHeight") && (out$1.textLineHeight = richItem.lineHeight);
	hasOwn(richItem, "width") && (out$1.textWidth = richItem.width);
	hasOwn(richItem, "height") && (out$1.textHeight = richItem.height);
	hasOwn(richItem, "backgroundColor") && (out$1.textBackgroundColor = richItem.backgroundColor);
	hasOwn(richItem, "padding") && (out$1.textPadding = richItem.padding);
	hasOwn(richItem, "borderColor") && (out$1.textBorderColor = richItem.borderColor);
	hasOwn(richItem, "borderWidth") && (out$1.textBorderWidth = richItem.borderWidth);
	hasOwn(richItem, "borderRadius") && (out$1.textBorderRadius = richItem.borderRadius);
	hasOwn(richItem, "shadowColor") && (out$1.textBoxShadowColor = richItem.shadowColor);
	hasOwn(richItem, "shadowBlur") && (out$1.textBoxShadowBlur = richItem.shadowBlur);
	hasOwn(richItem, "shadowOffsetX") && (out$1.textBoxShadowOffsetX = richItem.shadowOffsetX);
	hasOwn(richItem, "shadowOffsetY") && (out$1.textBoxShadowOffsetY = richItem.shadowOffsetY);
	hasOwn(richItem, "textShadowColor") && (out$1.textShadowColor = richItem.textShadowColor);
	hasOwn(richItem, "textShadowBlur") && (out$1.textShadowBlur = richItem.textShadowBlur);
	hasOwn(richItem, "textShadowOffsetX") && (out$1.textShadowOffsetX = richItem.textShadowOffsetX);
	hasOwn(richItem, "textShadowOffsetY") && (out$1.textShadowOffsetY = richItem.textShadowOffsetY);
}
function warnDeprecated(deprecated, insteadApproach) {
	var key$1 = deprecated + "^_^" + insteadApproach;
	if (!deprecatedLogs[key$1]) {
		console.warn("[ECharts] DEPRECATED: \"" + deprecated + "\" has been deprecated. " + insteadApproach);
		deprecatedLogs[key$1] = true;
	}
}

//#endregion
//#region node_modules/echarts/lib/animation/customGraphicTransition.js
var LEGACY_TRANSFORM_PROPS_MAP = {
	position: ["x", "y"],
	scale: ["scaleX", "scaleY"],
	origin: ["originX", "originY"]
};
var LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP);
var TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function(obj, key$1) {
	obj[key$1] = 1;
	return obj;
}, {});
var transformPropNamesStr = TRANSFORMABLE_PROPS.join(", ");
var ELEMENT_ANIMATABLE_PROPS = [
	"",
	"style",
	"shape",
	"extra"
];
var transitionInnerStore = makeInner();
function getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {
	var animationProp = animationType + "Animation";
	var config = getAnimationConfig(animationType, parentModel, dataIndex) || {};
	var userDuring = transitionInnerStore(el).userDuring;
	if (config.duration > 0) {
		config.during = userDuring ? bind(duringCall, {
			el,
			userDuring
		}) : null;
		config.setToFinal = true;
		config.scope = animationType;
	}
	extend(config, elOption[animationProp]);
	return config;
}
function applyUpdateTransition(el, elOption, animatableModel, opts) {
	opts = opts || {};
	var dataIndex = opts.dataIndex, isInit = opts.isInit, clearStyle = opts.clearStyle;
	var hasAnimation = animatableModel.isAnimationEnabled();
	var store = transitionInnerStore(el);
	var styleOpt = elOption.style;
	store.userDuring = elOption.during;
	var transFromProps = {};
	var propsToSet = {};
	prepareTransformAllPropsFinal(el, elOption, propsToSet);
	if (el.type === "compound") {
		/**
		* We cannot directly clone shape for compoundPath,
		* because it makes the path to be an object instead of a Path instance,
		* and thus missing `buildPath` method.
		*/
		var paths = el.shape.paths;
		var optionPaths = elOption.shape.paths;
		for (var i$1 = 0; i$1 < optionPaths.length; i$1++) {
			var path = optionPaths[i$1];
			prepareShapeOrExtraAllPropsFinal("shape", path, paths[i$1]);
		}
	} else {
		prepareShapeOrExtraAllPropsFinal("shape", elOption, propsToSet);
		prepareShapeOrExtraAllPropsFinal("extra", elOption, propsToSet);
	}
	if (!isInit && hasAnimation) {
		prepareTransformTransitionFrom(el, elOption, transFromProps);
		prepareShapeOrExtraTransitionFrom("shape", el, elOption, transFromProps);
		prepareShapeOrExtraTransitionFrom("extra", el, elOption, transFromProps);
		prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);
	}
	propsToSet.style = styleOpt;
	applyPropsDirectly(el, propsToSet, clearStyle);
	applyMiscProps(el, elOption);
	if (hasAnimation) if (isInit) {
		var enterFromProps_1 = {};
		each(ELEMENT_ANIMATABLE_PROPS, function(propName) {
			var prop = propName ? elOption[propName] : elOption;
			if (prop && prop.enterFrom) {
				if (propName) enterFromProps_1[propName] = enterFromProps_1[propName] || {};
				extend(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);
			}
		});
		var config = getElementAnimationConfig("enter", el, elOption, animatableModel, dataIndex);
		if (config.duration > 0) el.animateFrom(enterFromProps_1, config);
	} else applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);
	updateLeaveTo(el, elOption);
	styleOpt ? el.dirty() : el.markRedraw();
}
function updateLeaveTo(el, elOption) {
	var leaveToProps = transitionInnerStore(el).leaveToProps;
	for (var i$1 = 0; i$1 < ELEMENT_ANIMATABLE_PROPS.length; i$1++) {
		var propName = ELEMENT_ANIMATABLE_PROPS[i$1];
		var prop = propName ? elOption[propName] : elOption;
		if (prop && prop.leaveTo) {
			if (!leaveToProps) leaveToProps = transitionInnerStore(el).leaveToProps = {};
			if (propName) leaveToProps[propName] = leaveToProps[propName] || {};
			extend(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);
		}
	}
}
function applyLeaveTransition(el, elOption, animatableModel, onRemove) {
	if (el) {
		var parent_1 = el.parent;
		var leaveToProps = transitionInnerStore(el).leaveToProps;
		if (leaveToProps) {
			var config = getElementAnimationConfig("update", el, elOption, animatableModel, 0);
			config.done = function() {
				parent_1 && parent_1.remove(el);
				onRemove && onRemove();
			};
			el.animateTo(leaveToProps, config);
		} else {
			parent_1 && parent_1.remove(el);
			onRemove && onRemove();
		}
	}
}
function isTransitionAll(transition) {
	return transition === "all";
}
function applyPropsDirectly(el, allPropsFinal, clearStyle) {
	var styleOpt = allPropsFinal.style;
	if (!el.isGroup && styleOpt) {
		if (clearStyle) {
			el.useStyle({});
			var animators = el.animators;
			for (var i$1 = 0; i$1 < animators.length; i$1++) {
				var animator = animators[i$1];
				if (animator.targetName === "style") animator.changeTarget(el.style);
			}
		}
		el.setStyle(styleOpt);
	}
	if (allPropsFinal) {
		allPropsFinal.style = null;
		allPropsFinal && el.attr(allPropsFinal);
		allPropsFinal.style = styleOpt;
	}
}
function applyPropsTransition(el, elOption, dataIndex, model, transFromProps) {
	if (transFromProps) {
		var config = getElementAnimationConfig("update", el, elOption, model, dataIndex);
		if (config.duration > 0) el.animateFrom(transFromProps, config);
	}
}
function applyMiscProps(el, elOption) {
	hasOwn(elOption, "silent") && (el.silent = elOption.silent);
	hasOwn(elOption, "ignore") && (el.ignore = elOption.ignore);
	if (el instanceof Displayable_default) hasOwn(elOption, "invisible") && (el.invisible = elOption.invisible);
	if (el instanceof Path_default) hasOwn(elOption, "autoBatch") && (el.autoBatch = elOption.autoBatch);
}
var tmpDuringScope = {};
var transitionDuringAPI = {
	setTransform: function(key$1, val) {
		assert(hasOwn(TRANSFORM_PROPS_MAP, key$1), "Only " + transformPropNamesStr + " available in `setTransform`.");
		tmpDuringScope.el[key$1] = val;
		return this;
	},
	getTransform: function(key$1) {
		assert(hasOwn(TRANSFORM_PROPS_MAP, key$1), "Only " + transformPropNamesStr + " available in `getTransform`.");
		return tmpDuringScope.el[key$1];
	},
	setShape: function(key$1, val) {
		assertNotReserved(key$1);
		var el = tmpDuringScope.el;
		var shape = el.shape || (el.shape = {});
		shape[key$1] = val;
		el.dirtyShape && el.dirtyShape();
		return this;
	},
	getShape: function(key$1) {
		assertNotReserved(key$1);
		var shape = tmpDuringScope.el.shape;
		if (shape) return shape[key$1];
	},
	setStyle: function(key$1, val) {
		assertNotReserved(key$1);
		var el = tmpDuringScope.el;
		var style = el.style;
		if (style) {
			if (eqNaN(val)) warn("style." + key$1 + " must not be assigned with NaN.");
			style[key$1] = val;
			el.dirtyStyle && el.dirtyStyle();
		}
		return this;
	},
	getStyle: function(key$1) {
		assertNotReserved(key$1);
		var style = tmpDuringScope.el.style;
		if (style) return style[key$1];
	},
	setExtra: function(key$1, val) {
		assertNotReserved(key$1);
		var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
		extra[key$1] = val;
		return this;
	},
	getExtra: function(key$1) {
		assertNotReserved(key$1);
		var extra = tmpDuringScope.el.extra;
		if (extra) return extra[key$1];
	}
};
function assertNotReserved(key$1) {
	if (key$1 === "transition" || key$1 === "enterFrom" || key$1 === "leaveTo") throw new Error("key must not be \"" + key$1 + "\"");
}
function duringCall() {
	var scope = this;
	var el = scope.el;
	if (!el) return;
	var latestUserDuring = transitionInnerStore(el).userDuring;
	var scopeUserDuring = scope.userDuring;
	if (latestUserDuring !== scopeUserDuring) {
		scope.el = scope.userDuring = null;
		return;
	}
	tmpDuringScope.el = el;
	scopeUserDuring(transitionDuringAPI);
}
function prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {
	var attrOpt = elOption[mainAttr];
	if (!attrOpt) return;
	var elPropsInAttr = fromEl[mainAttr];
	var transFromPropsInAttr;
	if (elPropsInAttr) {
		var transition = elOption.transition;
		var attrTransition = attrOpt.transition;
		if (attrTransition) {
			!transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
			if (isTransitionAll(attrTransition)) extend(transFromPropsInAttr, elPropsInAttr);
			else {
				var transitionKeys = normalizeToArray(attrTransition);
				for (var i$1 = 0; i$1 < transitionKeys.length; i$1++) {
					var key$1 = transitionKeys[i$1];
					var elVal = elPropsInAttr[key$1];
					transFromPropsInAttr[key$1] = elVal;
				}
			}
		} else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {
			!transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
			var elPropsInAttrKeys = keys(elPropsInAttr);
			for (var i$1 = 0; i$1 < elPropsInAttrKeys.length; i$1++) {
				var key$1 = elPropsInAttrKeys[i$1];
				var elVal = elPropsInAttr[key$1];
				if (isNonStyleTransitionEnabled(attrOpt[key$1], elVal)) transFromPropsInAttr[key$1] = elVal;
			}
		}
	}
}
function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {
	var attrOpt = elOption[mainAttr];
	if (!attrOpt) return;
	var allPropsInAttr = allProps[mainAttr] = {};
	var keysInAttr = keys(attrOpt);
	for (var i$1 = 0; i$1 < keysInAttr.length; i$1++) {
		var key$1 = keysInAttr[i$1];
		allPropsInAttr[key$1] = cloneValue(attrOpt[key$1]);
	}
}
function prepareTransformTransitionFrom(el, elOption, transFromProps) {
	var transition = elOption.transition;
	var transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);
	for (var i$1 = 0; i$1 < transitionKeys.length; i$1++) {
		var key$1 = transitionKeys[i$1];
		if (key$1 === "style" || key$1 === "shape" || key$1 === "extra") continue;
		var elVal = el[key$1];
		checkTransformPropRefer(key$1, "el.transition");
		transFromProps[key$1] = elVal;
	}
}
function prepareTransformAllPropsFinal(el, elOption, allProps) {
	for (var i$1 = 0; i$1 < LEGACY_TRANSFORM_PROPS.length; i$1++) {
		var legacyName = LEGACY_TRANSFORM_PROPS[i$1];
		var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];
		var legacyArr = elOption[legacyName];
		if (legacyArr) {
			allProps[xyName[0]] = legacyArr[0];
			allProps[xyName[1]] = legacyArr[1];
		}
	}
	for (var i$1 = 0; i$1 < TRANSFORMABLE_PROPS.length; i$1++) {
		var key$1 = TRANSFORMABLE_PROPS[i$1];
		if (elOption[key$1] != null) allProps[key$1] = elOption[key$1];
	}
}
function prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {
	if (!styleOpt) return;
	var fromElStyle = fromEl.style;
	var transFromStyleProps;
	if (fromElStyle) {
		var styleTransition = styleOpt.transition;
		var elTransition = elOption.transition;
		if (styleTransition && !isTransitionAll(styleTransition)) {
			var transitionKeys = normalizeToArray(styleTransition);
			!transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
			for (var i$1 = 0; i$1 < transitionKeys.length; i$1++) {
				var key$1 = transitionKeys[i$1];
				var elVal = fromElStyle[key$1];
				transFromStyleProps[key$1] = elVal;
			}
		} else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, "style") >= 0)) {
			var animationProps = fromEl.getAnimationStyleProps();
			var animationStyleProps = animationProps ? animationProps.style : null;
			if (animationStyleProps) {
				!transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
				var styleKeys = keys(styleOpt);
				for (var i$1 = 0; i$1 < styleKeys.length; i$1++) {
					var key$1 = styleKeys[i$1];
					if (animationStyleProps[key$1]) {
						var elVal = fromElStyle[key$1];
						transFromStyleProps[key$1] = elVal;
					}
				}
			}
		}
	}
}
function isNonStyleTransitionEnabled(optVal, elVal) {
	return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;
}
var checkTransformPropRefer = function(key$1, usedIn) {
	if (!hasOwn(TRANSFORM_PROPS_MAP, key$1)) warn("Prop `" + key$1 + "` is not a permitted in `" + usedIn + "`. Only `" + keys(TRANSFORM_PROPS_MAP).join("`, `") + "` are permitted.");
};

//#endregion
//#region node_modules/echarts/lib/animation/customGraphicKeyframeAnimation.js
var getStateToRestore = makeInner();
var KEYFRAME_EXCLUDE_KEYS = [
	"percent",
	"easing",
	"shape",
	"style",
	"extra"
];
/**
* Stop previous keyframe animation and restore the attributes.
* Avoid new keyframe animation starts with wrong internal state when the percent: 0 is not set.
*/
function stopPreviousKeyframeAnimationAndRestore(el) {
	el.stopAnimation("keyframe");
	el.attr(getStateToRestore(el));
}
function applyKeyframeAnimation(el, animationOpts, animatableModel) {
	if (!animatableModel.isAnimationEnabled() || !animationOpts) return;
	if (isArray(animationOpts)) {
		each(animationOpts, function(singleAnimationOpts) {
			applyKeyframeAnimation(el, singleAnimationOpts, animatableModel);
		});
		return;
	}
	var keyframes = animationOpts.keyframes;
	var duration = animationOpts.duration;
	if (animatableModel && duration == null) {
		var config = getAnimationConfig("enter", animatableModel, 0);
		duration = config && config.duration;
	}
	if (!keyframes || !duration) return;
	var stateToRestore = getStateToRestore(el);
	each(ELEMENT_ANIMATABLE_PROPS, function(targetPropName) {
		if (targetPropName && !el[targetPropName]) return;
		var animator;
		var endFrameIsSet = false;
		keyframes.sort(function(a, b) {
			return a.percent - b.percent;
		});
		each(keyframes, function(kf) {
			var animators = el.animators;
			var kfValues = targetPropName ? kf[targetPropName] : kf;
			if (kf.percent >= 1) endFrameIsSet = true;
			if (!kfValues) return;
			var propKeys = keys(kfValues);
			if (!targetPropName) propKeys = filter(propKeys, function(key$1) {
				return indexOf(KEYFRAME_EXCLUDE_KEYS, key$1) < 0;
			});
			if (!propKeys.length) return;
			if (!animator) {
				animator = el.animate(targetPropName, animationOpts.loop, true);
				animator.scope = "keyframe";
			}
			for (var i$1 = 0; i$1 < animators.length; i$1++) if (animators[i$1] !== animator && animators[i$1].targetName === animator.targetName) animators[i$1].stopTracks(propKeys);
			targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {});
			var savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore;
			each(propKeys, function(key$1) {
				savedTarget[key$1] = ((targetPropName ? el[targetPropName] : el) || {})[key$1];
			});
			animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing);
		});
		if (!animator) return;
		if (!endFrameIsSet) warn("End frame with percent: 1 is missing in the keyframeAnimation.", true);
		animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing);
	});
}

//#endregion
//#region node_modules/echarts/lib/chart/custom/CustomView.js
var EMPHASIS = "emphasis";
var NORMAL = "normal";
var BLUR = "blur";
var SELECT = "select";
var STATES = [
	NORMAL,
	EMPHASIS,
	BLUR,
	SELECT
];
var PATH_ITEM_STYLE = {
	normal: ["itemStyle"],
	emphasis: [EMPHASIS, "itemStyle"],
	blur: [BLUR, "itemStyle"],
	select: [SELECT, "itemStyle"]
};
var PATH_LABEL = {
	normal: ["label"],
	emphasis: [EMPHASIS, "label"],
	blur: [BLUR, "label"],
	select: [SELECT, "label"]
};
var DEFAULT_TRANSITION = ["x", "y"];
var GROUP_DIFF_PREFIX = "e\0\0";
var attachedTxInfoTmp = {
	normal: {},
	emphasis: {},
	blur: {},
	select: {}
};
/**
* FIXME: register rather than import directly, for size.
*
* To reduce total package size of each coordinate systems, the modules `prepareCustom`
* of each coordinate systems are not required by each coordinate systems directly, but
* required by the module `custom`.
*
* prepareInfoForCustomSeries {Function}: optional
*     @return {Object} {coordSys: {...}, api: {
*         coord: function (data, clamp) {}, // return point in global.
*         size: function (dataSize, dataItem) {} // return size of each axis in coordSys.
*     }}
*/
var prepareCustoms = {
	cartesian2d: cartesianPrepareCustom,
	geo: geoPrepareCustom,
	single: singlePrepareCustom,
	polar: polarPrepareCustom,
	calendar: calendarPrepareCustom,
	matrix: matrixPrepareCustom
};
function isPath(el) {
	return el instanceof Path_default;
}
function isDisplayable(el) {
	return el instanceof Displayable_default;
}
function copyElement(sourceEl, targetEl) {
	targetEl.copyTransform(sourceEl);
	if (isDisplayable(targetEl) && isDisplayable(sourceEl)) {
		targetEl.setStyle(sourceEl.style);
		targetEl.z = sourceEl.z;
		targetEl.z2 = sourceEl.z2;
		targetEl.zlevel = sourceEl.zlevel;
		targetEl.invisible = sourceEl.invisible;
		targetEl.ignore = sourceEl.ignore;
		if (isPath(targetEl) && isPath(sourceEl)) targetEl.setShape(sourceEl.shape);
	}
}
var CustomChartView = function(_super) {
	__extends(CustomChartView$1, _super);
	function CustomChartView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = CustomChartView$1.type;
		return _this;
	}
	CustomChartView$1.prototype.render = function(customSeries, ecModel, api, payload) {
		this._progressiveEls = null;
		var oldData = this._data;
		var data = customSeries.getData();
		var group = this.group;
		var renderItem = makeRenderItem(customSeries, data, ecModel, api);
		if (!oldData) group.removeAll();
		data.diff(oldData).add(function(newIdx) {
			createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
		}).remove(function(oldIdx) {
			var el = oldData.getItemGraphicEl(oldIdx);
			el && applyLeaveTransition(el, customInnerStore(el).option, customSeries);
		}).update(function(newIdx, oldIdx) {
			createOrUpdateItem(api, oldData.getItemGraphicEl(oldIdx), newIdx, renderItem(newIdx, payload), customSeries, group, data);
		}).execute();
		var clipPath = customSeries.get("clip", true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;
		if (clipPath) group.setClipPath(clipPath);
		else group.removeClipPath();
		this._data = data;
	};
	CustomChartView$1.prototype.incrementalPrepareRender = function(customSeries, ecModel, api) {
		this.group.removeAll();
		this._data = null;
	};
	CustomChartView$1.prototype.incrementalRender = function(params, customSeries, ecModel, api, payload) {
		var data = customSeries.getData();
		var renderItem = makeRenderItem(customSeries, data, ecModel, api);
		var progressiveEls = this._progressiveEls = [];
		function setIncrementalAndHoverLayer(el$1) {
			if (!el$1.isGroup) {
				el$1.incremental = true;
				el$1.ensureState("emphasis").hoverLayer = true;
			}
		}
		for (var idx = params.start; idx < params.end; idx++) {
			var el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data);
			if (el) {
				el.traverse(setIncrementalAndHoverLayer);
				progressiveEls.push(el);
			}
		}
	};
	CustomChartView$1.prototype.eachRendered = function(cb) {
		traverseElements(this._progressiveEls || this.group, cb);
	};
	CustomChartView$1.prototype.filterForExposedEvent = function(eventType, query, targetEl, packedEvent) {
		var elementName = query.element;
		if (elementName == null || targetEl.name === elementName) return true;
		while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) if (targetEl.name === elementName) return true;
		return false;
	};
	CustomChartView$1.type = "custom";
	return CustomChartView$1;
}(Chart_default);
var CustomView_default = CustomChartView;
function createEl$1(elOption) {
	var graphicType = elOption.type;
	var el;
	if (graphicType === "path") {
		var shape = elOption.shape;
		var pathRect = shape.width != null && shape.height != null ? {
			x: shape.x || 0,
			y: shape.y || 0,
			width: shape.width,
			height: shape.height
		} : null;
		var pathData = getPathData(shape);
		el = makePath(pathData, null, pathRect, shape.layout || "center");
		customInnerStore(el).customPathData = pathData;
	} else if (graphicType === "image") {
		el = new Image_default({});
		customInnerStore(el).customImagePath = elOption.style.image;
	} else if (graphicType === "text") el = new Text_default({});
	else if (graphicType === "group") el = new Group_default();
	else if (graphicType === "compoundPath") {
		var shape = elOption.shape;
		if (!shape || !shape.paths) {
			var errMsg = "";
			errMsg = "shape.paths must be specified in compoundPath";
			throwError(errMsg);
		}
		var paths = map(shape.paths, function(path) {
			if (path.type === "path") return makePath(path.shape.pathData, path, null);
			var Clz$1 = getShapeClass(path.type);
			if (!Clz$1) {
				var errMsg$1 = "";
				errMsg$1 = "graphic type \"" + graphicType + "\" can not be found.";
				throwError(errMsg$1);
			}
			return new Clz$1();
		});
		el = new CompoundPath_default({ shape: { paths } });
	} else {
		var Clz = getShapeClass(graphicType);
		if (!Clz) {
			var errMsg = "";
			errMsg = "graphic type \"" + graphicType + "\" can not be found.";
			throwError(errMsg);
		}
		el = new Clz();
	}
	customInnerStore(el).customGraphicType = graphicType;
	el.name = elOption.name;
	el.z2EmphasisLift = 1;
	el.z2SelectLift = 1;
	return el;
}
function updateElNormal(api, el, dataIndex, elOption, attachedTxInfo, seriesModel, isInit) {
	stopPreviousKeyframeAnimationAndRestore(el);
	var txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;
	if (txCfgOpt) el.setTextConfig(txCfgOpt);
	if (elOption && elOption.transition == null) elOption.transition = DEFAULT_TRANSITION;
	var styleOpt = elOption && elOption.style;
	if (styleOpt) {
		if (el.type === "text") {
			var textOptionStyle = styleOpt;
			hasOwn(textOptionStyle, "textFill") && (textOptionStyle.fill = textOptionStyle.textFill);
			hasOwn(textOptionStyle, "textStroke") && (textOptionStyle.stroke = textOptionStyle.textStroke);
		}
		var decalPattern = void 0;
		var decalObj = isPath(el) ? styleOpt.decal : null;
		if (api && decalObj) {
			decalObj.dirty = true;
			decalPattern = createOrUpdatePatternFromDecal(decalObj, api);
		}
		styleOpt.__decalPattern = decalPattern;
	}
	if (isDisplayable(el)) {
		if (styleOpt) {
			var decalPattern = styleOpt.__decalPattern;
			if (decalPattern) styleOpt.decal = decalPattern;
		}
	}
	applyUpdateTransition(el, elOption, seriesModel, {
		dataIndex,
		isInit,
		clearStyle: true
	});
	applyKeyframeAnimation(el, elOption.keyframeAnimation, seriesModel);
}
function updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo) {
	var elDisplayable = el.isGroup ? null : el;
	var txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg;
	if (elDisplayable) {
		var stateObj = elDisplayable.ensureState(state);
		if (styleOpt === false) {
			var existingEmphasisState = elDisplayable.getState(state);
			if (existingEmphasisState) existingEmphasisState.style = null;
		} else stateObj.style = styleOpt || null;
		if (txCfgOpt) stateObj.textConfig = txCfgOpt;
		setDefaultStateProxy(elDisplayable);
	}
}
function updateZ$2(el, elOption, seriesModel) {
	if (el.isGroup) return;
	var elDisplayable = el;
	var currentZ = seriesModel.currentZ;
	var currentZLevel = seriesModel.currentZLevel;
	elDisplayable.z = currentZ;
	elDisplayable.zlevel = currentZLevel;
	var optZ2 = elOption.z2;
	optZ2 != null && (elDisplayable.z2 = optZ2 || 0);
	for (var i$1 = 0; i$1 < STATES.length; i$1++) updateZForEachState(elDisplayable, elOption, STATES[i$1]);
}
function updateZForEachState(elDisplayable, elOption, state) {
	var isNormal = state === NORMAL;
	var elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);
	var optZ2 = elStateOpt ? elStateOpt.z2 : null;
	var stateObj;
	if (optZ2 != null) {
		stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);
		stateObj.z2 = optZ2 || 0;
	}
}
function makeRenderItem(customSeries, data, ecModel, api) {
	var renderItem = customSeries.get("renderItem");
	if (typeof renderItem === "string") {
		var registeredRenderItem = getCustomSeries(renderItem);
		if (registeredRenderItem) renderItem = registeredRenderItem;
		else console.warn("Custom series renderItem '" + renderItem + "' not found.\n                Call 'echarts.registerCustomSeries' to register it.");
	}
	var coordSys = customSeries.coordinateSystem;
	var prepareResult$1 = {};
	if (coordSys) {
		assert(renderItem, "series.render is required.");
		assert(coordSys.prepareCustoms || prepareCustoms[coordSys.type], "This coordSys does not support custom series.");
		prepareResult$1 = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);
	}
	var userAPI = defaults({
		getWidth: api.getWidth,
		getHeight: api.getHeight,
		getZr: api.getZr,
		getDevicePixelRatio: api.getDevicePixelRatio,
		value,
		style,
		ordinalRawValue,
		styleEmphasis,
		visual,
		barLayout,
		currentSeriesIndices,
		font
	}, prepareResult$1.api || {});
	var userParams = {
		context: {},
		seriesId: customSeries.id,
		seriesName: customSeries.name,
		seriesIndex: customSeries.seriesIndex,
		coordSys: prepareResult$1.coordSys,
		dataInsideLength: data.count(),
		encode: wrapEncodeDef(customSeries.getData()),
		itemPayload: customSeries.get("itemPayload") || {}
	};
	var currDataIndexInside;
	var currItemModel;
	var currItemStyleModels = {};
	var currLabelModels = {};
	var seriesItemStyleModels = {};
	var seriesLabelModels = {};
	for (var i$1 = 0; i$1 < STATES.length; i$1++) {
		var stateName = STATES[i$1];
		seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);
		seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);
	}
	function getItemModel$1(dataIndexInside) {
		return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);
	}
	function getItemStyleModel(dataIndexInside, state) {
		return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel$1(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel$1(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);
	}
	function getLabelModel(dataIndexInside, state) {
		return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel$1(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel$1(dataIndexInside).getModel(PATH_LABEL[state]);
	}
	return function(dataIndexInside, payload) {
		currDataIndexInside = dataIndexInside;
		currItemModel = null;
		currItemStyleModels = {};
		currLabelModels = {};
		return renderItem && renderItem(defaults({
			dataIndexInside,
			dataIndex: data.getRawIndex(dataIndexInside),
			actionType: payload ? payload.type : null
		}, userParams), userAPI);
	};
	/**
	* @public
	* @param dim by default 0.
	* @param dataIndexInside by default `currDataIndexInside`.
	*/
	function value(dim, dataIndexInside) {
		dataIndexInside ??= currDataIndexInside;
		return data.getStore().get(data.getDimensionIndex(dim || 0), dataIndexInside);
	}
	/**
	* @public
	* @param dim by default 0.
	* @param dataIndexInside by default `currDataIndexInside`.
	*/
	function ordinalRawValue(dim, dataIndexInside) {
		dataIndexInside ??= currDataIndexInside;
		dim = dim || 0;
		var dimInfo = data.getDimensionInfo(dim);
		if (!dimInfo) {
			var dimIndex = data.getDimensionIndex(dim);
			return dimIndex >= 0 ? data.getStore().get(dimIndex, dataIndexInside) : void 0;
		}
		var val = data.get(dimInfo.name, dataIndexInside);
		var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
		return ordinalMeta ? ordinalMeta.categories[val] : val;
	}
	/**
	* @deprecated The original intention of `api.style` is enable to set itemStyle
	* like other series. But it is not necessary and not easy to give a strict definition
	* of what it returns. And since echarts5 it needs to be make compat work. So
	* deprecates it since echarts5.
	*
	* By default, `visual` is applied to style (to support visualMap).
	* `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`,
	* it can be implemented as:
	* `api.style({stroke: api.visual('color'), fill: null})`;
	*
	* [Compat]: since ec5, RectText has been separated from its hosts el.
	* so `api.style()` will only return the style from `itemStyle` but not handle `label`
	* any more. But `series.label` config is never published in doc.
	* We still compat it in `api.style()`. But not encourage to use it and will still not
	* to pulish it to doc.
	* @public
	* @param dataIndexInside by default `currDataIndexInside`.
	*/
	function style(userProps, dataIndexInside) {
		warnDeprecated("api.style", "Please write literal style directly instead.");
		dataIndexInside ??= currDataIndexInside;
		var style$1 = data.getItemVisual(dataIndexInside, "style");
		var visualColor = style$1 && style$1.fill;
		var opacity = style$1 && style$1.opacity;
		var itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();
		visualColor != null && (itemStyle.fill = visualColor);
		opacity != null && (itemStyle.opacity = opacity);
		var opt = { inheritColor: isString(visualColor) ? visualColor : tokens_default.color.neutral99 };
		var labelModel = getLabelModel(dataIndexInside, NORMAL);
		var textStyle = createTextStyle(labelModel, null, opt, false, true);
		textStyle.text = labelModel.getShallow("show") ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
		var textConfig = createTextConfig(labelModel, opt, false);
		preFetchFromExtra(userProps, itemStyle);
		itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
		userProps && applyUserPropsAfter(itemStyle, userProps);
		itemStyle.legacy = true;
		return itemStyle;
	}
	/**
	* @deprecated The reason see `api.style()`
	* @public
	* @param dataIndexInside by default `currDataIndexInside`.
	*/
	function styleEmphasis(userProps, dataIndexInside) {
		warnDeprecated("api.styleEmphasis", "Please write literal style directly instead.");
		dataIndexInside ??= currDataIndexInside;
		var itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();
		var labelModel = getLabelModel(dataIndexInside, EMPHASIS);
		var textStyle = createTextStyle(labelModel, null, null, true, true);
		textStyle.text = labelModel.getShallow("show") ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
		var textConfig = createTextConfig(labelModel, null, true);
		preFetchFromExtra(userProps, itemStyle);
		itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
		userProps && applyUserPropsAfter(itemStyle, userProps);
		itemStyle.legacy = true;
		return itemStyle;
	}
	function applyUserPropsAfter(itemStyle, extra) {
		for (var key$1 in extra) if (hasOwn(extra, key$1)) itemStyle[key$1] = extra[key$1];
	}
	function preFetchFromExtra(extra, itemStyle) {
		if (extra) {
			extra.textFill && (itemStyle.textFill = extra.textFill);
			extra.textPosition && (itemStyle.textPosition = extra.textPosition);
		}
	}
	/**
	* @public
	* @param dataIndexInside by default `currDataIndexInside`.
	*/
	function visual(visualType, dataIndexInside) {
		dataIndexInside ??= currDataIndexInside;
		if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {
			var style_1 = data.getItemVisual(dataIndexInside, "style");
			return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null;
		}
		if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) return data.getItemVisual(dataIndexInside, visualType);
	}
	/**
	* @public
	* @return If not support, return undefined.
	*/
	function barLayout(opt) {
		if (coordSys.type === "cartesian2d") return getLayoutOnAxis(defaults({ axis: coordSys.getBaseAxis() }, opt));
	}
	/**
	* @public
	*/
	function currentSeriesIndices() {
		return ecModel.getCurrentSeriesIndices();
	}
	/**
	* @public
	* @return font string
	*/
	function font(opt) {
		return getFont(opt, ecModel);
	}
}
function wrapEncodeDef(data) {
	var encodeDef = {};
	each(data.dimensions, function(dimName) {
		var dimInfo = data.getDimensionInfo(dimName);
		if (!dimInfo.isExtraCoord) {
			var coordDim = dimInfo.coordDim;
			var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
			dataDims[dimInfo.coordDimIndex] = data.getDimensionIndex(dimName);
		}
	});
	return encodeDef;
}
function createOrUpdateItem(api, existsEl, dataIndex, elOption, seriesModel, group, data) {
	if (!elOption) {
		group.remove(existsEl);
		return;
	}
	var el = doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group);
	el && data.setItemGraphicEl(dataIndex, el);
	el && toggleHoverEmphasis(el, elOption.focus, elOption.blurScope, elOption.emphasisDisabled);
	return el;
}
function doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group) {
	assert(elOption, "should not have an null/undefined element setting");
	var toBeReplacedIdx = -1;
	var oldEl = existsEl;
	if (existsEl && doesElNeedRecreate(existsEl, elOption, seriesModel)) {
		toBeReplacedIdx = indexOf(group.childrenRef(), existsEl);
		existsEl = null;
	}
	var isInit = !existsEl;
	var el = existsEl;
	if (!el) {
		el = createEl$1(elOption);
		if (oldEl) copyElement(oldEl, el);
	} else el.clearStates();
	if (elOption.morph === false) el.disableMorphing = true;
	else if (el.disableMorphing) el.disableMorphing = false;
	if (elOption.tooltipDisabled) el.tooltipDisabled = true;
	attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;
	attachedTxInfoTmp.isLegacy = false;
	doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);
	doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);
	updateElNormal(api, el, dataIndex, elOption, attachedTxInfoTmp, seriesModel, isInit);
	hasOwn(elOption, "info") && (customInnerStore(el).info = elOption.info);
	for (var i$1 = 0; i$1 < STATES.length; i$1++) {
		var stateName = STATES[i$1];
		if (stateName !== NORMAL) {
			var otherStateOpt = retrieveStateOption(elOption, stateName);
			var otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);
			updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp);
		}
	}
	updateZ$2(el, elOption, seriesModel);
	if (elOption.type === "group") mergeChildren(api, el, dataIndex, elOption, seriesModel);
	if (toBeReplacedIdx >= 0) group.replaceAt(el, toBeReplacedIdx);
	else group.add(el);
	return el;
}
function doesElNeedRecreate(el, elOption, seriesModel) {
	var elInner = customInnerStore(el);
	var elOptionType = elOption.type;
	var elOptionShape = elOption.shape;
	var elOptionStyle = elOption.style;
	return seriesModel.isUniversalTransitionEnabled() || elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === "path" && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === "image" && hasOwn(elOptionStyle, "image") && elOptionStyle.image !== elInner.customImagePath;
}
function doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {
	var clipPathOpt = elOption.clipPath;
	if (clipPathOpt === false) {
		if (el && el.getClipPath()) el.removeClipPath();
	} else if (clipPathOpt) {
		var clipPath = el.getClipPath();
		if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt, seriesModel)) clipPath = null;
		if (!clipPath) {
			clipPath = createEl$1(clipPathOpt);
			assert(isPath(clipPath), "Only any type of `path` can be used in `clipPath`, rather than " + clipPath.type + ".");
			el.setClipPath(clipPath);
		}
		updateElNormal(null, clipPath, dataIndex, clipPathOpt, null, seriesModel, isInit);
	}
}
function doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {
	if (el.isGroup || el.type === "compoundPath") return;
	processTxInfo(elOption, null, attachedTxInfo);
	processTxInfo(elOption, EMPHASIS, attachedTxInfo);
	var txConOptNormal = attachedTxInfo.normal.conOpt;
	var txConOptEmphasis = attachedTxInfo.emphasis.conOpt;
	var txConOptBlur = attachedTxInfo.blur.conOpt;
	var txConOptSelect = attachedTxInfo.select.conOpt;
	if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {
		var textContent = el.getTextContent();
		if (txConOptNormal === false) textContent && el.removeTextContent();
		else {
			txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || { type: "text" };
			if (!textContent) {
				textContent = createEl$1(txConOptNormal);
				el.setTextContent(textContent);
			} else textContent.clearStates();
			updateElNormal(null, textContent, dataIndex, txConOptNormal, null, seriesModel, isInit);
			var txConStlOptNormal = txConOptNormal && txConOptNormal.style;
			for (var i$1 = 0; i$1 < STATES.length; i$1++) {
				var stateName = STATES[i$1];
				if (stateName !== NORMAL) {
					var txConOptOtherState = attachedTxInfo[stateName].conOpt;
					updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null);
				}
			}
			txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();
		}
	}
}
function processTxInfo(elOption, state, attachedTxInfo) {
	var stateOpt = !state ? elOption : retrieveStateOption(elOption, state);
	var styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);
	var elType = elOption.type;
	var txCfg = stateOpt ? stateOpt.textConfig : null;
	var txConOptNormal = elOption.textContent;
	var txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);
	if (styleOpt && (attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {
		attachedTxInfo.isLegacy = true;
		var convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state);
		if (!txCfg && convertResult.textConfig) txCfg = convertResult.textConfig;
		if (!txConOpt && convertResult.textContent) txConOpt = convertResult.textContent;
	}
	if (!state && txConOpt) {
		var txConOptNormal_1 = txConOpt;
		!txConOptNormal_1.type && (txConOptNormal_1.type = "text");
		assert(txConOptNormal_1.type === "text", "textContent.type must be \"text\"");
	}
	var info = !state ? attachedTxInfo.normal : attachedTxInfo[state];
	info.cfg = txCfg;
	info.conOpt = txConOpt;
}
function retrieveStateOption(elOption, state) {
	return !state ? elOption : elOption ? elOption[state] : null;
}
function retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {
	var style = stateOption && stateOption.style;
	if (style == null && state === EMPHASIS && stateOptionNormal) style = stateOptionNormal.styleEmphasis;
	return style;
}
function mergeChildren(api, el, dataIndex, elOption, seriesModel) {
	var newChildren = elOption.children;
	var newLen = newChildren ? newChildren.length : 0;
	var mergeChildren$1 = elOption.$mergeChildren;
	var byName = mergeChildren$1 === "byName" || elOption.diffChildrenByName;
	var notMerge = mergeChildren$1 === false;
	if (!newLen && !byName && !notMerge) return;
	if (byName) {
		diffGroupChildren({
			api,
			oldChildren: el.children() || [],
			newChildren: newChildren || [],
			dataIndex,
			seriesModel,
			group: el
		});
		return;
	}
	notMerge && el.removeAll();
	var index = 0;
	for (; index < newLen; index++) {
		var newChild = newChildren[index];
		var oldChild = el.childAt(index);
		if (newChild) {
			if (newChild.ignore == null) newChild.ignore = false;
			doCreateOrUpdateEl(api, oldChild, dataIndex, newChild, seriesModel, el);
		} else {
			assert(oldChild, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before.");
			oldChild.ignore = true;
		}
	}
	for (var i$1 = el.childCount() - 1; i$1 >= index; i$1--) removeChildFromGroup(el, el.childAt(i$1), seriesModel);
}
function removeChildFromGroup(group, child, seriesModel) {
	child && applyLeaveTransition(child, customInnerStore(group).option, seriesModel);
}
function diffGroupChildren(context) {
	new DataDiffer_default(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
}
function getKey(item, idx) {
	var name = item && item.name;
	return name != null ? name : GROUP_DIFF_PREFIX + idx;
}
function processAddUpdate(newIndex, oldIndex) {
	var context = this.context;
	var childOption = newIndex != null ? context.newChildren[newIndex] : null;
	var child = oldIndex != null ? context.oldChildren[oldIndex] : null;
	doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group);
}
function processRemove(oldIndex) {
	var context = this.context;
	var child = context.oldChildren[oldIndex];
	child && applyLeaveTransition(child, customInnerStore(child).option, context.seriesModel);
}
/**
* @return SVG Path data.
*/
function getPathData(shape) {
	return shape && (shape.pathData || shape.d);
}
function hasOwnPathData(shape) {
	return shape && (hasOwn(shape, "pathData") || hasOwn(shape, "d"));
}

//#endregion
//#region node_modules/echarts/lib/chart/custom/install.js
function install$24(registers) {
	registers.registerChartView(CustomView_default);
	registers.registerSeriesModel(CustomSeries_default);
}

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js
var inner$11 = makeInner();
var clone$2 = clone;
var bind$1 = bind;
/**
* Base axis pointer class in 2D.
*/
var BaseAxisPointer = function() {
	function BaseAxisPointer$1() {
		this._dragging = false;
		/**
		* In px, arbitrary value. Do not set too small,
		* no animation is ok for most cases.
		*/
		this.animationThreshold = 15;
	}
	/**
	* @implement
	*/
	BaseAxisPointer$1.prototype.render = function(axisModel, axisPointerModel, api, forceRender) {
		var value = axisPointerModel.get("value");
		var status = axisPointerModel.get("status");
		this._axisModel = axisModel;
		this._axisPointerModel = axisPointerModel;
		this._api = api;
		if (!forceRender && this._lastValue === value && this._lastStatus === status) return;
		this._lastValue = value;
		this._lastStatus = status;
		var group = this._group;
		var handle = this._handle;
		if (!status || status === "hide") {
			group && group.hide();
			handle && handle.hide();
			return;
		}
		group && group.show();
		handle && handle.show();
		var elOption = {};
		this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
		var graphicKey = elOption.graphicKey;
		if (graphicKey !== this._lastGraphicKey) this.clear(api);
		this._lastGraphicKey = graphicKey;
		var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
		if (!group) {
			group = this._group = new Group_default();
			this.createPointerEl(group, elOption, axisModel, axisPointerModel);
			this.createLabelEl(group, elOption, axisModel, axisPointerModel);
			api.getZr().add(group);
		} else {
			var doUpdateProps = curry(updateProps$1, axisPointerModel, moveAnimation);
			this.updatePointerEl(group, elOption, doUpdateProps);
			this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
		}
		updateMandatoryProps(group, axisPointerModel, true);
		this._renderHandle(value);
	};
	/**
	* @implement
	*/
	BaseAxisPointer$1.prototype.remove = function(api) {
		this.clear(api);
	};
	/**
	* @implement
	*/
	BaseAxisPointer$1.prototype.dispose = function(api) {
		this.clear(api);
	};
	/**
	* @protected
	*/
	BaseAxisPointer$1.prototype.determineAnimation = function(axisModel, axisPointerModel) {
		var animation = axisPointerModel.get("animation");
		var axis = axisModel.axis;
		var isCategoryAxis = axis.type === "category";
		var useSnap = axisPointerModel.get("snap");
		if (!useSnap && !isCategoryAxis) return false;
		if (animation === "auto" || animation == null) {
			var animationThreshold = this.animationThreshold;
			if (isCategoryAxis && axis.getBandWidth() > animationThreshold) return true;
			if (useSnap) {
				var seriesDataCount = getAxisInfo$1(axisModel).seriesDataCount;
				var axisExtent = axis.getExtent();
				return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
			}
			return false;
		}
		return animation === true;
	};
	/**
	* add {pointer, label, graphicKey} to elOption
	* @protected
	*/
	BaseAxisPointer$1.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {};
	/**
	* @protected
	*/
	BaseAxisPointer$1.prototype.createPointerEl = function(group, elOption, axisModel, axisPointerModel) {
		var pointerOption = elOption.pointer;
		if (pointerOption) {
			var pointerEl = inner$11(group).pointerEl = new graphic_exports$1[pointerOption.type](clone$2(elOption.pointer));
			group.add(pointerEl);
		}
	};
	/**
	* @protected
	*/
	BaseAxisPointer$1.prototype.createLabelEl = function(group, elOption, axisModel, axisPointerModel) {
		if (elOption.label) {
			var labelEl = inner$11(group).labelEl = new Text_default(clone$2(elOption.label));
			group.add(labelEl);
			updateLabelShowHide(labelEl, axisPointerModel);
		}
	};
	/**
	* @protected
	*/
	BaseAxisPointer$1.prototype.updatePointerEl = function(group, elOption, updateProps$2) {
		var pointerEl = inner$11(group).pointerEl;
		if (pointerEl && elOption.pointer) {
			pointerEl.setStyle(elOption.pointer.style);
			updateProps$2(pointerEl, { shape: elOption.pointer.shape });
		}
	};
	/**
	* @protected
	*/
	BaseAxisPointer$1.prototype.updateLabelEl = function(group, elOption, updateProps$2, axisPointerModel) {
		var labelEl = inner$11(group).labelEl;
		if (labelEl) {
			labelEl.setStyle(elOption.label.style);
			updateProps$2(labelEl, {
				x: elOption.label.x,
				y: elOption.label.y
			});
			updateLabelShowHide(labelEl, axisPointerModel);
		}
	};
	/**
	* @private
	*/
	BaseAxisPointer$1.prototype._renderHandle = function(value) {
		if (this._dragging || !this.updateHandleTransform) return;
		var axisPointerModel = this._axisPointerModel;
		var zr = this._api.getZr();
		var handle = this._handle;
		var handleModel = axisPointerModel.getModel("handle");
		var status = axisPointerModel.get("status");
		if (!handleModel.get("show") || !status || status === "hide") {
			handle && zr.remove(handle);
			this._handle = null;
			return;
		}
		var isInit;
		if (!this._handle) {
			isInit = true;
			handle = this._handle = createIcon(handleModel.get("icon"), {
				cursor: "move",
				draggable: true,
				onmousemove: function(e$1) {
					stop(e$1.event);
				},
				onmousedown: bind$1(this._onHandleDragMove, this, 0, 0),
				drift: bind$1(this._onHandleDragMove, this),
				ondragend: bind$1(this._onHandleDragEnd, this)
			});
			zr.add(handle);
		}
		updateMandatoryProps(handle, axisPointerModel, false);
		handle.setStyle(handleModel.getItemStyle(null, [
			"color",
			"borderColor",
			"borderWidth",
			"opacity",
			"shadowColor",
			"shadowBlur",
			"shadowOffsetX",
			"shadowOffsetY"
		]));
		var handleSize = handleModel.get("size");
		if (!isArray(handleSize)) handleSize = [handleSize, handleSize];
		handle.scaleX = handleSize[0] / 2;
		handle.scaleY = handleSize[1] / 2;
		createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
		this._moveHandleToValue(value, isInit);
	};
	BaseAxisPointer$1.prototype._moveHandleToValue = function(value, isInit) {
		updateProps$1(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
	};
	BaseAxisPointer$1.prototype._onHandleDragMove = function(dx, dy) {
		var handle = this._handle;
		if (!handle) return;
		this._dragging = true;
		var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
		this._payloadInfo = trans;
		handle.stopAnimation();
		handle.attr(getHandleTransProps(trans));
		inner$11(handle).lastProp = null;
		this._doDispatchAxisPointer();
	};
	/**
	* Throttled method.
	*/
	BaseAxisPointer$1.prototype._doDispatchAxisPointer = function() {
		if (!this._handle) return;
		var payloadInfo = this._payloadInfo;
		var axisModel = this._axisModel;
		this._api.dispatchAction({
			type: "updateAxisPointer",
			x: payloadInfo.cursorPoint[0],
			y: payloadInfo.cursorPoint[1],
			tooltipOption: payloadInfo.tooltipOption,
			axesInfo: [{
				axisDim: axisModel.axis.dim,
				axisIndex: axisModel.componentIndex
			}]
		});
	};
	BaseAxisPointer$1.prototype._onHandleDragEnd = function() {
		this._dragging = false;
		if (!this._handle) return;
		var value = this._axisPointerModel.get("value");
		this._moveHandleToValue(value);
		this._api.dispatchAction({ type: "hideTip" });
	};
	/**
	* @private
	*/
	BaseAxisPointer$1.prototype.clear = function(api) {
		this._lastValue = null;
		this._lastStatus = null;
		var zr = api.getZr();
		var group = this._group;
		var handle = this._handle;
		if (zr && group) {
			this._lastGraphicKey = null;
			group && zr.remove(group);
			handle && zr.remove(handle);
			this._group = null;
			this._handle = null;
			this._payloadInfo = null;
		}
		clear(this, "_doDispatchAxisPointer");
	};
	/**
	* @protected
	*/
	BaseAxisPointer$1.prototype.doClear = function() {};
	BaseAxisPointer$1.prototype.buildLabel = function(xy, wh, xDimIndex) {
		xDimIndex = xDimIndex || 0;
		return {
			x: xy[xDimIndex],
			y: xy[1 - xDimIndex],
			width: wh[xDimIndex],
			height: wh[1 - xDimIndex]
		};
	};
	return BaseAxisPointer$1;
}();
function updateProps$1(animationModel, moveAnimation, el, props) {
	if (!propsEqual(inner$11(el).lastProp, props)) {
		inner$11(el).lastProp = props;
		moveAnimation ? updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
	}
}
function propsEqual(lastProps, newProps) {
	if (isObject(lastProps) && isObject(newProps)) {
		var equals_1 = true;
		each(newProps, function(item, key$1) {
			equals_1 = equals_1 && propsEqual(lastProps[key$1], item);
		});
		return !!equals_1;
	} else return lastProps === newProps;
}
function updateLabelShowHide(labelEl, axisPointerModel) {
	labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(trans) {
	return {
		x: trans.x || 0,
		y: trans.y || 0,
		rotation: trans.rotation || 0
	};
}
function updateMandatoryProps(group, axisPointerModel, silent) {
	var z = axisPointerModel.get("z");
	var zlevel = axisPointerModel.get("zlevel");
	group && group.traverse(function(el) {
		if (el.type !== "group") {
			z != null && (el.z = z);
			zlevel != null && (el.zlevel = zlevel);
			el.silent = silent;
		}
	});
}
var BaseAxisPointer_default = BaseAxisPointer;

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/viewHelper.js
function buildElStyle(axisPointerModel) {
	var axisPointerType = axisPointerModel.get("type");
	var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
	var style;
	if (axisPointerType === "line") {
		style = styleModel.getLineStyle();
		style.fill = null;
	} else if (axisPointerType === "shadow") {
		style = styleModel.getAreaStyle();
		style.stroke = null;
	}
	return style;
}
/**
* @param {Function} labelPos {align, verticalAlign, position}
*/
function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
	var text = getValueLabel(axisPointerModel.get("value"), axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
		precision: axisPointerModel.get(["label", "precision"]),
		formatter: axisPointerModel.get(["label", "formatter"])
	});
	var labelModel = axisPointerModel.getModel("label");
	var paddings = normalizeCssArray(labelModel.get("padding") || 0);
	var font = labelModel.getFont();
	var textRect = getBoundingRect(text, font);
	var position$1 = labelPos.position;
	var width = textRect.width + paddings[1] + paddings[3];
	var height = textRect.height + paddings[0] + paddings[2];
	var align = labelPos.align;
	align === "right" && (position$1[0] -= width);
	align === "center" && (position$1[0] -= width / 2);
	var verticalAlign = labelPos.verticalAlign;
	verticalAlign === "bottom" && (position$1[1] -= height);
	verticalAlign === "middle" && (position$1[1] -= height / 2);
	confineInContainer(position$1, width, height, api);
	var bgColor = labelModel.get("backgroundColor");
	if (!bgColor || bgColor === "auto") bgColor = axisModel.get([
		"axisLine",
		"lineStyle",
		"color"
	]);
	elOption.label = {
		x: position$1[0],
		y: position$1[1],
		style: createTextStyle(labelModel, {
			text,
			font,
			fill: labelModel.getTextColor(),
			padding: paddings,
			backgroundColor: bgColor
		}),
		z2: 10
	};
}
function confineInContainer(position$1, width, height, api) {
	var viewWidth = api.getWidth();
	var viewHeight = api.getHeight();
	position$1[0] = Math.min(position$1[0] + width, viewWidth) - width;
	position$1[1] = Math.min(position$1[1] + height, viewHeight) - height;
	position$1[0] = Math.max(position$1[0], 0);
	position$1[1] = Math.max(position$1[1], 0);
}
function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
	value = axis.scale.parse(value);
	var text = axis.scale.getLabel({ value }, { precision: opt.precision });
	var formatter = opt.formatter;
	if (formatter) {
		var params_1 = {
			value: getAxisRawValue(axis, { value }),
			axisDimension: axis.dim,
			axisIndex: axis.index,
			seriesData: []
		};
		each(seriesDataIndices, function(idxItem) {
			var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
			var dataIndex = idxItem.dataIndexInside;
			var dataParams = series && series.getDataParams(dataIndex);
			dataParams && params_1.seriesData.push(dataParams);
		});
		if (isString(formatter)) text = formatter.replace("{value}", text);
		else if (isFunction(formatter)) text = formatter(params_1);
	}
	return text;
}
function getTransformedPosition(axis, value, layoutInfo) {
	var transform = create$2();
	rotate(transform, transform, layoutInfo.rotation);
	translate(transform, transform, layoutInfo.position);
	return applyTransform$1([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
}
function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
	var textLayout = AxisBuilder_default.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
	layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
	buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
		position: getTransformedPosition(axisModel.axis, value, layoutInfo),
		align: textLayout.textAlign,
		verticalAlign: textLayout.textVerticalAlign
	});
}
function makeLineShape(p1, p2, xDimIndex) {
	xDimIndex = xDimIndex || 0;
	return {
		x1: p1[xDimIndex],
		y1: p1[1 - xDimIndex],
		x2: p2[xDimIndex],
		y2: p2[1 - xDimIndex]
	};
}
function makeRectShape(xy, wh, xDimIndex) {
	xDimIndex = xDimIndex || 0;
	return {
		x: xy[xDimIndex],
		y: xy[1 - xDimIndex],
		width: wh[xDimIndex],
		height: wh[1 - xDimIndex]
	};
}
function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
	return {
		cx,
		cy,
		r0,
		r,
		startAngle,
		endAngle,
		clockwise: true
	};
}

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js
var CartesianAxisPointer = function(_super) {
	__extends(CartesianAxisPointer$1, _super);
	function CartesianAxisPointer$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* @override
	*/
	CartesianAxisPointer$1.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
		var axis = axisModel.axis;
		var grid = axis.grid;
		var axisPointerType = axisPointerModel.get("type");
		var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
		var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
		if (axisPointerType && axisPointerType !== "none") {
			var elStyle = buildElStyle(axisPointerModel);
			var pointerOption = pointerShapeBuilder$2[axisPointerType](axis, pixelValue, otherExtent);
			pointerOption.style = elStyle;
			elOption.graphicKey = pointerOption.type;
			elOption.pointer = pointerOption;
		}
		var layoutInfo = layout$2(grid.getRect(), axisModel);
		buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
	};
	/**
	* @override
	*/
	CartesianAxisPointer$1.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
		var layoutInfo = layout$2(axisModel.axis.grid.getRect(), axisModel, { labelInside: false });
		layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
		var pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
		return {
			x: pos[0],
			y: pos[1],
			rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
		};
	};
	/**
	* @override
	*/
	CartesianAxisPointer$1.prototype.updateHandleTransform = function(transform, delta, axisModel, axisPointerModel) {
		var axis = axisModel.axis;
		var grid = axis.grid;
		var axisExtent = axis.getGlobalExtent(true);
		var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
		var dimIndex = axis.dim === "x" ? 0 : 1;
		var currPosition = [transform.x, transform.y];
		currPosition[dimIndex] += delta[dimIndex];
		currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
		currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
		var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
		var cursorPoint = [cursorOtherValue, cursorOtherValue];
		cursorPoint[dimIndex] = currPosition[dimIndex];
		return {
			x: currPosition[0],
			y: currPosition[1],
			rotation: transform.rotation,
			cursorPoint,
			tooltipOption: [{ verticalAlign: "middle" }, { align: "center" }][dimIndex]
		};
	};
	return CartesianAxisPointer$1;
}(BaseAxisPointer_default);
function getCartesian(grid, axis) {
	var opt = {};
	opt[axis.dim + "AxisIndex"] = axis.index;
	return grid.getCartesian(opt);
}
var pointerShapeBuilder$2 = {
	line: function(axis, pixelValue, otherExtent) {
		return {
			type: "Line",
			subPixelOptimize: true,
			shape: makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis))
		};
	},
	shadow: function(axis, pixelValue, otherExtent) {
		var bandWidth = Math.max(1, axis.getBandWidth());
		var span = otherExtent[1] - otherExtent[0];
		return {
			type: "Rect",
			shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
		};
	}
};
function getAxisDimIndex(axis) {
	return axis.dim === "x" ? 0 : 1;
}
var CartesianAxisPointer_default = CartesianAxisPointer;

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js
var AxisPointerModel = function(_super) {
	__extends(AxisPointerModel$1, _super);
	function AxisPointerModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = AxisPointerModel$1.type;
		return _this;
	}
	AxisPointerModel$1.type = "axisPointer";
	AxisPointerModel$1.defaultOption = {
		show: "auto",
		z: 50,
		type: "line",
		snap: false,
		triggerTooltip: true,
		triggerEmphasis: true,
		value: null,
		status: null,
		link: [],
		animation: null,
		animationDurationUpdate: 200,
		lineStyle: {
			color: tokens_default.color.border,
			width: 1,
			type: "dashed"
		},
		shadowStyle: { color: tokens_default.color.shadowTint },
		label: {
			show: true,
			formatter: null,
			precision: "auto",
			margin: 3,
			color: tokens_default.color.neutral00,
			padding: [
				5,
				7,
				5,
				7
			],
			backgroundColor: tokens_default.color.accent60,
			borderColor: null,
			borderWidth: 0,
			borderRadius: 3
		},
		handle: {
			show: false,
			icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
			size: 45,
			margin: 50,
			color: tokens_default.color.accent40,
			throttle: 40
		}
	};
	return AxisPointerModel$1;
}(Component_default);
var AxisPointerModel_default = AxisPointerModel;

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/globalListener.js
var inner$10 = makeInner();
var each$9 = each;
/**
* @param {string} key
* @param {module:echarts/ExtensionAPI} api
* @param {Function} handler
*      param: {string} currTrigger
*      param: {Array.<number>} point
*/
function register(key$1, api, handler) {
	if (env_default.node) return;
	var zr = api.getZr();
	inner$10(zr).records || (inner$10(zr).records = {});
	initGlobalListeners(zr, api);
	var record = inner$10(zr).records[key$1] || (inner$10(zr).records[key$1] = {});
	record.handler = handler;
}
function initGlobalListeners(zr, api) {
	if (inner$10(zr).initialized) return;
	inner$10(zr).initialized = true;
	useHandler("click", curry(doEnter, "click"));
	useHandler("mousemove", curry(doEnter, "mousemove"));
	useHandler("globalout", onLeave);
	function useHandler(eventType, cb) {
		zr.on(eventType, function(e$1) {
			var dis = makeDispatchAction$1(api);
			each$9(inner$10(zr).records, function(record) {
				record && cb(record, e$1, dis.dispatchAction);
			});
			dispatchTooltipFinally(dis.pendings, api);
		});
	}
}
function dispatchTooltipFinally(pendings, api) {
	var showLen = pendings.showTip.length;
	var hideLen = pendings.hideTip.length;
	var actuallyPayload;
	if (showLen) actuallyPayload = pendings.showTip[showLen - 1];
	else if (hideLen) actuallyPayload = pendings.hideTip[hideLen - 1];
	if (actuallyPayload) {
		actuallyPayload.dispatchAction = null;
		api.dispatchAction(actuallyPayload);
	}
}
function onLeave(record, e$1, dispatchAction$2) {
	record.handler("leave", null, dispatchAction$2);
}
function doEnter(currTrigger, record, e$1, dispatchAction$2) {
	record.handler(currTrigger, e$1, dispatchAction$2);
}
function makeDispatchAction$1(api) {
	var pendings = {
		showTip: [],
		hideTip: []
	};
	var dispatchAction$2 = function(payload) {
		var pendingList = pendings[payload.type];
		if (pendingList) pendingList.push(payload);
		else {
			payload.dispatchAction = dispatchAction$2;
			api.dispatchAction(payload);
		}
	};
	return {
		dispatchAction: dispatchAction$2,
		pendings
	};
}
function unregister(key$1, api) {
	if (env_default.node) return;
	var zr = api.getZr();
	if ((inner$10(zr).records || {})[key$1]) inner$10(zr).records[key$1] = null;
}

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/AxisPointerView.js
var AxisPointerView = function(_super) {
	__extends(AxisPointerView$1, _super);
	function AxisPointerView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = AxisPointerView$1.type;
		return _this;
	}
	AxisPointerView$1.prototype.render = function(globalAxisPointerModel, ecModel, api) {
		var globalTooltipModel = ecModel.getComponent("tooltip");
		var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
		register("axisPointer", api, function(currTrigger, e$1, dispatchAction$2) {
			if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) dispatchAction$2({
				type: "updateAxisPointer",
				currTrigger,
				x: e$1 && e$1.offsetX,
				y: e$1 && e$1.offsetY
			});
		});
	};
	AxisPointerView$1.prototype.remove = function(ecModel, api) {
		unregister("axisPointer", api);
	};
	AxisPointerView$1.prototype.dispose = function(ecModel, api) {
		unregister("axisPointer", api);
	};
	AxisPointerView$1.type = "axisPointer";
	return AxisPointerView$1;
}(Component_default$1);
var AxisPointerView_default = AxisPointerView;

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js
/**
* @param finder contains {seriesIndex, dataIndex, dataIndexInside}
* @param ecModel
* @return  {point: [x, y], el: ...} point Will not be null.
*/
function findPointFromSeries(finder, ecModel) {
	var point = [];
	var seriesIndex = finder.seriesIndex;
	var seriesModel;
	if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) return { point: [] };
	var data = seriesModel.getData();
	var dataIndex = queryDataIndex(data, finder);
	if (dataIndex == null || dataIndex < 0 || isArray(dataIndex)) return { point: [] };
	var el = data.getItemGraphicEl(dataIndex);
	var coordSys = seriesModel.coordinateSystem;
	if (seriesModel.getTooltipPosition) point = seriesModel.getTooltipPosition(dataIndex) || [];
	else if (coordSys && coordSys.dataToPoint) if (finder.isStacked) {
		var baseAxis = coordSys.getBaseAxis();
		var valueAxisDim = coordSys.getOtherAxis(baseAxis).dim;
		var baseAxisDim = baseAxis.dim;
		var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
		var baseDim = data.mapDimension(baseAxisDim);
		var stackedData = [];
		stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
		stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo("stackResultDimension"), dataIndex);
		point = coordSys.dataToPoint(stackedData) || [];
	} else point = coordSys.dataToPoint(data.getValues(map(coordSys.dimensions, function(dim) {
		return data.mapDimension(dim);
	}), dataIndex)) || [];
	else if (el) {
		var rect = el.getBoundingRect().clone();
		rect.applyTransform(el.transform);
		point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
	}
	return {
		point,
		el
	};
}

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/axisTrigger.js
var inner$9 = makeInner();
/**
* Basic logic: check all axis, if they do not demand show/highlight,
* then hide/downplay them.
*
* @return content of event obj for echarts.connect.
*/
function axisTrigger(payload, ecModel, api) {
	var currTrigger = payload.currTrigger;
	var point = [payload.x, payload.y];
	var finder = payload;
	var dispatchAction$2 = payload.dispatchAction || bind(api.dispatchAction, api);
	var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
	if (!coordSysAxesInfo) return;
	if (illegalPoint(point)) point = findPointFromSeries({
		seriesIndex: finder.seriesIndex,
		dataIndex: finder.dataIndex
	}, ecModel).point;
	var isIllegalPoint = illegalPoint(point);
	var inputAxesInfo = finder.axesInfo;
	var axesInfo = coordSysAxesInfo.axesInfo;
	var shouldHide = currTrigger === "leave" || illegalPoint(point);
	var outputPayload = {};
	var showValueMap = {};
	var dataByCoordSys = {
		list: [],
		map: {}
	};
	var updaters = {
		showPointer: curry(showPointer, showValueMap),
		showTooltip: curry(showTooltip, dataByCoordSys)
	};
	each(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
		var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
		each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key$1) {
			var axis = axisInfo.axis;
			var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
			if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
				var val = inputAxisInfo && inputAxisInfo.value;
				if (val == null && !isIllegalPoint) val = axis.pointToData(point);
				val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
			}
		});
	});
	var linkTriggers = {};
	each(axesInfo, function(tarAxisInfo, tarKey) {
		var linkGroup = tarAxisInfo.linkGroup;
		if (linkGroup && !showValueMap[tarKey]) each(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
			var srcValItem = showValueMap[srcKey];
			if (srcAxisInfo !== tarAxisInfo && srcValItem) {
				var val = srcValItem.value;
				linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
				linkTriggers[tarAxisInfo.key] = val;
			}
		});
	});
	each(linkTriggers, function(val, tarKey) {
		processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
	});
	updateModelActually(showValueMap, axesInfo, outputPayload);
	dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction$2);
	dispatchHighDownActually(axesInfo, dispatchAction$2, api);
	return outputPayload;
}
function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
	var axis = axisInfo.axis;
	if (axis.scale.isBlank() || !axis.containData(newValue)) return;
	if (!axisInfo.involveSeries) {
		updaters.showPointer(axisInfo, newValue);
		return;
	}
	var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
	var payloadBatch = payloadInfo.payloadBatch;
	var snapToValue = payloadInfo.snapToValue;
	if (payloadBatch[0] && outputFinder.seriesIndex == null) extend(outputFinder, payloadBatch[0]);
	if (!noSnap && axisInfo.snap) {
		if (axis.containData(snapToValue) && snapToValue != null) newValue = snapToValue;
	}
	updaters.showPointer(axisInfo, newValue, payloadBatch);
	updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}
function buildPayloadsBySeries(value, axisInfo) {
	var axis = axisInfo.axis;
	var dim = axis.dim;
	var snapToValue = value;
	var payloadBatch = [];
	var minDist = Number.MAX_VALUE;
	var minDiff = -1;
	each(axisInfo.seriesModels, function(series, idx) {
		var dataDim = series.getData().mapDimensionsAll(dim);
		var seriesNestestValue;
		var dataIndices;
		if (series.getAxisTooltipData) {
			var result = series.getAxisTooltipData(dataDim, value, axis);
			dataIndices = result.dataIndices;
			seriesNestestValue = result.nestestValue;
		} else {
			dataIndices = series.indicesOfNearest(dim, dataDim[0], value, axis.type === "category" ? .5 : null);
			if (!dataIndices.length) return;
			seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
		}
		if (seriesNestestValue == null || !isFinite(seriesNestestValue)) return;
		var diff = value - seriesNestestValue;
		var dist$2 = Math.abs(diff);
		if (dist$2 <= minDist) {
			if (dist$2 < minDist || diff >= 0 && minDiff < 0) {
				minDist = dist$2;
				minDiff = diff;
				snapToValue = seriesNestestValue;
				payloadBatch.length = 0;
			}
			each(dataIndices, function(dataIndex) {
				payloadBatch.push({
					seriesIndex: series.seriesIndex,
					dataIndexInside: dataIndex,
					dataIndex: series.getData().getRawIndex(dataIndex)
				});
			});
		}
	});
	return {
		payloadBatch,
		snapToValue
	};
}
function showPointer(showValueMap, axisInfo, value, payloadBatch) {
	showValueMap[axisInfo.key] = {
		value,
		payloadBatch
	};
}
function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
	var payloadBatch = payloadInfo.payloadBatch;
	var axis = axisInfo.axis;
	var axisModel = axis.model;
	var axisPointerModel = axisInfo.axisPointerModel;
	if (!axisInfo.triggerTooltip || !payloadBatch.length) return;
	var coordSysModel = axisInfo.coordSys.model;
	var coordSysKey = makeKey(coordSysModel);
	var coordSysItem = dataByCoordSys.map[coordSysKey];
	if (!coordSysItem) {
		coordSysItem = dataByCoordSys.map[coordSysKey] = {
			coordSysId: coordSysModel.id,
			coordSysIndex: coordSysModel.componentIndex,
			coordSysType: coordSysModel.type,
			coordSysMainType: coordSysModel.mainType,
			dataByAxis: []
		};
		dataByCoordSys.list.push(coordSysItem);
	}
	coordSysItem.dataByAxis.push({
		axisDim: axis.dim,
		axisIndex: axisModel.componentIndex,
		axisType: axisModel.type,
		axisId: axisModel.id,
		value,
		valueLabelOpt: {
			precision: axisPointerModel.get(["label", "precision"]),
			formatter: axisPointerModel.get(["label", "formatter"])
		},
		seriesDataIndices: payloadBatch.slice()
	});
}
function updateModelActually(showValueMap, axesInfo, outputPayload) {
	var outputAxesInfo = outputPayload.axesInfo = [];
	each(axesInfo, function(axisInfo, key$1) {
		var option = axisInfo.axisPointerModel.option;
		var valItem = showValueMap[key$1];
		if (valItem) {
			!axisInfo.useHandle && (option.status = "show");
			option.value = valItem.value;
			option.seriesDataIndices = (valItem.payloadBatch || []).slice();
		} else !axisInfo.useHandle && (option.status = "hide");
		option.status === "show" && outputAxesInfo.push({
			axisDim: axisInfo.axis.dim,
			axisIndex: axisInfo.axis.model.componentIndex,
			value: option.value
		});
	});
}
function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction$2) {
	if (illegalPoint(point) || !dataByCoordSys.list.length) {
		dispatchAction$2({ type: "hideTip" });
		return;
	}
	var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
	dispatchAction$2({
		type: "showTip",
		escapeConnect: true,
		x: point[0],
		y: point[1],
		tooltipOption: payload.tooltipOption,
		position: payload.position,
		dataIndexInside: sampleItem.dataIndexInside,
		dataIndex: sampleItem.dataIndex,
		seriesIndex: sampleItem.seriesIndex,
		dataByCoordSys: dataByCoordSys.list
	});
}
function dispatchHighDownActually(axesInfo, dispatchAction$2, api) {
	var zr = api.getZr();
	var highDownKey = "axisPointerLastHighlights";
	var lastHighlights = inner$9(zr)[highDownKey] || {};
	var newHighlights = inner$9(zr)[highDownKey] = {};
	each(axesInfo, function(axisInfo, key$1) {
		var option = axisInfo.axisPointerModel.option;
		option.status === "show" && axisInfo.triggerEmphasis && each(option.seriesDataIndices, function(batchItem) {
			var key$2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
			newHighlights[key$2] = batchItem;
		});
	});
	var toHighlight = [];
	var toDownplay = [];
	each(lastHighlights, function(batchItem, key$1) {
		!newHighlights[key$1] && toDownplay.push(batchItem);
	});
	each(newHighlights, function(batchItem, key$1) {
		!lastHighlights[key$1] && toHighlight.push(batchItem);
	});
	toDownplay.length && api.dispatchAction({
		type: "downplay",
		escapeConnect: true,
		notBlur: true,
		batch: toDownplay
	});
	toHighlight.length && api.dispatchAction({
		type: "highlight",
		escapeConnect: true,
		notBlur: true,
		batch: toHighlight
	});
}
function findInputAxisInfo(inputAxesInfo, axisInfo) {
	for (var i$1 = 0; i$1 < (inputAxesInfo || []).length; i$1++) {
		var inputAxisInfo = inputAxesInfo[i$1];
		if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) return inputAxisInfo;
	}
}
function makeMapperParam(axisInfo) {
	var axisModel = axisInfo.axis.model;
	var item = {};
	var dim = item.axisDim = axisInfo.axis.dim;
	item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
	item.axisName = item[dim + "AxisName"] = axisModel.name;
	item.axisId = item[dim + "AxisId"] = axisModel.id;
	return item;
}
function illegalPoint(point) {
	return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/install.js
function install$35(registers) {
	AxisView_default.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer_default);
	registers.registerComponentModel(AxisPointerModel_default);
	registers.registerComponentView(AxisPointerView_default);
	registers.registerPreprocessor(function(option) {
		if (option) {
			(!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
			var link = option.axisPointer.link;
			if (link && !isArray(link)) option.axisPointer.link = [link];
		}
	});
	registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
		ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api);
	});
	registers.registerAction({
		type: "updateAxisPointer",
		event: "updateAxisPointer",
		update: ":updateAxisPointer"
	}, axisTrigger);
}

//#endregion
//#region node_modules/echarts/lib/component/grid/install.js
function install$25(registers) {
	use(install$56);
	use(install$35);
}

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/PolarAxisPointer.js
var PolarAxisPointer = function(_super) {
	__extends(PolarAxisPointer$1, _super);
	function PolarAxisPointer$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* @override
	*/
	PolarAxisPointer$1.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
		var axis = axisModel.axis;
		if (axis.dim === "angle") this.animationThreshold = Math.PI / 18;
		var polar = axis.polar;
		var otherExtent = polar.getOtherAxis(axis).getExtent();
		var coordValue = axis.dataToCoord(value);
		var axisPointerType = axisPointerModel.get("type");
		if (axisPointerType && axisPointerType !== "none") {
			var elStyle = buildElStyle(axisPointerModel);
			var pointerOption = pointerShapeBuilder$1[axisPointerType](axis, polar, coordValue, otherExtent);
			pointerOption.style = elStyle;
			elOption.graphicKey = pointerOption.type;
			elOption.pointer = pointerOption;
		}
		var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, axisPointerModel.get(["label", "margin"]));
		buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);
	};
	return PolarAxisPointer$1;
}(BaseAxisPointer_default);
function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
	var axis = axisModel.axis;
	var coord = axis.dataToCoord(value);
	var axisAngle = polar.getAngleAxis().getExtent()[0];
	axisAngle = axisAngle / 180 * Math.PI;
	var radiusExtent = polar.getRadiusAxis().getExtent();
	var position$1;
	var align;
	var verticalAlign;
	if (axis.dim === "radius") {
		var transform = create$2();
		rotate(transform, transform, axisAngle);
		translate(transform, transform, [polar.cx, polar.cy]);
		position$1 = applyTransform$1([coord, -labelMargin], transform);
		var labelRotation = axisModel.getModel("axisLabel").get("rotate") || 0;
		var labelLayout$1 = AxisBuilder_default.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
		align = labelLayout$1.textAlign;
		verticalAlign = labelLayout$1.textVerticalAlign;
	} else {
		var r = radiusExtent[1];
		position$1 = polar.coordToPoint([r + labelMargin, coord]);
		var cx = polar.cx;
		var cy = polar.cy;
		align = Math.abs(position$1[0] - cx) / r < .3 ? "center" : position$1[0] > cx ? "left" : "right";
		verticalAlign = Math.abs(position$1[1] - cy) / r < .3 ? "middle" : position$1[1] > cy ? "top" : "bottom";
	}
	return {
		position: position$1,
		align,
		verticalAlign
	};
}
var pointerShapeBuilder$1 = {
	line: function(axis, polar, coordValue, otherExtent) {
		return axis.dim === "angle" ? {
			type: "Line",
			shape: makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
		} : {
			type: "Circle",
			shape: {
				cx: polar.cx,
				cy: polar.cy,
				r: coordValue
			}
		};
	},
	shadow: function(axis, polar, coordValue, otherExtent) {
		var bandWidth = Math.max(1, axis.getBandWidth());
		var radian = Math.PI / 180;
		return axis.dim === "angle" ? {
			type: "Sector",
			shape: makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)
		} : {
			type: "Sector",
			shape: makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
		};
	}
};
var PolarAxisPointer_default = PolarAxisPointer;

//#endregion
//#region node_modules/echarts/lib/coord/polar/PolarModel.js
var PolarModel = function(_super) {
	__extends(PolarModel$1, _super);
	function PolarModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = PolarModel$1.type;
		return _this;
	}
	PolarModel$1.prototype.findAxisModel = function(axisType) {
		var foundAxisModel;
		this.ecModel.eachComponent(axisType, function(axisModel) {
			if (axisModel.getCoordSysModel() === this) foundAxisModel = axisModel;
		}, this);
		return foundAxisModel;
	};
	PolarModel$1.type = "polar";
	PolarModel$1.dependencies = ["radiusAxis", "angleAxis"];
	PolarModel$1.defaultOption = {
		z: 0,
		center: ["50%", "50%"],
		radius: "80%"
	};
	return PolarModel$1;
}(Component_default);
var PolarModel_default = PolarModel;

//#endregion
//#region node_modules/echarts/lib/coord/polar/AxisModel.js
var PolarAxisModel = function(_super) {
	__extends(PolarAxisModel$1, _super);
	function PolarAxisModel$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	PolarAxisModel$1.prototype.getCoordSysModel = function() {
		return this.getReferringComponents("polar", SINGLE_REFERRING).models[0];
	};
	PolarAxisModel$1.type = "polarAxis";
	return PolarAxisModel$1;
}(Component_default);
mixin(PolarAxisModel, AxisModelCommonMixin);
var AngleAxisModel = function(_super) {
	__extends(AngleAxisModel$1, _super);
	function AngleAxisModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = AngleAxisModel$1.type;
		return _this;
	}
	AngleAxisModel$1.type = "angleAxis";
	return AngleAxisModel$1;
}(PolarAxisModel);
var RadiusAxisModel = function(_super) {
	__extends(RadiusAxisModel$1, _super);
	function RadiusAxisModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = RadiusAxisModel$1.type;
		return _this;
	}
	RadiusAxisModel$1.type = "radiusAxis";
	return RadiusAxisModel$1;
}(PolarAxisModel);

//#endregion
//#region node_modules/echarts/lib/coord/polar/RadiusAxis.js
var RadiusAxis = function(_super) {
	__extends(RadiusAxis$1, _super);
	function RadiusAxis$1(scale$3, radiusExtent) {
		return _super.call(this, "radius", scale$3, radiusExtent) || this;
	}
	RadiusAxis$1.prototype.pointToData = function(point, clamp$1) {
		return this.polar.pointToData(point, clamp$1)[this.dim === "radius" ? 0 : 1];
	};
	return RadiusAxis$1;
}(Axis_default);
RadiusAxis.prototype.dataToRadius = Axis_default.prototype.dataToCoord;
RadiusAxis.prototype.radiusToData = Axis_default.prototype.coordToData;
var RadiusAxis_default = RadiusAxis;

//#endregion
//#region node_modules/echarts/lib/coord/polar/AngleAxis.js
var inner$8 = makeInner();
var AngleAxis = function(_super) {
	__extends(AngleAxis$1, _super);
	function AngleAxis$1(scale$3, angleExtent) {
		return _super.call(this, "angle", scale$3, angleExtent || [0, 360]) || this;
	}
	AngleAxis$1.prototype.pointToData = function(point, clamp$1) {
		return this.polar.pointToData(point, clamp$1)[this.dim === "radius" ? 0 : 1];
	};
	/**
	* Only be called in category axis.
	* Angle axis uses text height to decide interval
	*
	* @override
	* @return {number} Auto interval for cateogry axis tick and label
	*/
	AngleAxis$1.prototype.calculateCategoryInterval = function() {
		var axis = this;
		var labelModel = axis.getLabelModel();
		var ordinalScale = axis.scale;
		var ordinalExtent = ordinalScale.getExtent();
		var tickCount = ordinalScale.count();
		if (ordinalExtent[1] - ordinalExtent[0] < 1) return 0;
		var tickValue = ordinalExtent[0];
		var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
		var unitH = Math.abs(unitSpan);
		var rect = getBoundingRect(tickValue == null ? "" : tickValue + "", labelModel.getFont(), "center", "top");
		var dh = Math.max(rect.height, 7) / unitH;
		isNaN(dh) && (dh = Infinity);
		var interval = Math.max(0, Math.floor(dh));
		var cache = inner$8(axis.model);
		var lastAutoInterval = cache.lastAutoInterval;
		var lastTickCount = cache.lastTickCount;
		if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) interval = lastAutoInterval;
		else {
			cache.lastTickCount = tickCount;
			cache.lastAutoInterval = interval;
		}
		return interval;
	};
	return AngleAxis$1;
}(Axis_default);
AngleAxis.prototype.dataToAngle = Axis_default.prototype.dataToCoord;
AngleAxis.prototype.angleToData = Axis_default.prototype.coordToData;
var AngleAxis_default = AngleAxis;

//#endregion
//#region node_modules/echarts/lib/coord/polar/Polar.js
var polarDimensions = ["radius", "angle"];
var Polar = function() {
	function Polar$1(name) {
		this.dimensions = polarDimensions;
		this.type = "polar";
		/**
		* x of polar center
		*/
		this.cx = 0;
		/**
		* y of polar center
		*/
		this.cy = 0;
		this._radiusAxis = new RadiusAxis_default();
		this._angleAxis = new AngleAxis_default();
		this.axisPointerEnabled = true;
		this.name = name || "";
		this._radiusAxis.polar = this._angleAxis.polar = this;
	}
	/**
	* If contain coord
	*/
	Polar$1.prototype.containPoint = function(point) {
		var coord = this.pointToCoord(point);
		return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
	};
	/**
	* If contain data
	*/
	Polar$1.prototype.containData = function(data) {
		return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
	};
	Polar$1.prototype.getAxis = function(dim) {
		var key$1 = "_" + dim + "Axis";
		return this[key$1];
	};
	Polar$1.prototype.getAxes = function() {
		return [this._radiusAxis, this._angleAxis];
	};
	/**
	* Get axes by type of scale
	*/
	Polar$1.prototype.getAxesByScale = function(scaleType) {
		var axes = [];
		var angleAxis = this._angleAxis;
		var radiusAxis = this._radiusAxis;
		angleAxis.scale.type === scaleType && axes.push(angleAxis);
		radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
		return axes;
	};
	Polar$1.prototype.getAngleAxis = function() {
		return this._angleAxis;
	};
	Polar$1.prototype.getRadiusAxis = function() {
		return this._radiusAxis;
	};
	Polar$1.prototype.getOtherAxis = function(axis) {
		var angleAxis = this._angleAxis;
		return axis === angleAxis ? this._radiusAxis : angleAxis;
	};
	/**
	* Base axis will be used on stacking.
	*
	*/
	Polar$1.prototype.getBaseAxis = function() {
		return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
	};
	Polar$1.prototype.getTooltipAxes = function(dim) {
		var baseAxis = dim != null && dim !== "auto" ? this.getAxis(dim) : this.getBaseAxis();
		return {
			baseAxes: [baseAxis],
			otherAxes: [this.getOtherAxis(baseAxis)]
		};
	};
	/**
	* Convert a single data item to (x, y) point.
	* Parameter data is an array which the first element is radius and the second is angle
	*/
	Polar$1.prototype.dataToPoint = function(data, clamp$1, out$1) {
		return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp$1), this._angleAxis.dataToAngle(data[1], clamp$1)], out$1);
	};
	/**
	* Convert a (x, y) point to data
	*/
	Polar$1.prototype.pointToData = function(point, clamp$1, out$1) {
		out$1 = out$1 || [];
		var coord = this.pointToCoord(point);
		out$1[0] = this._radiusAxis.radiusToData(coord[0], clamp$1);
		out$1[1] = this._angleAxis.angleToData(coord[1], clamp$1);
		return out$1;
	};
	/**
	* Convert a (x, y) point to (radius, angle) coord
	*/
	Polar$1.prototype.pointToCoord = function(point) {
		var dx = point[0] - this.cx;
		var dy = point[1] - this.cy;
		var angleAxis = this.getAngleAxis();
		var extent = angleAxis.getExtent();
		var minAngle = Math.min(extent[0], extent[1]);
		var maxAngle = Math.max(extent[0], extent[1]);
		angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
		var radius = Math.sqrt(dx * dx + dy * dy);
		dx /= radius;
		dy /= radius;
		var radian = Math.atan2(-dy, dx) / Math.PI * 180;
		var dir$1 = radian < minAngle ? 1 : -1;
		while (radian < minAngle || radian > maxAngle) radian += dir$1 * 360;
		return [radius, radian];
	};
	/**
	* Convert a (radius, angle) coord to (x, y) point
	*/
	Polar$1.prototype.coordToPoint = function(coord, out$1) {
		out$1 = out$1 || [];
		var radius = coord[0];
		var radian = coord[1] / 180 * Math.PI;
		out$1[0] = Math.cos(radian) * radius + this.cx;
		out$1[1] = -Math.sin(radian) * radius + this.cy;
		return out$1;
	};
	/**
	* Get ring area of cartesian.
	* Area will have a contain function to determine if a point is in the coordinate system.
	*/
	Polar$1.prototype.getArea = function() {
		var angleAxis = this.getAngleAxis();
		var radiusExtent = this.getRadiusAxis().getExtent().slice();
		radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
		var angleExtent = angleAxis.getExtent();
		var RADIAN$5 = Math.PI / 180;
		var EPSILON$6 = 1e-4;
		return {
			cx: this.cx,
			cy: this.cy,
			r0: radiusExtent[0],
			r: radiusExtent[1],
			startAngle: -angleExtent[0] * RADIAN$5,
			endAngle: -angleExtent[1] * RADIAN$5,
			clockwise: angleAxis.inverse,
			contain: function(x, y) {
				var dx = x - this.cx;
				var dy = y - this.cy;
				var d2 = dx * dx + dy * dy;
				var r = this.r;
				var r0 = this.r0;
				return r !== r0 && d2 - EPSILON$6 <= r * r && d2 + EPSILON$6 >= r0 * r0;
			},
			x: this.cx - radiusExtent[1],
			y: this.cy - radiusExtent[1],
			width: radiusExtent[1] * 2,
			height: radiusExtent[1] * 2
		};
	};
	Polar$1.prototype.convertToPixel = function(ecModel, finder, value) {
		return getCoordSys$3(finder) === this ? this.dataToPoint(value) : null;
	};
	Polar$1.prototype.convertFromPixel = function(ecModel, finder, pixel) {
		return getCoordSys$3(finder) === this ? this.pointToData(pixel) : null;
	};
	return Polar$1;
}();
function getCoordSys$3(finder) {
	var seriesModel = finder.seriesModel;
	var polarModel = finder.polarModel;
	return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
var Polar_default = Polar;

//#endregion
//#region node_modules/echarts/lib/coord/polar/polarCreator.js
/**
* Resize method bound to the polar
*/
function resizePolar(polar, polarModel, api) {
	var center$2 = polarModel.get("center");
	var refContainer = createBoxLayoutReference(polarModel, api).refContainer;
	polar.cx = parsePercent$1(center$2[0], refContainer.width) + refContainer.x;
	polar.cy = parsePercent$1(center$2[1], refContainer.height) + refContainer.y;
	var radiusAxis = polar.getRadiusAxis();
	var size = Math.min(refContainer.width, refContainer.height) / 2;
	var radius = polarModel.get("radius");
	if (radius == null) radius = [0, "100%"];
	else if (!isArray(radius)) radius = [0, radius];
	var parsedRadius = [parsePercent$1(radius[0], size), parsePercent$1(radius[1], size)];
	radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1]);
}
/**
* Update polar
*/
function updatePolarScale(ecModel, api) {
	var polar = this;
	var angleAxis = polar.getAngleAxis();
	var radiusAxis = polar.getRadiusAxis();
	angleAxis.scale.setExtent(Infinity, -Infinity);
	radiusAxis.scale.setExtent(Infinity, -Infinity);
	ecModel.eachSeries(function(seriesModel) {
		if (seriesModel.coordinateSystem === polar) {
			var data_1 = seriesModel.getData();
			each(getDataDimensionsOnAxis(data_1, "radius"), function(dim) {
				radiusAxis.scale.unionExtentFromData(data_1, dim);
			});
			each(getDataDimensionsOnAxis(data_1, "angle"), function(dim) {
				angleAxis.scale.unionExtentFromData(data_1, dim);
			});
		}
	});
	niceScaleExtent(angleAxis.scale, angleAxis.model);
	niceScaleExtent(radiusAxis.scale, radiusAxis.model);
	if (angleAxis.type === "category" && !angleAxis.onBand) {
		var extent = angleAxis.getExtent();
		var diff = 360 / angleAxis.scale.count();
		angleAxis.inverse ? extent[1] += diff : extent[1] -= diff;
		angleAxis.setExtent(extent[0], extent[1]);
	}
}
function isAngleAxisModel(axisModel) {
	return axisModel.mainType === "angleAxis";
}
/**
* Set common axis properties
*/
function setAxis(axis, axisModel) {
	var _a$1;
	axis.type = axisModel.get("type");
	axis.scale = createScaleByModel$1(axisModel);
	axis.onBand = axisModel.get("boundaryGap") && axis.type === "category";
	axis.inverse = axisModel.get("inverse");
	if (isAngleAxisModel(axisModel)) {
		axis.inverse = axis.inverse !== axisModel.get("clockwise");
		var startAngle = axisModel.get("startAngle");
		var endAngle = (_a$1 = axisModel.get("endAngle")) !== null && _a$1 !== void 0 ? _a$1 : startAngle + (axis.inverse ? -360 : 360);
		axis.setExtent(startAngle, endAngle);
	}
	axisModel.axis = axis;
	axis.model = axisModel;
}
var polarCreator = {
	dimensions: polarDimensions,
	create: function(ecModel, api) {
		var polarList = [];
		ecModel.eachComponent("polar", function(polarModel, idx) {
			var polar = new Polar_default(idx + "");
			polar.update = updatePolarScale;
			var radiusAxis = polar.getRadiusAxis();
			var angleAxis = polar.getAngleAxis();
			var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
			var angleAxisModel = polarModel.findAxisModel("angleAxis");
			setAxis(radiusAxis, radiusAxisModel);
			setAxis(angleAxis, angleAxisModel);
			resizePolar(polar, polarModel, api);
			polarList.push(polar);
			polarModel.coordinateSystem = polar;
			polar.model = polarModel;
		});
		ecModel.eachSeries(function(seriesModel) {
			if (seriesModel.get("coordinateSystem") === "polar") {
				var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
				if (!polarModel) throw new Error("Polar \"" + retrieve(seriesModel.get("polarIndex"), seriesModel.get("polarId"), 0) + "\" not found");
				seriesModel.coordinateSystem = polarModel.coordinateSystem;
			}
		});
		return polarList;
	}
};
var polarCreator_default = polarCreator;

//#endregion
//#region node_modules/echarts/lib/component/axis/AngleAxisView.js
var elementList = [
	"axisLine",
	"axisLabel",
	"axisTick",
	"minorTick",
	"splitLine",
	"minorSplitLine",
	"splitArea"
];
function getAxisLineShape(polar, rExtent, angle) {
	rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
	var start$1 = polar.coordToPoint([rExtent[0], angle]);
	var end$1 = polar.coordToPoint([rExtent[1], angle]);
	return {
		x1: start$1[0],
		y1: start$1[1],
		x2: end$1[0],
		y2: end$1[1]
	};
}
function getRadiusIdx(polar) {
	return polar.getRadiusAxis().inverse ? 0 : 1;
}
function fixAngleOverlap(list) {
	var firstItem = list[0];
	var lastItem = list[list.length - 1];
	if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) list.pop();
}
var AngleAxisView = function(_super) {
	__extends(AngleAxisView$1, _super);
	function AngleAxisView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = AngleAxisView$1.type;
		_this.axisPointerClass = "PolarAxisPointer";
		return _this;
	}
	AngleAxisView$1.prototype.render = function(angleAxisModel, ecModel) {
		this.group.removeAll();
		if (!angleAxisModel.get("show")) return;
		var angleAxis = angleAxisModel.axis;
		var polar = angleAxis.polar;
		var radiusExtent = polar.getRadiusAxis().getExtent();
		var ticksAngles = angleAxis.getTicksCoords({ breakTicks: "none" });
		var minorTickAngles = angleAxis.getMinorTicksCoords();
		var labels = map(angleAxis.getViewLabels(), function(labelItem) {
			labelItem = clone(labelItem);
			var scale$3 = angleAxis.scale;
			var tickValue = scale$3.type === "ordinal" ? scale$3.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
			labelItem.coord = angleAxis.dataToCoord(tickValue);
			return labelItem;
		});
		fixAngleOverlap(labels);
		fixAngleOverlap(ticksAngles);
		each(elementList, function(name) {
			if (angleAxisModel.get([name, "show"]) && (!angleAxis.scale.isBlank() || name === "axisLine")) angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
		}, this);
	};
	AngleAxisView$1.type = "angleAxis";
	return AngleAxisView$1;
}(AxisView_default);
var angelAxisElementsBuilders = {
	axisLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
		var lineStyleModel = angleAxisModel.getModel(["axisLine", "lineStyle"]);
		var angleAxis = polar.getAngleAxis();
		var RADIAN$5 = Math.PI / 180;
		var angleExtent = angleAxis.getExtent();
		var rId = getRadiusIdx(polar);
		var r0Id = rId ? 0 : 1;
		var shape;
		var shapeType = Math.abs(angleExtent[1] - angleExtent[0]) === 360 ? "Circle" : "Arc";
		if (radiusExtent[r0Id] === 0) shape = new graphic_exports$1[shapeType]({
			shape: {
				cx: polar.cx,
				cy: polar.cy,
				r: radiusExtent[rId],
				startAngle: -angleExtent[0] * RADIAN$5,
				endAngle: -angleExtent[1] * RADIAN$5,
				clockwise: angleAxis.inverse
			},
			style: lineStyleModel.getLineStyle(),
			z2: 1,
			silent: true
		});
		else shape = new Ring_default({
			shape: {
				cx: polar.cx,
				cy: polar.cy,
				r: radiusExtent[rId],
				r0: radiusExtent[r0Id]
			},
			style: lineStyleModel.getLineStyle(),
			z2: 1,
			silent: true
		});
		shape.style.fill = null;
		group.add(shape);
	},
	axisTick: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
		var tickModel = angleAxisModel.getModel("axisTick");
		var tickLen = (tickModel.get("inside") ? -1 : 1) * tickModel.get("length");
		var radius = radiusExtent[getRadiusIdx(polar)];
		var lines = map(ticksAngles, function(tickAngleItem) {
			return new Line_default({ shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord) });
		});
		group.add(mergePath(lines, { style: defaults(tickModel.getModel("lineStyle").getLineStyle(), { stroke: angleAxisModel.get([
			"axisLine",
			"lineStyle",
			"color"
		]) }) }));
	},
	minorTick: function(group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
		if (!minorTickAngles.length) return;
		var tickModel = angleAxisModel.getModel("axisTick");
		var minorTickModel = angleAxisModel.getModel("minorTick");
		var tickLen = (tickModel.get("inside") ? -1 : 1) * minorTickModel.get("length");
		var radius = radiusExtent[getRadiusIdx(polar)];
		var lines = [];
		for (var i$1 = 0; i$1 < minorTickAngles.length; i$1++) for (var k$1 = 0; k$1 < minorTickAngles[i$1].length; k$1++) lines.push(new Line_default({ shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i$1][k$1].coord) }));
		group.add(mergePath(lines, { style: defaults(minorTickModel.getModel("lineStyle").getLineStyle(), defaults(tickModel.getLineStyle(), { stroke: angleAxisModel.get([
			"axisLine",
			"lineStyle",
			"color"
		]) })) }));
	},
	axisLabel: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
		var rawCategoryData = angleAxisModel.getCategories(true);
		var commonLabelModel = angleAxisModel.getModel("axisLabel");
		var labelMargin = commonLabelModel.get("margin");
		var triggerEvent = angleAxisModel.get("triggerEvent");
		each(labels, function(labelItem, idx) {
			var labelModel = commonLabelModel;
			var tickValue = labelItem.tickValue;
			var r = radiusExtent[getRadiusIdx(polar)];
			var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);
			var cx = polar.cx;
			var cy = polar.cy;
			var labelTextAlign = Math.abs(p[0] - cx) / r < .3 ? "center" : p[0] > cx ? "left" : "right";
			var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < .3 ? "middle" : p[1] > cy ? "top" : "bottom";
			if (rawCategoryData && rawCategoryData[tickValue]) {
				var rawCategoryItem = rawCategoryData[tickValue];
				if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) labelModel = new Model_default(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);
			}
			var textEl = new Text_default({
				silent: AxisBuilder_default.isLabelSilent(angleAxisModel),
				style: createTextStyle(labelModel, {
					x: p[0],
					y: p[1],
					fill: labelModel.getTextColor() || angleAxisModel.get([
						"axisLine",
						"lineStyle",
						"color"
					]),
					text: labelItem.formattedLabel,
					align: labelTextAlign,
					verticalAlign: labelTextVerticalAlign
				})
			});
			group.add(textEl);
			setTooltipConfig({
				el: textEl,
				componentModel: angleAxisModel,
				itemName: labelItem.formattedLabel,
				formatterParamsExtra: {
					isTruncated: function() {
						return textEl.isTruncated;
					},
					value: labelItem.rawLabel,
					tickIndex: idx
				}
			});
			if (triggerEvent) {
				var eventData = AxisBuilder_default.makeAxisEventDataBase(angleAxisModel);
				eventData.targetType = "axisLabel";
				eventData.value = labelItem.rawLabel;
				getECData(textEl).eventData = eventData;
			}
		}, this);
	},
	splitLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
		var lineStyleModel = angleAxisModel.getModel("splitLine").getModel("lineStyle");
		var lineColors = lineStyleModel.get("color");
		var lineCount = 0;
		lineColors = lineColors instanceof Array ? lineColors : [lineColors];
		var splitLines = [];
		for (var i$1 = 0; i$1 < ticksAngles.length; i$1++) {
			var colorIndex = lineCount++ % lineColors.length;
			splitLines[colorIndex] = splitLines[colorIndex] || [];
			splitLines[colorIndex].push(new Line_default({ shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i$1].coord) }));
		}
		for (var i$1 = 0; i$1 < splitLines.length; i$1++) group.add(mergePath(splitLines[i$1], {
			style: defaults({ stroke: lineColors[i$1 % lineColors.length] }, lineStyleModel.getLineStyle()),
			silent: true,
			z: angleAxisModel.get("z")
		}));
	},
	minorSplitLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
		if (!minorTickAngles.length) return;
		var lineStyleModel = angleAxisModel.getModel("minorSplitLine").getModel("lineStyle");
		var lines = [];
		for (var i$1 = 0; i$1 < minorTickAngles.length; i$1++) for (var k$1 = 0; k$1 < minorTickAngles[i$1].length; k$1++) lines.push(new Line_default({ shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i$1][k$1].coord) }));
		group.add(mergePath(lines, {
			style: lineStyleModel.getLineStyle(),
			silent: true,
			z: angleAxisModel.get("z")
		}));
	},
	splitArea: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
		if (!ticksAngles.length) return;
		var areaStyleModel = angleAxisModel.getModel("splitArea").getModel("areaStyle");
		var areaColors = areaStyleModel.get("color");
		var lineCount = 0;
		areaColors = areaColors instanceof Array ? areaColors : [areaColors];
		var splitAreas = [];
		var RADIAN$5 = Math.PI / 180;
		var prevAngle = -ticksAngles[0].coord * RADIAN$5;
		var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
		var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
		var clockwise = angleAxisModel.get("clockwise");
		for (var i$1 = 1, len$1 = ticksAngles.length; i$1 <= len$1; i$1++) {
			var coord = i$1 === len$1 ? ticksAngles[0].coord : ticksAngles[i$1].coord;
			var colorIndex = lineCount++ % areaColors.length;
			splitAreas[colorIndex] = splitAreas[colorIndex] || [];
			splitAreas[colorIndex].push(new Sector_default({
				shape: {
					cx: polar.cx,
					cy: polar.cy,
					r0,
					r: r1,
					startAngle: prevAngle,
					endAngle: -coord * RADIAN$5,
					clockwise
				},
				silent: true
			}));
			prevAngle = -coord * RADIAN$5;
		}
		for (var i$1 = 0; i$1 < splitAreas.length; i$1++) group.add(mergePath(splitAreas[i$1], {
			style: defaults({ fill: areaColors[i$1 % areaColors.length] }, areaStyleModel.getAreaStyle()),
			silent: true
		}));
	}
};
var AngleAxisView_default = AngleAxisView;

//#endregion
//#region node_modules/echarts/lib/component/axis/RadiusAxisView.js
var selfBuilderAttrs$1 = [
	"splitLine",
	"splitArea",
	"minorSplitLine"
];
var RadiusAxisView = function(_super) {
	__extends(RadiusAxisView$1, _super);
	function RadiusAxisView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = RadiusAxisView$1.type;
		_this.axisPointerClass = "PolarAxisPointer";
		return _this;
	}
	RadiusAxisView$1.prototype.render = function(radiusAxisModel, ecModel, api) {
		this.group.removeAll();
		if (!radiusAxisModel.get("show")) return;
		var oldAxisGroup = this._axisGroup;
		var newAxisGroup = this._axisGroup = new Group_default();
		this.group.add(newAxisGroup);
		var radiusAxis = radiusAxisModel.axis;
		var polar = radiusAxis.polar;
		var angleAxis = polar.getAngleAxis();
		var ticksCoords = radiusAxis.getTicksCoords();
		var minorTicksCoords = radiusAxis.getMinorTicksCoords();
		var axisAngle = angleAxis.getExtent()[0];
		var radiusExtent = radiusAxis.getExtent();
		var axisBuilder = new AxisBuilder_default(radiusAxisModel, api, layoutAxis(polar, radiusAxisModel, axisAngle));
		axisBuilder.build();
		newAxisGroup.add(axisBuilder.group);
		groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel);
		each(selfBuilderAttrs$1, function(name) {
			if (radiusAxisModel.get([name, "show"]) && !radiusAxis.scale.isBlank()) axisElementBuilders$1[name](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
		}, this);
	};
	RadiusAxisView$1.type = "radiusAxis";
	return RadiusAxisView$1;
}(AxisView_default);
var axisElementBuilders$1 = {
	splitLine: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
		var lineStyleModel = radiusAxisModel.getModel("splitLine").getModel("lineStyle");
		var lineColors = lineStyleModel.get("color");
		var lineCount = 0;
		var angleAxis = polar.getAngleAxis();
		var RADIAN$5 = Math.PI / 180;
		var angleExtent = angleAxis.getExtent();
		var shapeType = Math.abs(angleExtent[1] - angleExtent[0]) === 360 ? "Circle" : "Arc";
		lineColors = lineColors instanceof Array ? lineColors : [lineColors];
		var splitLines = [];
		for (var i$1 = 0; i$1 < ticksCoords.length; i$1++) {
			var colorIndex = lineCount++ % lineColors.length;
			splitLines[colorIndex] = splitLines[colorIndex] || [];
			splitLines[colorIndex].push(new graphic_exports$1[shapeType]({ shape: {
				cx: polar.cx,
				cy: polar.cy,
				r: Math.max(ticksCoords[i$1].coord, 0),
				startAngle: -angleExtent[0] * RADIAN$5,
				endAngle: -angleExtent[1] * RADIAN$5,
				clockwise: angleAxis.inverse
			} }));
		}
		for (var i$1 = 0; i$1 < splitLines.length; i$1++) group.add(mergePath(splitLines[i$1], {
			style: defaults({
				stroke: lineColors[i$1 % lineColors.length],
				fill: null
			}, lineStyleModel.getLineStyle()),
			silent: true
		}));
	},
	minorSplitLine: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
		if (!minorTicksCoords.length) return;
		var lineStyleModel = radiusAxisModel.getModel("minorSplitLine").getModel("lineStyle");
		var lines = [];
		for (var i$1 = 0; i$1 < minorTicksCoords.length; i$1++) for (var k$1 = 0; k$1 < minorTicksCoords[i$1].length; k$1++) lines.push(new Circle_default({ shape: {
			cx: polar.cx,
			cy: polar.cy,
			r: minorTicksCoords[i$1][k$1].coord
		} }));
		group.add(mergePath(lines, {
			style: defaults({ fill: null }, lineStyleModel.getLineStyle()),
			silent: true
		}));
	},
	splitArea: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
		if (!ticksCoords.length) return;
		var areaStyleModel = radiusAxisModel.getModel("splitArea").getModel("areaStyle");
		var areaColors = areaStyleModel.get("color");
		var lineCount = 0;
		areaColors = areaColors instanceof Array ? areaColors : [areaColors];
		var splitAreas = [];
		var prevRadius = ticksCoords[0].coord;
		for (var i$1 = 1; i$1 < ticksCoords.length; i$1++) {
			var colorIndex = lineCount++ % areaColors.length;
			splitAreas[colorIndex] = splitAreas[colorIndex] || [];
			splitAreas[colorIndex].push(new Sector_default({
				shape: {
					cx: polar.cx,
					cy: polar.cy,
					r0: prevRadius,
					r: ticksCoords[i$1].coord,
					startAngle: 0,
					endAngle: Math.PI * 2
				},
				silent: true
			}));
			prevRadius = ticksCoords[i$1].coord;
		}
		for (var i$1 = 0; i$1 < splitAreas.length; i$1++) group.add(mergePath(splitAreas[i$1], {
			style: defaults({ fill: areaColors[i$1 % areaColors.length] }, areaStyleModel.getAreaStyle()),
			silent: true
		}));
	}
};
/**
* @inner
*/
function layoutAxis(polar, radiusAxisModel, axisAngle) {
	return {
		position: [polar.cx, polar.cy],
		rotation: axisAngle / 180 * Math.PI,
		labelDirection: -1,
		tickDirection: -1,
		nameDirection: 1,
		labelRotate: radiusAxisModel.getModel("axisLabel").get("rotate"),
		z2: 1
	};
}
var RadiusAxisView_default = RadiusAxisView;

//#endregion
//#region node_modules/echarts/lib/layout/barPolar.js
function getSeriesStackId(seriesModel) {
	return seriesModel.get("stack") || "__ec_stack_" + seriesModel.seriesIndex;
}
function getAxisKey(polar, axis) {
	return axis.dim + polar.model.componentIndex;
}
function barLayoutPolar(seriesType$1, ecModel, api) {
	var lastStackCoords = {};
	var barWidthAndOffset = calRadialBar(filter(ecModel.getSeriesByType(seriesType$1), function(seriesModel) {
		return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "polar";
	}));
	ecModel.eachSeriesByType(seriesType$1, function(seriesModel) {
		if (seriesModel.coordinateSystem.type !== "polar") return;
		var data = seriesModel.getData();
		var polar = seriesModel.coordinateSystem;
		var baseAxis = polar.getBaseAxis();
		var axisKey = getAxisKey(polar, baseAxis);
		var stackId = getSeriesStackId(seriesModel);
		var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
		var columnOffset = columnLayoutInfo.offset;
		var columnWidth = columnLayoutInfo.width;
		var valueAxis$1 = polar.getOtherAxis(baseAxis);
		var cx = seriesModel.coordinateSystem.cx;
		var cy = seriesModel.coordinateSystem.cy;
		var barMinHeight = seriesModel.get("barMinHeight") || 0;
		var barMinAngle = seriesModel.get("barMinAngle") || 0;
		lastStackCoords[stackId] = lastStackCoords[stackId] || [];
		var valueDim = data.mapDimension(valueAxis$1.dim);
		var baseDim = data.mapDimension(baseAxis.dim);
		var stacked = isDimensionStacked(data, valueDim);
		var clampLayout = baseAxis.dim !== "radius" || !seriesModel.get("roundCap", true);
		var startValue = valueAxis$1.model.get("startValue");
		var valueAxisStart = valueAxis$1.dataToCoord(startValue || 0);
		for (var idx = 0, len$1 = data.count(); idx < len$1; idx++) {
			var value = data.get(valueDim, idx);
			var baseValue = data.get(baseDim, idx);
			var sign = value >= 0 ? "p" : "n";
			var baseCoord = valueAxisStart;
			if (stacked) {
				if (!lastStackCoords[stackId][baseValue]) lastStackCoords[stackId][baseValue] = {
					p: valueAxisStart,
					n: valueAxisStart
				};
				baseCoord = lastStackCoords[stackId][baseValue][sign];
			}
			var r0 = void 0;
			var r = void 0;
			var startAngle = void 0;
			var endAngle = void 0;
			if (valueAxis$1.dim === "radius") {
				var radiusSpan = valueAxis$1.dataToCoord(value) - valueAxisStart;
				var angle = baseAxis.dataToCoord(baseValue);
				if (Math.abs(radiusSpan) < barMinHeight) radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
				r0 = baseCoord;
				r = baseCoord + radiusSpan;
				startAngle = angle - columnOffset;
				endAngle = startAngle - columnWidth;
				stacked && (lastStackCoords[stackId][baseValue][sign] = r);
			} else {
				var angleSpan = valueAxis$1.dataToCoord(value, clampLayout) - valueAxisStart;
				var radius = baseAxis.dataToCoord(baseValue);
				if (Math.abs(angleSpan) < barMinAngle) angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
				r0 = radius + columnOffset;
				r = r0 + columnWidth;
				startAngle = baseCoord;
				endAngle = baseCoord + angleSpan;
				stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);
			}
			data.setItemLayout(idx, {
				cx,
				cy,
				r0,
				r,
				startAngle: -startAngle * Math.PI / 180,
				endAngle: -endAngle * Math.PI / 180,
				clockwise: startAngle >= endAngle
			});
		}
	});
}
/**
* Calculate bar width and offset for radial bar charts
*/
function calRadialBar(barSeries) {
	var columnsMap = {};
	each(barSeries, function(seriesModel, idx) {
		var data = seriesModel.getData();
		var polar = seriesModel.coordinateSystem;
		var baseAxis = polar.getBaseAxis();
		var axisKey = getAxisKey(polar, baseAxis);
		var axisExtent = baseAxis.getExtent();
		var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
		var columnsOnAxis = columnsMap[axisKey] || {
			bandWidth,
			remainedWidth: bandWidth,
			autoWidthCount: 0,
			categoryGap: "20%",
			gap: "30%",
			stacks: {}
		};
		var stacks = columnsOnAxis.stacks;
		columnsMap[axisKey] = columnsOnAxis;
		var stackId = getSeriesStackId(seriesModel);
		if (!stacks[stackId]) columnsOnAxis.autoWidthCount++;
		stacks[stackId] = stacks[stackId] || {
			width: 0,
			maxWidth: 0
		};
		var barWidth = parsePercent$1(seriesModel.get("barWidth"), bandWidth);
		var barMaxWidth = parsePercent$1(seriesModel.get("barMaxWidth"), bandWidth);
		var barGap = seriesModel.get("barGap");
		var barCategoryGap = seriesModel.get("barCategoryGap");
		if (barWidth && !stacks[stackId].width) {
			barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
			stacks[stackId].width = barWidth;
			columnsOnAxis.remainedWidth -= barWidth;
		}
		barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
		barGap != null && (columnsOnAxis.gap = barGap);
		barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
	});
	var result = {};
	each(columnsMap, function(columnsOnAxis, coordSysName) {
		result[coordSysName] = {};
		var stacks = columnsOnAxis.stacks;
		var bandWidth = columnsOnAxis.bandWidth;
		var categoryGap = parsePercent$1(columnsOnAxis.categoryGap, bandWidth);
		var barGapPercent = parsePercent$1(columnsOnAxis.gap, 1);
		var remainedWidth = columnsOnAxis.remainedWidth;
		var autoWidthCount = columnsOnAxis.autoWidthCount;
		var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
		autoWidth = Math.max(autoWidth, 0);
		each(stacks, function(column, stack) {
			var maxWidth = column.maxWidth;
			if (maxWidth && maxWidth < autoWidth) {
				maxWidth = Math.min(maxWidth, remainedWidth);
				if (column.width) maxWidth = Math.min(maxWidth, column.width);
				remainedWidth -= maxWidth;
				column.width = maxWidth;
				autoWidthCount--;
			}
		});
		autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
		autoWidth = Math.max(autoWidth, 0);
		var widthSum = 0;
		var lastColumn;
		each(stacks, function(column, idx) {
			if (!column.width) column.width = autoWidth;
			lastColumn = column;
			widthSum += column.width * (1 + barGapPercent);
		});
		if (lastColumn) widthSum -= lastColumn.width * barGapPercent;
		var offset = -widthSum / 2;
		each(stacks, function(column, stackId) {
			result[coordSysName][stackId] = result[coordSysName][stackId] || {
				offset,
				width: column.width
			};
			offset += column.width * (1 + barGapPercent);
		});
	});
	return result;
}
var barPolar_default = barLayoutPolar;

//#endregion
//#region node_modules/echarts/lib/component/polar/install.js
var angleAxisExtraOption = {
	startAngle: 90,
	clockwise: true,
	splitNumber: 12,
	axisLabel: { rotate: 0 }
};
var radiusAxisExtraOption = { splitNumber: 5 };
var PolarView = function(_super) {
	__extends(PolarView$1, _super);
	function PolarView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = PolarView$1.type;
		return _this;
	}
	PolarView$1.type = "polar";
	return PolarView$1;
}(Component_default$1);
function install$26(registers) {
	use(install$35);
	AxisView_default.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer_default);
	registers.registerCoordinateSystem("polar", polarCreator_default);
	registers.registerComponentModel(PolarModel_default);
	registers.registerComponentView(PolarView);
	axisModelCreator(registers, "angle", AngleAxisModel, angleAxisExtraOption);
	axisModelCreator(registers, "radius", RadiusAxisModel, radiusAxisExtraOption);
	registers.registerComponentView(AngleAxisView_default);
	registers.registerComponentView(RadiusAxisView_default);
	registers.registerLayout(curry(barPolar_default, "bar"));
}

//#endregion
//#region node_modules/echarts/lib/coord/single/singleAxisHelper.js
function layout(axisModel, opt) {
	opt = opt || {};
	var single = axisModel.coordinateSystem;
	var axis = axisModel.axis;
	var layout$3 = {};
	var axisPosition = axis.position;
	var orient = axis.orient;
	var rect = single.getRect();
	var rectBound = [
		rect.x,
		rect.x + rect.width,
		rect.y,
		rect.y + rect.height
	];
	var positionMap = {
		horizontal: {
			top: rectBound[2],
			bottom: rectBound[3]
		},
		vertical: {
			left: rectBound[0],
			right: rectBound[1]
		}
	};
	layout$3.position = [orient === "vertical" ? positionMap.vertical[axisPosition] : rectBound[0], orient === "horizontal" ? positionMap.horizontal[axisPosition] : rectBound[3]];
	layout$3.rotation = Math.PI / 2 * {
		horizontal: 0,
		vertical: 1
	}[orient];
	layout$3.labelDirection = layout$3.tickDirection = layout$3.nameDirection = {
		top: -1,
		bottom: 1,
		right: 1,
		left: -1
	}[axisPosition];
	if (axisModel.get(["axisTick", "inside"])) layout$3.tickDirection = -layout$3.tickDirection;
	if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) layout$3.labelDirection = -layout$3.labelDirection;
	var labelRotate = axisModel.get(["axisLabel", "rotate"]);
	layout$3.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
	layout$3.z2 = 1;
	return layout$3;
}

//#endregion
//#region node_modules/echarts/lib/component/axis/SingleAxisView.js
var selfBuilderAttrs = [
	"splitArea",
	"splitLine",
	"breakArea"
];
var SingleAxisView = function(_super) {
	__extends(SingleAxisView$1, _super);
	function SingleAxisView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SingleAxisView$1.type;
		_this.axisPointerClass = "SingleAxisPointer";
		return _this;
	}
	SingleAxisView$1.prototype.render = function(axisModel, ecModel, api, payload) {
		var group = this.group;
		group.removeAll();
		var oldAxisGroup = this._axisGroup;
		this._axisGroup = new Group_default();
		var axisBuilder = new AxisBuilder_default(axisModel, api, layout(axisModel));
		axisBuilder.build();
		group.add(this._axisGroup);
		group.add(axisBuilder.group);
		each(selfBuilderAttrs, function(name) {
			if (axisModel.get([name, "show"])) axisElementBuilders[name](this, this.group, this._axisGroup, axisModel, api);
		}, this);
		groupTransition(oldAxisGroup, this._axisGroup, axisModel);
		_super.prototype.render.call(this, axisModel, ecModel, api, payload);
	};
	SingleAxisView$1.prototype.remove = function() {
		rectCoordAxisHandleRemove(this);
	};
	SingleAxisView$1.type = "singleAxis";
	return SingleAxisView$1;
}(AxisView_default);
var axisElementBuilders = {
	splitLine: function(axisView, group, axisGroup, axisModel, api) {
		var axis = axisModel.axis;
		if (axis.scale.isBlank()) return;
		var splitLineModel = axisModel.getModel("splitLine");
		var lineStyleModel = splitLineModel.getModel("lineStyle");
		var lineColors = lineStyleModel.get("color");
		lineColors = lineColors instanceof Array ? lineColors : [lineColors];
		var lineWidth = lineStyleModel.get("width");
		var gridRect = axisModel.coordinateSystem.getRect();
		var isHorizontal = axis.isHorizontal();
		var splitLines = [];
		var lineCount = 0;
		var ticksCoords = axis.getTicksCoords({
			tickModel: splitLineModel,
			breakTicks: "none",
			pruneByBreak: "preserve_extent_bound"
		});
		var p1 = [];
		var p2 = [];
		for (var i$1 = 0; i$1 < ticksCoords.length; ++i$1) {
			var tickCoord = axis.toGlobalCoord(ticksCoords[i$1].coord);
			if (isHorizontal) {
				p1[0] = tickCoord;
				p1[1] = gridRect.y;
				p2[0] = tickCoord;
				p2[1] = gridRect.y + gridRect.height;
			} else {
				p1[0] = gridRect.x;
				p1[1] = tickCoord;
				p2[0] = gridRect.x + gridRect.width;
				p2[1] = tickCoord;
			}
			var line = new Line_default({
				shape: {
					x1: p1[0],
					y1: p1[1],
					x2: p2[0],
					y2: p2[1]
				},
				silent: true
			});
			subPixelOptimizeLine$1(line.shape, lineWidth);
			var colorIndex = lineCount++ % lineColors.length;
			splitLines[colorIndex] = splitLines[colorIndex] || [];
			splitLines[colorIndex].push(line);
		}
		var lineStyle = lineStyleModel.getLineStyle(["color"]);
		for (var i$1 = 0; i$1 < splitLines.length; ++i$1) group.add(mergePath(splitLines[i$1], {
			style: defaults({ stroke: lineColors[i$1 % lineColors.length] }, lineStyle),
			silent: true
		}));
	},
	splitArea: function(axisView, group, axisGroup, axisModel, api) {
		rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, axisModel);
	},
	breakArea: function(axisView, group, axisGroup, axisModel, api) {
		var axisBreakHelper = getAxisBreakHelper();
		var scale$3 = axisModel.axis.scale;
		if (axisBreakHelper && scale$3.type !== "ordinal") axisBreakHelper.rectCoordBuildBreakAxis(group, axisView, axisModel, axisModel.coordinateSystem.getRect(), api);
	}
};
var SingleAxisView_default = SingleAxisView;

//#endregion
//#region node_modules/echarts/lib/coord/single/AxisModel.js
var SingleAxisModel = function(_super) {
	__extends(SingleAxisModel$1, _super);
	function SingleAxisModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SingleAxisModel$1.type;
		return _this;
	}
	SingleAxisModel$1.prototype.getCoordSysModel = function() {
		return this;
	};
	SingleAxisModel$1.type = "singleAxis";
	SingleAxisModel$1.layoutMode = "box";
	SingleAxisModel$1.defaultOption = {
		left: "5%",
		top: "5%",
		right: "5%",
		bottom: "5%",
		type: "value",
		position: "bottom",
		orient: "horizontal",
		axisLine: {
			show: true,
			lineStyle: {
				width: 1,
				type: "solid"
			}
		},
		tooltip: { show: true },
		axisTick: {
			show: true,
			length: 6,
			lineStyle: { width: 1 }
		},
		axisLabel: {
			show: true,
			interval: "auto"
		},
		splitLine: {
			show: true,
			lineStyle: {
				type: "dashed",
				opacity: .2
			}
		},
		jitter: 0,
		jitterOverlap: true,
		jitterMargin: 2
	};
	return SingleAxisModel$1;
}(Component_default);
mixin(SingleAxisModel, AxisModelCommonMixin.prototype);
var AxisModel_default = SingleAxisModel;

//#endregion
//#region node_modules/echarts/lib/coord/single/SingleAxis.js
var SingleAxis = function(_super) {
	__extends(SingleAxis$1, _super);
	function SingleAxis$1(dim, scale$3, coordExtent, axisType, position$1) {
		var _this = _super.call(this, dim, scale$3, coordExtent) || this;
		_this.type = axisType || "value";
		_this.position = position$1 || "bottom";
		return _this;
	}
	/**
	* Judge the orient of the axis.
	*/
	SingleAxis$1.prototype.isHorizontal = function() {
		var position$1 = this.position;
		return position$1 === "top" || position$1 === "bottom";
	};
	SingleAxis$1.prototype.pointToData = function(point, clamp$1) {
		return this.coordinateSystem.pointToData(point)[0];
	};
	return SingleAxis$1;
}(Axis_default);
var SingleAxis_default = SingleAxis;

//#endregion
//#region node_modules/echarts/lib/coord/single/Single.js
var singleDimensions = ["single"];
/**
* Create a single coordinates system.
*/
var Single = function() {
	function Single$1(axisModel, ecModel, api) {
		this.type = "single";
		this.dimension = "single";
		/**
		* Add it just for draw tooltip.
		*/
		this.dimensions = singleDimensions;
		this.axisPointerEnabled = true;
		this.model = axisModel;
		this._init(axisModel, ecModel, api);
	}
	/**
	* Initialize single coordinate system.
	*/
	Single$1.prototype._init = function(axisModel, ecModel, api) {
		var dim = this.dimension;
		var axis = new SingleAxis_default(dim, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisModel.get("position"));
		axis.onBand = axis.type === "category" && axisModel.get("boundaryGap");
		axis.inverse = axisModel.get("inverse");
		axis.orient = axisModel.get("orient");
		axisModel.axis = axis;
		axis.model = axisModel;
		axis.coordinateSystem = this;
		this._axis = axis;
	};
	/**
	* Update axis scale after data processed
	*/
	Single$1.prototype.update = function(ecModel, api) {
		ecModel.eachSeries(function(seriesModel) {
			if (seriesModel.coordinateSystem === this) {
				var data_1 = seriesModel.getData();
				each(data_1.mapDimensionsAll(this.dimension), function(dim) {
					this._axis.scale.unionExtentFromData(data_1, dim);
				}, this);
				niceScaleExtent(this._axis.scale, this._axis.model);
			}
		}, this);
	};
	/**
	* Resize the single coordinate system.
	*/
	Single$1.prototype.resize = function(axisModel, api) {
		var refContainer = createBoxLayoutReference(axisModel, api).refContainer;
		this._rect = getLayoutRect(axisModel.getBoxLayoutParams(), refContainer);
		this._adjustAxis();
	};
	Single$1.prototype.getRect = function() {
		return this._rect;
	};
	Single$1.prototype._adjustAxis = function() {
		var rect = this._rect;
		var axis = this._axis;
		var isHorizontal = axis.isHorizontal();
		var extent = isHorizontal ? [0, rect.width] : [0, rect.height];
		var idx = axis.inverse ? 1 : 0;
		axis.setExtent(extent[idx], extent[1 - idx]);
		this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);
	};
	Single$1.prototype._updateAxisTransform = function(axis, coordBase) {
		var axisExtent = axis.getExtent();
		var extentSum = axisExtent[0] + axisExtent[1];
		var isHorizontal = axis.isHorizontal();
		axis.toGlobalCoord = isHorizontal ? function(coord) {
			return coord + coordBase;
		} : function(coord) {
			return extentSum - coord + coordBase;
		};
		axis.toLocalCoord = isHorizontal ? function(coord) {
			return coord - coordBase;
		} : function(coord) {
			return extentSum - coord + coordBase;
		};
	};
	/**
	* Get axis.
	*/
	Single$1.prototype.getAxis = function() {
		return this._axis;
	};
	/**
	* Get axis, add it just for draw tooltip.
	*/
	Single$1.prototype.getBaseAxis = function() {
		return this._axis;
	};
	Single$1.prototype.getAxes = function() {
		return [this._axis];
	};
	Single$1.prototype.getTooltipAxes = function() {
		return {
			baseAxes: [this.getAxis()],
			otherAxes: []
		};
	};
	/**
	* If contain point.
	*/
	Single$1.prototype.containPoint = function(point) {
		var rect = this.getRect();
		var axis = this.getAxis();
		if (axis.orient === "horizontal") return axis.contain(axis.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height;
		else return axis.contain(axis.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height;
	};
	Single$1.prototype.pointToData = function(point, reserved, out$1) {
		out$1 = out$1 || [];
		var axis = this.getAxis();
		out$1[0] = axis.coordToData(axis.toLocalCoord(point[axis.orient === "horizontal" ? 0 : 1]));
		return out$1;
	};
	/**
	* Convert the series data to concrete point.
	* Can be [val] | val
	*/
	Single$1.prototype.dataToPoint = function(val, reserved, out$1) {
		var axis = this.getAxis();
		var rect = this.getRect();
		out$1 = out$1 || [];
		var idx = axis.orient === "horizontal" ? 0 : 1;
		if (val instanceof Array) val = val[0];
		out$1[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
		out$1[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
		return out$1;
	};
	Single$1.prototype.convertToPixel = function(ecModel, finder, value) {
		return getCoordSys$2(finder) === this ? this.dataToPoint(value) : null;
	};
	Single$1.prototype.convertFromPixel = function(ecModel, finder, pixel) {
		return getCoordSys$2(finder) === this ? this.pointToData(pixel) : null;
	};
	return Single$1;
}();
function getCoordSys$2(finder) {
	var seriesModel = finder.seriesModel;
	var singleModel = finder.singleAxisModel;
	return singleModel && singleModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
var Single_default = Single;

//#endregion
//#region node_modules/echarts/lib/coord/single/singleCreator.js
/**
* Create single coordinate system and inject it into seriesModel.
*/
function create(ecModel, api) {
	var singles = [];
	ecModel.eachComponent("singleAxis", function(axisModel, idx) {
		var single = new Single_default(axisModel, ecModel, api);
		single.name = "single_" + idx;
		single.resize(axisModel, api);
		axisModel.coordinateSystem = single;
		singles.push(single);
	});
	ecModel.eachSeries(function(seriesModel) {
		if (seriesModel.get("coordinateSystem") === "singleAxis") {
			var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
			seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
		}
	});
	return singles;
}
var singleCreator = {
	create,
	dimensions: singleDimensions
};
var singleCreator_default = singleCreator;

//#endregion
//#region node_modules/echarts/lib/component/axisPointer/SingleAxisPointer.js
var XY$2 = ["x", "y"];
var WH$2 = ["width", "height"];
var SingleAxisPointer = function(_super) {
	__extends(SingleAxisPointer$1, _super);
	function SingleAxisPointer$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* @override
	*/
	SingleAxisPointer$1.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
		var axis = axisModel.axis;
		var coordSys = axis.coordinateSystem;
		var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));
		var pixelValue = coordSys.dataToPoint(value)[0];
		var axisPointerType = axisPointerModel.get("type");
		if (axisPointerType && axisPointerType !== "none") {
			var elStyle = buildElStyle(axisPointerModel);
			var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
			pointerOption.style = elStyle;
			elOption.graphicKey = pointerOption.type;
			elOption.pointer = pointerOption;
		}
		var layoutInfo = layout(axisModel);
		buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
	};
	/**
	* @override
	*/
	SingleAxisPointer$1.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
		var layoutInfo = layout(axisModel, { labelInside: false });
		layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
		var position$1 = getTransformedPosition(axisModel.axis, value, layoutInfo);
		return {
			x: position$1[0],
			y: position$1[1],
			rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
		};
	};
	/**
	* @override
	*/
	SingleAxisPointer$1.prototype.updateHandleTransform = function(transform, delta, axisModel, axisPointerModel) {
		var axis = axisModel.axis;
		var coordSys = axis.coordinateSystem;
		var dimIndex = getPointDimIndex(axis);
		var axisExtent = getGlobalExtent(coordSys, dimIndex);
		var currPosition = [transform.x, transform.y];
		currPosition[dimIndex] += delta[dimIndex];
		currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
		currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
		var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
		var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
		var cursorPoint = [cursorOtherValue, cursorOtherValue];
		cursorPoint[dimIndex] = currPosition[dimIndex];
		return {
			x: currPosition[0],
			y: currPosition[1],
			rotation: transform.rotation,
			cursorPoint,
			tooltipOption: { verticalAlign: "middle" }
		};
	};
	return SingleAxisPointer$1;
}(BaseAxisPointer_default);
var pointerShapeBuilder = {
	line: function(axis, pixelValue, otherExtent) {
		return {
			type: "Line",
			subPixelOptimize: true,
			shape: makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis))
		};
	},
	shadow: function(axis, pixelValue, otherExtent) {
		var bandWidth = axis.getBandWidth();
		var span = otherExtent[1] - otherExtent[0];
		return {
			type: "Rect",
			shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
		};
	}
};
function getPointDimIndex(axis) {
	return axis.isHorizontal() ? 0 : 1;
}
function getGlobalExtent(coordSys, dimIndex) {
	var rect = coordSys.getRect();
	return [rect[XY$2[dimIndex]], rect[XY$2[dimIndex]] + rect[WH$2[dimIndex]]];
}
var SingleAxisPointer_default = SingleAxisPointer;

//#endregion
//#region node_modules/echarts/lib/component/singleAxis/install.js
var SingleView = function(_super) {
	__extends(SingleView$1, _super);
	function SingleView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SingleView$1.type;
		return _this;
	}
	SingleView$1.type = "single";
	return SingleView$1;
}(Component_default$1);
function install$28(registers) {
	use(install$35);
	AxisView_default.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer_default);
	registers.registerComponentView(SingleView);
	registers.registerComponentView(SingleAxisView_default);
	registers.registerComponentModel(AxisModel_default);
	axisModelCreator(registers, "single", AxisModel_default, AxisModel_default.defaultOption);
	registers.registerCoordinateSystem("single", singleCreator_default);
}

//#endregion
//#region node_modules/echarts/lib/coord/calendar/CalendarModel.js
var CalendarModel = function(_super) {
	__extends(CalendarModel$1, _super);
	function CalendarModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = CalendarModel$1.type;
		return _this;
	}
	/**
	* @override
	*/
	CalendarModel$1.prototype.init = function(option, parentModel, ecModel) {
		var inputPositionParams = getLayoutParams(option);
		_super.prototype.init.apply(this, arguments);
		mergeAndNormalizeLayoutParams$1(option, inputPositionParams);
	};
	/**
	* @override
	*/
	CalendarModel$1.prototype.mergeOption = function(option) {
		_super.prototype.mergeOption.apply(this, arguments);
		mergeAndNormalizeLayoutParams$1(this.option, option);
	};
	CalendarModel$1.prototype.getCellSize = function() {
		return this.option.cellSize;
	};
	CalendarModel$1.type = "calendar";
	CalendarModel$1.layoutMode = "box";
	CalendarModel$1.defaultOption = {
		z: 2,
		left: 80,
		top: 60,
		cellSize: 20,
		orient: "horizontal",
		splitLine: {
			show: true,
			lineStyle: {
				color: tokens_default.color.axisLine,
				width: 1,
				type: "solid"
			}
		},
		itemStyle: {
			color: tokens_default.color.neutral00,
			borderWidth: 1,
			borderColor: tokens_default.color.neutral10
		},
		dayLabel: {
			show: true,
			firstDay: 0,
			position: "start",
			margin: tokens_default.size.s,
			color: tokens_default.color.secondary
		},
		monthLabel: {
			show: true,
			position: "start",
			margin: tokens_default.size.s,
			align: "center",
			formatter: null,
			color: tokens_default.color.secondary
		},
		yearLabel: {
			show: true,
			position: null,
			margin: tokens_default.size.xl,
			formatter: null,
			color: tokens_default.color.quaternary,
			fontFamily: "sans-serif",
			fontWeight: "bolder",
			fontSize: 20
		}
	};
	return CalendarModel$1;
}(Component_default);
function mergeAndNormalizeLayoutParams$1(target, raw) {
	var cellSize = target.cellSize;
	var cellSizeArr;
	if (!isArray(cellSize)) cellSizeArr = target.cellSize = [cellSize, cellSize];
	else cellSizeArr = cellSize;
	if (cellSizeArr.length === 1) cellSizeArr[1] = cellSizeArr[0];
	mergeLayoutParam(target, raw, {
		type: "box",
		ignoreSize: map([0, 1], function(hvIdx) {
			if (sizeCalculable(raw, hvIdx)) cellSizeArr[hvIdx] = "auto";
			return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== "auto";
		})
	});
}
var CalendarModel_default = CalendarModel;

//#endregion
//#region node_modules/echarts/lib/component/calendar/CalendarView.js
var CalendarView = function(_super) {
	__extends(CalendarView$1, _super);
	function CalendarView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = CalendarView$1.type;
		return _this;
	}
	CalendarView$1.prototype.render = function(calendarModel, ecModel, api) {
		var group = this.group;
		group.removeAll();
		var coordSys = calendarModel.coordinateSystem;
		var rangeData = coordSys.getRangeInfo();
		var orient = coordSys.getOrient();
		var localeModel = ecModel.getLocaleModel();
		this._renderDayRect(calendarModel, rangeData, group);
		this._renderLines(calendarModel, rangeData, orient, group);
		this._renderYearText(calendarModel, rangeData, orient, group);
		this._renderMonthText(calendarModel, localeModel, orient, group);
		this._renderWeekText(calendarModel, localeModel, rangeData, orient, group);
	};
	CalendarView$1.prototype._renderDayRect = function(calendarModel, rangeData, group) {
		var coordSys = calendarModel.coordinateSystem;
		var itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
		var sw = coordSys.getCellWidth();
		var sh = coordSys.getCellHeight();
		for (var i$1 = rangeData.start.time; i$1 <= rangeData.end.time; i$1 = coordSys.getNextNDay(i$1, 1).time) {
			var point = coordSys.dataToCalendarLayout([i$1], false).tl;
			var rect = new Rect_default({
				shape: {
					x: point[0],
					y: point[1],
					width: sw,
					height: sh
				},
				cursor: "default",
				style: itemRectStyleModel
			});
			group.add(rect);
		}
	};
	CalendarView$1.prototype._renderLines = function(calendarModel, rangeData, orient, group) {
		var self$1 = this;
		var coordSys = calendarModel.coordinateSystem;
		var lineStyleModel = calendarModel.getModel(["splitLine", "lineStyle"]).getLineStyle();
		var show = calendarModel.get(["splitLine", "show"]);
		var lineWidth = lineStyleModel.lineWidth;
		this._tlpoints = [];
		this._blpoints = [];
		this._firstDayOfMonth = [];
		this._firstDayPoints = [];
		var firstDay = rangeData.start;
		for (var i$1 = 0; firstDay.time <= rangeData.end.time; i$1++) {
			addPoints(firstDay.formatedDate);
			if (i$1 === 0) firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
			var date = firstDay.date;
			date.setMonth(date.getMonth() + 1);
			firstDay = coordSys.getDateInfo(date);
		}
		addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
		function addPoints(date$1) {
			self$1._firstDayOfMonth.push(coordSys.getDateInfo(date$1));
			self$1._firstDayPoints.push(coordSys.dataToCalendarLayout([date$1], false).tl);
			var points$3 = self$1._getLinePointsOfOneWeek(calendarModel, date$1, orient);
			self$1._tlpoints.push(points$3[0]);
			self$1._blpoints.push(points$3[points$3.length - 1]);
			show && self$1._drawSplitline(points$3, lineStyleModel, group);
		}
		show && this._drawSplitline(self$1._getEdgesPoints(self$1._tlpoints, lineWidth, orient), lineStyleModel, group);
		show && this._drawSplitline(self$1._getEdgesPoints(self$1._blpoints, lineWidth, orient), lineStyleModel, group);
	};
	CalendarView$1.prototype._getEdgesPoints = function(points$3, lineWidth, orient) {
		var rs = [points$3[0].slice(), points$3[points$3.length - 1].slice()];
		var idx = orient === "horizontal" ? 0 : 1;
		rs[0][idx] = rs[0][idx] - lineWidth / 2;
		rs[1][idx] = rs[1][idx] + lineWidth / 2;
		return rs;
	};
	CalendarView$1.prototype._drawSplitline = function(points$3, lineStyle, group) {
		var poyline = new Polyline_default({
			z2: 20,
			shape: { points: points$3 },
			style: lineStyle
		});
		group.add(poyline);
	};
	CalendarView$1.prototype._getLinePointsOfOneWeek = function(calendarModel, date, orient) {
		var coordSys = calendarModel.coordinateSystem;
		var parsedDate = coordSys.getDateInfo(date);
		var points$3 = [];
		for (var i$1 = 0; i$1 < 7; i$1++) {
			var tmpD = coordSys.getNextNDay(parsedDate.time, i$1);
			var point = coordSys.dataToCalendarLayout([tmpD.time], false);
			points$3[2 * tmpD.day] = point.tl;
			points$3[2 * tmpD.day + 1] = point[orient === "horizontal" ? "bl" : "tr"];
		}
		return points$3;
	};
	CalendarView$1.prototype._formatterLabel = function(formatter, params) {
		if (isString(formatter) && formatter) return formatTplSimple(formatter, params);
		if (isFunction(formatter)) return formatter(params);
		return params.nameMap;
	};
	CalendarView$1.prototype._yearTextPositionControl = function(textEl, point, orient, position$1, margin) {
		var x = point[0];
		var y = point[1];
		var aligns = ["center", "bottom"];
		if (position$1 === "bottom") {
			y += margin;
			aligns = ["center", "top"];
		} else if (position$1 === "left") x -= margin;
		else if (position$1 === "right") {
			x += margin;
			aligns = ["center", "top"];
		} else y -= margin;
		var rotate$1 = 0;
		if (position$1 === "left" || position$1 === "right") rotate$1 = Math.PI / 2;
		return {
			rotation: rotate$1,
			x,
			y,
			style: {
				align: aligns[0],
				verticalAlign: aligns[1]
			}
		};
	};
	CalendarView$1.prototype._renderYearText = function(calendarModel, rangeData, orient, group) {
		var yearLabel = calendarModel.getModel("yearLabel");
		if (!yearLabel.get("show")) return;
		var margin = yearLabel.get("margin");
		var pos = yearLabel.get("position");
		if (!pos) pos = orient !== "horizontal" ? "top" : "left";
		var points$3 = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
		var xc = (points$3[0][0] + points$3[1][0]) / 2;
		var yc = (points$3[0][1] + points$3[1][1]) / 2;
		var idx = orient === "horizontal" ? 0 : 1;
		var posPoints = {
			top: [xc, points$3[idx][1]],
			bottom: [xc, points$3[1 - idx][1]],
			left: [points$3[1 - idx][0], yc],
			right: [points$3[idx][0], yc]
		};
		var name = rangeData.start.y;
		if (+rangeData.end.y > +rangeData.start.y) name = name + "-" + rangeData.end.y;
		var formatter = yearLabel.get("formatter");
		var params = {
			start: rangeData.start.y,
			end: rangeData.end.y,
			nameMap: name
		};
		var content = this._formatterLabel(formatter, params);
		var yearText = new Text_default({
			z2: 30,
			style: createTextStyle(yearLabel, { text: content }),
			silent: yearLabel.get("silent")
		});
		yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
		group.add(yearText);
	};
	CalendarView$1.prototype._monthTextPositionControl = function(point, isCenter, orient, position$1, margin) {
		var align = "left";
		var vAlign = "top";
		var x = point[0];
		var y = point[1];
		if (orient === "horizontal") {
			y = y + margin;
			if (isCenter) align = "center";
			if (position$1 === "start") vAlign = "bottom";
		} else {
			x = x + margin;
			if (isCenter) vAlign = "middle";
			if (position$1 === "start") align = "right";
		}
		return {
			x,
			y,
			align,
			verticalAlign: vAlign
		};
	};
	CalendarView$1.prototype._renderMonthText = function(calendarModel, localeModel, orient, group) {
		var monthLabel = calendarModel.getModel("monthLabel");
		if (!monthLabel.get("show")) return;
		var nameMap = monthLabel.get("nameMap");
		var margin = monthLabel.get("margin");
		var pos = monthLabel.get("position");
		var align = monthLabel.get("align");
		var termPoints = [this._tlpoints, this._blpoints];
		if (!nameMap || isString(nameMap)) {
			if (nameMap) localeModel = getLocaleModel(nameMap) || localeModel;
			nameMap = localeModel.get(["time", "monthAbbr"]) || [];
		}
		var idx = pos === "start" ? 0 : 1;
		var axis = orient === "horizontal" ? 0 : 1;
		margin = pos === "start" ? -margin : margin;
		var isCenter = align === "center";
		var labelSilent = monthLabel.get("silent");
		for (var i$1 = 0; i$1 < termPoints[idx].length - 1; i$1++) {
			var tmp = termPoints[idx][i$1].slice();
			var firstDay = this._firstDayOfMonth[i$1];
			if (isCenter) tmp[axis] = (this._firstDayPoints[i$1][axis] + termPoints[0][i$1 + 1][axis]) / 2;
			var formatter = monthLabel.get("formatter");
			var name_1 = nameMap[+firstDay.m - 1];
			var params = {
				yyyy: firstDay.y,
				yy: (firstDay.y + "").slice(2),
				MM: firstDay.m,
				M: +firstDay.m,
				nameMap: name_1
			};
			var content = this._formatterLabel(formatter, params);
			var monthText = new Text_default({
				z2: 30,
				style: extend(createTextStyle(monthLabel, { text: content }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin)),
				silent: labelSilent
			});
			group.add(monthText);
		}
	};
	CalendarView$1.prototype._weekTextPositionControl = function(point, orient, position$1, margin, cellSize) {
		var align = "center";
		var vAlign = "middle";
		var x = point[0];
		var y = point[1];
		var isStart = position$1 === "start";
		if (orient === "horizontal") {
			x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
			align = isStart ? "right" : "left";
		} else {
			y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
			vAlign = isStart ? "bottom" : "top";
		}
		return {
			x,
			y,
			align,
			verticalAlign: vAlign
		};
	};
	CalendarView$1.prototype._renderWeekText = function(calendarModel, localeModel, rangeData, orient, group) {
		var dayLabel = calendarModel.getModel("dayLabel");
		if (!dayLabel.get("show")) return;
		var coordSys = calendarModel.coordinateSystem;
		var pos = dayLabel.get("position");
		var nameMap = dayLabel.get("nameMap");
		var margin = dayLabel.get("margin");
		var firstDayOfWeek = coordSys.getFirstDayOfWeek();
		if (!nameMap || isString(nameMap)) {
			if (nameMap) localeModel = getLocaleModel(nameMap) || localeModel;
			nameMap = localeModel.get(["time", "dayOfWeekShort"]) || map(localeModel.get(["time", "dayOfWeekAbbr"]), function(val) {
				return val[0];
			});
		}
		var start$1 = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
		var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
		margin = parsePercent$1(margin, Math.min(cellSize[1], cellSize[0]));
		if (pos === "start") {
			start$1 = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
			margin = -margin;
		}
		var labelSilent = dayLabel.get("silent");
		for (var i$1 = 0; i$1 < 7; i$1++) {
			var tmpD = coordSys.getNextNDay(start$1, i$1);
			var point = coordSys.dataToCalendarLayout([tmpD.time], false).center;
			var day = i$1;
			day = Math.abs((i$1 + firstDayOfWeek) % 7);
			var weekText = new Text_default({
				z2: 30,
				style: extend(createTextStyle(dayLabel, { text: nameMap[day] }), this._weekTextPositionControl(point, orient, pos, margin, cellSize)),
				silent: labelSilent
			});
			group.add(weekText);
		}
	};
	CalendarView$1.type = "calendar";
	return CalendarView$1;
}(Component_default$1);
var CalendarView_default = CalendarView;

//#endregion
//#region node_modules/echarts/lib/coord/calendar/Calendar.js
var PROXIMATE_ONE_DAY = 864e5;
var Calendar = function() {
	function Calendar$1(calendarModel, ecModel, api) {
		this.type = "calendar";
		this.dimensions = Calendar$1.dimensions;
		this.getDimensionsInfo = Calendar$1.getDimensionsInfo;
		this._model = calendarModel;
		this._update(ecModel, api);
	}
	Calendar$1.getDimensionsInfo = function() {
		return [{
			name: "time",
			type: "time"
		}, "value"];
	};
	Calendar$1.prototype.getRangeInfo = function() {
		return this._rangeInfo;
	};
	Calendar$1.prototype.getModel = function() {
		return this._model;
	};
	Calendar$1.prototype.getRect = function() {
		return this._rect;
	};
	Calendar$1.prototype.getCellWidth = function() {
		return this._sw;
	};
	Calendar$1.prototype.getCellHeight = function() {
		return this._sh;
	};
	Calendar$1.prototype.getOrient = function() {
		return this._orient;
	};
	/**
	* getFirstDayOfWeek
	*
	* @example
	*     0 : start at Sunday
	*     1 : start at Monday
	*
	* @return {number}
	*/
	Calendar$1.prototype.getFirstDayOfWeek = function() {
		return this._firstDayOfWeek;
	};
	/**
	* get date info
	* }
	*/
	Calendar$1.prototype.getDateInfo = function(date) {
		date = parseDate(date);
		var y = date.getFullYear();
		var m$1 = date.getMonth() + 1;
		var mStr = m$1 < 10 ? "0" + m$1 : "" + m$1;
		var d = date.getDate();
		var dStr = d < 10 ? "0" + d : "" + d;
		var day = date.getDay();
		day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
		return {
			y: y + "",
			m: mStr,
			d: dStr,
			day,
			time: date.getTime(),
			formatedDate: y + "-" + mStr + "-" + dStr,
			date
		};
	};
	Calendar$1.prototype.getNextNDay = function(date, n) {
		n = n || 0;
		if (n === 0) return this.getDateInfo(date);
		date = new Date(this.getDateInfo(date).time);
		date.setDate(date.getDate() + n);
		return this.getDateInfo(date);
	};
	Calendar$1.prototype._update = function(ecModel, api) {
		this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
		this._orient = this._model.get("orient");
		this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
		this._rangeInfo = this._getRangeInfo(this._initRangeOption());
		var weeks = this._rangeInfo.weeks || 1;
		var whNames = ["width", "height"];
		var cellSize = this._model.getCellSize().slice();
		var layoutParams = this._model.getBoxLayoutParams();
		var cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
		each([0, 1], function(idx) {
			if (cellSizeSpecified(cellSize, idx)) layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
		});
		var whGlobal = {
			width: api.getWidth(),
			height: api.getHeight()
		};
		var calendarRect = this._rect = getLayoutRect(layoutParams, whGlobal);
		each([0, 1], function(idx) {
			if (!cellSizeSpecified(cellSize, idx)) cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
		});
		function cellSizeSpecified(cellSize$1, idx) {
			return cellSize$1[idx] != null && cellSize$1[idx] !== "auto";
		}
		this._sw = cellSize[0];
		this._sh = cellSize[1];
	};
	/**
	* Convert a time data(time, value) item to (x, y) point.
	*/
	Calendar$1.prototype.dataToPoint = function(data, clamp$1, out$1) {
		out$1 = out$1 || [];
		isArray(data) && (data = data[0]);
		clamp$1 ??= true;
		var dayInfo = this.getDateInfo(data);
		var range = this._rangeInfo;
		var date = dayInfo.formatedDate;
		if (clamp$1 && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
			out$1[0] = out$1[1] = NaN;
			return out$1;
		}
		var week = dayInfo.day;
		var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;
		if (this._orient === "vertical") {
			out$1[0] = this._rect.x + week * this._sw + this._sw / 2;
			out$1[1] = this._rect.y + nthWeek * this._sh + this._sh / 2;
		} else {
			out$1[0] = this._rect.x + nthWeek * this._sw + this._sw / 2;
			out$1[1] = this._rect.y + week * this._sh + this._sh / 2;
		}
		return out$1;
	};
	/**
	* Convert a (x, y) point to time data
	*/
	Calendar$1.prototype.pointToData = function(point) {
		var date = this.pointToDate(point);
		return date && date.time;
	};
	Calendar$1.prototype.dataToLayout = function(data, clamp$1, out$1) {
		out$1 = out$1 || {};
		var rect = out$1.rect = out$1.rect || {};
		var contentRect = out$1.contentRect = out$1.contentRect || {};
		var point = this.dataToPoint(data, clamp$1);
		rect.x = point[0] - this._sw / 2;
		rect.y = point[1] - this._sh / 2;
		rect.width = this._sw;
		rect.height = this._sh;
		BoundingRect_default.copy(contentRect, rect);
		expandOrShrinkRect(contentRect, this._lineWidth / 2, true, true);
		return out$1;
	};
	/**
	* Convert a time date item to (x, y) four point.
	*/
	Calendar$1.prototype.dataToCalendarLayout = function(data, clamp$1) {
		var point = this.dataToPoint(data, clamp$1);
		return {
			center: point,
			tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
			tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
			br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
			bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
		};
	};
	/**
	* Convert a (x, y) point to time date
	*
	* @param  {Array} point point
	* @return {Object}       date
	*/
	Calendar$1.prototype.pointToDate = function(point) {
		var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
		var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
		var range = this._rangeInfo.range;
		if (this._orient === "vertical") return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
		return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
	};
	Calendar$1.prototype.convertToPixel = function(ecModel, finder, value) {
		var coordSys = getCoordSys$1(finder);
		return coordSys === this ? coordSys.dataToPoint(value) : null;
	};
	Calendar$1.prototype.convertToLayout = function(ecModel, finder, value) {
		var coordSys = getCoordSys$1(finder);
		return coordSys === this ? coordSys.dataToLayout(value) : null;
	};
	Calendar$1.prototype.convertFromPixel = function(ecModel, finder, pixel) {
		var coordSys = getCoordSys$1(finder);
		return coordSys === this ? coordSys.pointToData(pixel) : null;
	};
	Calendar$1.prototype.containPoint = function(point) {
		console.warn("Not implemented.");
		return false;
	};
	/**
	* initRange
	* Normalize to an [start, end] array
	*/
	Calendar$1.prototype._initRangeOption = function() {
		var range = this._model.get("range");
		var normalizedRange;
		if (isArray(range) && range.length === 1) range = range[0];
		if (!isArray(range)) {
			var rangeStr = range.toString();
			if (/^\d{4}$/.test(rangeStr)) normalizedRange = [rangeStr + "-01-01", rangeStr + "-12-31"];
			if (/^\d{4}[\/|-]\d{1,2}$/.test(rangeStr)) {
				var start$1 = this.getDateInfo(rangeStr);
				var firstDay = start$1.date;
				firstDay.setMonth(firstDay.getMonth() + 1);
				var end$1 = this.getNextNDay(firstDay, -1);
				normalizedRange = [start$1.formatedDate, end$1.formatedDate];
			}
			if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rangeStr)) normalizedRange = [rangeStr, rangeStr];
		} else normalizedRange = range;
		if (!normalizedRange) {
			logError("Invalid date range.");
			return range;
		}
		var tmp = this._getRangeInfo(normalizedRange);
		if (tmp.start.time > tmp.end.time) normalizedRange.reverse();
		return normalizedRange;
	};
	/**
	* range info
	*
	* @private
	* @param  {Array} range range ['2017-01-01', '2017-07-08']
	*  If range[0] > range[1], they will not be reversed.
	* @return {Object}       obj
	*/
	Calendar$1.prototype._getRangeInfo = function(range) {
		var parsedRange = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];
		var reversed;
		if (parsedRange[0].time > parsedRange[1].time) {
			reversed = true;
			parsedRange.reverse();
		}
		var allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1;
		var date = new Date(parsedRange[0].time);
		var startDateNum = date.getDate();
		var endDateNum = parsedRange[1].date.getDate();
		date.setDate(startDateNum + allDay - 1);
		var dateNum = date.getDate();
		if (dateNum !== endDateNum) {
			var sign = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;
			while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign > 0) {
				allDay -= sign;
				date.setDate(dateNum - sign);
			}
		}
		var weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);
		var nthWeek = reversed ? -weeks + 1 : weeks - 1;
		reversed && parsedRange.reverse();
		return {
			range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],
			start: parsedRange[0],
			end: parsedRange[1],
			allDay,
			weeks,
			nthWeek,
			fweek: parsedRange[0].day,
			lweek: parsedRange[1].day
		};
	};
	/**
	* get date by nthWeeks and week day in range
	*
	* @private
	* @param  {number} nthWeek the week
	* @param  {number} day   the week day
	* @param  {Array} range [d1, d2]
	* @return {Object}
	*/
	Calendar$1.prototype._getDateByWeeksAndDay = function(nthWeek, day, range) {
		var rangeInfo = this._getRangeInfo(range);
		if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) return null;
		var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
		var date = new Date(rangeInfo.start.time);
		date.setDate(+rangeInfo.start.d + nthDay);
		return this.getDateInfo(date);
	};
	Calendar$1.create = function(ecModel, api) {
		var calendarList = [];
		ecModel.eachComponent("calendar", function(calendarModel) {
			var calendar = new Calendar$1(calendarModel, ecModel, api);
			calendarList.push(calendar);
			calendarModel.coordinateSystem = calendar;
		});
		ecModel.eachComponent(function(mainType, componentModel) {
			injectCoordSysByOption({
				targetModel: componentModel,
				coordSysType: "calendar",
				coordSysProvider: simpleCoordSysInjectionProvider
			});
		});
		return calendarList;
	};
	Calendar$1.dimensions = ["time", "value"];
	return Calendar$1;
}();
function getCoordSys$1(finder) {
	var calendarModel = finder.calendarModel;
	var seriesModel = finder.seriesModel;
	return calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
}
var Calendar_default = Calendar;

//#endregion
//#region node_modules/echarts/lib/component/calendar/install.js
function install$30(registers) {
	registers.registerComponentModel(CalendarModel_default);
	registers.registerComponentView(CalendarView_default);
	registers.registerCoordinateSystem("calendar", Calendar_default);
}

//#endregion
//#region node_modules/echarts/lib/coord/matrix/matrixCoordHelper.js
var MatrixCellLayoutInfoType = {
	level: 1,
	leaf: 2,
	nonLeaf: 3
};
/**
* @public Public to users in `chart.convertFromPixel`.
*/
var MatrixClampOption = {
	none: 0,
	all: 1,
	body: 2,
	corner: 3
};
/**
* For the x direction,
*  - find dimension cell from `xMatrixDim`,
*      - If `xDimCell` or `yDimCell` is not a leaf, return the non-leaf cell itself.
*  - otherwise find level from `yMatrixDim`.
*  - otherwise return `NullUndefined`.
*
* For the y direction, it's the opposite.
*/
function coordDataToAllCellLevelLayout(coordValue, dims, thisDimIdx) {
	var result = dims[XY[thisDimIdx]].getCell(coordValue);
	if (!result && isNumber(coordValue) && coordValue < 0) result = dims[XY[1 - thisDimIdx]].getUnitLayoutInfo(thisDimIdx, Math.round(coordValue));
	return result;
}
function resetXYLocatorRange(out$1) {
	var rg = out$1 || [];
	rg[0] = rg[0] || [];
	rg[1] = rg[1] || [];
	rg[0][0] = rg[0][1] = rg[1][0] = rg[1][1] = NaN;
	return rg;
}
/**
* If illegal or out of boundary, set NaN to `locOut`. See `isXYLocatorRangeInvalidOnDim`.
* x dimension and y dimension are calculated separately.
*/
function parseCoordRangeOption(locOut, reasonOut, data, dims, clamp$1) {
	parseCoordRangeOptionOnOneDim(locOut[0], reasonOut, clamp$1, data, dims, 0);
	parseCoordRangeOptionOnOneDim(locOut[1], reasonOut, clamp$1, data, dims, 1);
}
function parseCoordRangeOptionOnOneDim(locDimOut, reasonOut, clamp$1, data, dims, dimIdx) {
	locDimOut[0] = Infinity;
	locDimOut[1] = -Infinity;
	var dataOnDim = data[dimIdx];
	var coordValArr = isArray(dataOnDim) ? dataOnDim : [dataOnDim];
	var len$1 = coordValArr.length;
	var hasClamp = !!clamp$1;
	if (len$1 >= 1) {
		parseCoordRangeOptionOnOneDimOnePart(locDimOut, reasonOut, coordValArr, hasClamp, dims, dimIdx, 0);
		if (len$1 > 1) parseCoordRangeOptionOnOneDimOnePart(locDimOut, reasonOut, coordValArr, hasClamp, dims, dimIdx, len$1 - 1);
	} else {
		if (reasonOut) reasonOut.push("Should be like [[\"x1\", \"x2\"], [\"y1\", \"y2\"]], or [\"x1\", \"y1\"], rather than empty.");
		locDimOut[0] = locDimOut[1] = NaN;
	}
	if (hasClamp) {
		var locLowerBound = -dims[XY[1 - dimIdx]].getLocatorCount(dimIdx);
		var locUpperBound = dims[XY[dimIdx]].getLocatorCount(dimIdx) - 1;
		if (clamp$1 === MatrixClampOption.body) locLowerBound = mathMax$1(0, locLowerBound);
		else if (clamp$1 === MatrixClampOption.corner) locUpperBound = mathMin$1(-1, locUpperBound);
		if (locUpperBound < locLowerBound) locLowerBound = locUpperBound = NaN;
		if (eqNaN(locDimOut[0])) locDimOut[0] = locLowerBound;
		if (eqNaN(locDimOut[1])) locDimOut[1] = locUpperBound;
		locDimOut[0] = mathMax$1(mathMin$1(locDimOut[0], locUpperBound), locLowerBound);
		locDimOut[1] = mathMax$1(mathMin$1(locDimOut[1], locUpperBound), locLowerBound);
	}
}
function parseCoordRangeOptionOnOneDimOnePart(locDimOut, reasonOut, coordValArr, hasClamp, dims, dimIdx, partIdx) {
	var layout$3 = coordDataToAllCellLevelLayout(coordValArr[partIdx], dims, dimIdx);
	if (!layout$3) {
		if (!hasClamp && reasonOut) reasonOut.push("Can not find cell by coord[" + dimIdx + "][" + partIdx + "].");
		locDimOut[0] = locDimOut[1] = NaN;
		return;
	}
	var locatorA = layout$3.id[XY[dimIdx]];
	var locatorB = locatorA;
	var dimCell = cellLayoutInfoToDimCell(layout$3);
	if (dimCell) locatorB += dimCell.span[XY[dimIdx]] - 1;
	locDimOut[0] = mathMin$1(locDimOut[0], locatorA, locatorB);
	locDimOut[1] = mathMax$1(locDimOut[1], locatorA, locatorB);
}
/**
* @param locatorRange Must be the return of `parseCoordRangeOption`,
*  where if not NaN, it must be a valid locator.
*/
function isXYLocatorRangeInvalidOnDim(locatorRange, dimIdx) {
	return eqNaN(locatorRange[dimIdx][0]) || eqNaN(locatorRange[dimIdx][1]);
}
function resolveXYLocatorRangeByCellMerge(inOutLocatorRange, outMergedMarkList, mergeDefList, mergeDefListTravelLen) {
	outMergedMarkList = outMergedMarkList || _tmpOutMergedMarkList;
	for (var idx = 0; idx < mergeDefListTravelLen; idx++) outMergedMarkList[idx] = false;
	while (true) {
		var expanded = false;
		for (var idx = 0; idx < mergeDefListTravelLen; idx++) {
			var mergeDef = mergeDefList[idx];
			if (!outMergedMarkList[idx] && mergeDef.cellMergeOwner && expandXYLocatorRangeIfIntersect(inOutLocatorRange, mergeDef.locatorRange)) {
				outMergedMarkList[idx] = true;
				expanded = true;
			}
		}
		if (!expanded) break;
	}
}
var _tmpOutMergedMarkList = [];
function expandXYLocatorRangeIfIntersect(thisLocRange, otherLocRange) {
	if (!locatorRangeIntersectOneDim(thisLocRange[0], otherLocRange[0]) || !locatorRangeIntersectOneDim(thisLocRange[1], otherLocRange[1])) return false;
	thisLocRange[0][0] = mathMin$1(thisLocRange[0][0], otherLocRange[0][0]);
	thisLocRange[0][1] = mathMax$1(thisLocRange[0][1], otherLocRange[0][1]);
	thisLocRange[1][0] = mathMin$1(thisLocRange[1][0], otherLocRange[1][0]);
	thisLocRange[1][1] = mathMax$1(thisLocRange[1][1], otherLocRange[1][1]);
	return true;
}
function locatorRangeIntersectOneDim(locRange1OneDim, locRange2OneDim) {
	return locRange1OneDim[1] >= locRange2OneDim[0] && locRange1OneDim[0] <= locRange2OneDim[1];
}
function fillIdSpanFromLocatorRange(owner, locatorRange) {
	owner.id.set(locatorRange[0][0], locatorRange[1][0]);
	owner.span.set(locatorRange[0][1] - owner.id.x + 1, locatorRange[1][1] - owner.id.y + 1);
}
function cloneXYLocatorRange(target, source) {
	target[0][0] = source[0][0];
	target[0][1] = source[0][1];
	target[1][0] = source[1][0];
	target[1][1] = source[1][1];
}
/**
* If illegal, the corresponding x/y/width/height is set to `NaN`.
* `x/width` or `y/height` is supported to be calculated separately,
* i.e., one side are NaN, the other side are normal.
* @param oneDimOut only write to `x/width` or `y/height`, depending on `dimIdx`.
*/
function xyLocatorRangeToRectOneDim(oneDimOut, locRange, dims, dimIdx) {
	var layoutMin = coordDataToAllCellLevelLayout(locRange[dimIdx][0], dims, dimIdx);
	var layoutMax = coordDataToAllCellLevelLayout(locRange[dimIdx][1], dims, dimIdx);
	oneDimOut[XY[dimIdx]] = oneDimOut[WH[dimIdx]] = NaN;
	if (layoutMin && layoutMax) {
		oneDimOut[XY[dimIdx]] = layoutMin.xy;
		oneDimOut[WH[dimIdx]] = layoutMax.xy + layoutMax.wh - layoutMin.xy;
	}
}
/**
* @usage To get/set on dimension, use:
*  `xyVal[XY[dim]] = val;` // set on this dimension.
*  `xyVal[XY[1 - dim]] = val;` // set on the perpendicular dimension.
*/
function setDimXYValue(out$1, dimIdx, valueOnThisDim, valueOnOtherDim) {
	out$1[XY[dimIdx]] = valueOnThisDim;
	out$1[XY[1 - dimIdx]] = valueOnOtherDim;
	return out$1;
}
/**
* Return NullUndefined if not dimension cell.
*/
function cellLayoutInfoToDimCell(cellLayoutInfo) {
	return cellLayoutInfo && (cellLayoutInfo.type === MatrixCellLayoutInfoType.leaf || cellLayoutInfo.type === MatrixCellLayoutInfoType.nonLeaf) ? cellLayoutInfo : null;
}
function createNaNRectLike() {
	return {
		x: NaN,
		y: NaN,
		width: NaN,
		height: NaN
	};
}

//#endregion
//#region node_modules/echarts/lib/coord/matrix/MatrixDim.js
/**
* Lifetime: the same with `MatrixModel`, but different from `coord/Matrix`.
*/
var MatrixDim = function() {
	function MatrixDim$1(dim, dimModel) {
		this._cells = [];
		this._levels = [];
		this.dim = dim;
		this.dimIdx = dim === "x" ? 0 : 1;
		this._model = dimModel;
		this._uniqueValueGen = createUniqueValueGenerator(dim);
		var dimModelData = dimModel.get("data", true);
		if (dimModelData != null && !isArray(dimModelData)) {
			error("Illegal echarts option - matrix." + this.dim + ".data must be an array if specified.");
			dimModelData = [];
		}
		if (dimModelData) this._initByDimModelData(dimModelData);
		else this._initBySeriesData();
	}
	MatrixDim$1.prototype._initByDimModelData = function(dimModelData) {
		var self$1 = this;
		var _cells = self$1._cells;
		var _levels = self$1._levels;
		var sameLocatorCellsLists = [];
		var _cellCount = 0;
		self$1._leavesCount = traverseInitCells(dimModelData, 0, 0);
		postInitCells();
		return;
		function traverseInitCells(dimModelData$1, firstLeafLocator, level) {
			var totalSpan = 0;
			if (!dimModelData$1) return totalSpan;
			each(dimModelData$1, function(option, optionIdx) {
				var invalidOption = false;
				var cellOption;
				if (isString(option)) cellOption = { value: option };
				else if (isObject(option)) {
					cellOption = option;
					if (option.value != null && !isString(option.value)) {
						invalidOption = true;
						cellOption = { value: null };
					}
				} else {
					cellOption = { value: null };
					if (option != null) invalidOption = true;
				}
				if (invalidOption) error("Illegal echarts option - matrix." + self$1.dim + ".data[" + optionIdx + "] must be `string | {value: string}`.");
				var cell = {
					type: MatrixCellLayoutInfoType.nonLeaf,
					ordinal: NaN,
					level,
					firstLeafLocator,
					id: new Point_default(),
					span: setDimXYValue(new Point_default(), self$1.dimIdx, 1, 1),
					option: cellOption,
					xy: NaN,
					wh: NaN,
					dim: self$1,
					rect: createNaNRectLike()
				};
				_cellCount++;
				(sameLocatorCellsLists[firstLeafLocator] || (sameLocatorCellsLists[firstLeafLocator] = [])).push(cell);
				if (!_levels[level]) _levels[level] = {
					type: MatrixCellLayoutInfoType.level,
					xy: NaN,
					wh: NaN,
					option: null,
					id: new Point_default(),
					dim: self$1
				};
				var childrenSpan = traverseInitCells(cellOption.children, firstLeafLocator, level + 1);
				var subSpan = Math.max(1, childrenSpan);
				cell.span[XY[self$1.dimIdx]] = subSpan;
				totalSpan += subSpan;
				firstLeafLocator += subSpan;
			});
			return totalSpan;
		}
		function postInitCells() {
			var categories = [];
			while (_cells.length < _cellCount) for (var locator = 0; locator < sameLocatorCellsLists.length; locator++) {
				var cell = sameLocatorCellsLists[locator].pop();
				if (cell) {
					cell.ordinal = categories.length;
					var val = cell.option.value;
					categories.push(val);
					_cells.push(cell);
					self$1._uniqueValueGen.calcDupBase(val);
				}
			}
			self$1._uniqueValueGen.ensureValueUnique(categories, _cells);
			self$1._scale = new Ordinal_default({ ordinalMeta: self$1._ordinalMeta = new OrdinalMeta_default({
				categories,
				needCollect: false,
				deduplication: false
			}) });
			for (var idx = 0; idx < self$1._leavesCount; idx++) {
				var leaf = self$1._cells[idx];
				leaf.type = MatrixCellLayoutInfoType.leaf;
				leaf.span[XY[1 - self$1.dimIdx]] = self$1._levels.length - leaf.level;
			}
			self$1._initCellsId();
			self$1._initLevelIdOptions();
		}
	};
	MatrixDim$1.prototype._initBySeriesData = function() {
		var self$1 = this;
		self$1._leavesCount = 0;
		self$1._levels = [{
			type: MatrixCellLayoutInfoType.level,
			xy: NaN,
			wh: NaN,
			option: null,
			id: new Point_default(),
			dim: self$1
		}];
		self$1._initLevelIdOptions();
		self$1._scale = new Ordinal_default({ ordinalMeta: self$1._ordinalMeta = new OrdinalMeta_default({
			needCollect: true,
			deduplication: true,
			onCollect: function(value, ordinalNumber) {
				var cell = self$1._cells[ordinalNumber] = {
					type: MatrixCellLayoutInfoType.leaf,
					ordinal: ordinalNumber,
					level: 0,
					firstLeafLocator: ordinalNumber,
					id: new Point_default(),
					span: setDimXYValue(new Point_default(), self$1.dimIdx, 1, 1),
					option: { value: value + "" },
					xy: NaN,
					wh: NaN,
					dim: self$1,
					rect: createNaNRectLike()
				};
				self$1._leavesCount++;
				self$1._setCellId(cell);
			}
		}) });
	};
	MatrixDim$1.prototype._setCellId = function(cell) {
		var levelsLen = this._levels.length;
		var dimIdx = this.dimIdx;
		setDimXYValue(cell.id, dimIdx, cell.firstLeafLocator, cell.level - levelsLen);
	};
	MatrixDim$1.prototype._initCellsId = function() {
		var levelsLen = this._levels.length;
		var dimIdx = this.dimIdx;
		each(this._cells, function(cell) {
			setDimXYValue(cell.id, dimIdx, cell.firstLeafLocator, cell.level - levelsLen);
		});
	};
	MatrixDim$1.prototype._initLevelIdOptions = function() {
		var levelsLen = this._levels.length;
		var dimIdx = this.dimIdx;
		var levelOptionList = this._model.get("levels", true);
		levelOptionList = isArray(levelOptionList) ? levelOptionList : [];
		each(this._levels, function(levelCfg, level) {
			setDimXYValue(levelCfg.id, dimIdx, 0, level - levelsLen);
			levelCfg.option = levelOptionList[level];
		});
	};
	MatrixDim$1.prototype.shouldShow = function() {
		return !!this._model.getShallow("show", true);
	};
	/**
	* Iterate leaves (they are layout units) if dimIdx === this.dimIdx.
	* Iterate levels if dimIdx !== this.dimIdx.
	*/
	MatrixDim$1.prototype.resetLayoutIterator = function(it, dimIdx, startLocator, count$1) {
		it = it || new ListIterator();
		if (dimIdx === this.dimIdx) {
			var len$1 = this._leavesCount;
			var startIdx = startLocator != null ? Math.max(0, startLocator) : 0;
			count$1 = count$1 != null ? Math.min(count$1, len$1) : len$1;
			it.reset(this._cells, startIdx, startIdx + count$1);
		} else {
			var len$1 = this._levels.length;
			var startIdx = startLocator != null ? Math.max(0, startLocator + len$1) : 0;
			count$1 = count$1 != null ? Math.min(count$1, len$1) : len$1;
			it.reset(this._levels, startIdx, startIdx + count$1);
		}
		return it;
	};
	MatrixDim$1.prototype.resetCellIterator = function(it) {
		return (it || new ListIterator()).reset(this._cells, 0);
	};
	MatrixDim$1.prototype.resetLevelIterator = function(it) {
		return (it || new ListIterator()).reset(this._levels, 0);
	};
	MatrixDim$1.prototype.getLayout = function(outRect, dimIdx, locator) {
		var layout$3 = this.getUnitLayoutInfo(dimIdx, locator);
		outRect[XY[dimIdx]] = layout$3 ? layout$3.xy : NaN;
		outRect[WH[dimIdx]] = layout$3 ? layout$3.wh : NaN;
	};
	/**
	* Get leaf cell or get level info.
	* Should be able to return null/undefined if not found on x or y, thus input `dimIdx` is needed.
	*/
	MatrixDim$1.prototype.getUnitLayoutInfo = function(dimIdx, locator) {
		return dimIdx === this.dimIdx ? locator < this._leavesCount ? this._cells[locator] : void 0 : this._levels[locator + this._levels.length];
	};
	/**
	* Get dimension cell by data, including leaves and non-leaves.
	*/
	MatrixDim$1.prototype.getCell = function(value) {
		var ordinal = this._scale.parse(value);
		return eqNaN(ordinal) ? void 0 : this._cells[ordinal];
	};
	/**
	* Get leaf count or get level count.
	*/
	MatrixDim$1.prototype.getLocatorCount = function(dimIdx) {
		return dimIdx === this.dimIdx ? this._leavesCount : this._levels.length;
	};
	MatrixDim$1.prototype.getOrdinalMeta = function() {
		return this._ordinalMeta;
	};
	return MatrixDim$1;
}();
function createUniqueValueGenerator(dim) {
	var dimUpper = dim.toUpperCase();
	var defaultValReg = /* @__PURE__ */ new RegExp("^" + dimUpper + "([0-9]+)$");
	var dupBase = 0;
	function calcDupBase(val) {
		var matchResult;
		if (val != null && (matchResult = val.match(defaultValReg))) dupBase = mathMax$1(dupBase, +matchResult[1] + 1);
	}
	function makeUniqueValue() {
		return "" + dimUpper + dupBase++;
	}
	function ensureValueUnique(categories, cells) {
		var cateMap = createHashMap();
		for (var idx = 0; idx < categories.length; idx++) {
			var value = categories[idx];
			if (value == null || cateMap.get(value) != null) {
				categories[idx] = value = makeUniqueValue();
				cells[idx].option = defaults({ value }, cells[idx].option);
			}
			cateMap.set(value, true);
		}
	}
	return {
		calcDupBase,
		ensureValueUnique
	};
}

//#endregion
//#region node_modules/echarts/lib/coord/matrix/MatrixBodyCorner.js
/**
* Lifetime: the same with `MatrixModel`, but different from `coord/Matrix`.
*/
var MatrixBodyCorner = function() {
	function MatrixBodyCorner$1(kind, bodyOrCornerModel, dims) {
		this._model = bodyOrCornerModel;
		this._dims = dims;
		this._kind = kind;
		this._cellMergeOwnerList = [];
	}
	/**
	* Can not be called before series models initialization finished, since the ordinalMeta may
	* use collect the values from `series.data` in series initialization.
	*/
	MatrixBodyCorner$1.prototype._ensureCellMap = function() {
		var self$1 = this;
		var _cellMap = self$1._cellMap;
		if (!_cellMap) {
			_cellMap = self$1._cellMap = createHashMap();
			fillCellMap();
		}
		return _cellMap;
		function fillCellMap() {
			var parsedList = [];
			var cellOptionList = self$1._model.getShallow("data");
			if (cellOptionList && !isArray(cellOptionList)) {
				error("matrix." + cellOptionList + ".data must be an array if specified.");
				cellOptionList = null;
			}
			each(cellOptionList, function(option, idx$1) {
				if (!isObject(option) || !isArray(option.coord)) {
					error("Illegal matrix." + self$1._kind + ".data[" + idx$1 + "], must be a {coord: [...], ...}");
					return;
				}
				var locatorRange$1 = resetXYLocatorRange([]);
				var reasonArr = null;
				reasonArr = [];
				parseCoordRangeOption(locatorRange$1, reasonArr, option.coord, self$1._dims, option.coordClamp ? MatrixClampOption[self$1._kind] : MatrixClampOption.none);
				if (isXYLocatorRangeInvalidOnDim(locatorRange$1, 0) || isXYLocatorRangeInvalidOnDim(locatorRange$1, 1)) {
					error("Can not determine cells by option matrix." + self$1._kind + ".data[" + idx$1 + "]: " + ("" + reasonArr.join(" ")));
					return;
				}
				var cellMergeOwner = option && option.mergeCells;
				var parsed$1 = {
					id: new Point_default(),
					span: new Point_default(),
					locatorRange: locatorRange$1,
					option,
					cellMergeOwner
				};
				fillIdSpanFromLocatorRange(parsed$1, locatorRange$1);
				parsedList.push(parsed$1);
			});
			var mergedMarkList = [];
			for (var parsedIdx = 0; parsedIdx < parsedList.length; parsedIdx++) {
				var parsed = parsedList[parsedIdx];
				if (!parsed.cellMergeOwner) continue;
				var locatorRange = parsed.locatorRange;
				resolveXYLocatorRangeByCellMerge(locatorRange, mergedMarkList, parsedList, parsedIdx);
				for (var idx = 0; idx < parsedIdx; idx++) if (mergedMarkList[idx]) parsedList[idx].cellMergeOwner = false;
				if (locatorRange[0][0] !== parsed.id.x || locatorRange[1][0] !== parsed.id.y) {
					parsed.cellMergeOwner = false;
					var newOption = extend({}, parsed.option);
					newOption.coord = null;
					var newParsed = {
						id: new Point_default(),
						span: new Point_default(),
						locatorRange,
						option: newOption,
						cellMergeOwner: true
					};
					fillIdSpanFromLocatorRange(newParsed, locatorRange);
					parsedList.push(newParsed);
				}
			}
			each(parsedList, function(parsed$1) {
				var topLeftCell = ensureBodyOrCornerCell(parsed$1.id.x, parsed$1.id.y);
				if (parsed$1.cellMergeOwner) {
					topLeftCell.cellMergeOwner = true;
					topLeftCell.span = parsed$1.span;
					topLeftCell.locatorRange = parsed$1.locatorRange;
					topLeftCell.spanRect = createNaNRectLike();
					self$1._cellMergeOwnerList.push(topLeftCell);
				}
				if (!parsed$1.cellMergeOwner && !parsed$1.option) return;
				for (var yidx = 0; yidx < parsed$1.span.y; yidx++) for (var xidx = 0; xidx < parsed$1.span.x; xidx++) {
					var cell = ensureBodyOrCornerCell(parsed$1.id.x + xidx, parsed$1.id.y + yidx);
					cell.option = parsed$1.option;
					if (parsed$1.cellMergeOwner) cell.inSpanOf = topLeftCell;
				}
			});
		}
		function ensureBodyOrCornerCell(x, y) {
			var key$1 = makeCellMapKey(x, y);
			var cell = _cellMap.get(key$1);
			if (!cell) cell = _cellMap.set(key$1, {
				id: new Point_default(x, y),
				option: null,
				inSpanOf: null,
				span: null,
				spanRect: null,
				locatorRange: null,
				cellMergeOwner: false
			});
			return cell;
		}
	};
	/**
	* Body cells or corner cell are not commonly defined specifically, especially in a large
	* table, thus his is a sparse data structure - bodys or corner cells exist only if there
	* are options specified to it (in `matrix.body.data` or `matrix.corner.data`);
	* otherwise, return `NullUndefined`.
	*/
	MatrixBodyCorner$1.prototype.getCell = function(xy) {
		return this._ensureCellMap().get(makeCellMapKey(xy[0], xy[1]));
	};
	/**
	* Only cell existing (has specific definition or props) will be travelled.
	*/
	MatrixBodyCorner$1.prototype.travelExistingCells = function(cb) {
		this._ensureCellMap().each(cb);
	};
	/**
	* @param locatorRange Must be the return of `parseCoordRangeOption`.
	*/
	MatrixBodyCorner$1.prototype.expandRangeByCellMerge = function(locatorRange) {
		if (!isXYLocatorRangeInvalidOnDim(locatorRange, 0) && !isXYLocatorRangeInvalidOnDim(locatorRange, 1) && locatorRange[0][0] === locatorRange[0][1] && locatorRange[1][0] === locatorRange[1][1]) {
			_tmpERBCMLocator[0] = locatorRange[0][0];
			_tmpERBCMLocator[1] = locatorRange[1][0];
			var cell = this.getCell(_tmpERBCMLocator);
			var inSpanOf = cell && cell.inSpanOf;
			if (inSpanOf) {
				cloneXYLocatorRange(locatorRange, inSpanOf.locatorRange);
				return;
			}
		}
		var list = this._cellMergeOwnerList;
		resolveXYLocatorRangeByCellMerge(locatorRange, null, list, list.length);
	};
	return MatrixBodyCorner$1;
}();
var _tmpERBCMLocator = [];
function makeCellMapKey(x, y) {
	return x + "|" + y;
}

//#endregion
//#region node_modules/echarts/lib/coord/matrix/MatrixModel.js
var defaultLabelOption = {
	show: true,
	color: tokens_default.color.secondary,
	overflow: "break",
	lineOverflow: "truncate",
	padding: [
		2,
		3,
		2,
		3
	],
	distance: 0
};
function makeDefaultCellItemStyleOption(isCorner) {
	return {
		color: "none",
		borderWidth: 1,
		borderColor: isCorner ? "none" : tokens_default.color.borderTint
	};
}
var defaultDimOption = {
	show: true,
	label: defaultLabelOption,
	itemStyle: makeDefaultCellItemStyleOption(false),
	silent: void 0,
	dividerLineStyle: {
		width: 1,
		color: tokens_default.color.border
	}
};
var defaultMatrixOption = {
	z: -50,
	left: "10%",
	top: "10%",
	right: "10%",
	bottom: "10%",
	x: defaultDimOption,
	y: defaultDimOption,
	body: {
		label: defaultLabelOption,
		itemStyle: makeDefaultCellItemStyleOption(false),
		silent: void 0
	},
	corner: {
		label: defaultLabelOption,
		itemStyle: makeDefaultCellItemStyleOption(true),
		silent: void 0
	},
	backgroundStyle: {
		color: "none",
		borderColor: tokens_default.color.axisLine,
		borderWidth: 1
	}
};
var MatrixModel = function(_super) {
	__extends(MatrixModel$1, _super);
	function MatrixModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MatrixModel$1.type;
		return _this;
	}
	MatrixModel$1.prototype.optionUpdated = function() {
		var dimModels = this._dimModels = {
			x: new MatrixDimensionModel(this.get("x", true) || {}),
			y: new MatrixDimensionModel(this.get("y", true) || {})
		};
		dimModels.x.option.type = dimModels.y.option.type = "category";
		var dims = {
			x: dimModels.x.dim = new MatrixDim("x", dimModels.x),
			y: dimModels.y.dim = new MatrixDim("y", dimModels.y)
		};
		this._body = new MatrixBodyCorner("body", new Model_default(this.getShallow("body")), dims);
		this._corner = new MatrixBodyCorner("corner", new Model_default(this.getShallow("corner")), dims);
	};
	MatrixModel$1.prototype.getDimensionModel = function(dim) {
		return this._dimModels[dim];
	};
	MatrixModel$1.prototype.getBody = function() {
		return this._body;
	};
	MatrixModel$1.prototype.getCorner = function() {
		return this._corner;
	};
	MatrixModel$1.type = "matrix";
	MatrixModel$1.layoutMode = "box";
	MatrixModel$1.defaultOption = defaultMatrixOption;
	return MatrixModel$1;
}(Component_default);
var MatrixDimensionModel = function(_super) {
	__extends(MatrixDimensionModel$1, _super);
	function MatrixDimensionModel$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	MatrixDimensionModel$1.prototype.getOrdinalMeta = function() {
		return this.dim.getOrdinalMeta();
	};
	return MatrixDimensionModel$1;
}(Model_default);
var MatrixModel_default = MatrixModel;

//#endregion
//#region node_modules/echarts/lib/component/matrix/MatrixView.js
var round$1 = Math.round;
var Z2_BACKGROUND = 0;
var Z2_OUTER_BORDER = 99;
var Z2_BODY_CORNER_CELL_DEFAULT = {
	normal: 25,
	special: 100
};
var Z2_DIMENSION_CELL_DEFAULT = {
	normal: 50,
	special: 125
};
var MatrixView = function(_super) {
	__extends(MatrixView$1, _super);
	function MatrixView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MatrixView$1.type;
		return _this;
	}
	MatrixView$1.prototype.render = function(matrixModel, ecModel) {
		this.group.removeAll();
		var group = this.group;
		var rect = matrixModel.coordinateSystem.getRect();
		var xDimModel = matrixModel.getDimensionModel("x");
		var yDimModel = matrixModel.getDimensionModel("y");
		var xDim$1 = xDimModel.dim;
		var yDim$1 = yDimModel.dim;
		renderDimensionCells(group, matrixModel, ecModel);
		createBodyAndCorner(group, matrixModel, xDim$1, yDim$1, ecModel);
		var outerBorderZ2 = retrieve2(matrixModel.getShallow("borderZ2", true), Z2_OUTER_BORDER);
		var dividerLineZ2 = outerBorderZ2 - 1;
		var bgStyle = matrixModel.getModel("backgroundStyle").getItemStyle(["borderWidth"]);
		bgStyle.lineWidth = 0;
		var borderStyle = matrixModel.getModel("backgroundStyle").getItemStyle([
			"color",
			"decal",
			"shadowColor",
			"shadowBlur",
			"shadowOffsetX",
			"shadowOffsetY"
		]);
		borderStyle.fill = "none";
		var bgRect = createMatrixRect(rect.clone(), bgStyle, Z2_BACKGROUND);
		var borderRect = createMatrixRect(rect.clone(), borderStyle, outerBorderZ2);
		bgRect.silent = true;
		borderRect.silent = true;
		group.add(bgRect);
		group.add(borderRect);
		var xDimCell0 = xDim$1.getUnitLayoutInfo(0, 0);
		var yDimCell0 = yDim$1.getUnitLayoutInfo(1, 0);
		if (xDimCell0 && yDimCell0) {
			if (xDim$1.shouldShow()) group.add(createMatrixLine({
				x1: rect.x,
				y1: yDimCell0.xy,
				x2: rect.x + rect.width,
				y2: yDimCell0.xy
			}, xDimModel.getModel("dividerLineStyle").getLineStyle(), dividerLineZ2));
			if (yDim$1.shouldShow()) group.add(createMatrixLine({
				x1: xDimCell0.xy,
				y1: rect.y,
				x2: xDimCell0.xy,
				y2: rect.y + rect.height
			}, yDimModel.getModel("dividerLineStyle").getLineStyle(), dividerLineZ2));
		}
	};
	MatrixView$1.type = "matrix";
	return MatrixView$1;
}(Component_default$1);
function renderDimensionCells(group, matrixModel, ecModel) {
	renderOnDimension(0);
	renderOnDimension(1);
	function renderOnDimension(dimIdx) {
		var thisDimModel = matrixModel.getDimensionModel(XY[dimIdx]);
		var thisDim = thisDimModel.dim;
		if (!thisDim.shouldShow()) return;
		var thisDimBgStyleModel = thisDimModel.getModel("itemStyle");
		var thisDimLabelModel = thisDimModel.getModel("label");
		var tooltipOption = matrixModel.getShallow("tooltip", true);
		var xyLocator = [];
		for (var it_1 = thisDim.resetCellIterator(); it_1.next();) {
			var dimCell = it_1.item;
			var shape = {};
			BoundingRect_default.copy(shape, dimCell.rect);
			set$1(xyLocator, dimCell.id.x, dimCell.id.y);
			createMatrixCell(xyLocator, matrixModel, group, ecModel, dimCell.option, thisDimBgStyleModel, thisDimLabelModel, thisDimModel, shape, dimCell.option.value, Z2_DIMENSION_CELL_DEFAULT, tooltipOption);
		}
	}
}
function createBodyAndCorner(group, matrixModel, xDim$1, yDim$1, ecModel) {
	createBodyOrCornerCells("body", matrixModel.getBody(), xDim$1, yDim$1);
	if (xDim$1.shouldShow() && yDim$1.shouldShow()) createBodyOrCornerCells("corner", matrixModel.getCorner(), yDim$1, xDim$1);
	function createBodyOrCornerCells(bodyCornerOptionRoot, bodyOrCorner, dimForCoordX, dimForCoordY) {
		var parentCellModel = new Model_default(matrixModel.getShallow(bodyCornerOptionRoot, true));
		var parentItemStyleModel = parentCellModel.getModel("itemStyle");
		var parentLabelModel = parentCellModel.getModel("label");
		var itx = new ListIterator();
		var ity = new ListIterator();
		var xyLocator = [];
		var tooltipOption = matrixModel.getShallow("tooltip", true);
		for (dimForCoordY.resetLayoutIterator(ity, 1); ity.next();) for (dimForCoordX.resetLayoutIterator(itx, 0); itx.next();) {
			var xLayout = itx.item;
			var yLayout = ity.item;
			set$1(xyLocator, xLayout.id.x, yLayout.id.y);
			var bodyCornerCell = bodyOrCorner.getCell(xyLocator);
			if (bodyCornerCell && bodyCornerCell.inSpanOf && bodyCornerCell.inSpanOf !== bodyCornerCell) continue;
			var shape = {};
			if (bodyCornerCell && bodyCornerCell.span) BoundingRect_default.copy(shape, bodyCornerCell.spanRect);
			else {
				xLayout.dim.getLayout(shape, 0, xyLocator[0]);
				yLayout.dim.getLayout(shape, 1, xyLocator[1]);
			}
			var bodyCornerCellOption = bodyCornerCell ? bodyCornerCell.option : null;
			createMatrixCell(xyLocator, matrixModel, group, ecModel, bodyCornerCellOption, parentItemStyleModel, parentLabelModel, parentCellModel, shape, bodyCornerCellOption ? bodyCornerCellOption.value : null, Z2_BODY_CORNER_CELL_DEFAULT, tooltipOption);
		}
	}
}
function createMatrixCell(xyLocator, matrixModel, group, ecModel, cellOption, parentItemStyleModel, parentLabelModel, parentCellModel, shape, textValue, zrCellDefault, tooltipOption) {
	var _a$1;
	_tmpCellItemStyleModel.option = cellOption ? cellOption.itemStyle : null;
	_tmpCellItemStyleModel.parentModel = parentItemStyleModel;
	_tmpCellModel.option = cellOption;
	_tmpCellModel.parentModel = parentCellModel;
	var z2 = retrieve2(_tmpCellModel.getShallow("z2"), cellOption && cellOption.itemStyle ? zrCellDefault.special : zrCellDefault.normal);
	var tooltipOptionShow = tooltipOption && tooltipOption.show;
	var cellRect = createMatrixRect(shape, _tmpCellItemStyleModel.getItemStyle(), z2);
	group.add(cellRect);
	var cursorOption = _tmpCellModel.get("cursor");
	if (cursorOption != null) cellRect.attr("cursor", cursorOption);
	var cellText;
	if (textValue != null) {
		var text = textValue + "";
		_tmpCellLabelModel.option = cellOption ? cellOption.label : null;
		_tmpCellLabelModel.parentModel = parentLabelModel;
		_tmpCellLabelModel.ecModel = ecModel;
		setLabelStyle(cellRect, { normal: _tmpCellLabelModel }, {
			defaultText: text,
			autoOverflowArea: true,
			layoutRect: clone(cellRect.shape)
		});
		cellText = cellRect.getTextContent();
		if (cellText) {
			cellText.z2 = z2 + 1;
			var style = cellText.style;
			if (style && style.overflow && style.overflow !== "none" && style.lineOverflow) {
				var clipShape = {};
				BoundingRect_default.copy(clipShape, shape);
				expandOrShrinkRect(clipShape, (((_a$1 = cellRect.style) === null || _a$1 === void 0 ? void 0 : _a$1.lineWidth) || 0) / 2, true, true);
				cellRect.updateInnerText();
				cellText.getLocalTransform(_tmpInnerTextTrans);
				invert(_tmpInnerTextTrans, _tmpInnerTextTrans);
				BoundingRect_default.applyTransform(clipShape, clipShape, _tmpInnerTextTrans);
				cellText.setClipPath(new Rect_default({ shape: clipShape }));
			}
		}
		setTooltipConfig({
			el: cellRect,
			componentModel: matrixModel,
			itemName: text,
			itemTooltipOption: tooltipOption,
			formatterParamsExtra: { xyLocator: xyLocator.slice() }
		});
	}
	if (cellText) {
		var labelSilent = _tmpCellLabelModel.get("silent");
		if (labelSilent == null) labelSilent = !tooltipOptionShow;
		cellText.silent = labelSilent;
		cellText.ignoreHostSilent = true;
	}
	var rectSilent = _tmpCellModel.get("silent");
	if (rectSilent == null) rectSilent = !cellRect.style || cellRect.style.fill === "none" || !cellRect.style.fill;
	cellRect.silent = rectSilent;
	clearTmpModel(_tmpCellModel);
	clearTmpModel(_tmpCellItemStyleModel);
	clearTmpModel(_tmpCellLabelModel);
}
var _tmpCellModel = new Model_default();
var _tmpCellItemStyleModel = new Model_default();
var _tmpCellLabelModel = new Model_default();
var _tmpInnerTextTrans = [];
function createMatrixRect(shape, style, z2) {
	var lineWidth = style.lineWidth;
	if (lineWidth) {
		var x2Original = shape.x + shape.width;
		var y2Original = shape.y + shape.height;
		shape.x = subPixelOptimize(shape.x, lineWidth, true);
		shape.y = subPixelOptimize(shape.y, lineWidth, true);
		shape.width = subPixelOptimize(x2Original, lineWidth, true) - shape.x;
		shape.height = subPixelOptimize(y2Original, lineWidth, true) - shape.y;
	}
	return new Rect_default({
		shape,
		style,
		z2
	});
}
function createMatrixLine(shape, style, z2) {
	var lineWidth = style.lineWidth;
	if (lineWidth) {
		if (round$1(shape.x1 * 2) === round$1(shape.x2 * 2)) shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
		if (round$1(shape.y1 * 2) === round$1(shape.y2 * 2)) shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	}
	return new Line_default({
		shape,
		style,
		silent: true,
		z2
	});
}
var MatrixView_default = MatrixView;

//#endregion
//#region node_modules/echarts/lib/coord/matrix/Matrix.js
var Matrix = function() {
	function Matrix$1(matrixModel, ecModel, api) {
		this.dimensions = Matrix$1.dimensions;
		this.type = "matrix";
		this._model = matrixModel;
		var models = this._dimModels = {
			x: matrixModel.getDimensionModel("x"),
			y: matrixModel.getDimensionModel("y")
		};
		this._dims = {
			x: models.x.dim,
			y: models.y.dim
		};
		this._resize(matrixModel, api);
	}
	/**
	* @see fetchers in `model/referHelper.ts`,
	* which is used to parse data in ordinal way.
	* In most series only 'x' and 'y' is required,
	* but some series, such as heatmap, can specify value.
	*/
	Matrix$1.getDimensionsInfo = function() {
		return [
			{
				name: "x",
				type: "ordinal"
			},
			{
				name: "y",
				type: "ordinal"
			},
			{ name: "value" }
		];
	};
	Matrix$1.create = function(ecModel, api) {
		var matrixList = [];
		ecModel.eachComponent("matrix", function(matrixModel) {
			var matrix = new Matrix$1(matrixModel, ecModel, api);
			matrixList.push(matrix);
			matrixModel.coordinateSystem = matrix;
		});
		ecModel.eachComponent(function(mainType, componentModel) {
			injectCoordSysByOption({
				targetModel: componentModel,
				coordSysType: "matrix",
				coordSysProvider: simpleCoordSysInjectionProvider
			});
		});
		return matrixList;
	};
	Matrix$1.prototype.getRect = function() {
		return this._rect;
	};
	Matrix$1.prototype._resize = function(matrixModel, api) {
		var dims = this._dims;
		var dimModels = this._dimModels;
		var rect = this._rect = getLayoutRect(matrixModel.getBoxLayoutParams(), {
			width: api.getWidth(),
			height: api.getHeight()
		});
		layOutUnitsOnDimension(dimModels, dims, rect, 0);
		layOutUnitsOnDimension(dimModels, dims, rect, 1);
		layOutDimCellsRestInfoByUnit(0, dims);
		layOutDimCellsRestInfoByUnit(1, dims);
		layOutBodyCornerCellMerge(this._model.getBody(), dims);
		layOutBodyCornerCellMerge(this._model.getCorner(), dims);
	};
	/**
	* @implement
	* - The input is allowed to be `[NaN/null/undefined, xxx]`/`[xxx, NaN/null/undefined]`;
	*  the return is `[NaN, xxxresult]`/`[xxxresult, NaN]` or clamped boundary value if
	*  `clamp` passed. This is for the usage that only get coord on single x or y.
	* - Alwasy return an numeric array, but never be null/undefined.
	*  If it can not be located or invalid, return `[NaN, NaN]`.
	*/
	Matrix$1.prototype.dataToPoint = function(data, opt, out$1) {
		out$1 = out$1 || [];
		this.dataToLayout(data, opt, _dtpOutDataToLayout);
		out$1[0] = _dtpOutDataToLayout.rect.x + _dtpOutDataToLayout.rect.width / 2;
		out$1[1] = _dtpOutDataToLayout.rect.y + _dtpOutDataToLayout.rect.height / 2;
		return out$1;
	};
	/**
	* @implement
	* - The input is allowed to be `[NaN/null/undefined, xxx]`/`[xxx, NaN/null/undefined]`;
	*  the return is `{x: NaN, width: NaN, y: xxxresulty, height: xxxresulth}`/
	*  `{y: NaN, height: NaN, x: xxxresultx, width: xxxresultw}` or clamped boundary value
	*  if `clamp` passed. This is for the usage that only get coord on single x or y.
	* - The returned `out.rect` and `out.matrixXYLocatorRange` is always an object or an 2d-array,
	*  but never be null/undefined. If it cannot be located or invalid, `NaN` is in their
	*  corresponding number props.
	* - Do not provide `out.contentRect`, because it's allowed to input non-leaf dimension x/y or
	*  a range of x/y, which determines a rect covering multiple cells (even not merged), in which
	*  case the padding and borderWidth can not be determined to make a contentRect. Therefore only
	*  return `out.rect` in any case for consistency. The caller is responsible for adding space to
	*  avoid covering cell borders, if necessary.
	*/
	Matrix$1.prototype.dataToLayout = function(data, opt, out$1) {
		var dims = this._dims;
		out$1 = out$1 || {};
		var outRect = out$1.rect = out$1.rect || {};
		outRect.x = outRect.y = outRect.width = outRect.height = NaN;
		var outLocRange = out$1.matrixXYLocatorRange = resetXYLocatorRange(out$1.matrixXYLocatorRange);
		if (!isArray(data)) {
			error("Input data must be an array in `convertToLayout`, `convertToPixel`");
			return out$1;
		}
		parseCoordRangeOption(outLocRange, null, data, dims, retrieve2(opt && opt.clamp, MatrixClampOption.none));
		if (!opt || !opt.ignoreMergeCells) {
			if (!opt || opt.clamp !== MatrixClampOption.corner) this._model.getBody().expandRangeByCellMerge(outLocRange);
			if (!opt || opt.clamp !== MatrixClampOption.body) this._model.getCorner().expandRangeByCellMerge(outLocRange);
		}
		xyLocatorRangeToRectOneDim(outRect, outLocRange, dims, 0);
		xyLocatorRangeToRectOneDim(outRect, outLocRange, dims, 1);
		return out$1;
	};
	/**
	* The returned locator pair can be the input of `dataToPoint` or `dataToLayout`.
	*
	* If point[0] is out of the matrix rect,
	*  the out[0] is NaN;
	* else if it is on the right of top-left corner of body,
	*  the out[0] is the oridinal number (>= 0).
	* else
	*  out[0] is the locator for corner or header (<= 0).
	*
	* The same rule goes for point[1] and out[1].
	*
	* But point[0] and point[1] are calculated separately, i.e.,
	* the reuslt can be `[1, NaN]` or `[NaN, 1]` if only one dimension is out of boundary.
	*
	* @implement
	*/
	Matrix$1.prototype.pointToData = function(point, opt, out$1) {
		var dims = this._dims;
		pointToDataOneDimPrepareCtx(_tmpCtxPointToData, 0, dims, point, opt && opt.clamp);
		pointToDataOneDimPrepareCtx(_tmpCtxPointToData, 1, dims, point, opt && opt.clamp);
		out$1 = out$1 || [];
		out$1[0] = out$1[1] = NaN;
		if (_tmpCtxPointToData.y === CtxPointToDataAreaType.inCorner && _tmpCtxPointToData.x === CtxPointToDataAreaType.inBody) pointToDataOnlyHeaderFillOut(_tmpCtxPointToData, out$1, 0, dims);
		else if (_tmpCtxPointToData.x === CtxPointToDataAreaType.inCorner && _tmpCtxPointToData.y === CtxPointToDataAreaType.inBody) pointToDataOnlyHeaderFillOut(_tmpCtxPointToData, out$1, 1, dims);
		else {
			pointToDataBodyCornerFillOut(_tmpCtxPointToData, out$1, 0, dims);
			pointToDataBodyCornerFillOut(_tmpCtxPointToData, out$1, 1, dims);
		}
		return out$1;
	};
	Matrix$1.prototype.convertToPixel = function(ecModel, finder, value, opt) {
		var coordSys = getCoordSys(finder);
		return coordSys === this ? coordSys.dataToPoint(value, opt) : void 0;
	};
	Matrix$1.prototype.convertToLayout = function(ecModel, finder, value, opt) {
		var coordSys = getCoordSys(finder);
		return coordSys === this ? coordSys.dataToLayout(value, opt) : void 0;
	};
	Matrix$1.prototype.convertFromPixel = function(ecModel, finder, pixel, opt) {
		var coordSys = getCoordSys(finder);
		return coordSys === this ? coordSys.pointToData(pixel, opt) : void 0;
	};
	Matrix$1.prototype.containPoint = function(point) {
		return this._rect.contain(point[0], point[1]);
	};
	Matrix$1.dimensions = [
		"x",
		"y",
		"value"
	];
	return Matrix$1;
}();
var _dtpOutDataToLayout = { rect: createNaNRectLike() };
var _ptdLevelIt = new ListIterator();
var _ptdDimCellIt = new ListIterator();
function layOutUnitsOnDimension(dimModels, dims, matrixRect, dimIdx) {
	var otherDimIdx = 1 - dimIdx;
	var thisDim = dims[XY[dimIdx]];
	var otherDim = dims[XY[otherDimIdx]];
	var otherDimShow = otherDim.shouldShow();
	for (var it_1 = thisDim.resetCellIterator(); it_1.next();) it_1.item.wh = it_1.item.xy = NaN;
	for (var it_2 = otherDim.resetLayoutIterator(null, dimIdx); it_2.next();) it_2.item.wh = it_2.item.xy = NaN;
	var restSize = matrixRect[WH[dimIdx]];
	var restCellsCount = thisDim.getLocatorCount(dimIdx) + otherDim.getLocatorCount(dimIdx);
	var tmpLevelModel = new Model_default();
	for (var it_3 = otherDim.resetLevelIterator(); it_3.next();) {
		tmpLevelModel.option = it_3.item.option;
		tmpLevelModel.parentModel = dimModels[XY[otherDimIdx]];
		layOutSpecified(it_3.item, otherDimShow ? tmpLevelModel.get("levelSize") : 0);
	}
	var tmpCellModel = new Model_default();
	for (var it_4 = thisDim.resetCellIterator(); it_4.next();) if (it_4.item.type === MatrixCellLayoutInfoType.leaf) {
		tmpCellModel.option = it_4.item.option;
		tmpCellModel.parentModel = void 0;
		layOutSpecified(it_4.item, tmpCellModel.get("size"));
	}
	function layOutSpecified(item, sizeOption) {
		var size = parseSizeOption(sizeOption, dimIdx, matrixRect);
		if (!eqNaN(size)) {
			item.wh = confineSize(size, restSize);
			restSize = confineSize(restSize - item.wh);
			restCellsCount--;
		}
	}
	var computedCellWH = restCellsCount ? restSize / restCellsCount : 0;
	var notAlignToBigmost = !restCellsCount && restSize >= 1;
	var currXY = matrixRect[XY[dimIdx]];
	var maxLocator = thisDim.getLocatorCount(dimIdx) - 1;
	var it = new ListIterator();
	for (otherDim.resetLayoutIterator(it, dimIdx); it.next();) layOutUnspecified(it.item);
	for (thisDim.resetLayoutIterator(it, dimIdx); it.next();) layOutUnspecified(it.item);
	function layOutUnspecified(item) {
		if (eqNaN(item.wh)) item.wh = computedCellWH;
		item.xy = currXY;
		if (item.id[XY[dimIdx]] === maxLocator && !notAlignToBigmost) item.wh = matrixRect[XY[dimIdx]] + matrixRect[WH[dimIdx]] - item.xy;
		currXY += item.wh;
	}
}
function layOutDimCellsRestInfoByUnit(dimIdx, dims) {
	for (var it_5 = dims[XY[dimIdx]].resetCellIterator(); it_5.next();) {
		var dimCell = it_5.item;
		layOutRectOneDimBasedOnUnit(dimCell.rect, dimIdx, dimCell.id, dimCell.span, dims);
		layOutRectOneDimBasedOnUnit(dimCell.rect, 1 - dimIdx, dimCell.id, dimCell.span, dims);
		if (dimCell.type === MatrixCellLayoutInfoType.nonLeaf) {
			dimCell.xy = dimCell.rect[XY[dimIdx]];
			dimCell.wh = dimCell.rect[WH[dimIdx]];
		}
	}
}
function layOutBodyCornerCellMerge(bodyOrCorner, dims) {
	bodyOrCorner.travelExistingCells(function(cell) {
		var computedSpan = cell.span;
		if (computedSpan) {
			var layoutRect = cell.spanRect;
			var id = cell.id;
			layOutRectOneDimBasedOnUnit(layoutRect, 0, id, computedSpan, dims);
			layOutRectOneDimBasedOnUnit(layoutRect, 1, id, computedSpan, dims);
		}
	});
}
function layOutRectOneDimBasedOnUnit(outRect, dimIdx, id, span, dims) {
	outRect[WH[dimIdx]] = 0;
	var dim = id[XY[dimIdx]] < 0 ? dims[XY[1 - dimIdx]] : dims[XY[dimIdx]];
	var layoutUnit = dim.getUnitLayoutInfo(dimIdx, id[XY[dimIdx]]);
	outRect[XY[dimIdx]] = layoutUnit.xy;
	outRect[WH[dimIdx]] = layoutUnit.wh;
	if (span[XY[dimIdx]] > 1) {
		var layoutUnit2 = dim.getUnitLayoutInfo(dimIdx, id[XY[dimIdx]] + span[XY[dimIdx]] - 1);
		outRect[WH[dimIdx]] = layoutUnit2.xy + layoutUnit2.wh - layoutUnit.xy;
	}
}
/**
* Return NaN if not defined or invalid.
*/
function parseSizeOption(sizeOption, dimIdx, matrixRect) {
	return confineSize(parsePositionSizeOption(sizeOption, matrixRect[WH[dimIdx]]), matrixRect[WH[dimIdx]]);
}
function confineSize(sizeNum, sizeLimit) {
	return Math.max(Math.min(sizeNum, retrieve2(sizeLimit, Infinity)), 0);
}
function getCoordSys(finder) {
	var matrixModel = finder.matrixModel;
	var seriesModel = finder.seriesModel;
	return matrixModel ? matrixModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
}
var CtxPointToDataAreaType = {
	inBody: 1,
	inCorner: 2,
	outside: 3
};
var _tmpCtxPointToData = {
	x: null,
	y: null,
	point: []
};
function pointToDataOneDimPrepareCtx(ctx, dimIdx, dims, point, clamp$1) {
	var thisDim = dims[XY[dimIdx]];
	var otherDim = dims[XY[1 - dimIdx]];
	var bodyMaxUnit = thisDim.getUnitLayoutInfo(dimIdx, thisDim.getLocatorCount(dimIdx) - 1);
	var body0Unit = thisDim.getUnitLayoutInfo(dimIdx, 0);
	var cornerMinUnit = otherDim.getUnitLayoutInfo(dimIdx, -otherDim.getLocatorCount(dimIdx));
	var cornerMinus1Unit = otherDim.shouldShow() ? otherDim.getUnitLayoutInfo(dimIdx, -1) : null;
	var coord = ctx.point[dimIdx] = point[dimIdx];
	if (!body0Unit && !cornerMinus1Unit) {
		ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;
		return;
	}
	if (clamp$1 === MatrixClampOption.body) {
		if (body0Unit) {
			ctx[XY[dimIdx]] = CtxPointToDataAreaType.inBody;
			coord = mathMin$1(bodyMaxUnit.xy + bodyMaxUnit.wh, mathMax$1(body0Unit.xy, coord));
			ctx.point[dimIdx] = coord;
		} else ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;
		return;
	} else if (clamp$1 === MatrixClampOption.corner) {
		if (cornerMinus1Unit) {
			ctx[XY[dimIdx]] = CtxPointToDataAreaType.inCorner;
			coord = mathMin$1(cornerMinus1Unit.xy + cornerMinus1Unit.wh, mathMax$1(cornerMinUnit.xy, coord));
			ctx.point[dimIdx] = coord;
		} else ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;
		return;
	}
	var pxLoc0 = body0Unit ? body0Unit.xy : cornerMinus1Unit ? cornerMinus1Unit.xy + cornerMinus1Unit.wh : NaN;
	var pxMin = cornerMinUnit ? cornerMinUnit.xy : pxLoc0;
	var pxMax = bodyMaxUnit ? bodyMaxUnit.xy + bodyMaxUnit.wh : pxLoc0;
	if (coord < pxMin) {
		if (!clamp$1) {
			ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;
			return;
		}
		coord = pxMin;
	} else if (coord > pxMax) {
		if (!clamp$1) {
			ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;
			return;
		}
		coord = pxMax;
	}
	ctx.point[dimIdx] = coord;
	ctx[XY[dimIdx]] = pxLoc0 <= coord && coord <= pxMax ? CtxPointToDataAreaType.inBody : pxMin <= coord && coord <= pxLoc0 ? CtxPointToDataAreaType.inCorner : CtxPointToDataAreaType.outside;
}
function pointToDataOnlyHeaderFillOut(ctx, partialOut, dimIdx, dims) {
	var otherDimIdx = 1 - dimIdx;
	if (ctx[XY[dimIdx]] === CtxPointToDataAreaType.outside) return;
	for (dims[XY[dimIdx]].resetCellIterator(_ptdDimCellIt); _ptdDimCellIt.next();) {
		var cell = _ptdDimCellIt.item;
		if (isCoordInRect(ctx.point[dimIdx], cell.rect, dimIdx) && isCoordInRect(ctx.point[otherDimIdx], cell.rect, otherDimIdx)) {
			partialOut[dimIdx] = cell.ordinal;
			partialOut[otherDimIdx] = cell.id[XY[otherDimIdx]];
			return;
		}
	}
}
function pointToDataBodyCornerFillOut(ctx, partialOut, dimIdx, dims) {
	if (ctx[XY[dimIdx]] === CtxPointToDataAreaType.outside) return;
	for ((ctx[XY[dimIdx]] === CtxPointToDataAreaType.inCorner ? dims[XY[1 - dimIdx]] : dims[XY[dimIdx]]).resetLayoutIterator(_ptdLevelIt, dimIdx); _ptdLevelIt.next();) if (isCoordInLayoutInfo(ctx.point[dimIdx], _ptdLevelIt.item)) {
		partialOut[dimIdx] = _ptdLevelIt.item.id[XY[dimIdx]];
		return;
	}
}
function isCoordInLayoutInfo(coord, cell) {
	return cell.xy <= coord && coord <= cell.xy + cell.wh;
}
function isCoordInRect(coord, rect, dimIdx) {
	return rect[XY[dimIdx]] <= coord && coord <= rect[XY[dimIdx]] + rect[WH[dimIdx]];
}
var Matrix_default = Matrix;

//#endregion
//#region node_modules/echarts/lib/component/matrix/install.js
function install$31(registers) {
	registers.registerComponentModel(MatrixModel_default);
	registers.registerComponentView(MatrixView_default);
	registers.registerCoordinateSystem("matrix", Matrix_default);
}

//#endregion
//#region node_modules/echarts/lib/component/graphic/GraphicModel.js
function setKeyInfoToNewElOption(resultItem, newElOption) {
	var existElOption = resultItem.existing;
	newElOption.id = resultItem.keyInfo.id;
	!newElOption.type && existElOption && (newElOption.type = existElOption.type);
	if (newElOption.parentId == null) {
		var newElParentOption = newElOption.parentOption;
		if (newElParentOption) newElOption.parentId = newElParentOption.id;
		else if (existElOption) newElOption.parentId = existElOption.parentId;
	}
	newElOption.parentOption = null;
}
function isSetLoc(obj, props) {
	var isSet;
	each(props, function(prop) {
		obj[prop] != null && obj[prop] !== "auto" && (isSet = true);
	});
	return isSet;
}
function mergeNewElOptionToExist(existList, index, newElOption) {
	var newElOptCopy = extend({}, newElOption);
	var existElOption = existList[index];
	var $action = newElOption.$action || "merge";
	if ($action === "merge") if (existElOption) {
		var newType = newElOption.type;
		assert(!newType || existElOption.type === newType, "Please set $action: \"replace\" to change `type`");
		merge(existElOption, newElOptCopy, true);
		mergeLayoutParam(existElOption, newElOptCopy, { ignoreSize: true });
		copyLayoutParams(newElOption, existElOption);
		copyTransitionInfo(newElOption, existElOption);
		copyTransitionInfo(newElOption, existElOption, "shape");
		copyTransitionInfo(newElOption, existElOption, "style");
		copyTransitionInfo(newElOption, existElOption, "extra");
		newElOption.clipPath = existElOption.clipPath;
	} else existList[index] = newElOptCopy;
	else if ($action === "replace") existList[index] = newElOptCopy;
	else if ($action === "remove") existElOption && (existList[index] = null);
}
var TRANSITION_PROPS_TO_COPY = [
	"transition",
	"enterFrom",
	"leaveTo"
];
var ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat([
	"enterAnimation",
	"updateAnimation",
	"leaveAnimation"
]);
function copyTransitionInfo(target, source, targetProp) {
	if (targetProp) {
		if (!target[targetProp] && source[targetProp]) target[targetProp] = {};
		target = target[targetProp];
		source = source[targetProp];
	}
	if (!target || !source) return;
	var props = targetProp ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY;
	for (var i$1 = 0; i$1 < props.length; i$1++) {
		var prop = props[i$1];
		if (target[prop] == null && source[prop] != null) target[prop] = source[prop];
	}
}
function setLayoutInfoToExist(existItem, newElOption) {
	if (!existItem) return;
	existItem.hv = newElOption.hv = [isSetLoc(newElOption, ["left", "right"]), isSetLoc(newElOption, ["top", "bottom"])];
	if (existItem.type === "group") {
		var existingGroupOpt = existItem;
		var newGroupOpt = newElOption;
		existingGroupOpt.width ??= newGroupOpt.width = 0;
		existingGroupOpt.height ??= newGroupOpt.height = 0;
	}
}
var GraphicComponentModel = function(_super) {
	__extends(GraphicComponentModel$1, _super);
	function GraphicComponentModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = GraphicComponentModel$1.type;
		_this.preventAutoZ = true;
		return _this;
	}
	GraphicComponentModel$1.prototype.mergeOption = function(option, ecModel) {
		var elements = this.option.elements;
		this.option.elements = null;
		_super.prototype.mergeOption.call(this, option, ecModel);
		this.option.elements = elements;
	};
	GraphicComponentModel$1.prototype.optionUpdated = function(newOption, isInit) {
		var thisOption = this.option;
		var newList = (isInit ? thisOption : newOption).elements;
		var existList = thisOption.elements = isInit ? [] : thisOption.elements;
		var flattenedList = [];
		this._flatten(newList, flattenedList, null);
		var mappingResult = mappingToExists(existList, flattenedList, "normalMerge");
		var elOptionsToUpdate = this._elOptionsToUpdate = [];
		each(mappingResult, function(resultItem, index) {
			var newElOption = resultItem.newOption;
			assert(isObject(newElOption) || resultItem.existing, "Empty graphic option definition");
			if (!newElOption) return;
			elOptionsToUpdate.push(newElOption);
			setKeyInfoToNewElOption(resultItem, newElOption);
			mergeNewElOptionToExist(existList, index, newElOption);
			setLayoutInfoToExist(existList[index], newElOption);
		}, this);
		thisOption.elements = filter(existList, function(item) {
			item && delete item.$action;
			return item != null;
		});
	};
	/**
	* Convert
	* [{
	*  type: 'group',
	*  id: 'xx',
	*  children: [{type: 'circle'}, {type: 'polygon'}]
	* }]
	* to
	* [
	*  {type: 'group', id: 'xx'},
	*  {type: 'circle', parentId: 'xx'},
	*  {type: 'polygon', parentId: 'xx'}
	* ]
	*/
	GraphicComponentModel$1.prototype._flatten = function(optionList, result, parentOption) {
		each(optionList, function(option) {
			if (!option) return;
			if (parentOption) option.parentOption = parentOption;
			result.push(option);
			var children = option.children;
			if (children && children.length) this._flatten(children, result, option);
			delete option.children;
		}, this);
	};
	GraphicComponentModel$1.prototype.useElOptionsToUpdate = function() {
		var els = this._elOptionsToUpdate;
		this._elOptionsToUpdate = null;
		return els;
	};
	GraphicComponentModel$1.type = "graphic";
	GraphicComponentModel$1.defaultOption = { elements: [] };
	return GraphicComponentModel$1;
}(Component_default);

//#endregion
//#region node_modules/echarts/lib/component/graphic/GraphicView.js
var nonShapeGraphicElements = {
	path: null,
	compoundPath: null,
	group: Group_default,
	image: Image_default,
	text: Text_default
};
var inner$7 = makeInner();
var GraphicComponentView = function(_super) {
	__extends(GraphicComponentView$1, _super);
	function GraphicComponentView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = GraphicComponentView$1.type;
		return _this;
	}
	GraphicComponentView$1.prototype.init = function() {
		this._elMap = createHashMap();
	};
	GraphicComponentView$1.prototype.render = function(graphicModel, ecModel, api) {
		if (graphicModel !== this._lastGraphicModel) this._clear();
		this._lastGraphicModel = graphicModel;
		this._updateElements(graphicModel);
		this._relocate(graphicModel, api);
	};
	/**
	* Update graphic elements.
	*/
	GraphicComponentView$1.prototype._updateElements = function(graphicModel) {
		var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();
		if (!elOptionsToUpdate) return;
		var elMap = this._elMap;
		var rootGroup = this.group;
		var globalZ = graphicModel.get("z");
		var globalZLevel = graphicModel.get("zlevel");
		each(elOptionsToUpdate, function(elOption) {
			var id = convertOptionIdName(elOption.id, null);
			var elExisting = id != null ? elMap.get(id) : null;
			var parentId = convertOptionIdName(elOption.parentId, null);
			var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
			var elType = elOption.type;
			var elOptionStyle = elOption.style;
			if (elType === "text" && elOptionStyle) {
				if (elOption.hv && elOption.hv[1]) elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null;
			}
			var textContentOption = elOption.textContent;
			var textConfig = elOption.textConfig;
			if (elOptionStyle && isEC4CompatibleStyle(elOptionStyle, elType, !!textConfig, !!textContentOption)) {
				var convertResult = convertFromEC4CompatibleStyle(elOptionStyle, elType, true);
				if (!textConfig && convertResult.textConfig) textConfig = elOption.textConfig = convertResult.textConfig;
				if (!textContentOption && convertResult.textContent) textContentOption = convertResult.textContent;
			}
			var elOptionCleaned = getCleanedElOption(elOption);
			elExisting && assert(targetElParent === elExisting.parent, "Changing parent is not supported.");
			var $action = elOption.$action || "merge";
			var isMerge = $action === "merge";
			var isReplace = $action === "replace";
			if (isMerge) {
				var isInit = !elExisting;
				var el_1 = elExisting;
				if (isInit) el_1 = createEl(id, targetElParent, elOption.type, elMap);
				else {
					el_1 && (inner$7(el_1).isNew = false);
					stopPreviousKeyframeAnimationAndRestore(el_1);
				}
				if (el_1) {
					applyUpdateTransition(el_1, elOptionCleaned, graphicModel, { isInit });
					updateCommonAttrs(el_1, elOption, globalZ, globalZLevel);
				}
			} else if (isReplace) {
				removeEl$1(elExisting, elOption, elMap, graphicModel);
				var el_2 = createEl(id, targetElParent, elOption.type, elMap);
				if (el_2) {
					applyUpdateTransition(el_2, elOptionCleaned, graphicModel, { isInit: true });
					updateCommonAttrs(el_2, elOption, globalZ, globalZLevel);
				}
			} else if ($action === "remove") {
				updateLeaveTo(elExisting, elOption);
				removeEl$1(elExisting, elOption, elMap, graphicModel);
			}
			var el = elMap.get(id);
			if (el && textContentOption) {
				if (isMerge) {
					var textContentExisting = el.getTextContent();
					textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new Text_default(textContentOption));
				} else if (isReplace) el.setTextContent(new Text_default(textContentOption));
			}
			if (el) {
				var clipPathOption = elOption.clipPath;
				if (clipPathOption) {
					var clipPathType = clipPathOption.type;
					var clipPath = void 0;
					var isInit = false;
					if (isMerge) {
						var oldClipPath = el.getClipPath();
						isInit = !oldClipPath || inner$7(oldClipPath).type !== clipPathType;
						clipPath = isInit ? newEl(clipPathType) : oldClipPath;
					} else if (isReplace) {
						isInit = true;
						clipPath = newEl(clipPathType);
					}
					el.setClipPath(clipPath);
					applyUpdateTransition(clipPath, clipPathOption, graphicModel, { isInit });
					applyKeyframeAnimation(clipPath, clipPathOption.keyframeAnimation, graphicModel);
				}
				var elInner = inner$7(el);
				el.setTextConfig(textConfig);
				elInner.option = elOption;
				setEventData(el, graphicModel, elOption);
				setTooltipConfig({
					el,
					componentModel: graphicModel,
					itemName: el.name,
					itemTooltipOption: elOption.tooltip
				});
				applyKeyframeAnimation(el, elOption.keyframeAnimation, graphicModel);
			}
		});
	};
	/**
	* Locate graphic elements.
	*/
	GraphicComponentView$1.prototype._relocate = function(graphicModel, api) {
		var elOptions = graphicModel.option.elements;
		var rootGroup = this.group;
		var elMap = this._elMap;
		var apiWidth = api.getWidth();
		var apiHeight = api.getHeight();
		var xy = ["x", "y"];
		for (var i$1 = 0; i$1 < elOptions.length; i$1++) {
			var elOption = elOptions[i$1];
			var id = convertOptionIdName(elOption.id, null);
			var el = id != null ? elMap.get(id) : null;
			if (!el || !el.isGroup) continue;
			var parentEl = el.parent;
			var isParentRoot = parentEl === rootGroup;
			var elInner = inner$7(el);
			var parentElInner = inner$7(parentEl);
			elInner.width = parsePercent$1(elInner.option.width, isParentRoot ? apiWidth : parentElInner.width) || 0;
			elInner.height = parsePercent$1(elInner.option.height, isParentRoot ? apiHeight : parentElInner.height) || 0;
		}
		for (var i$1 = elOptions.length - 1; i$1 >= 0; i$1--) {
			var elOption = elOptions[i$1];
			var id = convertOptionIdName(elOption.id, null);
			var el = id != null ? elMap.get(id) : null;
			if (!el) continue;
			var parentEl = el.parent;
			var parentElInner = inner$7(parentEl);
			var containerInfo = parentEl === rootGroup ? {
				width: apiWidth,
				height: apiHeight
			} : {
				width: parentElInner.width,
				height: parentElInner.height
			};
			var layoutPos = {};
			var layouted = positionElement(el, elOption, containerInfo, null, {
				hv: elOption.hv,
				boundingMode: elOption.bounding
			}, layoutPos);
			if (!inner$7(el).isNew && layouted) {
				var transition = elOption.transition;
				var animatePos = {};
				for (var k$1 = 0; k$1 < xy.length; k$1++) {
					var key$1 = xy[k$1];
					var val = layoutPos[key$1];
					if (transition && (isTransitionAll(transition) || indexOf(transition, key$1) >= 0)) animatePos[key$1] = val;
					else el[key$1] = val;
				}
				updateProps(el, animatePos, graphicModel, 0);
			} else el.attr(layoutPos);
		}
	};
	/**
	* Clear all elements.
	*/
	GraphicComponentView$1.prototype._clear = function() {
		var _this = this;
		var elMap = this._elMap;
		elMap.each(function(el) {
			removeEl$1(el, inner$7(el).option, elMap, _this._lastGraphicModel);
		});
		this._elMap = createHashMap();
	};
	GraphicComponentView$1.prototype.dispose = function() {
		this._clear();
	};
	GraphicComponentView$1.type = "graphic";
	return GraphicComponentView$1;
}(Component_default$1);
function newEl(graphicType) {
	assert(graphicType, "graphic type MUST be set");
	var Clz = hasOwn(nonShapeGraphicElements, graphicType) ? nonShapeGraphicElements[graphicType] : getShapeClass(graphicType);
	assert(Clz, "graphic type " + graphicType + " can not be found");
	var el = new Clz({});
	inner$7(el).type = graphicType;
	return el;
}
function createEl(id, targetElParent, graphicType, elMap) {
	var el = newEl(graphicType);
	targetElParent.add(el);
	elMap.set(id, el);
	inner$7(el).id = id;
	inner$7(el).isNew = true;
	return el;
}
function removeEl$1(elExisting, elOption, elMap, graphicModel) {
	if (elExisting && elExisting.parent) {
		elExisting.type === "group" && elExisting.traverse(function(el) {
			removeEl$1(el, elOption, elMap, graphicModel);
		});
		applyLeaveTransition(elExisting, elOption, graphicModel);
		elMap.removeKey(inner$7(elExisting).id);
	}
}
function updateCommonAttrs(el, elOption, defaultZ, defaultZlevel) {
	if (!el.isGroup) each([
		["cursor", Displayable_default.prototype.cursor],
		["zlevel", defaultZlevel || 0],
		["z", defaultZ || 0],
		["z2", 0]
	], function(item) {
		var prop = item[0];
		if (hasOwn(elOption, prop)) el[prop] = retrieve2(elOption[prop], item[1]);
		else if (el[prop] == null) el[prop] = item[1];
	});
	each(keys(elOption), function(key$1) {
		if (key$1.indexOf("on") === 0) {
			var val = elOption[key$1];
			el[key$1] = isFunction(val) ? val : null;
		}
	});
	if (hasOwn(elOption, "draggable")) el.draggable = elOption.draggable;
	elOption.name != null && (el.name = elOption.name);
	elOption.id != null && (el.id = elOption.id);
}
function getCleanedElOption(elOption) {
	elOption = extend({}, elOption);
	each([
		"id",
		"parentId",
		"$action",
		"hv",
		"bounding",
		"textContent",
		"clipPath"
	].concat(LOCATION_PARAMS), function(name) {
		delete elOption[name];
	});
	return elOption;
}
function setEventData(el, graphicModel, elOption) {
	var eventData = getECData(el).eventData;
	if (!el.silent && !el.ignore && !eventData) eventData = getECData(el).eventData = {
		componentType: "graphic",
		componentIndex: graphicModel.componentIndex,
		name: el.name
	};
	if (eventData) eventData.info = elOption.info;
}

//#endregion
//#region node_modules/echarts/lib/component/graphic/install.js
function install$32(registers) {
	registers.registerComponentModel(GraphicComponentModel);
	registers.registerComponentView(GraphicComponentView);
	registers.registerPreprocessor(function(option) {
		var graphicOption = option.graphic;
		if (isArray(graphicOption)) if (!graphicOption[0] || !graphicOption[0].elements) option.graphic = [{ elements: graphicOption }];
		else option.graphic = [option.graphic[0]];
		else if (graphicOption && !graphicOption.elements) option.graphic = [{ elements: [graphicOption] }];
	});
}

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/helper.js
var DATA_ZOOM_AXIS_DIMENSIONS = [
	"x",
	"y",
	"radius",
	"angle",
	"single"
];
var SERIES_COORDS = [
	"cartesian2d",
	"polar",
	"singleAxis"
];
function isCoordSupported(seriesModel) {
	return indexOf(SERIES_COORDS, seriesModel.get("coordinateSystem")) >= 0;
}
function getAxisMainType(axisDim) {
	assert(axisDim);
	return axisDim + "Axis";
}
/**
* If two dataZoomModels has the same axis controlled, we say that they are 'linked'.
* This function finds all linked dataZoomModels start from the given payload.
*/
function findEffectedDataZooms(ecModel, payload) {
	var axisRecords = createHashMap();
	var effectedModels = [];
	var effectedModelMap = createHashMap();
	ecModel.eachComponent({
		mainType: "dataZoom",
		query: payload
	}, function(dataZoomModel) {
		if (!effectedModelMap.get(dataZoomModel.uid)) addToEffected(dataZoomModel);
	});
	var foundNewLink;
	do {
		foundNewLink = false;
		ecModel.eachComponent("dataZoom", processSingle);
	} while (foundNewLink);
	function processSingle(dataZoomModel) {
		if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
			addToEffected(dataZoomModel);
			foundNewLink = true;
		}
	}
	function addToEffected(dataZoom) {
		effectedModelMap.set(dataZoom.uid, true);
		effectedModels.push(dataZoom);
		markAxisControlled(dataZoom);
	}
	function isLinked(dataZoomModel) {
		var isLink = false;
		dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
			var axisIdxArr = axisRecords.get(axisDim);
			if (axisIdxArr && axisIdxArr[axisIndex]) isLink = true;
		});
		return isLink;
	}
	function markAxisControlled(dataZoomModel) {
		dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
			(axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
		});
	}
	return effectedModels;
}
/**
* Find the first target coordinate system.
* Available after model built.
*
* @return Like {
*                  grid: [
*                      {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
*                      {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
*                      ...
*                  ],  // cartesians must not be null/undefined.
*                  polar: [
*                      {model: coord0, axisModels: [axis4], coordIndex: 0},
*                      ...
*                  ],  // polars must not be null/undefined.
*                  singleAxis: [
*                      {model: coord0, axisModels: [], coordIndex: 0}
*                  ]
*              }
*/
function collectReferCoordSysModelInfo(dataZoomModel) {
	var ecModel = dataZoomModel.ecModel;
	var coordSysInfoWrap = {
		infoList: [],
		infoMap: createHashMap()
	};
	dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
		var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
		if (!axisModel) return;
		var coordSysModel = axisModel.getCoordSysModel();
		if (!coordSysModel) return;
		var coordSysUid = coordSysModel.uid;
		var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);
		if (!coordSysInfo) {
			coordSysInfo = {
				model: coordSysModel,
				axisModels: []
			};
			coordSysInfoWrap.infoList.push(coordSysInfo);
			coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
		}
		coordSysInfo.axisModels.push(axisModel);
	});
	return coordSysInfoWrap;
}

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/DataZoomModel.js
var DataZoomAxisInfo = function() {
	function DataZoomAxisInfo$1() {
		this.indexList = [];
		this.indexMap = [];
	}
	DataZoomAxisInfo$1.prototype.add = function(axisCmptIdx) {
		if (!this.indexMap[axisCmptIdx]) {
			this.indexList.push(axisCmptIdx);
			this.indexMap[axisCmptIdx] = true;
		}
	};
	return DataZoomAxisInfo$1;
}();
var DataZoomModel = function(_super) {
	__extends(DataZoomModel$1, _super);
	function DataZoomModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = DataZoomModel$1.type;
		_this._autoThrottle = true;
		_this._noTarget = true;
		/**
		* It is `[rangeModeForMin, rangeModeForMax]`.
		* The optional values for `rangeMode`:
		* + `'value'` mode: the axis extent will always be determined by
		*     `dataZoom.startValue` and `dataZoom.endValue`, despite
		*     how data like and how `axis.min` and `axis.max` are.
		* + `'percent'` mode: `100` represents 100% of the `[dMin, dMax]`,
		*     where `dMin` is `axis.min` if `axis.min` specified, otherwise `data.extent[0]`,
		*     and `dMax` is `axis.max` if `axis.max` specified, otherwise `data.extent[1]`.
		*     Axis extent will be determined by the result of the percent of `[dMin, dMax]`.
		*
		* For example, when users are using dynamic data (update data periodically via `setOption`),
		* if in `'value`' mode, the window will be kept in a fixed value range despite how
		* data are appended, while if in `'percent'` mode, whe window range will be changed alone with
		* the appended data (suppose `axis.min` and `axis.max` are not specified).
		*/
		_this._rangePropMode = ["percent", "percent"];
		return _this;
	}
	DataZoomModel$1.prototype.init = function(option, parentModel, ecModel) {
		var inputRawOption = retrieveRawOption(option);
		/**
		* Suppose a "main process" start at the point that model prepared (that is,
		* model initialized or merged or method called in `action`).
		* We should keep the `main process` idempotent, that is, given a set of values
		* on `option`, we get the same result.
		*
		* But sometimes, values on `option` will be updated for providing users
		* a "final calculated value" (`dataZoomProcessor` will do that). Those value
		* should not be the base/input of the `main process`.
		*
		* So in that case we should save and keep the input of the `main process`
		* separately, called `settledOption`.
		*
		* For example, consider the case:
		* (Step_1) brush zoom the grid by `toolbox.dataZoom`,
		*     where the original input `option.startValue`, `option.endValue` are earsed by
		*     calculated value.
		* (Step)2) click the legend to hide and show a series,
		*     where the new range is calculated by the earsed `startValue` and `endValue`,
		*     which brings incorrect result.
		*/
		this.settledOption = inputRawOption;
		this.mergeDefaultAndTheme(option, ecModel);
		this._doInit(inputRawOption);
	};
	DataZoomModel$1.prototype.mergeOption = function(newOption) {
		var inputRawOption = retrieveRawOption(newOption);
		merge(this.option, newOption, true);
		merge(this.settledOption, inputRawOption, true);
		this._doInit(inputRawOption);
	};
	DataZoomModel$1.prototype._doInit = function(inputRawOption) {
		var thisOption = this.option;
		this._setDefaultThrottle(inputRawOption);
		this._updateRangeUse(inputRawOption);
		var settledOption = this.settledOption;
		each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
			if (this._rangePropMode[index] === "value") thisOption[names[0]] = settledOption[names[0]] = null;
		}, this);
		this._resetTarget();
	};
	DataZoomModel$1.prototype._resetTarget = function() {
		var optionOrient = this.get("orient", true);
		var targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();
		if (this._fillSpecifiedTargetAxis(targetAxisIndexMap)) this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
		else {
			this._orient = optionOrient || "horizontal";
			this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
		}
		this._noTarget = true;
		targetAxisIndexMap.each(function(axisInfo) {
			if (axisInfo.indexList.length) this._noTarget = false;
		}, this);
	};
	DataZoomModel$1.prototype._fillSpecifiedTargetAxis = function(targetAxisIndexMap) {
		var hasAxisSpecified = false;
		each(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
			var refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING);
			if (!refering.specified) return;
			hasAxisSpecified = true;
			var axisInfo = new DataZoomAxisInfo();
			each(refering.models, function(axisModel) {
				axisInfo.add(axisModel.componentIndex);
			});
			targetAxisIndexMap.set(axisDim, axisInfo);
		}, this);
		return hasAxisSpecified;
	};
	DataZoomModel$1.prototype._fillAutoTargetAxisByOrient = function(targetAxisIndexMap, orient) {
		var ecModel = this.ecModel;
		var needAuto = true;
		if (needAuto) {
			var axisDim = orient === "vertical" ? "y" : "x";
			var axisModels = ecModel.findComponents({ mainType: axisDim + "Axis" });
			setParallelAxis(axisModels, axisDim);
		}
		if (needAuto) {
			var axisModels = ecModel.findComponents({
				mainType: "singleAxis",
				filter: function(axisModel) {
					return axisModel.get("orient", true) === orient;
				}
			});
			setParallelAxis(axisModels, "single");
		}
		function setParallelAxis(axisModels$1, axisDim$1) {
			var axisModel = axisModels$1[0];
			if (!axisModel) return;
			var axisInfo = new DataZoomAxisInfo();
			axisInfo.add(axisModel.componentIndex);
			targetAxisIndexMap.set(axisDim$1, axisInfo);
			needAuto = false;
			if (axisDim$1 === "x" || axisDim$1 === "y") {
				var gridModel_1 = axisModel.getReferringComponents("grid", SINGLE_REFERRING).models[0];
				gridModel_1 && each(axisModels$1, function(axModel) {
					if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents("grid", SINGLE_REFERRING).models[0]) axisInfo.add(axModel.componentIndex);
				});
			}
		}
		if (needAuto) each(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim$1) {
			if (!needAuto) return;
			var axisModels$1 = ecModel.findComponents({
				mainType: getAxisMainType(axisDim$1),
				filter: function(axisModel) {
					return axisModel.get("type", true) === "category";
				}
			});
			if (axisModels$1[0]) {
				var axisInfo = new DataZoomAxisInfo();
				axisInfo.add(axisModels$1[0].componentIndex);
				targetAxisIndexMap.set(axisDim$1, axisInfo);
				needAuto = false;
			}
		}, this);
	};
	DataZoomModel$1.prototype._makeAutoOrientByTargetAxis = function() {
		var dim;
		this.eachTargetAxis(function(axisDim) {
			!dim && (dim = axisDim);
		}, this);
		return dim === "y" ? "vertical" : "horizontal";
	};
	DataZoomModel$1.prototype._setDefaultThrottle = function(inputRawOption) {
		if (inputRawOption.hasOwnProperty("throttle")) this._autoThrottle = false;
		if (this._autoThrottle) {
			var globalOption = this.ecModel.option;
			this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
		}
	};
	DataZoomModel$1.prototype._updateRangeUse = function(inputRawOption) {
		var rangePropMode = this._rangePropMode;
		var rangeModeInOption = this.get("rangeMode");
		each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
			var percentSpecified = inputRawOption[names[0]] != null;
			var valueSpecified = inputRawOption[names[1]] != null;
			if (percentSpecified && !valueSpecified) rangePropMode[index] = "percent";
			else if (!percentSpecified && valueSpecified) rangePropMode[index] = "value";
			else if (rangeModeInOption) rangePropMode[index] = rangeModeInOption[index];
			else if (percentSpecified) rangePropMode[index] = "percent";
		});
	};
	DataZoomModel$1.prototype.noTarget = function() {
		return this._noTarget;
	};
	DataZoomModel$1.prototype.getFirstTargetAxisModel = function() {
		var firstAxisModel;
		this.eachTargetAxis(function(axisDim, axisIndex) {
			if (firstAxisModel == null) firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
		}, this);
		return firstAxisModel;
	};
	/**
	* @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
	*/
	DataZoomModel$1.prototype.eachTargetAxis = function(callback, context) {
		this._targetAxisInfoMap.each(function(axisInfo, axisDim) {
			each(axisInfo.indexList, function(axisIndex) {
				callback.call(context, axisDim, axisIndex);
			});
		});
	};
	/**
	* @return If not found, return null/undefined.
	*/
	DataZoomModel$1.prototype.getAxisProxy = function(axisDim, axisIndex) {
		var axisModel = this.getAxisModel(axisDim, axisIndex);
		if (axisModel) return axisModel.__dzAxisProxy;
	};
	/**
	* @return If not found, return null/undefined.
	*/
	DataZoomModel$1.prototype.getAxisModel = function(axisDim, axisIndex) {
		assert(axisDim && axisIndex != null);
		var axisInfo = this._targetAxisInfoMap.get(axisDim);
		if (axisInfo && axisInfo.indexMap[axisIndex]) return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
	};
	/**
	* If not specified, set to undefined.
	*/
	DataZoomModel$1.prototype.setRawRange = function(opt) {
		var thisOption = this.option;
		var settledOption = this.settledOption;
		each([["start", "startValue"], ["end", "endValue"]], function(names) {
			if (opt[names[0]] != null || opt[names[1]] != null) {
				thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
				thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
			}
		}, this);
		this._updateRangeUse(opt);
	};
	DataZoomModel$1.prototype.setCalculatedRange = function(opt) {
		var option = this.option;
		each([
			"start",
			"startValue",
			"end",
			"endValue"
		], function(name) {
			option[name] = opt[name];
		});
	};
	DataZoomModel$1.prototype.getPercentRange = function() {
		var axisProxy = this.findRepresentativeAxisProxy();
		if (axisProxy) return axisProxy.getDataPercentWindow();
	};
	/**
	* For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
	*
	* @return [startValue, endValue] value can only be '-' or finite number.
	*/
	DataZoomModel$1.prototype.getValueRange = function(axisDim, axisIndex) {
		if (axisDim == null && axisIndex == null) {
			var axisProxy = this.findRepresentativeAxisProxy();
			if (axisProxy) return axisProxy.getDataValueWindow();
		} else return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
	};
	/**
	* @param axisModel If axisModel given, find axisProxy
	*      corresponding to the axisModel
	*/
	DataZoomModel$1.prototype.findRepresentativeAxisProxy = function(axisModel) {
		if (axisModel) return axisModel.__dzAxisProxy;
		var firstProxy;
		var axisDimList = this._targetAxisInfoMap.keys();
		for (var i$1 = 0; i$1 < axisDimList.length; i$1++) {
			var axisDim = axisDimList[i$1];
			var axisInfo = this._targetAxisInfoMap.get(axisDim);
			for (var j = 0; j < axisInfo.indexList.length; j++) {
				var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);
				if (proxy.hostedBy(this)) return proxy;
				if (!firstProxy) firstProxy = proxy;
			}
		}
		return firstProxy;
	};
	DataZoomModel$1.prototype.getRangePropMode = function() {
		return this._rangePropMode.slice();
	};
	DataZoomModel$1.prototype.getOrient = function() {
		assert(this._orient);
		return this._orient;
	};
	DataZoomModel$1.type = "dataZoom";
	DataZoomModel$1.dependencies = [
		"xAxis",
		"yAxis",
		"radiusAxis",
		"angleAxis",
		"singleAxis",
		"series",
		"toolbox"
	];
	DataZoomModel$1.defaultOption = {
		z: 4,
		filterMode: "filter",
		start: 0,
		end: 100
	};
	return DataZoomModel$1;
}(Component_default);
/**
* Retrieve those raw params from option, which will be cached separately,
* because they will be overwritten by normalized/calculated values in the main
* process.
*/
function retrieveRawOption(option) {
	var ret = {};
	each([
		"start",
		"end",
		"startValue",
		"endValue",
		"throttle"
	], function(name) {
		option.hasOwnProperty(name) && (ret[name] = option[name]);
	});
	return ret;
}
var DataZoomModel_default = DataZoomModel;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js
var SelectDataZoomModel = function(_super) {
	__extends(SelectDataZoomModel$1, _super);
	function SelectDataZoomModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SelectDataZoomModel$1.type;
		return _this;
	}
	SelectDataZoomModel$1.type = "dataZoom.select";
	return SelectDataZoomModel$1;
}(DataZoomModel_default);
var SelectZoomModel_default = SelectDataZoomModel;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/DataZoomView.js
var DataZoomView = function(_super) {
	__extends(DataZoomView$1, _super);
	function DataZoomView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = DataZoomView$1.type;
		return _this;
	}
	DataZoomView$1.prototype.render = function(dataZoomModel, ecModel, api, payload) {
		this.dataZoomModel = dataZoomModel;
		this.ecModel = ecModel;
		this.api = api;
	};
	DataZoomView$1.type = "dataZoom";
	return DataZoomView$1;
}(Component_default$1);
var DataZoomView_default = DataZoomView;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/SelectZoomView.js
var SelectDataZoomView = function(_super) {
	__extends(SelectDataZoomView$1, _super);
	function SelectDataZoomView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SelectDataZoomView$1.type;
		return _this;
	}
	SelectDataZoomView$1.type = "dataZoom.select";
	return SelectDataZoomView$1;
}(DataZoomView_default);
var SelectZoomView_default = SelectDataZoomView;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/AxisProxy.js
var each$8 = each;
var asc$2 = asc$1;
/**
* Operate single axis.
* One axis can only operated by one axis operator.
* Different dataZoomModels may be defined to operate the same axis.
* (i.e. 'inside' data zoom and 'slider' data zoom components)
* So dataZoomModels share one axisProxy in that case.
*/
var AxisProxy = function() {
	function AxisProxy$1(dimName, axisIndex, dataZoomModel, ecModel) {
		this._dimName = dimName;
		this._axisIndex = axisIndex;
		this.ecModel = ecModel;
		this._dataZoomModel = dataZoomModel;
	}
	/**
	* Whether the axisProxy is hosted by dataZoomModel.
	*/
	AxisProxy$1.prototype.hostedBy = function(dataZoomModel) {
		return this._dataZoomModel === dataZoomModel;
	};
	/**
	* @return Value can only be NaN or finite value.
	*/
	AxisProxy$1.prototype.getDataValueWindow = function() {
		return this._valueWindow.slice();
	};
	/**
	* @return {Array.<number>}
	*/
	AxisProxy$1.prototype.getDataPercentWindow = function() {
		return this._percentWindow.slice();
	};
	AxisProxy$1.prototype.getTargetSeriesModels = function() {
		var seriesModels = [];
		this.ecModel.eachSeries(function(seriesModel) {
			if (isCoordSupported(seriesModel)) {
				var axisMainType = getAxisMainType(this._dimName);
				var axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];
				if (axisModel && this._axisIndex === axisModel.componentIndex) seriesModels.push(seriesModel);
			}
		}, this);
		return seriesModels;
	};
	AxisProxy$1.prototype.getAxisModel = function() {
		return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
	};
	AxisProxy$1.prototype.getMinMaxSpan = function() {
		return clone(this._minMaxSpan);
	};
	/**
	* Only calculate by given range and this._dataExtent, do not change anything.
	*/
	AxisProxy$1.prototype.calculateDataWindow = function(opt) {
		var dataExtent = this._dataExtent;
		var scale$3 = this.getAxisModel().axis.scale;
		var rangePropMode = this._dataZoomModel.getRangePropMode();
		var percentExtent = [0, 100];
		var percentWindow = [];
		var valueWindow = [];
		var hasPropModeValue;
		each$8(["start", "end"], function(prop, idx) {
			var boundPercent = opt[prop];
			var boundValue = opt[prop + "Value"];
			if (rangePropMode[idx] === "percent") {
				boundPercent ??= percentExtent[idx];
				boundValue = scale$3.parse(linearMap$2(boundPercent, percentExtent, dataExtent));
			} else {
				hasPropModeValue = true;
				boundValue = boundValue == null ? dataExtent[idx] : scale$3.parse(boundValue);
				boundPercent = linearMap$2(boundValue, dataExtent, percentExtent);
			}
			valueWindow[idx] = boundValue == null || isNaN(boundValue) ? dataExtent[idx] : boundValue;
			percentWindow[idx] = boundPercent == null || isNaN(boundPercent) ? percentExtent[idx] : boundPercent;
		});
		asc$2(valueWindow);
		asc$2(percentWindow);
		var spans = this._minMaxSpan;
		hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
		function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
			var suffix = toValue ? "Span" : "ValueSpan";
			sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
			for (var i$1 = 0; i$1 < 2; i$1++) {
				toWindow[i$1] = linearMap$2(fromWindow[i$1], fromExtent, toExtent, true);
				toValue && (toWindow[i$1] = scale$3.parse(toWindow[i$1]));
			}
		}
		return {
			valueWindow,
			percentWindow
		};
	};
	/**
	* Notice: reset should not be called before series.restoreData() is called,
	* so it is recommended to be called in "process stage" but not "model init
	* stage".
	*/
	AxisProxy$1.prototype.reset = function(dataZoomModel) {
		if (dataZoomModel !== this._dataZoomModel) return;
		var targetSeries = this.getTargetSeriesModels();
		this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
		this._updateMinMaxSpan();
		var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
		this._valueWindow = dataWindow.valueWindow;
		this._percentWindow = dataWindow.percentWindow;
		this._setAxisModel();
	};
	AxisProxy$1.prototype.filterData = function(dataZoomModel, api) {
		if (dataZoomModel !== this._dataZoomModel) return;
		var axisDim = this._dimName;
		var seriesModels = this.getTargetSeriesModels();
		var filterMode = dataZoomModel.get("filterMode");
		var valueWindow = this._valueWindow;
		if (filterMode === "none") return;
		each$8(seriesModels, function(seriesModel) {
			var seriesData = seriesModel.getData();
			var dataDims = seriesData.mapDimensionsAll(axisDim);
			if (!dataDims.length) return;
			if (filterMode === "weakFilter") {
				var store_1 = seriesData.getStore();
				var dataDimIndices_1 = map(dataDims, function(dim) {
					return seriesData.getDimensionIndex(dim);
				}, seriesData);
				seriesData.filterSelf(function(dataIndex) {
					var leftOut;
					var rightOut;
					var hasValue;
					for (var i$1 = 0; i$1 < dataDims.length; i$1++) {
						var value = store_1.get(dataDimIndices_1[i$1], dataIndex);
						var thisHasValue = !isNaN(value);
						var thisLeftOut = value < valueWindow[0];
						var thisRightOut = value > valueWindow[1];
						if (thisHasValue && !thisLeftOut && !thisRightOut) return true;
						thisHasValue && (hasValue = true);
						thisLeftOut && (leftOut = true);
						thisRightOut && (rightOut = true);
					}
					return hasValue && leftOut && rightOut;
				});
			} else each$8(dataDims, function(dim) {
				if (filterMode === "empty") seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
					return !isInWindow(value) ? NaN : value;
				}));
				else {
					var range = {};
					range[dim] = valueWindow;
					seriesData.selectRange(range);
				}
			});
			each$8(dataDims, function(dim) {
				seriesData.setApproximateExtent(valueWindow, dim);
			});
		});
		function isInWindow(value) {
			return value >= valueWindow[0] && value <= valueWindow[1];
		}
	};
	AxisProxy$1.prototype._updateMinMaxSpan = function() {
		var minMaxSpan = this._minMaxSpan = {};
		var dataZoomModel = this._dataZoomModel;
		var dataExtent = this._dataExtent;
		each$8(["min", "max"], function(minMax) {
			var percentSpan = dataZoomModel.get(minMax + "Span");
			var valueSpan = dataZoomModel.get(minMax + "ValueSpan");
			valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));
			if (valueSpan != null) percentSpan = linearMap$2(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
			else if (percentSpan != null) valueSpan = linearMap$2(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
			minMaxSpan[minMax + "Span"] = percentSpan;
			minMaxSpan[minMax + "ValueSpan"] = valueSpan;
		}, this);
	};
	AxisProxy$1.prototype._setAxisModel = function() {
		var axisModel = this.getAxisModel();
		var percentWindow = this._percentWindow;
		var valueWindow = this._valueWindow;
		if (!percentWindow) return;
		var precision = getPixelPrecision(valueWindow, [0, 500]);
		precision = Math.min(precision, 20);
		var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;
		if (percentWindow[0] !== 0) rawExtentInfo.setDeterminedMinMax("min", +valueWindow[0].toFixed(precision));
		if (percentWindow[1] !== 100) rawExtentInfo.setDeterminedMinMax("max", +valueWindow[1].toFixed(precision));
		rawExtentInfo.freeze();
	};
	return AxisProxy$1;
}();
function calculateDataExtent(axisProxy, axisDim, seriesModels) {
	var dataExtent = [Infinity, -Infinity];
	each$8(seriesModels, function(seriesModel) {
		unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);
	});
	var axisModel = axisProxy.getAxisModel();
	var rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();
	return [rawExtentResult.min, rawExtentResult.max];
}
var AxisProxy_default = AxisProxy;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js
var dataZoomProcessor = {
	getTargetSeries: function(ecModel) {
		function eachAxisModel(cb) {
			ecModel.eachComponent("dataZoom", function(dataZoomModel) {
				dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
					cb(axisDim, axisIndex, ecModel.getComponent(getAxisMainType(axisDim), axisIndex), dataZoomModel);
				});
			});
		}
		eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
			axisModel.__dzAxisProxy = null;
		});
		var proxyList = [];
		eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
			if (!axisModel.__dzAxisProxy) {
				axisModel.__dzAxisProxy = new AxisProxy_default(axisDim, axisIndex, dataZoomModel, ecModel);
				proxyList.push(axisModel.__dzAxisProxy);
			}
		});
		var seriesModelMap = createHashMap();
		each(proxyList, function(axisProxy) {
			each(axisProxy.getTargetSeriesModels(), function(seriesModel) {
				seriesModelMap.set(seriesModel.uid, seriesModel);
			});
		});
		return seriesModelMap;
	},
	overallReset: function(ecModel, api) {
		ecModel.eachComponent("dataZoom", function(dataZoomModel) {
			dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
				dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
			});
			dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
				dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);
			});
		});
		ecModel.eachComponent("dataZoom", function(dataZoomModel) {
			var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
			if (axisProxy) {
				var percentRange = axisProxy.getDataPercentWindow();
				var valueRange = axisProxy.getDataValueWindow();
				dataZoomModel.setCalculatedRange({
					start: percentRange[0],
					end: percentRange[1],
					startValue: valueRange[0],
					endValue: valueRange[1]
				});
			}
		});
	}
};
var dataZoomProcessor_default = dataZoomProcessor;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/dataZoomAction.js
function installDataZoomAction(registers) {
	registers.registerAction("dataZoom", function(payload, ecModel) {
		each(findEffectedDataZooms(ecModel, payload), function(dataZoomModel) {
			dataZoomModel.setRawRange({
				start: payload.start,
				end: payload.end,
				startValue: payload.startValue,
				endValue: payload.endValue
			});
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/installCommon.js
var installed$1 = false;
function installCommon$1(registers) {
	if (installed$1) return;
	installed$1 = true;
	registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor_default);
	installDataZoomAction(registers);
	registers.registerSubTypeDefaulter("dataZoom", function() {
		return "slider";
	});
}

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/installDataZoomSelect.js
function install$55(registers) {
	registers.registerComponentModel(SelectZoomModel_default);
	registers.registerComponentView(SelectZoomView_default);
	installCommon$1(registers);
}

//#endregion
//#region node_modules/echarts/lib/component/toolbox/featureManager.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var ToolboxFeature = function() {
	function ToolboxFeature$1() {}
	return ToolboxFeature$1;
}();
var features = {};
function registerFeature(name, ctor) {
	features[name] = ctor;
}
function getFeature(name) {
	return features[name];
}

//#endregion
//#region node_modules/echarts/lib/component/toolbox/ToolboxModel.js
var ToolboxModel = function(_super) {
	__extends(ToolboxModel$1, _super);
	function ToolboxModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ToolboxModel$1.type;
		return _this;
	}
	ToolboxModel$1.prototype.optionUpdated = function() {
		_super.prototype.optionUpdated.apply(this, arguments);
		var ecModel = this.ecModel;
		each(this.option.feature, function(featureOpt, featureName) {
			var Feature = getFeature(featureName);
			if (Feature) {
				if (Feature.getDefaultOption) Feature.defaultOption = Feature.getDefaultOption(ecModel);
				merge(featureOpt, Feature.defaultOption);
			}
		});
	};
	ToolboxModel$1.type = "toolbox";
	ToolboxModel$1.layoutMode = {
		type: "box",
		ignoreSize: true
	};
	ToolboxModel$1.defaultOption = {
		show: true,
		z: 6,
		orient: "horizontal",
		left: "right",
		top: "top",
		backgroundColor: "transparent",
		borderColor: tokens_default.color.border,
		borderRadius: 0,
		borderWidth: 0,
		padding: tokens_default.size.m,
		itemSize: 15,
		itemGap: tokens_default.size.s,
		showTitle: true,
		iconStyle: {
			borderColor: tokens_default.color.accent50,
			color: "none"
		},
		emphasis: { iconStyle: { borderColor: tokens_default.color.accent50 } },
		tooltip: {
			show: false,
			position: "bottom"
		}
	};
	return ToolboxModel$1;
}(Component_default);
var ToolboxModel_default = ToolboxModel;

//#endregion
//#region node_modules/echarts/lib/component/helper/listComponent.js
function makeBackground(rect, componentModel) {
	var padding = normalizeCssArray(componentModel.get("padding"));
	var style = componentModel.getItemStyle(["color", "opacity"]);
	style.fill = componentModel.get("backgroundColor");
	return new Rect_default({
		shape: {
			x: rect.x - padding[3],
			y: rect.y - padding[0],
			width: rect.width + padding[1] + padding[3],
			height: rect.height + padding[0] + padding[2],
			r: componentModel.get("borderRadius")
		},
		style,
		silent: true,
		z2: -1
	});
}

//#endregion
//#region node_modules/echarts/lib/component/toolbox/ToolboxView.js
var ToolboxView = function(_super) {
	__extends(ToolboxView$1, _super);
	function ToolboxView$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	ToolboxView$1.prototype.render = function(toolboxModel, ecModel, api, payload) {
		var group = this.group;
		group.removeAll();
		if (!toolboxModel.get("show")) return;
		var itemSize = +toolboxModel.get("itemSize");
		var isVertical = toolboxModel.get("orient") === "vertical";
		var featureOpts = toolboxModel.get("feature") || {};
		var features$1 = this._features || (this._features = {});
		var featureNames = [];
		each(featureOpts, function(opt, name) {
			featureNames.push(name);
		});
		new DataDiffer_default(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(curry(processFeature, null)).execute();
		this._featureNames = featureNames;
		function processFeature(newIndex, oldIndex) {
			var featureName = featureNames[newIndex];
			var oldName = featureNames[oldIndex];
			var featureOpt = featureOpts[featureName];
			var featureModel = new Model_default(featureOpt, toolboxModel, toolboxModel.ecModel);
			var feature;
			if (payload && payload.newTitle != null && payload.featureName === featureName) featureOpt.title = payload.newTitle;
			if (featureName && !oldName) {
				if (isUserFeatureName(featureName)) feature = {
					onclick: featureModel.option.onclick,
					featureName
				};
				else {
					var Feature = getFeature(featureName);
					if (!Feature) return;
					feature = new Feature();
				}
				features$1[featureName] = feature;
			} else {
				feature = features$1[oldName];
				if (!feature) return;
			}
			feature.uid = getUID("toolbox-feature");
			feature.model = featureModel;
			feature.ecModel = ecModel;
			feature.api = api;
			var isToolboxFeature = feature instanceof ToolboxFeature;
			if (!featureName && oldName) {
				isToolboxFeature && feature.dispose && feature.dispose(ecModel, api);
				return;
			}
			if (!featureModel.get("show") || isToolboxFeature && feature.unusable) {
				isToolboxFeature && feature.remove && feature.remove(ecModel, api);
				return;
			}
			createIconPaths(featureModel, feature, featureName);
			featureModel.setIconStatus = function(iconName, status) {
				var option = this.option;
				var iconPaths = this.iconPaths;
				option.iconStatus = option.iconStatus || {};
				option.iconStatus[iconName] = status;
				if (iconPaths[iconName]) (status === "emphasis" ? enterEmphasis : leaveEmphasis)(iconPaths[iconName]);
			};
			if (feature instanceof ToolboxFeature) {
				if (feature.render) feature.render(featureModel, ecModel, api, payload);
			}
		}
		function createIconPaths(featureModel, feature, featureName) {
			var iconStyleModel = featureModel.getModel("iconStyle");
			var iconStyleEmphasisModel = featureModel.getModel(["emphasis", "iconStyle"]);
			var icons = feature instanceof ToolboxFeature && feature.getIcons ? feature.getIcons() : featureModel.get("icon");
			var titles = featureModel.get("title") || {};
			var iconsMap;
			var titlesMap;
			if (isString(icons)) {
				iconsMap = {};
				iconsMap[featureName] = icons;
			} else iconsMap = icons;
			if (isString(titles)) {
				titlesMap = {};
				titlesMap[featureName] = titles;
			} else titlesMap = titles;
			var iconPaths = featureModel.iconPaths = {};
			each(iconsMap, function(iconStr, iconName) {
				var path = createIcon(iconStr, {}, {
					x: -itemSize / 2,
					y: -itemSize / 2,
					width: itemSize,
					height: itemSize
				});
				path.setStyle(iconStyleModel.getItemStyle());
				var pathEmphasisState = path.ensureState("emphasis");
				pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle();
				var textContent = new Text_default({
					style: {
						text: titlesMap[iconName],
						align: iconStyleEmphasisModel.get("textAlign"),
						borderRadius: iconStyleEmphasisModel.get("textBorderRadius"),
						padding: iconStyleEmphasisModel.get("textPadding"),
						fill: null,
						font: getFont({
							fontStyle: iconStyleEmphasisModel.get("textFontStyle"),
							fontFamily: iconStyleEmphasisModel.get("textFontFamily"),
							fontSize: iconStyleEmphasisModel.get("textFontSize"),
							fontWeight: iconStyleEmphasisModel.get("textFontWeight")
						}, ecModel)
					},
					ignore: true
				});
				path.setTextContent(textContent);
				setTooltipConfig({
					el: path,
					componentModel: toolboxModel,
					itemName: iconName,
					formatterParamsExtra: { title: titlesMap[iconName] }
				});
				path.__title = titlesMap[iconName];
				path.on("mouseover", function() {
					var hoverStyle = iconStyleEmphasisModel.getItemStyle();
					var defaultTextPosition = isVertical ? toolboxModel.get("right") == null && toolboxModel.get("left") !== "right" ? "right" : "left" : toolboxModel.get("bottom") == null && toolboxModel.get("top") !== "bottom" ? "bottom" : "top";
					textContent.setStyle({
						fill: iconStyleEmphasisModel.get("textFill") || hoverStyle.fill || hoverStyle.stroke || tokens_default.color.neutral99,
						backgroundColor: iconStyleEmphasisModel.get("textBackgroundColor")
					});
					path.setTextConfig({ position: iconStyleEmphasisModel.get("textPosition") || defaultTextPosition });
					textContent.ignore = !toolboxModel.get("showTitle");
					api.enterEmphasis(this);
				}).on("mouseout", function() {
					if (featureModel.get(["iconStatus", iconName]) !== "emphasis") api.leaveEmphasis(this);
					textContent.hide();
				});
				(featureModel.get(["iconStatus", iconName]) === "emphasis" ? enterEmphasis : leaveEmphasis)(path);
				group.add(path);
				path.on("click", bind(feature.onclick, feature, ecModel, api, iconName));
				iconPaths[iconName] = path;
			});
		}
		var refContainer = createBoxLayoutReference(toolboxModel, api).refContainer;
		var boxLayoutParams = toolboxModel.getBoxLayoutParams();
		var padding = toolboxModel.get("padding");
		var viewRect$1 = getLayoutRect(boxLayoutParams, refContainer, padding);
		box(toolboxModel.get("orient"), group, toolboxModel.get("itemGap"), viewRect$1.width, viewRect$1.height);
		positionElement(group, boxLayoutParams, refContainer, padding);
		group.add(makeBackground(group.getBoundingRect(), toolboxModel));
		isVertical || group.eachChild(function(icon) {
			var titleText = icon.__title;
			var emphasisState = icon.ensureState("emphasis");
			var emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});
			var textContent = icon.getTextContent();
			var emphasisTextState = textContent && textContent.ensureState("emphasis");
			if (emphasisTextState && !isFunction(emphasisTextState) && titleText) {
				var emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});
				var rect = getBoundingRect(titleText, Text_default.makeFont(emphasisTextStyle));
				var offsetX = icon.x + group.x;
				var offsetY = icon.y + group.y + itemSize;
				var needPutOnTop = false;
				if (offsetY + rect.height > api.getHeight()) {
					emphasisTextConfig.position = "top";
					needPutOnTop = true;
				}
				var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 10;
				if (offsetX + rect.width / 2 > api.getWidth()) {
					emphasisTextConfig.position = ["100%", topOffset];
					emphasisTextStyle.align = "right";
				} else if (offsetX - rect.width / 2 < 0) {
					emphasisTextConfig.position = [0, topOffset];
					emphasisTextStyle.align = "left";
				}
			}
		});
	};
	ToolboxView$1.prototype.updateView = function(toolboxModel, ecModel, api, payload) {
		each(this._features, function(feature) {
			feature instanceof ToolboxFeature && feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
		});
	};
	ToolboxView$1.prototype.remove = function(ecModel, api) {
		each(this._features, function(feature) {
			feature instanceof ToolboxFeature && feature.remove && feature.remove(ecModel, api);
		});
		this.group.removeAll();
	};
	ToolboxView$1.prototype.dispose = function(ecModel, api) {
		each(this._features, function(feature) {
			feature instanceof ToolboxFeature && feature.dispose && feature.dispose(ecModel, api);
		});
	};
	ToolboxView$1.type = "toolbox";
	return ToolboxView$1;
}(Component_default$1);
function isUserFeatureName(featureName) {
	return featureName.indexOf("my") === 0;
}
var ToolboxView_default = ToolboxView;

//#endregion
//#region node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js
var SaveAsImage = function(_super) {
	__extends(SaveAsImage$1, _super);
	function SaveAsImage$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	SaveAsImage$1.prototype.onclick = function(ecModel, api) {
		var model = this.model;
		var title = model.get("name") || ecModel.get("title.0.text") || "echarts";
		var isSvg = api.getZr().painter.getType() === "svg";
		var type = isSvg ? "svg" : model.get("type", true) || "png";
		var url = api.getConnectedDataURL({
			type,
			backgroundColor: model.get("backgroundColor", true) || ecModel.get("backgroundColor") || tokens_default.color.neutral00,
			connectedBackgroundColor: model.get("connectedBackgroundColor"),
			excludeComponents: model.get("excludeComponents"),
			pixelRatio: model.get("pixelRatio")
		});
		var browser = env_default.browser;
		if (typeof MouseEvent === "function" && (browser.newEdge || !browser.ie && !browser.edge)) {
			var $a = document.createElement("a");
			$a.download = title + "." + type;
			$a.target = "_blank";
			$a.href = url;
			var evt = new MouseEvent("click", {
				view: document.defaultView,
				bubbles: true,
				cancelable: false
			});
			$a.dispatchEvent(evt);
		} else if (window.navigator.msSaveOrOpenBlob || isSvg) {
			var parts = url.split(",");
			var base64Encoded = parts[0].indexOf("base64") > -1;
			var bstr = isSvg ? decodeURIComponent(parts[1]) : parts[1];
			base64Encoded && (bstr = window.atob(bstr));
			var filename = title + "." + type;
			if (window.navigator.msSaveOrOpenBlob) {
				var n = bstr.length;
				var u8arr = new Uint8Array(n);
				while (n--) u8arr[n] = bstr.charCodeAt(n);
				var blob = new Blob([u8arr]);
				window.navigator.msSaveOrOpenBlob(blob, filename);
			} else {
				var frame = document.createElement("iframe");
				document.body.appendChild(frame);
				var cw = frame.contentWindow;
				var doc = cw.document;
				doc.open("image/svg+xml", "replace");
				doc.write(bstr);
				doc.close();
				cw.focus();
				doc.execCommand("SaveAs", true, filename);
				document.body.removeChild(frame);
			}
		} else {
			var lang = model.get("lang");
			var html = "<body style=\"margin:0;\"><img src=\"" + url + "\" style=\"max-width:100%;\" title=\"" + (lang && lang[0] || "") + "\" /></body>";
			var tab = window.open();
			tab.document.write(html);
			tab.document.title = title;
		}
	};
	SaveAsImage$1.getDefaultOption = function(ecModel) {
		return {
			show: true,
			icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
			title: ecModel.getLocaleModel().get([
				"toolbox",
				"saveAsImage",
				"title"
			]),
			type: "png",
			connectedBackgroundColor: tokens_default.color.neutral00,
			name: "",
			excludeComponents: ["toolbox"],
			lang: ecModel.getLocaleModel().get([
				"toolbox",
				"saveAsImage",
				"lang"
			])
		};
	};
	return SaveAsImage$1;
}(ToolboxFeature);
var SaveAsImage_default = SaveAsImage;

//#endregion
//#region node_modules/echarts/lib/component/toolbox/feature/MagicType.js
var INNER_STACK_KEYWORD = "__ec_magicType_stack__";
var radioTypes = [["line", "bar"], ["stack"]];
var MagicType = function(_super) {
	__extends(MagicType$1, _super);
	function MagicType$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	MagicType$1.prototype.getIcons = function() {
		var model = this.model;
		var availableIcons = model.get("icon");
		var icons = {};
		each(model.get("type"), function(type) {
			if (availableIcons[type]) icons[type] = availableIcons[type];
		});
		return icons;
	};
	MagicType$1.getDefaultOption = function(ecModel) {
		return {
			show: true,
			type: [],
			icon: {
				line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
				bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
				stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
			},
			title: ecModel.getLocaleModel().get([
				"toolbox",
				"magicType",
				"title"
			]),
			option: {},
			seriesIndex: {}
		};
	};
	MagicType$1.prototype.onclick = function(ecModel, api, type) {
		var model = this.model;
		var seriesIndex = model.get(["seriesIndex", type]);
		if (!seriesOptGenreator[type]) return;
		var newOption = { series: [] };
		var generateNewSeriesTypes = function(seriesModel) {
			var seriesType$1 = seriesModel.subType;
			var seriesId = seriesModel.id;
			var newSeriesOpt = seriesOptGenreator[type](seriesType$1, seriesId, seriesModel, model);
			if (newSeriesOpt) {
				defaults(newSeriesOpt, seriesModel.option);
				newOption.series.push(newSeriesOpt);
			}
			var coordSys = seriesModel.coordinateSystem;
			if (coordSys && coordSys.type === "cartesian2d" && (type === "line" || type === "bar")) {
				var categoryAxis$1 = coordSys.getAxesByScale("ordinal")[0];
				if (categoryAxis$1) {
					var axisType = categoryAxis$1.dim + "Axis";
					var axisIndex = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0].componentIndex;
					newOption[axisType] = newOption[axisType] || [];
					for (var i$1 = 0; i$1 <= axisIndex; i$1++) newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
					newOption[axisType][axisIndex].boundaryGap = type === "bar";
				}
			}
		};
		each(radioTypes, function(radio) {
			if (indexOf(radio, type) >= 0) each(radio, function(item) {
				model.setIconStatus(item, "normal");
			});
		});
		model.setIconStatus(type, "emphasis");
		ecModel.eachComponent({
			mainType: "series",
			query: seriesIndex == null ? null : { seriesIndex }
		}, generateNewSeriesTypes);
		var newTitle;
		var currentType = type;
		if (type === "stack") {
			newTitle = merge({
				stack: model.option.title.tiled,
				tiled: model.option.title.stack
			}, model.option.title);
			if (model.get(["iconStatus", type]) !== "emphasis") currentType = "tiled";
		}
		api.dispatchAction({
			type: "changeMagicType",
			currentType,
			newOption,
			newTitle,
			featureName: "magicType"
		});
	};
	return MagicType$1;
}(ToolboxFeature);
var seriesOptGenreator = {
	"line": function(seriesType$1, seriesId, seriesModel, model) {
		if (seriesType$1 === "bar") return merge({
			id: seriesId,
			type: "line",
			data: seriesModel.get("data"),
			stack: seriesModel.get("stack"),
			markPoint: seriesModel.get("markPoint"),
			markLine: seriesModel.get("markLine")
		}, model.get(["option", "line"]) || {}, true);
	},
	"bar": function(seriesType$1, seriesId, seriesModel, model) {
		if (seriesType$1 === "line") return merge({
			id: seriesId,
			type: "bar",
			data: seriesModel.get("data"),
			stack: seriesModel.get("stack"),
			markPoint: seriesModel.get("markPoint"),
			markLine: seriesModel.get("markLine")
		}, model.get(["option", "bar"]) || {}, true);
	},
	"stack": function(seriesType$1, seriesId, seriesModel, model) {
		var isStack = seriesModel.get("stack") === INNER_STACK_KEYWORD;
		if (seriesType$1 === "line" || seriesType$1 === "bar") {
			model.setIconStatus("stack", isStack ? "normal" : "emphasis");
			return merge({
				id: seriesId,
				stack: isStack ? "" : INNER_STACK_KEYWORD
			}, model.get(["option", "stack"]) || {}, true);
		}
	}
};
registerAction({
	type: "changeMagicType",
	event: "magicTypeChanged",
	update: "prepareAndUpdate"
}, function(payload, ecModel) {
	ecModel.mergeOption(payload.newOption);
});
var MagicType_default = MagicType;

//#endregion
//#region node_modules/echarts/lib/component/toolbox/feature/DataView.js
var BLOCK_SPLITER = new Array(60).join("-");
var ITEM_SPLITER = "	";
/**
* Group series into two types
*  1. on category axis, like line, bar
*  2. others, like scatter, pie
*/
function groupSeries(ecModel) {
	var seriesGroupByCategoryAxis = {};
	var otherSeries = [];
	var meta = [];
	ecModel.eachRawSeries(function(seriesModel) {
		var coordSys = seriesModel.coordinateSystem;
		if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "polar")) {
			var baseAxis = coordSys.getBaseAxis();
			if (baseAxis.type === "category") {
				var key$1 = baseAxis.dim + "_" + baseAxis.index;
				if (!seriesGroupByCategoryAxis[key$1]) {
					seriesGroupByCategoryAxis[key$1] = {
						categoryAxis: baseAxis,
						valueAxis: coordSys.getOtherAxis(baseAxis),
						series: []
					};
					meta.push({
						axisDim: baseAxis.dim,
						axisIndex: baseAxis.index
					});
				}
				seriesGroupByCategoryAxis[key$1].series.push(seriesModel);
			} else otherSeries.push(seriesModel);
		} else otherSeries.push(seriesModel);
	});
	return {
		seriesGroupByCategoryAxis,
		other: otherSeries,
		meta
	};
}
/**
* Assemble content of series on cateogory axis
* @inner
*/
function assembleSeriesWithCategoryAxis(groups) {
	var tables = [];
	each(groups, function(group, key$1) {
		var categoryAxis$1 = group.categoryAxis;
		var valueAxisDim = group.valueAxis.dim;
		var headers = [" "].concat(map(group.series, function(series) {
			return series.name;
		}));
		var columns = [categoryAxis$1.model.getCategories()];
		each(group.series, function(series) {
			var rawData = series.getRawData();
			columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function(val) {
				return val;
			}));
		});
		var lines = [headers.join(ITEM_SPLITER)];
		for (var i$1 = 0; i$1 < columns[0].length; i$1++) {
			var items = [];
			for (var j = 0; j < columns.length; j++) items.push(columns[j][i$1]);
			lines.push(items.join(ITEM_SPLITER));
		}
		tables.push(lines.join("\n"));
	});
	return tables.join("\n\n" + BLOCK_SPLITER + "\n\n");
}
/**
* Assemble content of other series
*/
function assembleOtherSeries(series) {
	return map(series, function(series$1) {
		var data = series$1.getRawData();
		var lines = [series$1.name];
		var vals = [];
		data.each(data.dimensions, function() {
			var argLen = arguments.length;
			var dataIndex = arguments[argLen - 1];
			var name = data.getName(dataIndex);
			for (var i$1 = 0; i$1 < argLen - 1; i$1++) vals[i$1] = arguments[i$1];
			lines.push((name ? name + ITEM_SPLITER : "") + vals.join(ITEM_SPLITER));
		});
		return lines.join("\n");
	}).join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function getContentFromModel(ecModel) {
	var result = groupSeries(ecModel);
	return {
		value: filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function(str) {
			return !!str.replace(/[\n\t\s]/g, "");
		}).join("\n\n" + BLOCK_SPLITER + "\n\n"),
		meta: result.meta
	};
}
function trim$1(str) {
	return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
/**
* If a block is tsv format
*/
function isTSVFormat(block) {
	if (block.slice(0, block.indexOf("\n")).indexOf(ITEM_SPLITER) >= 0) return true;
}
var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
/**
* @param {string} tsv
* @return {Object}
*/
function parseTSVContents(tsv) {
	var tsvLines = tsv.split(/\n+/g);
	var headers = trim$1(tsvLines.shift()).split(itemSplitRegex);
	var categories = [];
	var series = map(headers, function(header) {
		return {
			name: header,
			data: []
		};
	});
	for (var i$1 = 0; i$1 < tsvLines.length; i$1++) {
		var items = trim$1(tsvLines[i$1]).split(itemSplitRegex);
		categories.push(items.shift());
		for (var j = 0; j < items.length; j++) series[j] && (series[j].data[i$1] = items[j]);
	}
	return {
		series,
		categories
	};
}
function parseListContents(str) {
	var lines = str.split(/\n+/g);
	var seriesName = trim$1(lines.shift());
	var data = [];
	for (var i$1 = 0; i$1 < lines.length; i$1++) {
		var line = trim$1(lines[i$1]);
		if (!line) continue;
		var items = line.split(itemSplitRegex);
		var name_1 = "";
		var value = void 0;
		var hasName = false;
		if (isNaN(items[0])) {
			hasName = true;
			name_1 = items[0];
			items = items.slice(1);
			data[i$1] = {
				name: name_1,
				value: []
			};
			value = data[i$1].value;
		} else value = data[i$1] = [];
		for (var j = 0; j < items.length; j++) value.push(+items[j]);
		if (value.length === 1) hasName ? data[i$1].value = value[0] : data[i$1] = value[0];
	}
	return {
		name: seriesName,
		data
	};
}
function parseContents(str, blockMetaList) {
	var blocks = str.split(new RegExp("\n*" + BLOCK_SPLITER + "\n*", "g"));
	var newOption = { series: [] };
	each(blocks, function(block, idx) {
		if (isTSVFormat(block)) {
			var result = parseTSVContents(block);
			var blockMeta = blockMetaList[idx];
			var axisKey = blockMeta.axisDim + "Axis";
			if (blockMeta) {
				newOption[axisKey] = newOption[axisKey] || [];
				newOption[axisKey][blockMeta.axisIndex] = { data: result.categories };
				newOption.series = newOption.series.concat(result.series);
			}
		} else {
			var result = parseListContents(block);
			newOption.series.push(result);
		}
	});
	return newOption;
}
var DataView = function(_super) {
	__extends(DataView$1, _super);
	function DataView$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	DataView$1.prototype.onclick = function(ecModel, api) {
		setTimeout(function() {
			api.dispatchAction({ type: "hideTip" });
		});
		var container = api.getDom();
		var model = this.model;
		if (this._dom) container.removeChild(this._dom);
		var root = document.createElement("div");
		root.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px";
		root.style.backgroundColor = model.get("backgroundColor") || tokens_default.color.neutral00;
		var header = document.createElement("h4");
		var lang = model.get("lang") || [];
		header.innerHTML = lang[0] || model.get("title");
		header.style.cssText = "margin:10px 20px";
		header.style.color = model.get("textColor");
		var viewMain = document.createElement("div");
		var textarea = document.createElement("textarea");
		viewMain.style.cssText = "overflow:auto";
		var optionToContent = model.get("optionToContent");
		var contentToOption = model.get("contentToOption");
		var result = getContentFromModel(ecModel);
		if (isFunction(optionToContent)) {
			var htmlOrDom = optionToContent(api.getOption());
			if (isString(htmlOrDom)) viewMain.innerHTML = htmlOrDom;
			else if (isDom(htmlOrDom)) viewMain.appendChild(htmlOrDom);
		} else {
			textarea.readOnly = model.get("readOnly");
			var style = textarea.style;
			style.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none";
			style.color = model.get("textColor");
			style.borderColor = model.get("textareaBorderColor");
			style.backgroundColor = model.get("textareaColor");
			textarea.value = result.value;
			viewMain.appendChild(textarea);
		}
		var blockMetaList = result.meta;
		var buttonContainer = document.createElement("div");
		buttonContainer.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
		var buttonStyle = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
		var closeButton = document.createElement("div");
		var refreshButton = document.createElement("div");
		buttonStyle += ";background-color:" + model.get("buttonColor");
		buttonStyle += ";color:" + model.get("buttonTextColor");
		var self$1 = this;
		function close() {
			container.removeChild(root);
			self$1._dom = null;
		}
		addEventListener(closeButton, "click", close);
		addEventListener(refreshButton, "click", function() {
			if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {
				warn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored.");
				close();
				return;
			}
			var newOption;
			try {
				if (isFunction(contentToOption)) newOption = contentToOption(viewMain, api.getOption());
				else newOption = parseContents(textarea.value, blockMetaList);
			} catch (e$1) {
				close();
				throw new Error("Data view format error " + e$1);
			}
			if (newOption) api.dispatchAction({
				type: "changeDataView",
				newOption
			});
			close();
		});
		closeButton.innerHTML = lang[1];
		refreshButton.innerHTML = lang[2];
		refreshButton.style.cssText = closeButton.style.cssText = buttonStyle;
		!model.get("readOnly") && buttonContainer.appendChild(refreshButton);
		buttonContainer.appendChild(closeButton);
		root.appendChild(header);
		root.appendChild(viewMain);
		root.appendChild(buttonContainer);
		viewMain.style.height = container.clientHeight - 80 + "px";
		container.appendChild(root);
		this._dom = root;
	};
	DataView$1.prototype.remove = function(ecModel, api) {
		this._dom && api.getDom().removeChild(this._dom);
	};
	DataView$1.prototype.dispose = function(ecModel, api) {
		this.remove(ecModel, api);
	};
	DataView$1.getDefaultOption = function(ecModel) {
		return {
			show: true,
			readOnly: false,
			optionToContent: null,
			contentToOption: null,
			icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
			title: ecModel.getLocaleModel().get([
				"toolbox",
				"dataView",
				"title"
			]),
			lang: ecModel.getLocaleModel().get([
				"toolbox",
				"dataView",
				"lang"
			]),
			backgroundColor: tokens_default.color.background,
			textColor: tokens_default.color.primary,
			textareaColor: tokens_default.color.background,
			textareaBorderColor: tokens_default.color.border,
			buttonColor: tokens_default.color.accent50,
			buttonTextColor: tokens_default.color.neutral00
		};
	};
	return DataView$1;
}(ToolboxFeature);
/**
* @inner
*/
function tryMergeDataOption(newData, originalData) {
	return map(newData, function(newVal, idx) {
		var original = originalData && originalData[idx];
		if (isObject(original) && !isArray(original)) {
			if (!(isObject(newVal) && !isArray(newVal))) newVal = { value: newVal };
			var shouldDeleteName = original.name != null && newVal.name == null;
			newVal = defaults(newVal, original);
			shouldDeleteName && delete newVal.name;
			return newVal;
		} else return newVal;
	});
}
registerAction({
	type: "changeDataView",
	event: "dataViewChanged",
	update: "prepareAndUpdate"
}, function(payload, ecModel) {
	var newSeriesOptList = [];
	each(payload.newOption.series, function(seriesOpt) {
		var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
		if (!seriesModel) newSeriesOptList.push(extend({ type: "scatter" }, seriesOpt));
		else {
			var originalData = seriesModel.get("data");
			newSeriesOptList.push({
				name: seriesOpt.name,
				data: tryMergeDataOption(seriesOpt.data, originalData)
			});
		}
	});
	ecModel.mergeOption(defaults({ series: newSeriesOptList }, payload.newOption));
});
var DataView_default = DataView;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/history.js
var each$7 = each;
var inner$6 = makeInner();
/**
* @param ecModel
* @param newSnapshot key is dataZoomId
*/
function push(ecModel, newSnapshot) {
	var storedSnapshots = getStoreSnapshots(ecModel);
	each$7(newSnapshot, function(batchItem, dataZoomId) {
		var i$1 = storedSnapshots.length - 1;
		for (; i$1 >= 0; i$1--) if (storedSnapshots[i$1][dataZoomId]) break;
		if (i$1 < 0) {
			var dataZoomModel = ecModel.queryComponents({
				mainType: "dataZoom",
				subType: "select",
				id: dataZoomId
			})[0];
			if (dataZoomModel) {
				var percentRange = dataZoomModel.getPercentRange();
				storedSnapshots[0][dataZoomId] = {
					dataZoomId,
					start: percentRange[0],
					end: percentRange[1]
				};
			}
		}
	});
	storedSnapshots.push(newSnapshot);
}
function pop(ecModel) {
	var storedSnapshots = getStoreSnapshots(ecModel);
	var head = storedSnapshots[storedSnapshots.length - 1];
	storedSnapshots.length > 1 && storedSnapshots.pop();
	var snapshot = {};
	each$7(head, function(batchItem, dataZoomId) {
		for (var i$1 = storedSnapshots.length - 1; i$1 >= 0; i$1--) {
			batchItem = storedSnapshots[i$1][dataZoomId];
			if (batchItem) {
				snapshot[dataZoomId] = batchItem;
				break;
			}
		}
	});
	return snapshot;
}
function clear$1(ecModel) {
	inner$6(ecModel).snapshots = null;
}
function count(ecModel) {
	return getStoreSnapshots(ecModel).length;
}
/**
* History length of each dataZoom may be different.
* this._history[0] is used to store origin range.
*/
function getStoreSnapshots(ecModel) {
	var store = inner$6(ecModel);
	if (!store.snapshots) store.snapshots = [{}];
	return store.snapshots;
}

//#endregion
//#region node_modules/echarts/lib/component/toolbox/feature/Restore.js
var RestoreOption = function(_super) {
	__extends(RestoreOption$1, _super);
	function RestoreOption$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	RestoreOption$1.prototype.onclick = function(ecModel, api) {
		clear$1(ecModel);
		api.dispatchAction({
			type: "restore",
			from: this.uid
		});
	};
	RestoreOption$1.getDefaultOption = function(ecModel) {
		return {
			show: true,
			icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
			title: ecModel.getLocaleModel().get([
				"toolbox",
				"restore",
				"title"
			])
		};
	};
	return RestoreOption$1;
}(ToolboxFeature);
registerAction({
	type: "restore",
	event: "restore",
	update: "prepareAndUpdate"
}, function(payload, ecModel) {
	ecModel.resetOption("recreate");
});
var Restore_default = RestoreOption;

//#endregion
//#region node_modules/echarts/lib/component/helper/BrushTargetManager.js
var INCLUDE_FINDER_MAIN_TYPES = [
	"grid",
	"xAxis",
	"yAxis",
	"geo",
	"graph",
	"polar",
	"radiusAxis",
	"angleAxis",
	"bmap"
];
var BrushTargetManager = function() {
	/**
	* @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid
	*        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}
	* @param opt.include include coordinate system types.
	*/
	function BrushTargetManager$1(finder, ecModel, opt) {
		var _this = this;
		this._targetInfoList = [];
		var foundCpts = parseFinder$1(ecModel, finder);
		each(targetInfoBuilders, function(builder, type) {
			if (!opt || !opt.include || indexOf(opt.include, type) >= 0) builder(foundCpts, _this._targetInfoList);
		});
	}
	BrushTargetManager$1.prototype.setOutputRanges = function(areas, ecModel) {
		this.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
			(area.coordRanges || (area.coordRanges = [])).push(coordRange);
			if (!area.coordRange) {
				area.coordRange = coordRange;
				var result = coordConvert[area.brushType](0, coordSys, coordRange);
				area.__rangeOffset = {
					offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
					xyMinMax: result.xyMinMax
				};
			}
		});
		return areas;
	};
	BrushTargetManager$1.prototype.matchOutputRanges = function(areas, ecModel, cb) {
		each(areas, function(area) {
			var targetInfo = this.findTargetInfo(area, ecModel);
			if (targetInfo && targetInfo !== true) each(targetInfo.coordSyses, function(coordSys) {
				cb(area, coordConvert[area.brushType](1, coordSys, area.range, true).values, coordSys, ecModel);
			});
		}, this);
	};
	/**
	* the `areas` is `BrushModel.areas`.
	* Called in layout stage.
	* convert `area.coordRange` to global range and set panelId to `area.range`.
	*/
	BrushTargetManager$1.prototype.setInputRanges = function(areas, ecModel) {
		each(areas, function(area) {
			var targetInfo = this.findTargetInfo(area, ecModel);
			assert(!targetInfo || targetInfo === true || area.coordRange, "coordRange must be specified when coord index specified.");
			assert(!targetInfo || targetInfo !== true || area.range, "range must be specified in global brush.");
			area.range = area.range || [];
			if (targetInfo && targetInfo !== true) {
				area.panelId = targetInfo.panelId;
				var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
				var rangeOffset = area.__rangeOffset;
				area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
			}
		}, this);
	};
	BrushTargetManager$1.prototype.makePanelOpts = function(api, getDefaultBrushType) {
		return map(this._targetInfoList, function(targetInfo) {
			var rect = targetInfo.getPanelRect();
			return {
				panelId: targetInfo.panelId,
				defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,
				clipPath: makeRectPanelClipPath(rect),
				isTargetByCursor: makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
				getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)
			};
		});
	};
	BrushTargetManager$1.prototype.controlSeries = function(area, seriesModel, ecModel) {
		var targetInfo = this.findTargetInfo(area, ecModel);
		return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
	};
	/**
	* If return Object, a coord found.
	* If return true, global found.
	* Otherwise nothing found.
	*/
	BrushTargetManager$1.prototype.findTargetInfo = function(area, ecModel) {
		var targetInfoList = this._targetInfoList;
		var foundCpts = parseFinder$1(ecModel, area);
		for (var i$1 = 0; i$1 < targetInfoList.length; i$1++) {
			var targetInfo = targetInfoList[i$1];
			var areaPanelId = area.panelId;
			if (areaPanelId) {
				if (targetInfo.panelId === areaPanelId) return targetInfo;
			} else for (var j = 0; j < targetInfoMatchers.length; j++) if (targetInfoMatchers[j](foundCpts, targetInfo)) return targetInfo;
		}
		return true;
	};
	return BrushTargetManager$1;
}();
function formatMinMax(minMax) {
	minMax[0] > minMax[1] && minMax.reverse();
	return minMax;
}
function parseFinder$1(ecModel, finder) {
	return parseFinder(ecModel, finder, { includeMainTypes: INCLUDE_FINDER_MAIN_TYPES });
}
var targetInfoBuilders = {
	grid: function(foundCpts, targetInfoList) {
		var xAxisModels = foundCpts.xAxisModels;
		var yAxisModels = foundCpts.yAxisModels;
		var gridModels = foundCpts.gridModels;
		var gridModelMap = createHashMap();
		var xAxesHas = {};
		var yAxesHas = {};
		if (!xAxisModels && !yAxisModels && !gridModels) return;
		each(xAxisModels, function(axisModel) {
			var gridModel = axisModel.axis.grid.model;
			gridModelMap.set(gridModel.id, gridModel);
			xAxesHas[gridModel.id] = true;
		});
		each(yAxisModels, function(axisModel) {
			var gridModel = axisModel.axis.grid.model;
			gridModelMap.set(gridModel.id, gridModel);
			yAxesHas[gridModel.id] = true;
		});
		each(gridModels, function(gridModel) {
			gridModelMap.set(gridModel.id, gridModel);
			xAxesHas[gridModel.id] = true;
			yAxesHas[gridModel.id] = true;
		});
		gridModelMap.each(function(gridModel) {
			var grid = gridModel.coordinateSystem;
			var cartesians = [];
			each(grid.getCartesians(), function(cartesian, index) {
				if (indexOf(xAxisModels, cartesian.getAxis("x").model) >= 0 || indexOf(yAxisModels, cartesian.getAxis("y").model) >= 0) cartesians.push(cartesian);
			});
			targetInfoList.push({
				panelId: "grid--" + gridModel.id,
				gridModel,
				coordSysModel: gridModel,
				coordSys: cartesians[0],
				coordSyses: cartesians,
				getPanelRect: panelRectBuilders.grid,
				xAxisDeclared: xAxesHas[gridModel.id],
				yAxisDeclared: yAxesHas[gridModel.id]
			});
		});
	},
	geo: function(foundCpts, targetInfoList) {
		each(foundCpts.geoModels, function(geoModel) {
			var coordSys = geoModel.coordinateSystem;
			targetInfoList.push({
				panelId: "geo--" + geoModel.id,
				geoModel,
				coordSysModel: geoModel,
				coordSys,
				coordSyses: [coordSys],
				getPanelRect: panelRectBuilders.geo
			});
		});
	}
};
var targetInfoMatchers = [function(foundCpts, targetInfo) {
	var xAxisModel = foundCpts.xAxisModel;
	var yAxisModel = foundCpts.yAxisModel;
	var gridModel = foundCpts.gridModel;
	!gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
	!gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
	return gridModel && gridModel === targetInfo.gridModel;
}, function(foundCpts, targetInfo) {
	var geoModel = foundCpts.geoModel;
	return geoModel && geoModel === targetInfo.geoModel;
}];
var panelRectBuilders = {
	grid: function() {
		return this.coordSys.master.getRect().clone();
	},
	geo: function() {
		var coordSys = this.coordSys;
		var rect = coordSys.getBoundingRect().clone();
		rect.applyTransform(getTransform$1(coordSys));
		return rect;
	}
};
var coordConvert = {
	lineX: curry(axisConvert, 0),
	lineY: curry(axisConvert, 1),
	rect: function(to, coordSys, rangeOrCoordRange, clamp$1) {
		var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp$1) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp$1);
		var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp$1) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp$1);
		var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
		return {
			values,
			xyMinMax: values
		};
	},
	polygon: function(to, coordSys, rangeOrCoordRange, clamp$1) {
		var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
		return {
			values: map(rangeOrCoordRange, function(item) {
				var p = to ? coordSys.pointToData(item, clamp$1) : coordSys.dataToPoint(item, clamp$1);
				xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
				xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
				xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
				xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
				return p;
			}),
			xyMinMax
		};
	}
};
function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
	assert(coordSys.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
	var axis = coordSys.getAxis(["x", "y"][axisNameIndex]);
	var values = formatMinMax(map([0, 1], function(i$1) {
		return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i$1]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i$1]));
	}));
	var xyMinMax = [];
	xyMinMax[axisNameIndex] = values;
	xyMinMax[1 - axisNameIndex] = [NaN, NaN];
	return {
		values,
		xyMinMax
	};
}
var diffProcessor = {
	lineX: curry(axisDiffProcessor, 0),
	lineY: curry(axisDiffProcessor, 1),
	rect: function(values, refer, scales) {
		return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
	},
	polygon: function(values, refer, scales) {
		return map(values, function(item, idx) {
			return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
		});
	}
};
function axisDiffProcessor(axisNameIndex, values, refer, scales) {
	return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
}
function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
	var sizeCurr = getSize(xyMinMaxCurr);
	var sizeOrigin = getSize(xyMinMaxOrigin);
	var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
	isNaN(scales[0]) && (scales[0] = 1);
	isNaN(scales[1]) && (scales[1] = 1);
	return scales;
}
function getSize(xyMinMax) {
	return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}
var BrushTargetManager_default = BrushTargetManager;

//#endregion
//#region node_modules/echarts/lib/component/toolbox/feature/DataZoom.js
var each$6 = each;
var DATA_ZOOM_ID_BASE = makeInternalComponentId("toolbox-dataZoom_");
var DataZoomFeature = function(_super) {
	__extends(DataZoomFeature$1, _super);
	function DataZoomFeature$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	DataZoomFeature$1.prototype.render = function(featureModel, ecModel, api, payload) {
		if (!this._brushController) {
			this._brushController = new BrushController_default(api.getZr());
			this._brushController.on("brush", bind(this._onBrush, this)).mount();
		}
		updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
		updateBackBtnStatus(featureModel, ecModel);
	};
	DataZoomFeature$1.prototype.onclick = function(ecModel, api, type) {
		handlers[type].call(this);
	};
	DataZoomFeature$1.prototype.remove = function(ecModel, api) {
		this._brushController && this._brushController.unmount();
	};
	DataZoomFeature$1.prototype.dispose = function(ecModel, api) {
		this._brushController && this._brushController.dispose();
	};
	DataZoomFeature$1.prototype._onBrush = function(eventParam) {
		var areas = eventParam.areas;
		if (!eventParam.isEnd || !areas.length) return;
		var snapshot = {};
		var ecModel = this.ecModel;
		this._brushController.updateCovers([]);
		new BrushTargetManager_default(makeAxisFinder(this.model), ecModel, { include: ["grid"] }).matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
			if (coordSys.type !== "cartesian2d") return;
			var brushType = area.brushType;
			if (brushType === "rect") {
				setBatch("x", coordSys, coordRange[0]);
				setBatch("y", coordSys, coordRange[1]);
			} else setBatch({
				lineX: "x",
				lineY: "y"
			}[brushType], coordSys, coordRange);
		});
		push(ecModel, snapshot);
		this._dispatchZoomAction(snapshot);
		function setBatch(dimName, coordSys, minMax) {
			var axis = coordSys.getAxis(dimName);
			var axisModel = axis.model;
			var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);
			var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
			if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
			dataZoomModel && (snapshot[dataZoomModel.id] = {
				dataZoomId: dataZoomModel.id,
				startValue: minMax[0],
				endValue: minMax[1]
			});
		}
		function findDataZoom(dimName, axisModel, ecModel$1) {
			var found;
			ecModel$1.eachComponent({
				mainType: "dataZoom",
				subType: "select"
			}, function(dzModel) {
				dzModel.getAxisModel(dimName, axisModel.componentIndex) && (found = dzModel);
			});
			return found;
		}
	};
	DataZoomFeature$1.prototype._dispatchZoomAction = function(snapshot) {
		var batch = [];
		each$6(snapshot, function(batchItem, dataZoomId) {
			batch.push(clone(batchItem));
		});
		batch.length && this.api.dispatchAction({
			type: "dataZoom",
			from: this.uid,
			batch
		});
	};
	DataZoomFeature$1.getDefaultOption = function(ecModel) {
		return {
			show: true,
			filterMode: "filter",
			icon: {
				zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
				back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
			},
			title: ecModel.getLocaleModel().get([
				"toolbox",
				"dataZoom",
				"title"
			]),
			brushStyle: {
				borderWidth: 0,
				color: tokens_default.color.backgroundTint
			}
		};
	};
	return DataZoomFeature$1;
}(ToolboxFeature);
var handlers = {
	zoom: function() {
		var nextActive = !this._isZoomActive;
		this.api.dispatchAction({
			type: "takeGlobalCursor",
			key: "dataZoomSelect",
			dataZoomSelectActive: nextActive
		});
	},
	back: function() {
		this._dispatchZoomAction(pop(this.ecModel));
	}
};
function makeAxisFinder(dzFeatureModel) {
	var setting = {
		xAxisIndex: dzFeatureModel.get("xAxisIndex", true),
		yAxisIndex: dzFeatureModel.get("yAxisIndex", true),
		xAxisId: dzFeatureModel.get("xAxisId", true),
		yAxisId: dzFeatureModel.get("yAxisId", true)
	};
	if (setting.xAxisIndex == null && setting.xAxisId == null) setting.xAxisIndex = "all";
	if (setting.yAxisIndex == null && setting.yAxisId == null) setting.yAxisIndex = "all";
	return setting;
}
function updateBackBtnStatus(featureModel, ecModel) {
	featureModel.setIconStatus("back", count(ecModel) > 1 ? "emphasis" : "normal");
}
function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
	var zoomActive = view._isZoomActive;
	if (payload && payload.type === "takeGlobalCursor") zoomActive = payload.key === "dataZoomSelect" ? payload.dataZoomSelectActive : false;
	view._isZoomActive = zoomActive;
	featureModel.setIconStatus("zoom", zoomActive ? "emphasis" : "normal");
	var panels = new BrushTargetManager_default(makeAxisFinder(featureModel), ecModel, { include: ["grid"] }).makePanelOpts(api, function(targetInfo) {
		return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? "lineX" : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? "lineY" : "rect";
	});
	view._brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {
		brushType: "auto",
		brushStyle: featureModel.getModel("brushStyle").getItemStyle()
	} : false);
}
registerInternalOptionCreator("dataZoom", function(ecModel) {
	var toolboxModel = ecModel.getComponent("toolbox", 0);
	var featureDataZoomPath = ["feature", "dataZoom"];
	if (!toolboxModel || toolboxModel.get(featureDataZoomPath) == null) return;
	var dzFeatureModel = toolboxModel.getModel(featureDataZoomPath);
	var dzOptions = [];
	var finderResult = parseFinder(ecModel, makeAxisFinder(dzFeatureModel));
	each$6(finderResult.xAxisModels, function(axisModel) {
		return buildInternalOptions(axisModel, "xAxis", "xAxisIndex");
	});
	each$6(finderResult.yAxisModels, function(axisModel) {
		return buildInternalOptions(axisModel, "yAxis", "yAxisIndex");
	});
	function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {
		var axisIndex = axisModel.componentIndex;
		var newOpt = {
			type: "select",
			$fromToolbox: true,
			filterMode: dzFeatureModel.get("filterMode", true) || "filter",
			id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex
		};
		newOpt[axisIndexPropName] = axisIndex;
		dzOptions.push(newOpt);
	}
	return dzOptions;
});
var DataZoom_default = DataZoomFeature;

//#endregion
//#region node_modules/echarts/lib/component/toolbox/install.js
function install$33(registers) {
	registers.registerComponentModel(ToolboxModel_default);
	registers.registerComponentView(ToolboxView_default);
	registerFeature("saveAsImage", SaveAsImage_default);
	registerFeature("magicType", MagicType_default);
	registerFeature("dataView", DataView_default);
	registerFeature("dataZoom", DataZoom_default);
	registerFeature("restore", Restore_default);
	use(install$55);
}

//#endregion
//#region node_modules/echarts/lib/component/tooltip/TooltipModel.js
var TooltipModel = function(_super) {
	__extends(TooltipModel$1, _super);
	function TooltipModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = TooltipModel$1.type;
		return _this;
	}
	TooltipModel$1.type = "tooltip";
	TooltipModel$1.dependencies = ["axisPointer"];
	TooltipModel$1.defaultOption = {
		z: 60,
		show: true,
		showContent: true,
		trigger: "item",
		triggerOn: "mousemove|click",
		alwaysShowContent: false,
		renderMode: "auto",
		confine: null,
		showDelay: 0,
		hideDelay: 100,
		transitionDuration: .4,
		displayTransition: true,
		enterable: false,
		backgroundColor: tokens_default.color.neutral00,
		shadowBlur: 10,
		shadowColor: "rgba(0, 0, 0, .2)",
		shadowOffsetX: 1,
		shadowOffsetY: 2,
		borderRadius: 4,
		borderWidth: 1,
		defaultBorderColor: tokens_default.color.border,
		padding: null,
		extraCssText: "",
		axisPointer: {
			type: "line",
			axis: "auto",
			animation: "auto",
			animationDurationUpdate: 200,
			animationEasingUpdate: "exponentialOut",
			crossStyle: {
				color: tokens_default.color.borderShade,
				width: 1,
				type: "dashed",
				textStyle: {}
			}
		},
		textStyle: {
			color: tokens_default.color.tertiary,
			fontSize: 14
		}
	};
	return TooltipModel$1;
}(Component_default);
var TooltipModel_default = TooltipModel;

//#endregion
//#region node_modules/echarts/lib/component/tooltip/helper.js
function shouldTooltipConfine(tooltipModel) {
	var confineOption = tooltipModel.get("confine");
	return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
}
function testStyle(styleProps) {
	if (!env_default.domSupported) return;
	var style = document.documentElement.style;
	for (var i$1 = 0, len$1 = styleProps.length; i$1 < len$1; i$1++) if (styleProps[i$1] in style) return styleProps[i$1];
}
var TRANSFORM_VENDOR = testStyle([
	"transform",
	"webkitTransform",
	"OTransform",
	"MozTransform",
	"msTransform"
]);
var TRANSITION_VENDOR = testStyle([
	"webkitTransition",
	"transition",
	"OTransition",
	"MozTransition",
	"msTransition"
]);
function toCSSVendorPrefix(styleVendor, styleProp) {
	if (!styleVendor) return styleProp;
	styleProp = toCamelCase(styleProp, true);
	var idx = styleVendor.indexOf(styleProp);
	styleVendor = idx === -1 ? styleProp : "-" + styleVendor.slice(0, idx) + "-" + styleProp;
	return styleVendor.toLowerCase();
}
function getComputedStyle(el, style) {
	var stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
	return stl ? style ? stl[style] : stl : null;
}

//#endregion
//#region node_modules/echarts/lib/component/tooltip/TooltipHTMLContent.js
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env_default.transform3dSupported ? "will-change:transform;" : "");
function mirrorPos(pos) {
	pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
	return pos;
}
function assembleArrow(tooltipModel, borderColor, arrowPosition) {
	if (!isString(arrowPosition) || arrowPosition === "inside") return "";
	var backgroundColor$1 = tooltipModel.get("backgroundColor");
	var borderWidth = tooltipModel.get("borderWidth");
	borderColor = convertToColorString(borderColor);
	var arrowPos = mirrorPos(arrowPosition);
	var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
	var positionStyle = "";
	var transformStyle = CSS_TRANSFORM_VENDOR + ":";
	var rotateDeg;
	if (indexOf(["left", "right"], arrowPos) > -1) {
		positionStyle += "top:50%";
		transformStyle += "translateY(-50%) rotate(" + (rotateDeg = arrowPos === "left" ? -225 : -45) + "deg)";
	} else {
		positionStyle += "left:50%";
		transformStyle += "translateX(-50%) rotate(" + (rotateDeg = arrowPos === "top" ? 225 : 45) + "deg)";
	}
	var rotateRadian = rotateDeg * Math.PI / 180;
	var arrowWH = arrowSize + borderWidth;
	var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
	var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
	positionStyle += ";" + arrowPos + ":-" + arrowOffset + "px";
	var borderStyle = borderColor + " solid " + borderWidth + "px;";
	return "<div style=\"" + [
		"position:absolute;width:" + arrowSize + "px;height:" + arrowSize + "px;z-index:-1;",
		positionStyle + ";" + transformStyle + ";",
		"border-bottom:" + borderStyle,
		"border-right:" + borderStyle,
		"background-color:" + backgroundColor$1 + ";"
	].join("") + "\"></div>";
}
function assembleTransition(duration, onlyFadeTransition, enableDisplayTransition) {
	var transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
	var transitionOption = "";
	var transitionText = "";
	if (enableDisplayTransition) {
		transitionOption = " " + duration / 2 + "s " + transitionCurve;
		transitionText = "opacity" + transitionOption + ",visibility" + transitionOption;
	}
	if (!onlyFadeTransition) {
		transitionOption = " " + duration + "s " + transitionCurve;
		transitionText += (transitionText.length ? "," : "") + (env_default.transformSupported ? "" + CSS_TRANSFORM_VENDOR + transitionOption : ",left" + transitionOption + ",top" + transitionOption);
	}
	return CSS_TRANSITION_VENDOR + ":" + transitionText;
}
function assembleTransform(x, y, toString) {
	var x0 = x.toFixed(0) + "px";
	var y0 = y.toFixed(0) + "px";
	if (!env_default.transformSupported) return toString ? "top:" + y0 + ";left:" + x0 + ";" : [["top", y0], ["left", x0]];
	var is3d = env_default.transform3dSupported;
	var translate$1 = "translate" + (is3d ? "3d" : "") + "(" + x0 + "," + y0 + (is3d ? ",0" : "") + ")";
	return toString ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate$1 + ";" : [
		["top", 0],
		["left", 0],
		[TRANSFORM_VENDOR, translate$1]
	];
}
/**
* @param {Object} textStyle
* @return {string}
* @inner
*/
function assembleFont(textStyleModel) {
	var cssText = [];
	var fontSize = textStyleModel.get("fontSize");
	var color$2 = textStyleModel.getTextColor();
	color$2 && cssText.push("color:" + color$2);
	cssText.push("font:" + textStyleModel.getFont());
	var lineHeight = retrieve2(textStyleModel.get("lineHeight"), Math.round(fontSize * 3 / 2));
	fontSize && cssText.push("line-height:" + lineHeight + "px");
	var shadowColor = textStyleModel.get("textShadowColor");
	var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
	var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
	var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
	shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
	each(["decoration", "align"], function(name) {
		var val = textStyleModel.get(name);
		val && cssText.push("text-" + name + ":" + val);
	});
	return cssText.join(";");
}
function assembleCssText(tooltipModel, enableTransition, onlyFadeTransition, enableDisplayTransition) {
	var cssText = [];
	var transitionDuration = tooltipModel.get("transitionDuration");
	var backgroundColor$1 = tooltipModel.get("backgroundColor");
	var shadowBlur = tooltipModel.get("shadowBlur");
	var shadowColor = tooltipModel.get("shadowColor");
	var shadowOffsetX = tooltipModel.get("shadowOffsetX");
	var shadowOffsetY = tooltipModel.get("shadowOffsetY");
	var textStyleModel = tooltipModel.getModel("textStyle");
	var padding = getPaddingFromTooltipModel(tooltipModel, "html");
	var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
	cssText.push("box-shadow:" + boxShadow);
	enableTransition && transitionDuration > 0 && cssText.push(assembleTransition(transitionDuration, onlyFadeTransition, enableDisplayTransition));
	if (backgroundColor$1) cssText.push("background-color:" + backgroundColor$1);
	each([
		"width",
		"color",
		"radius"
	], function(name) {
		var borderName = "border-" + name;
		var camelCase = toCamelCase(borderName);
		var val = tooltipModel.get(camelCase);
		val != null && cssText.push(borderName + ":" + val + (name === "color" ? "" : "px"));
	});
	cssText.push(assembleFont(textStyleModel));
	if (padding != null) cssText.push("padding:" + normalizeCssArray(padding).join("px ") + "px");
	return cssText.join(";") + ";";
}
function makeStyleCoord$1(out$1, zr, container, zrX, zrY) {
	var zrPainter = zr && zr.painter;
	if (container) {
		var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
		if (zrViewportRoot) transformLocalCoord(out$1, zrViewportRoot, container, zrX, zrY);
	} else {
		out$1[0] = zrX;
		out$1[1] = zrY;
		var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
		if (viewportRootOffset) {
			out$1[0] += viewportRootOffset.offsetLeft;
			out$1[1] += viewportRootOffset.offsetTop;
		}
	}
	out$1[2] = out$1[0] / zr.getWidth();
	out$1[3] = out$1[1] / zr.getHeight();
}
var TooltipHTMLContent = function() {
	function TooltipHTMLContent$1(api, opt) {
		this._show = false;
		this._styleCoord = [
			0,
			0,
			0,
			0
		];
		this._enterable = true;
		this._alwaysShowContent = false;
		this._firstShow = true;
		this._longHide = true;
		if (env_default.wxa) return null;
		var el = document.createElement("div");
		el.domBelongToZr = true;
		this.el = el;
		var zr = this._zr = api.getZr();
		var appendTo = opt.appendTo;
		var container = appendTo && (isString(appendTo) ? document.querySelector(appendTo) : isDom(appendTo) ? appendTo : isFunction(appendTo) && appendTo(api.getDom()));
		makeStyleCoord$1(this._styleCoord, zr, container, api.getWidth() / 2, api.getHeight() / 2);
		(container || api.getDom()).appendChild(el);
		this._api = api;
		this._container = container;
		var self$1 = this;
		el.onmouseenter = function() {
			if (self$1._enterable) {
				clearTimeout(self$1._hideTimeout);
				self$1._show = true;
			}
			self$1._inContent = true;
		};
		el.onmousemove = function(e$1) {
			e$1 = e$1 || window.event;
			if (!self$1._enterable) {
				var handler = zr.handler;
				normalizeEvent(zr.painter.getViewportRoot(), e$1, true);
				handler.dispatch("mousemove", e$1);
			}
		};
		el.onmouseleave = function() {
			self$1._inContent = false;
			if (self$1._enterable) {
				if (self$1._show) self$1.hideLater(self$1._hideDelay);
			}
		};
	}
	/**
	* Update when tooltip is rendered
	*/
	TooltipHTMLContent$1.prototype.update = function(tooltipModel) {
		if (!this._container) {
			var container = this._api.getDom();
			var position$1 = getComputedStyle(container, "position");
			var domStyle = container.style;
			if (domStyle.position !== "absolute" && position$1 !== "absolute") domStyle.position = "relative";
		}
		var alwaysShowContent = tooltipModel.get("alwaysShowContent");
		alwaysShowContent && this._moveIfResized();
		this._alwaysShowContent = alwaysShowContent;
		this._enableDisplayTransition = tooltipModel.get("displayTransition") && tooltipModel.get("transitionDuration") > 0;
		this.el.className = tooltipModel.get("className") || "";
	};
	TooltipHTMLContent$1.prototype.show = function(tooltipModel, nearPointColor) {
		clearTimeout(this._hideTimeout);
		clearTimeout(this._longHideTimeout);
		var el = this.el;
		var style = el.style;
		var styleCoord = this._styleCoord;
		if (!el.innerHTML) style.display = "none";
		else style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide, this._enableDisplayTransition) + assembleTransform(styleCoord[0], styleCoord[1], true) + ("border-color:" + convertToColorString(nearPointColor) + ";") + (tooltipModel.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none"));
		this._show = true;
		this._firstShow = false;
		this._longHide = false;
	};
	TooltipHTMLContent$1.prototype.setContent = function(content, markers, tooltipModel, borderColor, arrowPosition) {
		var el = this.el;
		if (content == null) {
			el.innerHTML = "";
			return;
		}
		var arrow = "";
		if (isString(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
		if (isString(content)) el.innerHTML = content + arrow;
		else if (content) {
			el.innerHTML = "";
			if (!isArray(content)) content = [content];
			for (var i$1 = 0; i$1 < content.length; i$1++) if (isDom(content[i$1]) && content[i$1].parentNode !== el) el.appendChild(content[i$1]);
			if (arrow && el.childNodes.length) {
				var arrowEl = document.createElement("div");
				arrowEl.innerHTML = arrow;
				el.appendChild(arrowEl);
			}
		}
	};
	TooltipHTMLContent$1.prototype.setEnterable = function(enterable) {
		this._enterable = enterable;
	};
	TooltipHTMLContent$1.prototype.getSize = function() {
		var el = this.el;
		return el ? [el.offsetWidth, el.offsetHeight] : [0, 0];
	};
	TooltipHTMLContent$1.prototype.moveTo = function(zrX, zrY) {
		if (!this.el) return;
		var styleCoord = this._styleCoord;
		makeStyleCoord$1(styleCoord, this._zr, this._container, zrX, zrY);
		if (styleCoord[0] != null && styleCoord[1] != null) {
			var style_1 = this.el.style;
			each(assembleTransform(styleCoord[0], styleCoord[1]), function(transform) {
				style_1[transform[0]] = transform[1];
			});
		}
	};
	/**
	* when `alwaysShowContent` is true,
	* move the tooltip after chart resized
	*/
	TooltipHTMLContent$1.prototype._moveIfResized = function() {
		var ratioX = this._styleCoord[2];
		var ratioY = this._styleCoord[3];
		this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
	};
	TooltipHTMLContent$1.prototype.hide = function() {
		var _this = this;
		var style = this.el.style;
		if (this._enableDisplayTransition) {
			style.visibility = "hidden";
			style.opacity = "0";
		} else style.display = "none";
		env_default.transform3dSupported && (style.willChange = "");
		this._show = false;
		this._longHideTimeout = setTimeout(function() {
			return _this._longHide = true;
		}, 500);
	};
	TooltipHTMLContent$1.prototype.hideLater = function(time) {
		if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) if (time) {
			this._hideDelay = time;
			this._show = false;
			this._hideTimeout = setTimeout(bind(this.hide, this), time);
		} else this.hide();
	};
	TooltipHTMLContent$1.prototype.isShow = function() {
		return this._show;
	};
	TooltipHTMLContent$1.prototype.dispose = function() {
		clearTimeout(this._hideTimeout);
		clearTimeout(this._longHideTimeout);
		var zr = this._zr;
		transformLocalCoordClear(zr && zr.painter && zr.painter.getViewportRoot(), this._container);
		var el = this.el;
		if (el) {
			el.onmouseenter = el.onmousemove = el.onmouseleave = null;
			var parentNode$1 = el.parentNode;
			parentNode$1 && parentNode$1.removeChild(el);
		}
		this.el = this._container = null;
	};
	return TooltipHTMLContent$1;
}();
var TooltipHTMLContent_default = TooltipHTMLContent;

//#endregion
//#region node_modules/echarts/lib/component/tooltip/TooltipRichContent.js
var TooltipRichContent = function() {
	function TooltipRichContent$1(api) {
		this._show = false;
		this._styleCoord = [
			0,
			0,
			0,
			0
		];
		this._alwaysShowContent = false;
		this._enterable = true;
		this._zr = api.getZr();
		makeStyleCoord(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
	}
	/**
	* Update when tooltip is rendered
	*/
	TooltipRichContent$1.prototype.update = function(tooltipModel) {
		var alwaysShowContent = tooltipModel.get("alwaysShowContent");
		alwaysShowContent && this._moveIfResized();
		this._alwaysShowContent = alwaysShowContent;
	};
	TooltipRichContent$1.prototype.show = function() {
		if (this._hideTimeout) clearTimeout(this._hideTimeout);
		this.el.show();
		this._show = true;
	};
	/**
	* Set tooltip content
	*/
	TooltipRichContent$1.prototype.setContent = function(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
		var _this = this;
		if (isObject(content)) throwError("Passing DOM nodes as content is not supported in richText tooltip!");
		if (this.el) this._zr.remove(this.el);
		var textStyleModel = tooltipModel.getModel("textStyle");
		this.el = new Text_default({
			style: {
				rich: markupStyleCreator.richTextStyles,
				text: content,
				lineHeight: 22,
				borderWidth: 1,
				borderColor,
				textShadowColor: textStyleModel.get("textShadowColor"),
				fill: tooltipModel.get(["textStyle", "color"]),
				padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
				verticalAlign: "top",
				align: "left"
			},
			z: tooltipModel.get("z")
		});
		each([
			"backgroundColor",
			"borderRadius",
			"shadowColor",
			"shadowBlur",
			"shadowOffsetX",
			"shadowOffsetY"
		], function(propName) {
			_this.el.style[propName] = tooltipModel.get(propName);
		});
		each([
			"textShadowBlur",
			"textShadowOffsetX",
			"textShadowOffsetY"
		], function(propName) {
			_this.el.style[propName] = textStyleModel.get(propName) || 0;
		});
		this._zr.add(this.el);
		var self$1 = this;
		this.el.on("mouseover", function() {
			if (self$1._enterable) {
				clearTimeout(self$1._hideTimeout);
				self$1._show = true;
			}
			self$1._inContent = true;
		});
		this.el.on("mouseout", function() {
			if (self$1._enterable) {
				if (self$1._show) self$1.hideLater(self$1._hideDelay);
			}
			self$1._inContent = false;
		});
	};
	TooltipRichContent$1.prototype.setEnterable = function(enterable) {
		this._enterable = enterable;
	};
	TooltipRichContent$1.prototype.getSize = function() {
		var el = this.el;
		var bounding = this.el.getBoundingRect();
		var shadowOuterSize = calcShadowOuterSize(el.style);
		return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
	};
	TooltipRichContent$1.prototype.moveTo = function(x, y) {
		var el = this.el;
		if (el) {
			var styleCoord = this._styleCoord;
			makeStyleCoord(styleCoord, this._zr, x, y);
			x = styleCoord[0];
			y = styleCoord[1];
			var style = el.style;
			var borderWidth = mathMaxWith0(style.borderWidth || 0);
			var shadowOuterSize = calcShadowOuterSize(style);
			el.x = x + borderWidth + shadowOuterSize.left;
			el.y = y + borderWidth + shadowOuterSize.top;
			el.markRedraw();
		}
	};
	/**
	* when `alwaysShowContent` is true,
	* move the tooltip after chart resized
	*/
	TooltipRichContent$1.prototype._moveIfResized = function() {
		var ratioX = this._styleCoord[2];
		var ratioY = this._styleCoord[3];
		this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
	};
	TooltipRichContent$1.prototype.hide = function() {
		if (this.el) this.el.hide();
		this._show = false;
	};
	TooltipRichContent$1.prototype.hideLater = function(time) {
		if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) if (time) {
			this._hideDelay = time;
			this._show = false;
			this._hideTimeout = setTimeout(bind(this.hide, this), time);
		} else this.hide();
	};
	TooltipRichContent$1.prototype.isShow = function() {
		return this._show;
	};
	TooltipRichContent$1.prototype.dispose = function() {
		this._zr.remove(this.el);
	};
	return TooltipRichContent$1;
}();
function mathMaxWith0(val) {
	return Math.max(0, val);
}
function calcShadowOuterSize(style) {
	var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
	var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
	var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
	return {
		left: mathMaxWith0(shadowBlur - shadowOffsetX),
		right: mathMaxWith0(shadowBlur + shadowOffsetX),
		top: mathMaxWith0(shadowBlur - shadowOffsetY),
		bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
	};
}
function makeStyleCoord(out$1, zr, zrX, zrY) {
	out$1[0] = zrX;
	out$1[1] = zrY;
	out$1[2] = out$1[0] / zr.getWidth();
	out$1[3] = out$1[1] / zr.getHeight();
}
var TooltipRichContent_default = TooltipRichContent;

//#endregion
//#region node_modules/echarts/lib/component/tooltip/TooltipView.js
var proxyRect = new Rect_default({ shape: {
	x: -1,
	y: -1,
	width: 2,
	height: 2
} });
var TooltipView = function(_super) {
	__extends(TooltipView$1, _super);
	function TooltipView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = TooltipView$1.type;
		return _this;
	}
	TooltipView$1.prototype.init = function(ecModel, api) {
		if (env_default.node || !api.getDom()) return;
		var tooltipModel = ecModel.getComponent("tooltip");
		this._tooltipContent = (this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"))) === "richText" ? new TooltipRichContent_default(api) : new TooltipHTMLContent_default(api, { appendTo: tooltipModel.get("appendToBody", true) ? "body" : tooltipModel.get("appendTo", true) });
	};
	TooltipView$1.prototype.render = function(tooltipModel, ecModel, api) {
		if (env_default.node || !api.getDom()) return;
		this.group.removeAll();
		this._tooltipModel = tooltipModel;
		this._ecModel = ecModel;
		this._api = api;
		var tooltipContent = this._tooltipContent;
		tooltipContent.update(tooltipModel);
		tooltipContent.setEnterable(tooltipModel.get("enterable"));
		this._initGlobalListener();
		this._keepShow();
		if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) createOrUpdate(this, "_updatePosition", 50, "fixRate");
		else clear(this, "_updatePosition");
	};
	TooltipView$1.prototype._initGlobalListener = function() {
		var triggerOn = this._tooltipModel.get("triggerOn");
		register("itemTooltip", this._api, bind(function(currTrigger, e$1, dispatchAction$2) {
			if (triggerOn !== "none") {
				if (triggerOn.indexOf(currTrigger) >= 0) this._tryShow(e$1, dispatchAction$2);
				else if (currTrigger === "leave") this._hide(dispatchAction$2);
			}
		}, this));
	};
	TooltipView$1.prototype._keepShow = function() {
		var tooltipModel = this._tooltipModel;
		var ecModel = this._ecModel;
		var api = this._api;
		var triggerOn = tooltipModel.get("triggerOn");
		if (this._lastX != null && this._lastY != null && triggerOn !== "none" && triggerOn !== "click") {
			var self_1 = this;
			clearTimeout(this._refreshUpdateTimeout);
			this._refreshUpdateTimeout = setTimeout(function() {
				!api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
					x: self_1._lastX,
					y: self_1._lastY,
					dataByCoordSys: self_1._lastDataByCoordSys
				});
			});
		}
	};
	/**
	* Show tip manually by
	* dispatchAction({
	*     type: 'showTip',
	*     x: 10,
	*     y: 10
	* });
	* Or
	* dispatchAction({
	*      type: 'showTip',
	*      seriesIndex: 0,
	*      dataIndex or dataIndexInside or name
	* });
	*
	*  TODO Batch
	*/
	TooltipView$1.prototype.manuallyShowTip = function(tooltipModel, ecModel, api, payload) {
		if (payload.from === this.uid || env_default.node || !api.getDom()) return;
		var dispatchAction$2 = makeDispatchAction(payload, api);
		this._ticket = "";
		var dataByCoordSys = payload.dataByCoordSys;
		var cmptRef = findComponentReference(payload, ecModel, api);
		if (cmptRef) {
			var rect = cmptRef.el.getBoundingRect().clone();
			rect.applyTransform(cmptRef.el.transform);
			this._tryShow({
				offsetX: rect.x + rect.width / 2,
				offsetY: rect.y + rect.height / 2,
				target: cmptRef.el,
				position: payload.position,
				positionDefault: "bottom"
			}, dispatchAction$2);
		} else if (payload.tooltip && payload.x != null && payload.y != null) {
			var el = proxyRect;
			el.x = payload.x;
			el.y = payload.y;
			el.update();
			getECData(el).tooltipConfig = {
				name: null,
				option: payload.tooltip
			};
			this._tryShow({
				offsetX: payload.x,
				offsetY: payload.y,
				target: el
			}, dispatchAction$2);
		} else if (dataByCoordSys) this._tryShow({
			offsetX: payload.x,
			offsetY: payload.y,
			position: payload.position,
			dataByCoordSys,
			tooltipOption: payload.tooltipOption
		}, dispatchAction$2);
		else if (payload.seriesIndex != null) {
			if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) return;
			var pointInfo = findPointFromSeries(payload, ecModel);
			var cx = pointInfo.point[0];
			var cy = pointInfo.point[1];
			if (cx != null && cy != null) this._tryShow({
				offsetX: cx,
				offsetY: cy,
				target: pointInfo.el,
				position: payload.position,
				positionDefault: "bottom"
			}, dispatchAction$2);
		} else if (payload.x != null && payload.y != null) {
			api.dispatchAction({
				type: "updateAxisPointer",
				x: payload.x,
				y: payload.y
			});
			this._tryShow({
				offsetX: payload.x,
				offsetY: payload.y,
				position: payload.position,
				target: api.getZr().findHover(payload.x, payload.y).target
			}, dispatchAction$2);
		}
	};
	TooltipView$1.prototype.manuallyHideTip = function(tooltipModel, ecModel, api, payload) {
		var tooltipContent = this._tooltipContent;
		if (this._tooltipModel) tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
		this._lastX = this._lastY = this._lastDataByCoordSys = null;
		if (payload.from !== this.uid) this._hide(makeDispatchAction(payload, api));
	};
	TooltipView$1.prototype._manuallyAxisShowTip = function(tooltipModel, ecModel, api, payload) {
		var seriesIndex = payload.seriesIndex;
		var dataIndex = payload.dataIndex;
		var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
		if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) return;
		var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
		if (!seriesModel) return;
		if (buildTooltipModel([
			seriesModel.getData().getItemModel(dataIndex),
			seriesModel,
			(seriesModel.coordinateSystem || {}).model
		], this._tooltipModel).get("trigger") !== "axis") return;
		api.dispatchAction({
			type: "updateAxisPointer",
			seriesIndex,
			dataIndex,
			position: payload.position
		});
		return true;
	};
	TooltipView$1.prototype._tryShow = function(e$1, dispatchAction$2) {
		var el = e$1.target;
		if (!this._tooltipModel) return;
		this._lastX = e$1.offsetX;
		this._lastY = e$1.offsetY;
		var dataByCoordSys = e$1.dataByCoordSys;
		if (dataByCoordSys && dataByCoordSys.length) this._showAxisTooltip(dataByCoordSys, e$1);
		else if (el) {
			if (getECData(el).ssrType === "legend") return;
			this._lastDataByCoordSys = null;
			var seriesDispatcher_1;
			var cmptDispatcher_1;
			findEventDispatcher(el, function(target) {
				if (target.tooltipDisabled) {
					seriesDispatcher_1 = cmptDispatcher_1 = null;
					return true;
				}
				if (seriesDispatcher_1 || cmptDispatcher_1) return;
				if (getECData(target).dataIndex != null) seriesDispatcher_1 = target;
				else if (getECData(target).tooltipConfig != null) cmptDispatcher_1 = target;
			}, true);
			if (seriesDispatcher_1) this._showSeriesItemTooltip(e$1, seriesDispatcher_1, dispatchAction$2);
			else if (cmptDispatcher_1) this._showComponentItemTooltip(e$1, cmptDispatcher_1, dispatchAction$2);
			else this._hide(dispatchAction$2);
		} else {
			this._lastDataByCoordSys = null;
			this._hide(dispatchAction$2);
		}
	};
	TooltipView$1.prototype._showOrMove = function(tooltipModel, cb) {
		var delay = tooltipModel.get("showDelay");
		cb = bind(cb, this);
		clearTimeout(this._showTimout);
		delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
	};
	TooltipView$1.prototype._showAxisTooltip = function(dataByCoordSys, e$1) {
		var ecModel = this._ecModel;
		var globalTooltipModel = this._tooltipModel;
		var point = [e$1.offsetX, e$1.offsetY];
		var singleTooltipModel = buildTooltipModel([e$1.tooltipOption], globalTooltipModel);
		var renderMode = this._renderMode;
		var cbParamsList = [];
		var articleMarkup = createTooltipMarkup("section", {
			blocks: [],
			noHeader: true
		});
		var markupTextArrLegacy = [];
		var markupStyleCreator = new TooltipMarkupStyleCreator();
		each(dataByCoordSys, function(itemCoordSys) {
			each(itemCoordSys.dataByAxis, function(axisItem) {
				var axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
				var axisValue = axisItem.value;
				if (!axisModel || axisValue == null) return;
				var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
				var axisSectionMarkup = createTooltipMarkup("section", {
					header: axisValueLabel,
					noHeader: !trim(axisValueLabel),
					sortBlocks: true,
					blocks: []
				});
				articleMarkup.blocks.push(axisSectionMarkup);
				each(axisItem.seriesDataIndices, function(idxItem) {
					var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
					var dataIndex = idxItem.dataIndexInside;
					var cbParams = series.getDataParams(dataIndex);
					if (cbParams.dataIndex < 0) return;
					cbParams.axisDim = axisItem.axisDim;
					cbParams.axisIndex = axisItem.axisIndex;
					cbParams.axisType = axisItem.axisType;
					cbParams.axisId = axisItem.axisId;
					cbParams.axisValue = getAxisRawValue(axisModel.axis, { value: axisValue });
					cbParams.axisValueLabel = axisValueLabel;
					cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
					var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
					var frag = seriesTooltipResult.frag;
					if (frag) {
						var valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
						axisSectionMarkup.blocks.push(valueFormatter ? extend({ valueFormatter }, frag) : frag);
					}
					if (seriesTooltipResult.text) markupTextArrLegacy.push(seriesTooltipResult.text);
					cbParamsList.push(cbParams);
				});
			});
		});
		articleMarkup.blocks.reverse();
		markupTextArrLegacy.reverse();
		var positionExpr = e$1.position;
		var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, singleTooltipModel.get("order"), ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
		builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
		var blockBreak = renderMode === "richText" ? "\n\n" : "<br/>";
		var allMarkupText = markupTextArrLegacy.join(blockBreak);
		this._showOrMove(singleTooltipModel, function() {
			if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
			else this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point[0], point[1], positionExpr, null, markupStyleCreator);
		});
	};
	TooltipView$1.prototype._showSeriesItemTooltip = function(e$1, dispatcher, dispatchAction$2) {
		var ecModel = this._ecModel;
		var ecData = getECData(dispatcher);
		var seriesIndex = ecData.seriesIndex;
		var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
		var dataModel = ecData.dataModel || seriesModel;
		var dataIndex = ecData.dataIndex;
		var dataType = ecData.dataType;
		var data = dataModel.getData(dataType);
		var renderMode = this._renderMode;
		var positionDefault = e$1.positionDefault;
		var tooltipModel = buildTooltipModel([
			data.getItemModel(dataIndex),
			dataModel,
			seriesModel && (seriesModel.coordinateSystem || {}).model
		], this._tooltipModel, positionDefault ? { position: positionDefault } : null);
		var tooltipTrigger = tooltipModel.get("trigger");
		if (tooltipTrigger != null && tooltipTrigger !== "item") return;
		var params = dataModel.getDataParams(dataIndex, dataType);
		var markupStyleCreator = new TooltipMarkupStyleCreator();
		params.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params.color), renderMode);
		var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
		var orderMode = tooltipModel.get("order");
		var valueFormatter = tooltipModel.get("valueFormatter");
		var frag = seriesTooltipResult.frag;
		var markupText = frag ? buildTooltipMarkup(valueFormatter ? extend({ valueFormatter }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
		var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
		this._showOrMove(tooltipModel, function() {
			this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e$1.offsetX, e$1.offsetY, e$1.position, e$1.target, markupStyleCreator);
		});
		dispatchAction$2({
			type: "showTip",
			dataIndexInside: dataIndex,
			dataIndex: data.getRawIndex(dataIndex),
			seriesIndex,
			from: this.uid
		});
	};
	TooltipView$1.prototype._showComponentItemTooltip = function(e$1, el, dispatchAction$2) {
		var isHTMLRenderMode = this._renderMode === "html";
		var ecData = getECData(el);
		var tooltipOpt = ecData.tooltipConfig.option || {};
		var encodeHTMLContent = tooltipOpt.encodeHTMLContent;
		if (isString(tooltipOpt)) {
			var content = tooltipOpt;
			tooltipOpt = {
				content,
				formatter: content
			};
			encodeHTMLContent = true;
		}
		if (encodeHTMLContent && isHTMLRenderMode && tooltipOpt.content) {
			tooltipOpt = clone(tooltipOpt);
			tooltipOpt.content = encodeHTML(tooltipOpt.content);
		}
		var tooltipModelCascade = [tooltipOpt];
		var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
		if (cmpt) tooltipModelCascade.push(cmpt);
		tooltipModelCascade.push({ formatter: tooltipOpt.content });
		var positionDefault = e$1.positionDefault;
		var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? { position: positionDefault } : null);
		var defaultHtml = subTooltipModel.get("content");
		var asyncTicket = Math.random() + "";
		var markupStyleCreator = new TooltipMarkupStyleCreator();
		this._showOrMove(subTooltipModel, function() {
			var formatterParams = clone(subTooltipModel.get("formatterParams") || {});
			this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e$1.offsetX, e$1.offsetY, e$1.position, el, markupStyleCreator);
		});
		dispatchAction$2({
			type: "showTip",
			from: this.uid
		});
	};
	TooltipView$1.prototype._showTooltipContent = function(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {
		this._ticket = "";
		if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) return;
		var tooltipContent = this._tooltipContent;
		tooltipContent.setEnterable(tooltipModel.get("enterable"));
		var formatter = tooltipModel.get("formatter");
		positionExpr = positionExpr || tooltipModel.get("position");
		var html = defaultHtml;
		var nearPointColor = this._getNearestPoint([x, y], params, tooltipModel.get("trigger"), tooltipModel.get("borderColor"), tooltipModel.get("defaultBorderColor", true)).color;
		if (formatter) if (isString(formatter)) {
			var useUTC = tooltipModel.ecModel.get("useUTC");
			var params0 = isArray(params) ? params[0] : params;
			var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
			html = formatter;
			if (isTimeAxis) html = format(params0.axisValue, html, useUTC);
			html = formatTpl(html, params, true);
		} else if (isFunction(formatter)) {
			var callback = bind(function(cbTicket, html$1) {
				if (cbTicket === this._ticket) {
					tooltipContent.setContent(html$1, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
					this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
				}
			}, this);
			this._ticket = asyncTicket;
			html = formatter(params, asyncTicket, callback);
		} else html = formatter;
		tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
		tooltipContent.show(tooltipModel, nearPointColor);
		this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
	};
	TooltipView$1.prototype._getNearestPoint = function(point, tooltipDataParams, trigger$2, borderColor, defaultBorderColor) {
		if (trigger$2 === "axis" || isArray(tooltipDataParams)) return { color: borderColor || defaultBorderColor };
		if (!isArray(tooltipDataParams)) return { color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor };
	};
	TooltipView$1.prototype._updatePosition = function(tooltipModel, positionExpr, x, y, content, params, el) {
		var viewWidth = this._api.getWidth();
		var viewHeight = this._api.getHeight();
		positionExpr = positionExpr || tooltipModel.get("position");
		var contentSize = content.getSize();
		var align = tooltipModel.get("align");
		var vAlign = tooltipModel.get("verticalAlign");
		var rect = el && el.getBoundingRect().clone();
		el && rect.applyTransform(el.transform);
		if (isFunction(positionExpr)) positionExpr = positionExpr([x, y], params, content.el, rect, {
			viewSize: [viewWidth, viewHeight],
			contentSize: contentSize.slice()
		});
		if (isArray(positionExpr)) {
			x = parsePercent$1(positionExpr[0], viewWidth);
			y = parsePercent$1(positionExpr[1], viewHeight);
		} else if (isObject(positionExpr)) {
			var boxLayoutPosition = positionExpr;
			boxLayoutPosition.width = contentSize[0];
			boxLayoutPosition.height = contentSize[1];
			var layoutRect = getLayoutRect(boxLayoutPosition, {
				width: viewWidth,
				height: viewHeight
			});
			x = layoutRect.x;
			y = layoutRect.y;
			align = null;
			vAlign = null;
		} else if (isString(positionExpr) && el) {
			var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
			x = pos[0];
			y = pos[1];
		} else {
			var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
			x = pos[0];
			y = pos[1];
		}
		align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
		vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
		if (shouldTooltipConfine(tooltipModel)) {
			var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
			x = pos[0];
			y = pos[1];
		}
		content.moveTo(x, y);
	};
	TooltipView$1.prototype._updateContentNotChangedOnAxis = function(dataByCoordSys, cbParamsList) {
		var lastCoordSys = this._lastDataByCoordSys;
		var lastCbParamsList = this._cbParamsList;
		var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
		contentNotChanged && each(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
			var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
			var thisDataByAxis = (dataByCoordSys[indexCoordSys] || {}).dataByAxis || [];
			contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
			contentNotChanged && each(lastDataByAxis, function(lastItem, indexAxis) {
				var thisItem = thisDataByAxis[indexAxis] || {};
				var lastIndices = lastItem.seriesDataIndices || [];
				var newIndices = thisItem.seriesDataIndices || [];
				contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
				contentNotChanged && each(lastIndices, function(lastIdxItem, j) {
					var newIdxItem = newIndices[j];
					contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
				});
				lastCbParamsList && each(lastItem.seriesDataIndices, function(idxItem) {
					var seriesIdx = idxItem.seriesIndex;
					var cbParams = cbParamsList[seriesIdx];
					var lastCbParams = lastCbParamsList[seriesIdx];
					if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) contentNotChanged = false;
				});
			});
		});
		this._lastDataByCoordSys = dataByCoordSys;
		this._cbParamsList = cbParamsList;
		return !!contentNotChanged;
	};
	TooltipView$1.prototype._hide = function(dispatchAction$2) {
		this._lastDataByCoordSys = null;
		dispatchAction$2({
			type: "hideTip",
			from: this.uid
		});
	};
	TooltipView$1.prototype.dispose = function(ecModel, api) {
		if (env_default.node || !api.getDom()) return;
		clear(this, "_updatePosition");
		this._tooltipContent.dispose();
		unregister("itemTooltip", api);
	};
	TooltipView$1.type = "tooltip";
	return TooltipView$1;
}(Component_default$1);
/**
* From top to bottom. (the last one should be globalTooltipModel);
*/
function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
	var ecModel = globalTooltipModel.ecModel;
	var resultModel;
	if (defaultTooltipOption) {
		resultModel = new Model_default(defaultTooltipOption, ecModel, ecModel);
		resultModel = new Model_default(globalTooltipModel.option, resultModel, ecModel);
	} else resultModel = globalTooltipModel;
	for (var i$1 = modelCascade.length - 1; i$1 >= 0; i$1--) {
		var tooltipOpt = modelCascade[i$1];
		if (tooltipOpt) {
			if (tooltipOpt instanceof Model_default) tooltipOpt = tooltipOpt.get("tooltip", true);
			if (isString(tooltipOpt)) tooltipOpt = { formatter: tooltipOpt };
			if (tooltipOpt) resultModel = new Model_default(tooltipOpt, resultModel, ecModel);
		}
	}
	return resultModel;
}
function makeDispatchAction(payload, api) {
	return payload.dispatchAction || bind(api.dispatchAction, api);
}
function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
	var size = content.getSize();
	var width = size[0];
	var height = size[1];
	if (gapH != null) if (x + width + gapH + 2 > viewWidth) x -= width + gapH;
	else x += gapH;
	if (gapV != null) if (y + height + gapV > viewHeight) y -= height + gapV;
	else y += gapV;
	return [x, y];
}
function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
	var size = content.getSize();
	var width = size[0];
	var height = size[1];
	x = Math.min(x + width, viewWidth) - width;
	y = Math.min(y + height, viewHeight) - height;
	x = Math.max(x, 0);
	y = Math.max(y, 0);
	return [x, y];
}
function calcTooltipPosition(position$1, rect, contentSize, borderWidth) {
	var domWidth = contentSize[0];
	var domHeight = contentSize[1];
	var offset = Math.ceil(Math.SQRT2 * borderWidth) + 8;
	var x = 0;
	var y = 0;
	var rectWidth = rect.width;
	var rectHeight = rect.height;
	switch (position$1) {
		case "inside":
			x = rect.x + rectWidth / 2 - domWidth / 2;
			y = rect.y + rectHeight / 2 - domHeight / 2;
			break;
		case "top":
			x = rect.x + rectWidth / 2 - domWidth / 2;
			y = rect.y - domHeight - offset;
			break;
		case "bottom":
			x = rect.x + rectWidth / 2 - domWidth / 2;
			y = rect.y + rectHeight + offset;
			break;
		case "left":
			x = rect.x - domWidth - offset;
			y = rect.y + rectHeight / 2 - domHeight / 2;
			break;
		case "right":
			x = rect.x + rectWidth + offset;
			y = rect.y + rectHeight / 2 - domHeight / 2;
	}
	return [x, y];
}
function isCenterAlign(align) {
	return align === "center" || align === "middle";
}
/**
* Find target component by payload like:
* ```js
* { legendId: 'some_id', name: 'xxx' }
* { toolboxIndex: 1, name: 'xxx' }
* { geoName: 'some_name', name: 'xxx' }
* ```
* PENDING: at present only
*
* If not found, return null/undefined.
*/
function findComponentReference(payload, ecModel, api) {
	var queryOptionMap = preParseFinder(payload).queryOptionMap;
	var componentMainType = queryOptionMap.keys()[0];
	if (!componentMainType || componentMainType === "series") return;
	var model = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
		useDefault: false,
		enableAll: false,
		enableNone: false
	}).models[0];
	if (!model) return;
	var view = api.getViewOfComponentModel(model);
	var el;
	view.group.traverse(function(subEl) {
		var tooltipConfig = getECData(subEl).tooltipConfig;
		if (tooltipConfig && tooltipConfig.name === payload.name) {
			el = subEl;
			return true;
		}
	});
	if (el) return {
		componentMainType,
		componentIndex: model.componentIndex,
		el
	};
}
var TooltipView_default = TooltipView;

//#endregion
//#region node_modules/echarts/lib/component/tooltip/install.js
function install$34(registers) {
	use(install$35);
	registers.registerComponentModel(TooltipModel_default);
	registers.registerComponentView(TooltipView_default);
	/**
	* @action
	* @property {string} type
	* @property {number} seriesIndex
	* @property {number} dataIndex
	* @property {number} [x]
	* @property {number} [y]
	*/
	registers.registerAction({
		type: "showTip",
		event: "showTip",
		update: "tooltip:manuallyShowTip"
	}, noop);
	registers.registerAction({
		type: "hideTip",
		event: "hideTip",
		update: "tooltip:manuallyHideTip"
	}, noop);
}

//#endregion
//#region node_modules/echarts/lib/component/brush/preprocessor.js
var DEFAULT_TOOLBOX_BTNS = [
	"rect",
	"polygon",
	"keep",
	"clear"
];
function brushPreprocessor(option, isNew) {
	var brushComponents = normalizeToArray(option ? option.brush : []);
	if (!brushComponents.length) return;
	var brushComponentSpecifiedBtns = [];
	each(brushComponents, function(brushOpt) {
		var tbs = brushOpt.hasOwnProperty("toolbox") ? brushOpt.toolbox : [];
		if (tbs instanceof Array) brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
	});
	var toolbox = option && option.toolbox;
	if (isArray(toolbox)) toolbox = toolbox[0];
	if (!toolbox) {
		toolbox = { feature: {} };
		option.toolbox = [toolbox];
	}
	var toolboxFeature = toolbox.feature || (toolbox.feature = {});
	var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
	var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
	brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
	removeDuplicate(brushTypes);
	if (isNew && !brushTypes.length) brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
}
function removeDuplicate(arr) {
	var map$2 = {};
	each(arr, function(val) {
		map$2[val] = 1;
	});
	arr.length = 0;
	each(map$2, function(flag, val) {
		arr.push(val);
	});
}

//#endregion
//#region node_modules/echarts/lib/visual/visualSolution.js
var each$5 = each;
function hasKeys(obj) {
	if (obj) {
		for (var name_1 in obj) if (obj.hasOwnProperty(name_1)) return true;
	}
}
function createVisualMappings(option, stateList, supplementVisualOption) {
	var visualMappings = {};
	each$5(stateList, function(state) {
		var mappings = visualMappings[state] = createMappings();
		each$5(option[state], function(visualData, visualType) {
			if (!VisualMapping_default.isValidType(visualType)) return;
			var mappingOption = {
				type: visualType,
				visual: visualData
			};
			supplementVisualOption && supplementVisualOption(mappingOption, state);
			mappings[visualType] = new VisualMapping_default(mappingOption);
			if (visualType === "opacity") {
				mappingOption = clone(mappingOption);
				mappingOption.type = "colorAlpha";
				mappings.__hidden.__alphaForOpacity = new VisualMapping_default(mappingOption);
			}
		});
	});
	return visualMappings;
	function createMappings() {
		var Creater = function() {};
		Creater.prototype.__hidden = Creater.prototype;
		return new Creater();
	}
}
function replaceVisualOption(thisOption, newOption, keys$1) {
	var has$2;
	each(keys$1, function(key$1) {
		if (newOption.hasOwnProperty(key$1) && hasKeys(newOption[key$1])) has$2 = true;
	});
	has$2 && each(keys$1, function(key$1) {
		if (newOption.hasOwnProperty(key$1) && hasKeys(newOption[key$1])) thisOption[key$1] = clone(newOption[key$1]);
		else delete thisOption[key$1];
	});
}
/**
* @param stateList
* @param visualMappings
* @param list
* @param getValueState param: valueOrIndex, return: state.
* @param scope Scope for getValueState
* @param dimension Concrete dimension, if used.
*/
function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
	var visualTypesMap = {};
	each(stateList, function(state) {
		visualTypesMap[state] = VisualMapping_default.prepareVisualTypes(visualMappings[state]);
	});
	var dataIndex;
	function getVisual(key$1) {
		return getItemVisualFromData(data, dataIndex, key$1);
	}
	function setVisual(key$1, value) {
		setItemVisualFromData(data, dataIndex, key$1, value);
	}
	if (dimension == null) data.each(eachItem);
	else data.each([dimension], eachItem);
	function eachItem(valueOrIndex, index) {
		dataIndex = dimension == null ? valueOrIndex : index;
		var rawDataItem = data.getRawDataItem(dataIndex);
		if (rawDataItem && rawDataItem.visualMap === false) return;
		var valueState = getValueState.call(scope, valueOrIndex);
		var mappings = visualMappings[valueState];
		var visualTypes = visualTypesMap[valueState];
		for (var i$1 = 0, len$1 = visualTypes.length; i$1 < len$1; i$1++) {
			var type = visualTypes[i$1];
			mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
		}
	}
}
/**
* @param data
* @param stateList
* @param visualMappings <state, Object.<visualType, module:echarts/visual/VisualMapping>>
* @param getValueState param: valueOrIndex, return: state.
* @param dim dimension or dimension index.
*/
function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
	var visualTypesMap = {};
	each(stateList, function(state) {
		visualTypesMap[state] = VisualMapping_default.prepareVisualTypes(visualMappings[state]);
	});
	return { progress: function progress(params, data) {
		var dimIndex;
		if (dim != null) dimIndex = data.getDimensionIndex(dim);
		function getVisual(key$1) {
			return getItemVisualFromData(data, dataIndex, key$1);
		}
		function setVisual(key$1, value$1) {
			setItemVisualFromData(data, dataIndex, key$1, value$1);
		}
		var dataIndex;
		var store = data.getStore();
		while ((dataIndex = params.next()) != null) {
			var rawDataItem = data.getRawDataItem(dataIndex);
			if (rawDataItem && rawDataItem.visualMap === false) continue;
			var value = dim != null ? store.get(dimIndex, dataIndex) : dataIndex;
			var valueState = getValueState(value);
			var mappings = visualMappings[valueState];
			var visualTypes = visualTypesMap[valueState];
			for (var i$1 = 0, len$1 = visualTypes.length; i$1 < len$1; i$1++) {
				var type = visualTypes[i$1];
				mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
			}
		}
	} };
}

//#endregion
//#region node_modules/echarts/lib/component/brush/selector.js
function makeBrushCommonSelectorForSeries(area) {
	var brushType = area.brushType;
	var selectors = {
		point: function(itemLayout) {
			return selector[brushType].point(itemLayout, selectors, area);
		},
		rect: function(itemLayout) {
			return selector[brushType].rect(itemLayout, selectors, area);
		}
	};
	return selectors;
}
var selector = {
	lineX: getLineSelectors(0),
	lineY: getLineSelectors(1),
	rect: {
		point: function(itemLayout, selectors, area) {
			return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);
		},
		rect: function(itemLayout, selectors, area) {
			return itemLayout && area.boundingRect.intersect(itemLayout);
		}
	},
	polygon: {
		point: function(itemLayout, selectors, area) {
			return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && contain(area.range, itemLayout[0], itemLayout[1]);
		},
		rect: function(itemLayout, selectors, area) {
			var points$3 = area.range;
			if (!itemLayout || points$3.length <= 1) return false;
			var x = itemLayout.x;
			var y = itemLayout.y;
			var width = itemLayout.width;
			var height = itemLayout.height;
			var p = points$3[0];
			if (contain(points$3, x, y) || contain(points$3, x + width, y) || contain(points$3, x, y + height) || contain(points$3, x + width, y + height) || BoundingRect_default.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x, y, x + width, y, points$3) || linePolygonIntersect(x, y, x, y + height, points$3) || linePolygonIntersect(x + width, y, x + width, y + height, points$3) || linePolygonIntersect(x, y + height, x + width, y + height, points$3)) return true;
		}
	}
};
function getLineSelectors(xyIndex) {
	var xy = ["x", "y"];
	var wh = ["width", "height"];
	return {
		point: function(itemLayout, selectors, area) {
			if (itemLayout) {
				var range = area.range;
				var p = itemLayout[xyIndex];
				return inLineRange(p, range);
			}
		},
		rect: function(itemLayout, selectors, area) {
			if (itemLayout) {
				var range = area.range;
				var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];
				layoutRange[1] < layoutRange[0] && layoutRange.reverse();
				return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
			}
		}
	};
}
function inLineRange(p, range) {
	return range[0] <= p && p <= range[1];
}

//#endregion
//#region node_modules/echarts/lib/component/brush/visualEncoding.js
var STATE_LIST = ["inBrush", "outOfBrush"];
var DISPATCH_METHOD = "__ecBrushSelect";
var DISPATCH_FLAG = "__ecInBrushSelectEvent";
function layoutCovers(ecModel) {
	ecModel.eachComponent({ mainType: "brush" }, function(brushModel) {
		(brushModel.brushTargetManager = new BrushTargetManager_default(brushModel.option, ecModel)).setInputRanges(brushModel.areas, ecModel);
	});
}
/**
* Register the visual encoding if this modules required.
*/
function brushVisual(ecModel, api, payload) {
	var brushSelected = [];
	var throttleType;
	var throttleDelay;
	ecModel.eachComponent({ mainType: "brush" }, function(brushModel) {
		payload && payload.type === "takeGlobalCursor" && brushModel.setBrushOption(payload.key === "brush" ? payload.brushOption : { brushType: false });
	});
	layoutCovers(ecModel);
	ecModel.eachComponent({ mainType: "brush" }, function(brushModel, brushIndex) {
		var thisBrushSelected = {
			brushId: brushModel.id,
			brushIndex,
			brushName: brushModel.name,
			areas: clone(brushModel.areas),
			selected: []
		};
		brushSelected.push(thisBrushSelected);
		var brushOption = brushModel.option;
		var brushLink = brushOption.brushLink;
		var linkedSeriesMap = [];
		var selectedDataIndexForLink = [];
		var rangeInfoBySeries = [];
		var hasBrushExists = false;
		if (!brushIndex) {
			throttleType = brushOption.throttleType;
			throttleDelay = brushOption.throttleDelay;
		}
		var areas = map(brushModel.areas, function(area) {
			var builder = boundingRectBuilders[area.brushType];
			var selectableArea = defaults({ boundingRect: builder ? builder(area) : void 0 }, area);
			selectableArea.selectors = makeBrushCommonSelectorForSeries(selectableArea);
			return selectableArea;
		});
		var visualMappings = createVisualMappings(brushModel.option, STATE_LIST, function(mappingOption) {
			mappingOption.mappingMethod = "fixed";
		});
		isArray(brushLink) && each(brushLink, function(seriesIndex) {
			linkedSeriesMap[seriesIndex] = 1;
		});
		function linkOthers(seriesIndex) {
			return brushLink === "all" || !!linkedSeriesMap[seriesIndex];
		}
		function brushed(rangeInfoList) {
			return !!rangeInfoList.length;
		}
		/**
		* Logic for each series: (If the logic has to be modified one day, do it carefully!)
		*
		* ( brushed  && hasBrushExist  && linkOthers  ) => StepA: record,  StepB: visualByRecord.
		*   !brushed    hasBrushExist                             nothing,        visualByRecord.
		*                !hasBrushExist                                              nothing.
		* ( !brushed  && hasBrushExist  && linkOthers  ) => StepA:  nothing,  StepB: visualByRecord.
		*                !hasBrushExist                                              nothing.
		* ( brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB: visualByCheck.
		*   !brushed                                                                  nothing.
		* ( !brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB:  nothing.
		*/
		ecModel.eachSeries(function(seriesModel, seriesIndex) {
			var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
			seriesModel.subType === "parallel" ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
		});
		function stepAParallel(seriesModel, seriesIndex) {
			var coordSys = seriesModel.coordinateSystem;
			hasBrushExists = hasBrushExists || coordSys.hasAxisBrushed();
			linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function(activeState, dataIndex) {
				activeState === "active" && (selectedDataIndexForLink[dataIndex] = 1);
			});
		}
		function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
			if (!seriesModel.brushSelector || brushModelNotControll(brushModel, seriesIndex)) return;
			each(areas, function(area) {
				if (brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel)) rangeInfoList.push(area);
				hasBrushExists = hasBrushExists || brushed(rangeInfoList);
			});
			if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
				var data_1 = seriesModel.getData();
				data_1.each(function(dataIndex) {
					if (checkInRange(seriesModel, rangeInfoList, data_1, dataIndex)) selectedDataIndexForLink[dataIndex] = 1;
				});
			}
		}
		ecModel.eachSeries(function(seriesModel, seriesIndex) {
			var seriesBrushSelected = {
				seriesId: seriesModel.id,
				seriesIndex,
				seriesName: seriesModel.name,
				dataIndex: []
			};
			thisBrushSelected.selected.push(seriesBrushSelected);
			var rangeInfoList = rangeInfoBySeries[seriesIndex];
			var data = seriesModel.getData();
			var getValueState = linkOthers(seriesIndex) ? function(dataIndex) {
				return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
			} : function(dataIndex) {
				return checkInRange(seriesModel, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
			};
			(linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && applyVisual(STATE_LIST, visualMappings, data, getValueState);
		});
	});
	dispatchAction$1(api, throttleType, throttleDelay, brushSelected, payload);
}
function dispatchAction$1(api, throttleType, throttleDelay, brushSelected, payload) {
	if (!payload) return;
	var zr = api.getZr();
	if (zr[DISPATCH_FLAG]) return;
	if (!zr[DISPATCH_METHOD]) zr[DISPATCH_METHOD] = doDispatch;
	createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType)(api, brushSelected);
}
function doDispatch(api, brushSelected) {
	if (!api.isDisposed()) {
		var zr = api.getZr();
		zr[DISPATCH_FLAG] = true;
		api.dispatchAction({
			type: "brushSelect",
			batch: brushSelected
		});
		zr[DISPATCH_FLAG] = false;
	}
}
function checkInRange(seriesModel, rangeInfoList, data, dataIndex) {
	for (var i$1 = 0, len$1 = rangeInfoList.length; i$1 < len$1; i$1++) {
		var area = rangeInfoList[i$1];
		if (seriesModel.brushSelector(dataIndex, data, area.selectors, area)) return true;
	}
}
function brushModelNotControll(brushModel, seriesIndex) {
	var seriesIndices = brushModel.option.seriesIndex;
	return seriesIndices != null && seriesIndices !== "all" && (isArray(seriesIndices) ? indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
}
var boundingRectBuilders = {
	rect: function(area) {
		return getBoundingRectFromMinMax(area.range);
	},
	polygon: function(area) {
		var minMax;
		var range = area.range;
		for (var i$1 = 0, len$1 = range.length; i$1 < len$1; i$1++) {
			minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
			var rg = range[i$1];
			rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
			rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
			rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
			rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
		}
		return minMax && getBoundingRectFromMinMax(minMax);
	}
};
function getBoundingRectFromMinMax(minMax) {
	return new BoundingRect_default(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
}

//#endregion
//#region node_modules/echarts/lib/component/brush/BrushView.js
var BrushView = function(_super) {
	__extends(BrushView$1, _super);
	function BrushView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = BrushView$1.type;
		return _this;
	}
	BrushView$1.prototype.init = function(ecModel, api) {
		this.ecModel = ecModel;
		this.api = api;
		this.model;
		(this._brushController = new BrushController_default(api.getZr())).on("brush", bind(this._onBrush, this)).mount();
	};
	BrushView$1.prototype.render = function(brushModel, ecModel, api, payload) {
		this.model = brushModel;
		this._updateController(brushModel, ecModel, api, payload);
	};
	BrushView$1.prototype.updateTransform = function(brushModel, ecModel, api, payload) {
		layoutCovers(ecModel);
		this._updateController(brushModel, ecModel, api, payload);
	};
	BrushView$1.prototype.updateVisual = function(brushModel, ecModel, api, payload) {
		this.updateTransform(brushModel, ecModel, api, payload);
	};
	BrushView$1.prototype.updateView = function(brushModel, ecModel, api, payload) {
		this._updateController(brushModel, ecModel, api, payload);
	};
	BrushView$1.prototype._updateController = function(brushModel, ecModel, api, payload) {
		(!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
	};
	BrushView$1.prototype.dispose = function() {
		this._brushController.dispose();
	};
	BrushView$1.prototype._onBrush = function(eventParam) {
		var modelId = this.model.id;
		var areas = this.model.brushTargetManager.setOutputRanges(eventParam.areas, this.ecModel);
		(!eventParam.isEnd || eventParam.removeOnClick) && this.api.dispatchAction({
			type: "brush",
			brushId: modelId,
			areas: clone(areas),
			$from: modelId
		});
		eventParam.isEnd && this.api.dispatchAction({
			type: "brushEnd",
			brushId: modelId,
			areas: clone(areas),
			$from: modelId
		});
	};
	BrushView$1.type = "brush";
	return BrushView$1;
}(Component_default$1);
var BrushView_default = BrushView;

//#endregion
//#region node_modules/echarts/lib/component/brush/BrushModel.js
var BrushModel = function(_super) {
	__extends(BrushModel$1, _super);
	function BrushModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = BrushModel$1.type;
		/**
		* @readOnly
		*/
		_this.areas = [];
		/**
		* Current brush painting area settings.
		* @readOnly
		*/
		_this.brushOption = {};
		return _this;
	}
	BrushModel$1.prototype.optionUpdated = function(newOption, isInit) {
		var thisOption = this.option;
		!isInit && replaceVisualOption(thisOption, newOption, ["inBrush", "outOfBrush"]);
		var inBrush = thisOption.inBrush = thisOption.inBrush || {};
		thisOption.outOfBrush = thisOption.outOfBrush || { color: this.option.defaultOutOfBrushColor };
		if (!inBrush.hasOwnProperty("liftZ")) inBrush.liftZ = 5;
	};
	/**
	* If `areas` is null/undefined, range state remain.
	*/
	BrushModel$1.prototype.setAreas = function(areas) {
		assert(isArray(areas));
		each(areas, function(area) {
			assert(area.brushType, "Illegal areas");
		});
		if (!areas) return;
		this.areas = map(areas, function(area) {
			return generateBrushOption(this.option, area);
		}, this);
	};
	/**
	* Set the current painting brush option.
	*/
	BrushModel$1.prototype.setBrushOption = function(brushOption) {
		this.brushOption = generateBrushOption(this.option, brushOption);
		this.brushType = this.brushOption.brushType;
	};
	BrushModel$1.type = "brush";
	BrushModel$1.dependencies = [
		"geo",
		"grid",
		"xAxis",
		"yAxis",
		"parallel",
		"series"
	];
	BrushModel$1.defaultOption = {
		seriesIndex: "all",
		brushType: "rect",
		brushMode: "single",
		transformable: true,
		brushStyle: {
			borderWidth: 1,
			color: tokens_default.color.backgroundTint,
			borderColor: tokens_default.color.borderTint
		},
		throttleType: "fixRate",
		throttleDelay: 0,
		removeOnClick: true,
		z: 1e4,
		defaultOutOfBrushColor: tokens_default.color.disabled
	};
	return BrushModel$1;
}(Component_default);
function generateBrushOption(option, brushOption) {
	return merge({
		brushType: option.brushType,
		brushMode: option.brushMode,
		transformable: option.transformable,
		brushStyle: new Model_default(option.brushStyle).getItemStyle(),
		removeOnClick: option.removeOnClick,
		z: option.z
	}, brushOption, true);
}
var BrushModel_default = BrushModel;

//#endregion
//#region node_modules/echarts/lib/component/toolbox/feature/Brush.js
var ICON_TYPES = [
	"rect",
	"polygon",
	"lineX",
	"lineY",
	"keep",
	"clear"
];
var BrushFeature = function(_super) {
	__extends(BrushFeature$1, _super);
	function BrushFeature$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	BrushFeature$1.prototype.render = function(featureModel, ecModel, api) {
		var brushType;
		var brushMode;
		var isBrushed;
		ecModel.eachComponent({ mainType: "brush" }, function(brushModel) {
			brushType = brushModel.brushType;
			brushMode = brushModel.brushOption.brushMode || "single";
			isBrushed = isBrushed || !!brushModel.areas.length;
		});
		this._brushType = brushType;
		this._brushMode = brushMode;
		each(featureModel.get("type", true), function(type) {
			featureModel.setIconStatus(type, (type === "keep" ? brushMode === "multiple" : type === "clear" ? isBrushed : type === brushType) ? "emphasis" : "normal");
		});
	};
	BrushFeature$1.prototype.updateView = function(featureModel, ecModel, api) {
		this.render(featureModel, ecModel, api);
	};
	BrushFeature$1.prototype.getIcons = function() {
		var model = this.model;
		var availableIcons = model.get("icon", true);
		var icons = {};
		each(model.get("type", true), function(type) {
			if (availableIcons[type]) icons[type] = availableIcons[type];
		});
		return icons;
	};
	BrushFeature$1.prototype.onclick = function(ecModel, api, type) {
		var brushType = this._brushType;
		var brushMode = this._brushMode;
		if (type === "clear") {
			api.dispatchAction({
				type: "axisAreaSelect",
				intervals: []
			});
			api.dispatchAction({
				type: "brush",
				command: "clear",
				areas: []
			});
		} else api.dispatchAction({
			type: "takeGlobalCursor",
			key: "brush",
			brushOption: {
				brushType: type === "keep" ? brushType : brushType === type ? false : type,
				brushMode: type === "keep" ? brushMode === "multiple" ? "single" : "multiple" : brushMode
			}
		});
	};
	BrushFeature$1.getDefaultOption = function(ecModel) {
		return {
			show: true,
			type: ICON_TYPES.slice(),
			icon: {
				rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
				polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
				lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
				lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
				keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
				clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
			},
			title: ecModel.getLocaleModel().get([
				"toolbox",
				"brush",
				"title"
			])
		};
	};
	return BrushFeature$1;
}(ToolboxFeature);
var Brush_default = BrushFeature;

//#endregion
//#region node_modules/echarts/lib/component/brush/install.js
function install$36(registers) {
	registers.registerComponentView(BrushView_default);
	registers.registerComponentModel(BrushModel_default);
	registers.registerPreprocessor(brushPreprocessor);
	registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, brushVisual);
	registers.registerAction({
		type: "brush",
		event: "brush",
		update: "updateVisual"
	}, function(payload, ecModel) {
		ecModel.eachComponent({
			mainType: "brush",
			query: payload
		}, function(brushModel) {
			brushModel.setAreas(payload.areas);
		});
	});
	/**
	* payload: {
	*      brushComponents: [
	*          {
	*              brushId,
	*              brushIndex,
	*              brushName,
	*              series: [
	*                  {
	*                      seriesId,
	*                      seriesIndex,
	*                      seriesName,
	*                      rawIndices: [21, 34, ...]
	*                  },
	*                  ...
	*              ]
	*          },
	*          ...
	*      ]
	* }
	*/
	registers.registerAction({
		type: "brushSelect",
		event: "brushSelected",
		update: "none"
	}, noop);
	registers.registerAction({
		type: "brushEnd",
		event: "brushEnd",
		update: "none"
	}, noop);
	registerFeature("brush", Brush_default);
}

//#endregion
//#region node_modules/echarts/lib/component/title/install.js
var TitleModel = function(_super) {
	__extends(TitleModel$1, _super);
	function TitleModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = TitleModel$1.type;
		_this.layoutMode = {
			type: "box",
			ignoreSize: true
		};
		return _this;
	}
	TitleModel$1.type = "title";
	TitleModel$1.defaultOption = {
		z: 6,
		show: true,
		text: "",
		target: "blank",
		subtext: "",
		subtarget: "blank",
		left: "center",
		top: tokens_default.size.m,
		backgroundColor: tokens_default.color.transparent,
		borderColor: tokens_default.color.primary,
		borderWidth: 0,
		padding: 5,
		itemGap: 10,
		textStyle: {
			fontSize: 18,
			fontWeight: "bold",
			color: tokens_default.color.primary
		},
		subtextStyle: {
			fontSize: 12,
			color: tokens_default.color.quaternary
		}
	};
	return TitleModel$1;
}(Component_default);
var TitleView = function(_super) {
	__extends(TitleView$1, _super);
	function TitleView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = TitleView$1.type;
		return _this;
	}
	TitleView$1.prototype.render = function(titleModel, ecModel, api) {
		this.group.removeAll();
		if (!titleModel.get("show")) return;
		var group = this.group;
		var textStyleModel = titleModel.getModel("textStyle");
		var subtextStyleModel = titleModel.getModel("subtextStyle");
		var textAlign = titleModel.get("textAlign");
		var textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
		var textEl = new Text_default({
			style: createTextStyle(textStyleModel, {
				text: titleModel.get("text"),
				fill: textStyleModel.getTextColor()
			}, { disableBox: true }),
			z2: 10
		});
		var textRect = textEl.getBoundingRect();
		var subText = titleModel.get("subtext");
		var subTextEl = new Text_default({
			style: createTextStyle(subtextStyleModel, {
				text: subText,
				fill: subtextStyleModel.getTextColor(),
				y: textRect.height + titleModel.get("itemGap"),
				verticalAlign: "top"
			}, { disableBox: true }),
			z2: 10
		});
		var link = titleModel.get("link");
		var sublink = titleModel.get("sublink");
		var triggerEvent = titleModel.get("triggerEvent", true);
		textEl.silent = !link && !triggerEvent;
		subTextEl.silent = !sublink && !triggerEvent;
		if (link) textEl.on("click", function() {
			windowOpen(link, "_" + titleModel.get("target"));
		});
		if (sublink) subTextEl.on("click", function() {
			windowOpen(sublink, "_" + titleModel.get("subtarget"));
		});
		getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
			componentType: "title",
			componentIndex: titleModel.componentIndex
		} : null;
		group.add(textEl);
		subText && group.add(subTextEl);
		var groupRect = group.getBoundingRect();
		var layoutOption = titleModel.getBoxLayoutParams();
		layoutOption.width = groupRect.width;
		layoutOption.height = groupRect.height;
		var layoutRect = getLayoutRect(layoutOption, createBoxLayoutReference(titleModel, api).refContainer, titleModel.get("padding"));
		if (!textAlign) {
			textAlign = titleModel.get("left") || titleModel.get("right");
			if (textAlign === "middle") textAlign = "center";
			if (textAlign === "right") layoutRect.x += layoutRect.width;
			else if (textAlign === "center") layoutRect.x += layoutRect.width / 2;
		}
		if (!textVerticalAlign) {
			textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
			if (textVerticalAlign === "center") textVerticalAlign = "middle";
			if (textVerticalAlign === "bottom") layoutRect.y += layoutRect.height;
			else if (textVerticalAlign === "middle") layoutRect.y += layoutRect.height / 2;
			textVerticalAlign = textVerticalAlign || "top";
		}
		group.x = layoutRect.x;
		group.y = layoutRect.y;
		group.markRedraw();
		var alignStyle = {
			align: textAlign,
			verticalAlign: textVerticalAlign
		};
		textEl.setStyle(alignStyle);
		subTextEl.setStyle(alignStyle);
		groupRect = group.getBoundingRect();
		var padding = layoutRect.margin;
		var style = titleModel.getItemStyle(["color", "opacity"]);
		style.fill = titleModel.get("backgroundColor");
		var rect = new Rect_default({
			shape: {
				x: groupRect.x - padding[3],
				y: groupRect.y - padding[0],
				width: groupRect.width + padding[1] + padding[3],
				height: groupRect.height + padding[0] + padding[2],
				r: titleModel.get("borderRadius")
			},
			style,
			subPixelOptimize: true,
			silent: true
		});
		group.add(rect);
	};
	TitleView$1.type = "title";
	return TitleView$1;
}(Component_default$1);
function install$37(registers) {
	registers.registerComponentModel(TitleModel);
	registers.registerComponentView(TitleView);
}

//#endregion
//#region node_modules/echarts/lib/component/timeline/TimelineModel.js
var TimelineModel = function(_super) {
	__extends(TimelineModel$1, _super);
	function TimelineModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = TimelineModel$1.type;
		_this.layoutMode = "box";
		return _this;
	}
	/**
	* @override
	*/
	TimelineModel$1.prototype.init = function(option, parentModel, ecModel) {
		this.mergeDefaultAndTheme(option, ecModel);
		this._initData();
	};
	/**
	* @override
	*/
	TimelineModel$1.prototype.mergeOption = function(option) {
		_super.prototype.mergeOption.apply(this, arguments);
		this._initData();
	};
	TimelineModel$1.prototype.setCurrentIndex = function(currentIndex) {
		if (currentIndex == null) currentIndex = this.option.currentIndex;
		var count$1 = this._data.count();
		if (this.option.loop) currentIndex = (currentIndex % count$1 + count$1) % count$1;
		else {
			currentIndex >= count$1 && (currentIndex = count$1 - 1);
			currentIndex < 0 && (currentIndex = 0);
		}
		this.option.currentIndex = currentIndex;
	};
	/**
	* @return {number} currentIndex
	*/
	TimelineModel$1.prototype.getCurrentIndex = function() {
		return this.option.currentIndex;
	};
	/**
	* @return {boolean}
	*/
	TimelineModel$1.prototype.isIndexMax = function() {
		return this.getCurrentIndex() >= this._data.count() - 1;
	};
	/**
	* @param {boolean} state true: play, false: stop
	*/
	TimelineModel$1.prototype.setPlayState = function(state) {
		this.option.autoPlay = !!state;
	};
	/**
	* @return {boolean} true: play, false: stop
	*/
	TimelineModel$1.prototype.getPlayState = function() {
		return !!this.option.autoPlay;
	};
	/**
	* @private
	*/
	TimelineModel$1.prototype._initData = function() {
		var thisOption = this.option;
		var dataArr = thisOption.data || [];
		var axisType = thisOption.axisType;
		var names = this._names = [];
		var processedDataArr;
		if (axisType === "category") {
			processedDataArr = [];
			each(dataArr, function(item, index) {
				var value = convertOptionIdName(getDataItemValue(item), "");
				var newItem;
				if (isObject(item)) {
					newItem = clone(item);
					newItem.value = index;
				} else newItem = index;
				processedDataArr.push(newItem);
				names.push(value);
			});
		} else processedDataArr = dataArr;
		(this._data = new SeriesData_default([{
			name: "value",
			type: {
				category: "ordinal",
				time: "time",
				value: "number"
			}[axisType] || "number"
		}], this)).initData(processedDataArr, names);
	};
	TimelineModel$1.prototype.getData = function() {
		return this._data;
	};
	/**
	* @public
	* @return {Array.<string>} categoreis
	*/
	TimelineModel$1.prototype.getCategories = function() {
		if (this.get("axisType") === "category") return this._names.slice();
	};
	TimelineModel$1.type = "timeline";
	/**
	* @protected
	*/
	TimelineModel$1.defaultOption = {
		z: 4,
		show: true,
		axisType: "time",
		realtime: true,
		left: "20%",
		top: null,
		right: "20%",
		bottom: 0,
		width: null,
		height: 40,
		padding: tokens_default.size.m,
		controlPosition: "left",
		autoPlay: false,
		rewind: false,
		loop: true,
		playInterval: 2e3,
		currentIndex: 0,
		itemStyle: {},
		label: { color: tokens_default.color.secondary },
		data: []
	};
	return TimelineModel$1;
}(Component_default);
var TimelineModel_default = TimelineModel;

//#endregion
//#region node_modules/echarts/lib/component/timeline/SliderTimelineModel.js
var SliderTimelineModel = function(_super) {
	__extends(SliderTimelineModel$1, _super);
	function SliderTimelineModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SliderTimelineModel$1.type;
		return _this;
	}
	SliderTimelineModel$1.type = "timeline.slider";
	/**
	* @protected
	*/
	SliderTimelineModel$1.defaultOption = inheritDefaultOption(TimelineModel_default.defaultOption, {
		backgroundColor: "rgba(0,0,0,0)",
		borderColor: tokens_default.color.border,
		borderWidth: 0,
		orient: "horizontal",
		inverse: false,
		tooltip: { trigger: "item" },
		symbol: "circle",
		symbolSize: 12,
		lineStyle: {
			show: true,
			width: 2,
			color: tokens_default.color.accent10
		},
		label: {
			position: "auto",
			show: true,
			interval: "auto",
			rotate: 0,
			color: tokens_default.color.tertiary
		},
		itemStyle: {
			color: tokens_default.color.accent20,
			borderWidth: 0
		},
		checkpointStyle: {
			symbol: "circle",
			symbolSize: 15,
			color: tokens_default.color.accent50,
			borderColor: tokens_default.color.accent50,
			borderWidth: 0,
			shadowBlur: 0,
			shadowOffsetX: 0,
			shadowOffsetY: 0,
			shadowColor: "rgba(0, 0, 0, 0)",
			animation: true,
			animationDuration: 300,
			animationEasing: "quinticInOut"
		},
		controlStyle: {
			show: true,
			showPlayBtn: true,
			showPrevBtn: true,
			showNextBtn: true,
			itemSize: 24,
			itemGap: 12,
			position: "left",
			playIcon: "path://M15 0C23.2843 0 30 6.71573 30 15C30 23.2843 23.2843 30 15 30C6.71573 30 0 23.2843 0 15C0 6.71573 6.71573 0 15 0ZM15 3C8.37258 3 3 8.37258 3 15C3 21.6274 8.37258 27 15 27C21.6274 27 27 21.6274 27 15C27 8.37258 21.6274 3 15 3ZM11.5 10.6699C11.5 9.90014 12.3333 9.41887 13 9.80371L20.5 14.1338C21.1667 14.5187 21.1667 15.4813 20.5 15.8662L13 20.1963C12.3333 20.5811 11.5 20.0999 11.5 19.3301V10.6699Z",
			stopIcon: "path://M15 0C23.2843 0 30 6.71573 30 15C30 23.2843 23.2843 30 15 30C6.71573 30 0 23.2843 0 15C0 6.71573 6.71573 0 15 0ZM15 3C8.37258 3 3 8.37258 3 15C3 21.6274 8.37258 27 15 27C21.6274 27 27 21.6274 27 15C27 8.37258 21.6274 3 15 3ZM11.5 10C12.3284 10 13 10.6716 13 11.5V18.5C13 19.3284 12.3284 20 11.5 20C10.6716 20 10 19.3284 10 18.5V11.5C10 10.6716 10.6716 10 11.5 10ZM18.5 10C19.3284 10 20 10.6716 20 11.5V18.5C20 19.3284 19.3284 20 18.5 20C17.6716 20 17 19.3284 17 18.5V11.5C17 10.6716 17.6716 10 18.5 10Z",
			nextIcon: "path://M0.838834 18.7383C0.253048 18.1525 0.253048 17.2028 0.838834 16.617L7.55635 9.89949L0.838834 3.18198C0.253048 2.59619 0.253048 1.64645 0.838834 1.06066C1.42462 0.474874 2.37437 0.474874 2.96015 1.06066L10.7383 8.83883L10.8412 8.95277C11.2897 9.50267 11.2897 10.2963 10.8412 10.8462L10.7383 10.9602L2.96015 18.7383C2.37437 19.3241 1.42462 19.3241 0.838834 18.7383Z",
			prevIcon: "path://M10.9602 1.06066C11.5459 1.64645 11.5459 2.59619 10.9602 3.18198L4.24264 9.89949L10.9602 16.617C11.5459 17.2028 11.5459 18.1525 10.9602 18.7383C10.3744 19.3241 9.42462 19.3241 8.83883 18.7383L1.06066 10.9602L0.957771 10.8462C0.509245 10.2963 0.509245 9.50267 0.957771 8.95277L1.06066 8.83883L8.83883 1.06066C9.42462 0.474874 10.3744 0.474874 10.9602 1.06066Z",
			prevBtnSize: 18,
			nextBtnSize: 18,
			color: tokens_default.color.accent50,
			borderColor: tokens_default.color.accent50,
			borderWidth: 0
		},
		emphasis: {
			label: {
				show: true,
				color: tokens_default.color.accent60
			},
			itemStyle: {
				color: tokens_default.color.accent60,
				borderColor: tokens_default.color.accent60
			},
			controlStyle: {
				color: tokens_default.color.accent70,
				borderColor: tokens_default.color.accent70
			}
		},
		progress: {
			lineStyle: { color: tokens_default.color.accent30 },
			itemStyle: { color: tokens_default.color.accent40 }
		},
		data: []
	});
	return SliderTimelineModel$1;
}(TimelineModel_default);
mixin(SliderTimelineModel, DataFormatMixin.prototype);
var SliderTimelineModel_default = SliderTimelineModel;

//#endregion
//#region node_modules/echarts/lib/component/timeline/TimelineView.js
var TimelineView = function(_super) {
	__extends(TimelineView$1, _super);
	function TimelineView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = TimelineView$1.type;
		return _this;
	}
	TimelineView$1.type = "timeline";
	return TimelineView$1;
}(Component_default$1);
var TimelineView_default = TimelineView;

//#endregion
//#region node_modules/echarts/lib/component/timeline/TimelineAxis.js
/**
* Extend axis 2d
*/
var TimelineAxis = function(_super) {
	__extends(TimelineAxis$1, _super);
	function TimelineAxis$1(dim, scale$3, coordExtent, axisType) {
		var _this = _super.call(this, dim, scale$3, coordExtent) || this;
		_this.type = axisType || "value";
		return _this;
	}
	/**
	* @override
	*/
	TimelineAxis$1.prototype.getLabelModel = function() {
		return this.model.getModel("label");
	};
	/**
	* @override
	*/
	TimelineAxis$1.prototype.isHorizontal = function() {
		return this.model.get("orient") === "horizontal";
	};
	return TimelineAxis$1;
}(Axis_default);
var TimelineAxis_default = TimelineAxis;

//#endregion
//#region node_modules/echarts/lib/component/timeline/SliderTimelineView.js
var PI = Math.PI;
var labelDataIndexStore = makeInner();
var SliderTimelineView = function(_super) {
	__extends(SliderTimelineView$1, _super);
	function SliderTimelineView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SliderTimelineView$1.type;
		return _this;
	}
	SliderTimelineView$1.prototype.init = function(ecModel, api) {
		this.api = api;
	};
	/**
	* @override
	*/
	SliderTimelineView$1.prototype.render = function(timelineModel, ecModel, api) {
		this.model = timelineModel;
		this.api = api;
		this.ecModel = ecModel;
		this.group.removeAll();
		if (timelineModel.get("show", true)) {
			var layoutInfo_1 = this._layout(timelineModel, api);
			var mainGroup_1 = this._createGroup("_mainGroup");
			var labelGroup = this._createGroup("_labelGroup");
			var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);
			timelineModel.formatTooltip = function(dataIndex) {
				return createTooltipMarkup("nameValue", {
					noName: true,
					value: axis_1.scale.getLabel({ value: dataIndex })
				});
			};
			each([
				"AxisLine",
				"AxisTick",
				"Control",
				"CurrentPointer"
			], function(name) {
				this["_render" + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);
			}, this);
			this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);
			this._position(layoutInfo_1, timelineModel);
		}
		this._doPlayStop();
		this._updateTicksStatus();
	};
	/**
	* @override
	*/
	SliderTimelineView$1.prototype.remove = function() {
		this._clearTimer();
		this.group.removeAll();
	};
	/**
	* @override
	*/
	SliderTimelineView$1.prototype.dispose = function() {
		this._clearTimer();
	};
	SliderTimelineView$1.prototype._layout = function(timelineModel, api) {
		var labelPosOpt = timelineModel.get(["label", "position"]);
		var orient = timelineModel.get("orient");
		var viewRect$1 = getViewRect(timelineModel, api);
		var parsedLabelPos;
		if (labelPosOpt == null || labelPosOpt === "auto") parsedLabelPos = orient === "horizontal" ? viewRect$1.y + viewRect$1.height / 2 < api.getHeight() / 2 ? "-" : "+" : viewRect$1.x + viewRect$1.width / 2 < api.getWidth() / 2 ? "+" : "-";
		else if (isString(labelPosOpt)) parsedLabelPos = {
			horizontal: {
				top: "-",
				bottom: "+"
			},
			vertical: {
				left: "-",
				right: "+"
			}
		}[orient][labelPosOpt];
		else parsedLabelPos = labelPosOpt;
		var labelAlignMap = {
			horizontal: "center",
			vertical: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "left" : "right"
		};
		var labelBaselineMap = {
			horizontal: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "top" : "bottom",
			vertical: "middle"
		};
		var rotationMap = {
			horizontal: 0,
			vertical: PI / 2
		};
		var mainLength = orient === "vertical" ? viewRect$1.height : viewRect$1.width;
		var controlModel = timelineModel.getModel("controlStyle");
		var showControl = controlModel.get("show", true);
		var controlSize = showControl ? controlModel.get("itemSize") : 0;
		var controlGap = showControl ? controlModel.get("itemGap") : 0;
		var sizePlusGap = controlSize + controlGap;
		var labelRotation = timelineModel.get(["label", "rotate"]) || 0;
		labelRotation = labelRotation * PI / 180;
		var playPosition;
		var prevBtnPosition;
		var nextBtnPosition;
		var controlPosition = controlModel.get("position", true);
		var showPlayBtn = showControl && controlModel.get("showPlayBtn", true);
		var showPrevBtn = showControl && controlModel.get("showPrevBtn", true);
		var showNextBtn = showControl && controlModel.get("showNextBtn", true);
		var xLeft = 0;
		var xRight = mainLength;
		if (controlPosition === "left" || controlPosition === "bottom") {
			showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
			showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
			showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
		} else {
			showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
			showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
			showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
		}
		var axisExtent = [xLeft, xRight];
		if (timelineModel.get("inverse")) axisExtent.reverse();
		return {
			viewRect: viewRect$1,
			mainLength,
			orient,
			rotation: rotationMap[orient],
			labelRotation,
			labelPosOpt: parsedLabelPos,
			labelAlign: timelineModel.get(["label", "align"]) || labelAlignMap[orient],
			labelBaseline: timelineModel.get(["label", "verticalAlign"]) || timelineModel.get(["label", "baseline"]) || labelBaselineMap[orient],
			playPosition,
			prevBtnPosition,
			nextBtnPosition,
			axisExtent,
			controlSize,
			controlGap
		};
	};
	SliderTimelineView$1.prototype._position = function(layoutInfo, timelineModel) {
		var mainGroup = this._mainGroup;
		var labelGroup = this._labelGroup;
		var viewRect$1 = layoutInfo.viewRect;
		if (layoutInfo.orient === "vertical") {
			var m$1 = create$2();
			var rotateOriginX = viewRect$1.x;
			var rotateOriginY = viewRect$1.y + viewRect$1.height;
			translate(m$1, m$1, [-rotateOriginX, -rotateOriginY]);
			rotate(m$1, m$1, -PI / 2);
			translate(m$1, m$1, [rotateOriginX, rotateOriginY]);
			viewRect$1 = viewRect$1.clone();
			viewRect$1.applyTransform(m$1);
		}
		var viewBound = getBound(viewRect$1);
		var mainBound = getBound(mainGroup.getBoundingRect());
		var labelBound = getBound(labelGroup.getBoundingRect());
		var mainPosition = [mainGroup.x, mainGroup.y];
		var labelsPosition = [labelGroup.x, labelGroup.y];
		labelsPosition[0] = mainPosition[0] = viewBound[0][0];
		var labelPosOpt = layoutInfo.labelPosOpt;
		if (labelPosOpt == null || isString(labelPosOpt)) {
			var mainBoundIdx = labelPosOpt === "+" ? 0 : 1;
			toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
			toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
		} else {
			var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
			toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
			labelsPosition[1] = mainPosition[1] + labelPosOpt;
		}
		mainGroup.setPosition(mainPosition);
		labelGroup.setPosition(labelsPosition);
		mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
		setOrigin(mainGroup);
		setOrigin(labelGroup);
		function setOrigin(targetGroup) {
			targetGroup.originX = viewBound[0][0] - targetGroup.x;
			targetGroup.originY = viewBound[1][0] - targetGroup.y;
		}
		function getBound(rect) {
			return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
		}
		function toBound(fromPos, from, to, dimIdx, boundIdx) {
			fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
		}
	};
	SliderTimelineView$1.prototype._createAxis = function(layoutInfo, timelineModel) {
		var data = timelineModel.getData();
		var axisType = timelineModel.get("axisType");
		var scale$3 = createScaleByModel(timelineModel, axisType);
		scale$3.getTicks = function() {
			return data.mapArray(["value"], function(value) {
				return { value };
			});
		};
		var dataExtent = data.getDataExtent("value");
		scale$3.setExtent(dataExtent[0], dataExtent[1]);
		scale$3.calcNiceTicks();
		var axis = new TimelineAxis_default("value", scale$3, layoutInfo.axisExtent, axisType);
		axis.model = timelineModel;
		return axis;
	};
	SliderTimelineView$1.prototype._createGroup = function(key$1) {
		var newGroup = this[key$1] = new Group_default();
		this.group.add(newGroup);
		return newGroup;
	};
	SliderTimelineView$1.prototype._renderAxisLine = function(layoutInfo, group, axis, timelineModel) {
		var axisExtent = axis.getExtent();
		if (!timelineModel.get(["lineStyle", "show"])) return;
		var line = new Line_default({
			shape: {
				x1: axisExtent[0],
				y1: 0,
				x2: axisExtent[1],
				y2: 0
			},
			style: extend({ lineCap: "round" }, timelineModel.getModel("lineStyle").getLineStyle()),
			silent: true,
			z2: 1
		});
		group.add(line);
		var progressLine = this._progressLine = new Line_default({
			shape: {
				x1: axisExtent[0],
				x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],
				y1: 0,
				y2: 0
			},
			style: defaults({
				lineCap: "round",
				lineWidth: line.style.lineWidth
			}, timelineModel.getModel(["progress", "lineStyle"]).getLineStyle()),
			silent: true,
			z2: 1
		});
		group.add(progressLine);
	};
	SliderTimelineView$1.prototype._renderAxisTick = function(layoutInfo, group, axis, timelineModel) {
		var _this = this;
		var data = timelineModel.getData();
		var ticks = axis.scale.getTicks();
		this._tickSymbols = [];
		each(ticks, function(tick) {
			var tickCoord = axis.dataToCoord(tick.value);
			var itemModel = data.getItemModel(tick.value);
			var itemStyleModel = itemModel.getModel("itemStyle");
			var hoverStyleModel = itemModel.getModel(["emphasis", "itemStyle"]);
			var progressStyleModel = itemModel.getModel(["progress", "itemStyle"]);
			var el = giveSymbol(itemModel, itemStyleModel, group, {
				x: tickCoord,
				y: 0,
				onclick: bind(_this._changeTimeline, _this, tick.value)
			});
			el.ensureState("emphasis").style = hoverStyleModel.getItemStyle();
			el.ensureState("progress").style = progressStyleModel.getItemStyle();
			enableHoverEmphasis(el);
			var ecData = getECData(el);
			if (itemModel.get("tooltip")) {
				ecData.dataIndex = tick.value;
				ecData.dataModel = timelineModel;
			} else ecData.dataIndex = ecData.dataModel = null;
			_this._tickSymbols.push(el);
		});
	};
	SliderTimelineView$1.prototype._renderAxisLabel = function(layoutInfo, group, axis, timelineModel) {
		var _this = this;
		if (!axis.getLabelModel().get("show")) return;
		var data = timelineModel.getData();
		var labels = axis.getViewLabels();
		this._tickLabels = [];
		each(labels, function(labelItem) {
			var dataIndex = labelItem.tickValue;
			var itemModel = data.getItemModel(dataIndex);
			var normalLabelModel = itemModel.getModel("label");
			var hoverLabelModel = itemModel.getModel(["emphasis", "label"]);
			var progressLabelModel = itemModel.getModel(["progress", "label"]);
			var tickCoord = axis.dataToCoord(labelItem.tickValue);
			var textEl = new Text_default({
				x: tickCoord,
				y: 0,
				rotation: layoutInfo.labelRotation - layoutInfo.rotation,
				onclick: bind(_this._changeTimeline, _this, dataIndex),
				silent: false,
				style: createTextStyle(normalLabelModel, {
					text: labelItem.formattedLabel,
					align: layoutInfo.labelAlign,
					verticalAlign: layoutInfo.labelBaseline
				})
			});
			textEl.ensureState("emphasis").style = createTextStyle(hoverLabelModel);
			textEl.ensureState("progress").style = createTextStyle(progressLabelModel);
			group.add(textEl);
			enableHoverEmphasis(textEl);
			labelDataIndexStore(textEl).dataIndex = dataIndex;
			_this._tickLabels.push(textEl);
		});
	};
	SliderTimelineView$1.prototype._renderControl = function(layoutInfo, group, axis, timelineModel) {
		var controlSize = layoutInfo.controlSize;
		var rotation = layoutInfo.rotation;
		var itemStyle = timelineModel.getModel("controlStyle").getItemStyle();
		var hoverStyle = timelineModel.getModel(["emphasis", "controlStyle"]).getItemStyle();
		var playState = timelineModel.getPlayState();
		var inverse = timelineModel.get("inverse", true);
		makeBtn(layoutInfo.nextBtnPosition, "next", bind(this._changeTimeline, this, inverse ? "-" : "+"));
		makeBtn(layoutInfo.prevBtnPosition, "prev", bind(this._changeTimeline, this, inverse ? "+" : "-"));
		makeBtn(layoutInfo.playPosition, playState ? "stop" : "play", bind(this._handlePlayClick, this, !playState), true);
		function makeBtn(position$1, iconName, onclick, willRotate) {
			if (!position$1) return;
			var iconSize = parsePercent(retrieve2(timelineModel.get(["controlStyle", iconName + "BtnSize"]), controlSize), controlSize);
			var rect = [
				0,
				-iconSize / 2,
				iconSize,
				iconSize
			];
			var btn = makeControlIcon(timelineModel, iconName + "Icon", rect, {
				x: position$1[0],
				y: position$1[1],
				originX: controlSize / 2,
				originY: 0,
				rotation: willRotate ? -rotation : 0,
				rectHover: true,
				style: itemStyle,
				onclick
			});
			btn.ensureState("emphasis").style = hoverStyle;
			group.add(btn);
			enableHoverEmphasis(btn);
		}
	};
	SliderTimelineView$1.prototype._renderCurrentPointer = function(layoutInfo, group, axis, timelineModel) {
		var data = timelineModel.getData();
		var currentIndex = timelineModel.getCurrentIndex();
		var pointerModel = data.getItemModel(currentIndex).getModel("checkpointStyle");
		var me = this;
		this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, {
			onCreate: function(pointer) {
				pointer.draggable = true;
				pointer.drift = bind(me._handlePointerDrag, me);
				pointer.ondragend = bind(me._handlePointerDragend, me);
				pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);
			},
			onUpdate: function(pointer) {
				pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);
			}
		});
	};
	SliderTimelineView$1.prototype._handlePlayClick = function(nextState) {
		this._clearTimer();
		this.api.dispatchAction({
			type: "timelinePlayChange",
			playState: nextState,
			from: this.uid
		});
	};
	SliderTimelineView$1.prototype._handlePointerDrag = function(dx, dy, e$1) {
		this._clearTimer();
		this._pointerChangeTimeline([e$1.offsetX, e$1.offsetY]);
	};
	SliderTimelineView$1.prototype._handlePointerDragend = function(e$1) {
		this._pointerChangeTimeline([e$1.offsetX, e$1.offsetY], true);
	};
	SliderTimelineView$1.prototype._pointerChangeTimeline = function(mousePos, trigger$2) {
		var toCoord = this._toAxisCoord(mousePos)[0];
		var axis = this._axis;
		var axisExtent = asc$1(axis.getExtent().slice());
		toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
		toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
		this._currentPointer.x = toCoord;
		this._currentPointer.markRedraw();
		var progressLine = this._progressLine;
		if (progressLine) {
			progressLine.shape.x2 = toCoord;
			progressLine.dirty();
		}
		var targetDataIndex = this._findNearestTick(toCoord);
		var timelineModel = this.model;
		if (trigger$2 || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get("realtime")) this._changeTimeline(targetDataIndex);
	};
	SliderTimelineView$1.prototype._doPlayStop = function() {
		var _this = this;
		this._clearTimer();
		if (this.model.getPlayState()) this._timer = setTimeout(function() {
			var timelineModel = _this.model;
			_this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get("rewind", true) ? -1 : 1));
		}, this.model.get("playInterval"));
	};
	SliderTimelineView$1.prototype._toAxisCoord = function(vertex) {
		var trans = this._mainGroup.getLocalTransform();
		return applyTransform$1(vertex, trans, true);
	};
	SliderTimelineView$1.prototype._findNearestTick = function(axisCoord) {
		var data = this.model.getData();
		var dist$2 = Infinity;
		var targetDataIndex;
		var axis = this._axis;
		data.each(["value"], function(value, dataIndex) {
			var coord = axis.dataToCoord(value);
			var d = Math.abs(coord - axisCoord);
			if (d < dist$2) {
				dist$2 = d;
				targetDataIndex = dataIndex;
			}
		});
		return targetDataIndex;
	};
	SliderTimelineView$1.prototype._clearTimer = function() {
		if (this._timer) {
			clearTimeout(this._timer);
			this._timer = null;
		}
	};
	SliderTimelineView$1.prototype._changeTimeline = function(nextIndex) {
		var currentIndex = this.model.getCurrentIndex();
		if (nextIndex === "+") nextIndex = currentIndex + 1;
		else if (nextIndex === "-") nextIndex = currentIndex - 1;
		this.api.dispatchAction({
			type: "timelineChange",
			currentIndex: nextIndex,
			from: this.uid
		});
	};
	SliderTimelineView$1.prototype._updateTicksStatus = function() {
		var currentIndex = this.model.getCurrentIndex();
		var tickSymbols = this._tickSymbols;
		var tickLabels = this._tickLabels;
		if (tickSymbols) for (var i$1 = 0; i$1 < tickSymbols.length; i$1++) tickSymbols && tickSymbols[i$1] && tickSymbols[i$1].toggleState("progress", i$1 < currentIndex);
		if (tickLabels) for (var i$1 = 0; i$1 < tickLabels.length; i$1++) tickLabels && tickLabels[i$1] && tickLabels[i$1].toggleState("progress", labelDataIndexStore(tickLabels[i$1]).dataIndex <= currentIndex);
	};
	SliderTimelineView$1.type = "timeline.slider";
	return SliderTimelineView$1;
}(TimelineView_default);
function createScaleByModel(model, axisType) {
	axisType = axisType || model.get("type");
	if (axisType) switch (axisType) {
		case "category": return new Ordinal_default({
			ordinalMeta: model.getCategories(),
			extent: [Infinity, -Infinity]
		});
		case "time": return new Time_default({
			locale: model.ecModel.getLocaleModel(),
			useUTC: model.ecModel.get("useUTC")
		});
		default: return new Interval_default();
	}
}
function getViewRect(model, api) {
	return getLayoutRect(model.getBoxLayoutParams(), createBoxLayoutReference(model, api).refContainer, model.get("padding"));
}
function makeControlIcon(timelineModel, objPath, rect, opts) {
	var style = opts.style;
	var icon = createIcon(timelineModel.get(["controlStyle", objPath]), opts || {}, new BoundingRect_default(rect[0], rect[1], rect[2], rect[3]));
	if (style) icon.setStyle(style);
	return icon;
}
/**
* Create symbol or update symbol
* opt: basic position and event handlers
*/
function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
	var color$2 = itemStyleModel.get("color");
	if (!symbol) {
		symbol = createSymbol(hostModel.get("symbol"), -1, -1, 2, 2, color$2);
		symbol.setStyle("strokeNoScale", true);
		group.add(symbol);
		callback && callback.onCreate(symbol);
	} else {
		symbol.setColor(color$2);
		group.add(symbol);
		callback && callback.onUpdate(symbol);
	}
	var itemStyle = itemStyleModel.getItemStyle(["color"]);
	symbol.setStyle(itemStyle);
	opt = merge({
		rectHover: true,
		z2: 100
	}, opt, true);
	var symbolSize = normalizeSymbolSize(hostModel.get("symbolSize"));
	opt.scaleX = symbolSize[0] / 2;
	opt.scaleY = symbolSize[1] / 2;
	var symbolOffset = normalizeSymbolOffset(hostModel.get("symbolOffset"), symbolSize);
	if (symbolOffset) {
		opt.x = (opt.x || 0) + symbolOffset[0];
		opt.y = (opt.y || 0) + symbolOffset[1];
	}
	opt.rotation = (hostModel.get("symbolRotate") || 0) * Math.PI / 180 || 0;
	symbol.attr(opt);
	symbol.updateTransform();
	return symbol;
}
function pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {
	if (pointer.dragging) return;
	var pointerModel = timelineModel.getModel("checkpointStyle");
	var toCoord = axis.dataToCoord(timelineModel.getData().get("value", dataIndex));
	if (noAnimation || !pointerModel.get("animation", true)) {
		pointer.attr({
			x: toCoord,
			y: 0
		});
		progressLine && progressLine.attr({ shape: { x2: toCoord } });
	} else {
		var animationCfg = {
			duration: pointerModel.get("animationDuration", true),
			easing: pointerModel.get("animationEasing", true)
		};
		pointer.stopAnimation(null, true);
		pointer.animateTo({
			x: toCoord,
			y: 0
		}, animationCfg);
		progressLine && progressLine.animateTo({ shape: { x2: toCoord } }, animationCfg);
	}
}
var SliderTimelineView_default = SliderTimelineView;

//#endregion
//#region node_modules/echarts/lib/component/timeline/timelineAction.js
function installTimelineAction(registers) {
	registers.registerAction({
		type: "timelineChange",
		event: "timelineChanged",
		update: "prepareAndUpdate"
	}, function(payload, ecModel, api) {
		var timelineModel = ecModel.getComponent("timeline");
		if (timelineModel && payload.currentIndex != null) {
			timelineModel.setCurrentIndex(payload.currentIndex);
			if (!timelineModel.get("loop", true) && timelineModel.isIndexMax() && timelineModel.getPlayState()) {
				timelineModel.setPlayState(false);
				api.dispatchAction({
					type: "timelinePlayChange",
					playState: false,
					from: payload.from
				});
			}
		}
		ecModel.resetOption("timeline", { replaceMerge: timelineModel.get("replaceMerge", true) });
		return defaults({ currentIndex: timelineModel.option.currentIndex }, payload);
	});
	registers.registerAction({
		type: "timelinePlayChange",
		event: "timelinePlayChanged",
		update: "update"
	}, function(payload, ecModel) {
		var timelineModel = ecModel.getComponent("timeline");
		if (timelineModel && payload.playState != null) timelineModel.setPlayState(payload.playState);
	});
}

//#endregion
//#region node_modules/echarts/lib/component/timeline/preprocessor.js
function timelinePreprocessor(option) {
	var timelineOpt = option && option.timeline;
	if (!isArray(timelineOpt)) timelineOpt = timelineOpt ? [timelineOpt] : [];
	each(timelineOpt, function(opt) {
		if (!opt) return;
		compatibleEC2(opt);
	});
}
function compatibleEC2(opt) {
	var type = opt.type;
	var ec2Types = {
		"number": "value",
		"time": "time"
	};
	if (ec2Types[type]) {
		opt.axisType = ec2Types[type];
		delete opt.type;
	}
	transferItem(opt);
	if (has$1(opt, "controlPosition")) {
		var controlStyle = opt.controlStyle || (opt.controlStyle = {});
		if (!has$1(controlStyle, "position")) controlStyle.position = opt.controlPosition;
		if (controlStyle.position === "none" && !has$1(controlStyle, "show")) {
			controlStyle.show = false;
			delete controlStyle.position;
		}
		delete opt.controlPosition;
	}
	each(opt.data || [], function(dataItem) {
		if (isObject(dataItem) && !isArray(dataItem)) {
			if (!has$1(dataItem, "value") && has$1(dataItem, "name")) dataItem.value = dataItem.name;
			transferItem(dataItem);
		}
	});
}
function transferItem(opt) {
	var itemStyle = opt.itemStyle || (opt.itemStyle = {});
	var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
	var label = opt.label || opt.label || {};
	var labelNormal = label.normal || (label.normal = {});
	var excludeLabelAttr = {
		normal: 1,
		emphasis: 1
	};
	each(label, function(value, name) {
		if (!excludeLabelAttr[name] && !has$1(labelNormal, name)) labelNormal[name] = value;
	});
	if (itemStyleEmphasis.label && !has$1(label, "emphasis")) {
		label.emphasis = itemStyleEmphasis.label;
		delete itemStyleEmphasis.label;
	}
}
function has$1(obj, attr) {
	return obj.hasOwnProperty(attr);
}

//#endregion
//#region node_modules/echarts/lib/component/timeline/install.js
function install$38(registers) {
	registers.registerComponentModel(SliderTimelineModel_default);
	registers.registerComponentView(SliderTimelineView_default);
	registers.registerSubTypeDefaulter("timeline", function() {
		return "slider";
	});
	installTimelineAction(registers);
	registers.registerPreprocessor(timelinePreprocessor);
}

//#endregion
//#region node_modules/echarts/lib/component/marker/checkMarkerInSeries.js
function checkMarkerInSeries(seriesOpts, markerType) {
	if (!seriesOpts) return false;
	var seriesOptArr = isArray(seriesOpts) ? seriesOpts : [seriesOpts];
	for (var idx = 0; idx < seriesOptArr.length; idx++) if (seriesOptArr[idx] && seriesOptArr[idx][markerType]) return true;
	return false;
}

//#endregion
//#region node_modules/echarts/lib/component/marker/MarkerModel.js
function fillLabel(opt) {
	defaultEmphasis(opt, "label", ["show"]);
}
var inner$5 = makeInner();
var MarkerModel = function(_super) {
	__extends(MarkerModel$1, _super);
	function MarkerModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MarkerModel$1.type;
		/**
		* If marker model is created by self from series
		*/
		_this.createdBySelf = false;
		_this.preventAutoZ = true;
		return _this;
	}
	/**
	* @overrite
	*/
	MarkerModel$1.prototype.init = function(option, parentModel, ecModel) {
		if (this.type === "marker") throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
		this.mergeDefaultAndTheme(option, ecModel);
		this._mergeOption(option, ecModel, false, true);
	};
	MarkerModel$1.prototype.isAnimationEnabled = function() {
		if (env_default.node) return false;
		var hostSeries = this.__hostSeries;
		return this.getShallow("animation") && hostSeries && hostSeries.isAnimationEnabled();
	};
	/**
	* @overrite
	*/
	MarkerModel$1.prototype.mergeOption = function(newOpt, ecModel) {
		this._mergeOption(newOpt, ecModel, false, false);
	};
	MarkerModel$1.prototype._mergeOption = function(newOpt, ecModel, createdBySelf, isInit) {
		var componentType = this.mainType;
		if (!createdBySelf) ecModel.eachSeries(function(seriesModel) {
			var markerOpt = seriesModel.get(this.mainType, true);
			var markerModel = inner$5(seriesModel)[componentType];
			if (!markerOpt || !markerOpt.data) {
				inner$5(seriesModel)[componentType] = null;
				return;
			}
			if (!markerModel) {
				if (isInit) fillLabel(markerOpt);
				each(markerOpt.data, function(item) {
					if (item instanceof Array) {
						fillLabel(item[0]);
						fillLabel(item[1]);
					} else fillLabel(item);
				});
				markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel);
				extend(markerModel, {
					mainType: this.mainType,
					seriesIndex: seriesModel.seriesIndex,
					name: seriesModel.name,
					createdBySelf: true
				});
				markerModel.__hostSeries = seriesModel;
			} else markerModel._mergeOption(markerOpt, ecModel, true);
			inner$5(seriesModel)[componentType] = markerModel;
		}, this);
	};
	MarkerModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		var data = this.getData();
		var value = this.getRawValue(dataIndex);
		var itemName = data.getName(dataIndex);
		return createTooltipMarkup("section", {
			header: this.name,
			blocks: [createTooltipMarkup("nameValue", {
				name: itemName,
				value,
				noName: !itemName,
				noValue: value == null
			})]
		});
	};
	MarkerModel$1.prototype.getData = function() {
		return this._data;
	};
	MarkerModel$1.prototype.setData = function(data) {
		this._data = data;
	};
	MarkerModel$1.prototype.getDataParams = function(dataIndex, dataType) {
		var params = DataFormatMixin.prototype.getDataParams.call(this, dataIndex, dataType);
		var hostSeries = this.__hostSeries;
		if (hostSeries) {
			params.seriesId = hostSeries.id;
			params.seriesName = hostSeries.name;
			params.seriesType = hostSeries.subType;
		}
		return params;
	};
	MarkerModel$1.getMarkerModelFromSeries = function(seriesModel, componentType) {
		return inner$5(seriesModel)[componentType];
	};
	MarkerModel$1.type = "marker";
	MarkerModel$1.dependencies = [
		"series",
		"grid",
		"polar",
		"geo"
	];
	return MarkerModel$1;
}(Component_default);
mixin(MarkerModel, DataFormatMixin.prototype);
var MarkerModel_default = MarkerModel;

//#endregion
//#region node_modules/echarts/lib/component/marker/MarkPointModel.js
var MarkPointModel = function(_super) {
	__extends(MarkPointModel$1, _super);
	function MarkPointModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MarkPointModel$1.type;
		return _this;
	}
	MarkPointModel$1.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
		return new MarkPointModel$1(markerOpt, masterMarkerModel, ecModel);
	};
	MarkPointModel$1.type = "markPoint";
	MarkPointModel$1.defaultOption = {
		z: 5,
		symbol: "pin",
		symbolSize: 50,
		tooltip: { trigger: "item" },
		label: {
			show: true,
			position: "inside"
		},
		itemStyle: { borderWidth: 2 },
		emphasis: { label: { show: true } }
	};
	return MarkPointModel$1;
}(MarkerModel_default);
var MarkPointModel_default = MarkPointModel;

//#endregion
//#region node_modules/echarts/lib/component/marker/markerHelper.js
function hasXOrY(item) {
	return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
}
function hasXAndY(item) {
	return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
}
function markerTypeCalculatorWithExtent(markerType, data, axisDim, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
	var coordArr = [];
	var calcDataDim = isDimensionStacked(data, targetDataDim) ? data.getCalculationInfo("stackResultDimension") : targetDataDim;
	var value = numCalculate(data, calcDataDim, markerType);
	var dataIndex = data.hostModel.indicesOfNearest(axisDim, calcDataDim, value)[0];
	coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
	coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
	var coordArrValue = data.get(targetDataDim, dataIndex);
	var precision = getPrecision(data.get(targetDataDim, dataIndex));
	precision = Math.min(precision, 20);
	if (precision >= 0) coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
	return [coordArr, coordArrValue];
}
var markerTypeCalculator = {
	min: curry(markerTypeCalculatorWithExtent, "min"),
	max: curry(markerTypeCalculatorWithExtent, "max"),
	average: curry(markerTypeCalculatorWithExtent, "average"),
	median: curry(markerTypeCalculatorWithExtent, "median")
};
/**
* Transform markPoint data item to format used in List by do the following
* 1. Calculate statistic like `max`, `min`, `average`
* 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
*/
function dataTransform(seriesModel, item) {
	if (!item) return;
	var data = seriesModel.getData();
	var coordSys = seriesModel.coordinateSystem;
	var dims = coordSys && coordSys.dimensions;
	if (!hasXAndY(item) && !isArray(item.coord) && isArray(dims)) {
		var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
		item = clone(item);
		if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
			var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
			var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
			var coordInfo = markerTypeCalculator[item.type](data, axisInfo.valueAxis.dim, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
			item.coord = coordInfo[0];
			item.value = coordInfo[1];
		} else item.coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];
	}
	if (item.coord == null || !isArray(dims)) {
		item.coord = [];
		var baseAxis = seriesModel.getBaseAxis();
		if (baseAxis && item.type && markerTypeCalculator[item.type]) {
			var otherAxis = coordSys.getOtherAxis(baseAxis);
			if (otherAxis) item.value = numCalculate(data, data.mapDimension(otherAxis.dim), item.type);
		}
	} else {
		var coord = item.coord;
		for (var i$1 = 0; i$1 < 2; i$1++) if (markerTypeCalculator[coord[i$1]]) coord[i$1] = numCalculate(data, data.mapDimension(dims[i$1]), coord[i$1]);
	}
	return item;
}
function getAxisInfo(item, data, coordSys, seriesModel) {
	var ret = {};
	if (item.valueIndex != null || item.valueDim != null) {
		ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
		ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
		ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
		ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
	} else {
		ret.baseAxis = seriesModel.getBaseAxis();
		ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
		ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
		ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
	}
	return ret;
}
function dataDimToCoordDim(seriesModel, dataDim) {
	var dimItem = seriesModel.getData().getDimensionInfo(dataDim);
	return dimItem && dimItem.coordDim;
}
/**
* Filter data which is out of coordinateSystem range
* [dataFilter description]
*/
function dataFilter(coordSys, item) {
	return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
}
function zoneFilter(coordSys, item1, item2) {
	return coordSys && coordSys.containZone && item1.coord && item2.coord && !hasXOrY(item1) && !hasXOrY(item2) ? coordSys.containZone(item1.coord, item2.coord) : true;
}
function createMarkerDimValueGetter(inCoordSys, dims) {
	return inCoordSys ? function(item, dimName, dataIndex, dimIndex) {
		return parseDataValue(dimIndex < 2 ? item.coord && item.coord[dimIndex] : item.value, dims[dimIndex]);
	} : function(item, dimName, dataIndex, dimIndex) {
		return parseDataValue(item.value, dims[dimIndex]);
	};
}
function numCalculate(data, valueDataDim, type) {
	if (type === "average") {
		var sum_1 = 0;
		var count_1 = 0;
		data.each(valueDataDim, function(val, idx) {
			if (!isNaN(val)) {
				sum_1 += val;
				count_1++;
			}
		});
		return sum_1 / count_1;
	} else if (type === "median") return data.getMedian(valueDataDim);
	else return data.getDataExtent(valueDataDim)[type === "max" ? 1 : 0];
}

//#endregion
//#region node_modules/echarts/lib/component/marker/MarkerView.js
var inner$4 = makeInner();
var MarkerView = function(_super) {
	__extends(MarkerView$1, _super);
	function MarkerView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MarkerView$1.type;
		return _this;
	}
	MarkerView$1.prototype.init = function() {
		this.markerGroupMap = createHashMap();
	};
	MarkerView$1.prototype.render = function(markerModel, ecModel, api) {
		var _this = this;
		var markerGroupMap = this.markerGroupMap;
		markerGroupMap.each(function(item) {
			inner$4(item).keep = false;
		});
		ecModel.eachSeries(function(seriesModel) {
			var markerModel$1 = MarkerModel_default.getMarkerModelFromSeries(seriesModel, _this.type);
			markerModel$1 && _this.renderSeries(seriesModel, markerModel$1, ecModel, api);
		});
		markerGroupMap.each(function(item) {
			!inner$4(item).keep && _this.group.remove(item.group);
		});
		updateZ$1(ecModel, markerGroupMap, this.type);
	};
	MarkerView$1.prototype.markKeep = function(drawGroup) {
		inner$4(drawGroup).keep = true;
	};
	MarkerView$1.prototype.toggleBlurSeries = function(seriesModelList, isBlur) {
		var _this = this;
		each(seriesModelList, function(seriesModel) {
			var markerModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, _this.type);
			if (markerModel) markerModel.getData().eachItemGraphicEl(function(el) {
				if (el) isBlur ? enterBlur(el) : leaveBlur(el);
			});
		});
	};
	MarkerView$1.type = "marker";
	return MarkerView$1;
}(Component_default$1);
function updateZ$1(ecModel, markerGroupMap, type) {
	ecModel.eachSeries(function(seriesModel) {
		var markerModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, type);
		var markerDraw = markerGroupMap.get(seriesModel.id);
		if (markerModel && markerDraw && markerDraw.group) {
			var _a$1 = retrieveZInfo(markerModel), z = _a$1.z, zlevel = _a$1.zlevel;
			traverseUpdateZ(markerDraw.group, z, zlevel);
		}
	});
}
var MarkerView_default = MarkerView;

//#endregion
//#region node_modules/echarts/lib/component/marker/MarkPointView.js
function updateMarkerLayout(mpData, seriesModel, api) {
	var coordSys = seriesModel.coordinateSystem;
	var apiWidth = api.getWidth();
	var apiHeight = api.getHeight();
	var coordRect = coordSys && coordSys.getArea && coordSys.getArea();
	mpData.each(function(idx) {
		var itemModel = mpData.getItemModel(idx);
		var isRelativeToCoordinate = itemModel.get("relativeTo") === "coordinate";
		var width = isRelativeToCoordinate ? coordRect ? coordRect.width : 0 : apiWidth;
		var height = isRelativeToCoordinate ? coordRect ? coordRect.height : 0 : apiHeight;
		var left = isRelativeToCoordinate && coordRect ? coordRect.x : 0;
		var top = isRelativeToCoordinate && coordRect ? coordRect.y : 0;
		var point;
		var xPx = parsePercent$1(itemModel.get("x"), width) + left;
		var yPx = parsePercent$1(itemModel.get("y"), height) + top;
		if (!isNaN(xPx) && !isNaN(yPx)) point = [xPx, yPx];
		else if (seriesModel.getMarkerPosition) point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
		else if (coordSys) {
			var x = mpData.get(coordSys.dimensions[0], idx);
			var y = mpData.get(coordSys.dimensions[1], idx);
			point = coordSys.dataToPoint([x, y]);
		}
		if (!isNaN(xPx)) point[0] = xPx;
		if (!isNaN(yPx)) point[1] = yPx;
		mpData.setItemLayout(idx, point);
	});
}
var MarkPointView = function(_super) {
	__extends(MarkPointView$1, _super);
	function MarkPointView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MarkPointView$1.type;
		return _this;
	}
	MarkPointView$1.prototype.updateTransform = function(markPointModel, ecModel, api) {
		ecModel.eachSeries(function(seriesModel) {
			var mpModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markPoint");
			if (mpModel) {
				updateMarkerLayout(mpModel.getData(), seriesModel, api);
				this.markerGroupMap.get(seriesModel.id).updateLayout();
			}
		}, this);
	};
	MarkPointView$1.prototype.renderSeries = function(seriesModel, mpModel, ecModel, api) {
		var coordSys = seriesModel.coordinateSystem;
		var seriesId = seriesModel.id;
		var seriesData = seriesModel.getData();
		var symbolDrawMap = this.markerGroupMap;
		var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw_default());
		var mpData = createData(coordSys, seriesModel, mpModel);
		mpModel.setData(mpData);
		updateMarkerLayout(mpModel.getData(), seriesModel, api);
		mpData.each(function(idx) {
			var itemModel = mpData.getItemModel(idx);
			var symbol = itemModel.getShallow("symbol");
			var symbolSize = itemModel.getShallow("symbolSize");
			var symbolRotate = itemModel.getShallow("symbolRotate");
			var symbolOffset = itemModel.getShallow("symbolOffset");
			var symbolKeepAspect = itemModel.getShallow("symbolKeepAspect");
			if (isFunction(symbol) || isFunction(symbolSize) || isFunction(symbolRotate) || isFunction(symbolOffset)) {
				var rawIdx = mpModel.getRawValue(idx);
				var dataParams = mpModel.getDataParams(idx);
				if (isFunction(symbol)) symbol = symbol(rawIdx, dataParams);
				if (isFunction(symbolSize)) symbolSize = symbolSize(rawIdx, dataParams);
				if (isFunction(symbolRotate)) symbolRotate = symbolRotate(rawIdx, dataParams);
				if (isFunction(symbolOffset)) symbolOffset = symbolOffset(rawIdx, dataParams);
			}
			var style = itemModel.getModel("itemStyle").getItemStyle();
			var z2 = itemModel.get("z2");
			var color$2 = getVisualFromData(seriesData, "color");
			if (!style.fill) style.fill = color$2;
			mpData.setItemVisual(idx, {
				z2: retrieve2(z2, 0),
				symbol,
				symbolSize,
				symbolRotate,
				symbolOffset,
				symbolKeepAspect,
				style
			});
		});
		symbolDraw.updateData(mpData);
		this.group.add(symbolDraw.group);
		mpData.eachItemGraphicEl(function(el) {
			el.traverse(function(child) {
				getECData(child).dataModel = mpModel;
			});
		});
		this.markKeep(symbolDraw);
		symbolDraw.group.silent = mpModel.get("silent") || seriesModel.get("silent");
	};
	MarkPointView$1.type = "markPoint";
	return MarkPointView$1;
}(MarkerView_default);
function createData(coordSys, seriesModel, mpModel) {
	var coordDimsInfos;
	if (coordSys) coordDimsInfos = map(coordSys && coordSys.dimensions, function(coordDim) {
		return extend(extend({}, seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}), {
			name: coordDim,
			ordinalMeta: null
		});
	});
	else coordDimsInfos = [{
		name: "value",
		type: "float"
	}];
	var mpData = new SeriesData_default(coordDimsInfos, mpModel);
	var dataOpt = map(mpModel.get("data"), curry(dataTransform, seriesModel));
	if (coordSys) dataOpt = filter(dataOpt, curry(dataFilter, coordSys));
	var dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
	mpData.initData(dataOpt, null, dimValueGetter);
	return mpData;
}
var MarkPointView_default = MarkPointView;

//#endregion
//#region node_modules/echarts/lib/component/marker/installMarkPoint.js
function install$39(registers) {
	registers.registerComponentModel(MarkPointModel_default);
	registers.registerComponentView(MarkPointView_default);
	registers.registerPreprocessor(function(opt) {
		if (checkMarkerInSeries(opt.series, "markPoint")) opt.markPoint = opt.markPoint || {};
	});
}

//#endregion
//#region node_modules/echarts/lib/component/marker/MarkLineModel.js
var MarkLineModel = function(_super) {
	__extends(MarkLineModel$1, _super);
	function MarkLineModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MarkLineModel$1.type;
		return _this;
	}
	MarkLineModel$1.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
		return new MarkLineModel$1(markerOpt, masterMarkerModel, ecModel);
	};
	MarkLineModel$1.type = "markLine";
	MarkLineModel$1.defaultOption = {
		z: 5,
		symbol: ["circle", "arrow"],
		symbolSize: [8, 16],
		symbolOffset: 0,
		precision: 2,
		tooltip: { trigger: "item" },
		label: {
			show: true,
			position: "end",
			distance: 5
		},
		lineStyle: { type: "dashed" },
		emphasis: {
			label: { show: true },
			lineStyle: { width: 3 }
		},
		animationEasing: "linear"
	};
	return MarkLineModel$1;
}(MarkerModel_default);
var MarkLineModel_default = MarkLineModel;

//#endregion
//#region node_modules/echarts/lib/component/marker/MarkLineView.js
var inner$3 = makeInner();
var markLineTransform = function(seriesModel, coordSys, mlModel, item) {
	var data = seriesModel.getData();
	var itemArray;
	if (!isArray(item)) {
		var mlType = item.type;
		if (mlType === "min" || mlType === "max" || mlType === "average" || mlType === "median" || item.xAxis != null || item.yAxis != null) {
			var valueAxis$1 = void 0;
			var value = void 0;
			if (item.yAxis != null || item.xAxis != null) {
				valueAxis$1 = coordSys.getAxis(item.yAxis != null ? "y" : "x");
				value = retrieve(item.yAxis, item.xAxis);
			} else {
				var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
				valueAxis$1 = axisInfo.valueAxis;
				var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
				value = numCalculate(data, valueDataDim, mlType);
			}
			var valueIndex = valueAxis$1.dim === "x" ? 0 : 1;
			var baseIndex = 1 - valueIndex;
			var mlFrom = clone(item);
			var mlTo = { coord: [] };
			mlFrom.type = null;
			mlFrom.coord = [];
			mlFrom.coord[baseIndex] = -Infinity;
			mlTo.coord[baseIndex] = Infinity;
			var precision = mlModel.get("precision");
			if (precision >= 0 && isNumber(value)) value = +value.toFixed(Math.min(precision, 20));
			mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
			itemArray = [
				mlFrom,
				mlTo,
				{
					type: mlType,
					valueIndex: item.valueIndex,
					value
				}
			];
		} else {
			logError("Invalid markLine data.");
			itemArray = [];
		}
	} else itemArray = item;
	var normalizedItem = [
		dataTransform(seriesModel, itemArray[0]),
		dataTransform(seriesModel, itemArray[1]),
		extend({}, itemArray[2])
	];
	normalizedItem[2].type = normalizedItem[2].type || null;
	merge(normalizedItem[2], normalizedItem[0]);
	merge(normalizedItem[2], normalizedItem[1]);
	return normalizedItem;
};
function isInfinity$1(val) {
	return !isNaN(val) && !isFinite(val);
}
function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
	var otherDimIndex = 1 - dimIndex;
	var dimName = coordSys.dimensions[dimIndex];
	return isInfinity$1(fromCoord[otherDimIndex]) && isInfinity$1(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
}
function markLineFilter(coordSys, item) {
	if (coordSys.type === "cartesian2d") {
		var fromCoord = item[0].coord;
		var toCoord = item[1].coord;
		if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) return true;
	}
	return dataFilter(coordSys, item[0]) && dataFilter(coordSys, item[1]);
}
function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
	var coordSys = seriesModel.coordinateSystem;
	var itemModel = data.getItemModel(idx);
	var point;
	var xPx = parsePercent$1(itemModel.get("x"), api.getWidth());
	var yPx = parsePercent$1(itemModel.get("y"), api.getHeight());
	if (!isNaN(xPx) && !isNaN(yPx)) point = [xPx, yPx];
	else {
		if (seriesModel.getMarkerPosition) point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
		else {
			var dims = coordSys.dimensions;
			var x = data.get(dims[0], idx);
			var y = data.get(dims[1], idx);
			point = coordSys.dataToPoint([x, y]);
		}
		if (isCoordinateSystemType(coordSys, "cartesian2d")) {
			var xAxis = coordSys.getAxis("x");
			var yAxis = coordSys.getAxis("y");
			var dims = coordSys.dimensions;
			if (isInfinity$1(data.get(dims[0], idx))) point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
			else if (isInfinity$1(data.get(dims[1], idx))) point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
		}
		if (!isNaN(xPx)) point[0] = xPx;
		if (!isNaN(yPx)) point[1] = yPx;
	}
	data.setItemLayout(idx, point);
}
var MarkLineView = function(_super) {
	__extends(MarkLineView$1, _super);
	function MarkLineView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MarkLineView$1.type;
		return _this;
	}
	MarkLineView$1.prototype.updateTransform = function(markLineModel, ecModel, api) {
		ecModel.eachSeries(function(seriesModel) {
			var mlModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markLine");
			if (mlModel) {
				var mlData_1 = mlModel.getData();
				var fromData_1 = inner$3(mlModel).from;
				var toData_1 = inner$3(mlModel).to;
				fromData_1.each(function(idx) {
					updateSingleMarkerEndLayout(fromData_1, idx, true, seriesModel, api);
					updateSingleMarkerEndLayout(toData_1, idx, false, seriesModel, api);
				});
				mlData_1.each(function(idx) {
					mlData_1.setItemLayout(idx, [fromData_1.getItemLayout(idx), toData_1.getItemLayout(idx)]);
				});
				this.markerGroupMap.get(seriesModel.id).updateLayout();
			}
		}, this);
	};
	MarkLineView$1.prototype.renderSeries = function(seriesModel, mlModel, ecModel, api) {
		var coordSys = seriesModel.coordinateSystem;
		var seriesId = seriesModel.id;
		var seriesData = seriesModel.getData();
		var lineDrawMap = this.markerGroupMap;
		var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw_default());
		this.group.add(lineDraw.group);
		var mlData = createList$1(coordSys, seriesModel, mlModel);
		var fromData = mlData.from;
		var toData = mlData.to;
		var lineData = mlData.line;
		inner$3(mlModel).from = fromData;
		inner$3(mlModel).to = toData;
		mlModel.setData(lineData);
		var symbolType = mlModel.get("symbol");
		var symbolSize = mlModel.get("symbolSize");
		var symbolRotate = mlModel.get("symbolRotate");
		var symbolOffset = mlModel.get("symbolOffset");
		if (!isArray(symbolType)) symbolType = [symbolType, symbolType];
		if (!isArray(symbolSize)) symbolSize = [symbolSize, symbolSize];
		if (!isArray(symbolRotate)) symbolRotate = [symbolRotate, symbolRotate];
		if (!isArray(symbolOffset)) symbolOffset = [symbolOffset, symbolOffset];
		mlData.from.each(function(idx) {
			updateDataVisualAndLayout(fromData, idx, true);
			updateDataVisualAndLayout(toData, idx, false);
		});
		lineData.each(function(idx) {
			var itemModel = lineData.getItemModel(idx);
			var lineStyle = itemModel.getModel("lineStyle").getLineStyle();
			lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
			var z2 = itemModel.get("z2");
			if (lineStyle.stroke == null) lineStyle.stroke = fromData.getItemVisual(idx, "style").fill;
			lineData.setItemVisual(idx, {
				z2: retrieve2(z2, 0),
				fromSymbolKeepAspect: fromData.getItemVisual(idx, "symbolKeepAspect"),
				fromSymbolOffset: fromData.getItemVisual(idx, "symbolOffset"),
				fromSymbolRotate: fromData.getItemVisual(idx, "symbolRotate"),
				fromSymbolSize: fromData.getItemVisual(idx, "symbolSize"),
				fromSymbol: fromData.getItemVisual(idx, "symbol"),
				toSymbolKeepAspect: toData.getItemVisual(idx, "symbolKeepAspect"),
				toSymbolOffset: toData.getItemVisual(idx, "symbolOffset"),
				toSymbolRotate: toData.getItemVisual(idx, "symbolRotate"),
				toSymbolSize: toData.getItemVisual(idx, "symbolSize"),
				toSymbol: toData.getItemVisual(idx, "symbol"),
				style: lineStyle
			});
		});
		lineDraw.updateData(lineData);
		mlData.line.eachItemGraphicEl(function(el) {
			getECData(el).dataModel = mlModel;
			el.traverse(function(child) {
				getECData(child).dataModel = mlModel;
			});
		});
		function updateDataVisualAndLayout(data, idx, isFrom) {
			var itemModel = data.getItemModel(idx);
			updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
			var style = itemModel.getModel("itemStyle").getItemStyle();
			if (style.fill == null) style.fill = getVisualFromData(seriesData, "color");
			data.setItemVisual(idx, {
				symbolKeepAspect: itemModel.get("symbolKeepAspect"),
				symbolOffset: retrieve2(itemModel.get("symbolOffset", true), symbolOffset[isFrom ? 0 : 1]),
				symbolRotate: retrieve2(itemModel.get("symbolRotate", true), symbolRotate[isFrom ? 0 : 1]),
				symbolSize: retrieve2(itemModel.get("symbolSize"), symbolSize[isFrom ? 0 : 1]),
				symbol: retrieve2(itemModel.get("symbol", true), symbolType[isFrom ? 0 : 1]),
				style
			});
		}
		this.markKeep(lineDraw);
		lineDraw.group.silent = mlModel.get("silent") || seriesModel.get("silent");
	};
	MarkLineView$1.type = "markLine";
	return MarkLineView$1;
}(MarkerView_default);
function createList$1(coordSys, seriesModel, mlModel) {
	var coordDimsInfos;
	if (coordSys) coordDimsInfos = map(coordSys && coordSys.dimensions, function(coordDim) {
		return extend(extend({}, seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}), {
			name: coordDim,
			ordinalMeta: null
		});
	});
	else coordDimsInfos = [{
		name: "value",
		type: "float"
	}];
	var fromData = new SeriesData_default(coordDimsInfos, mlModel);
	var toData = new SeriesData_default(coordDimsInfos, mlModel);
	var lineData = new SeriesData_default([], mlModel);
	var optData = map(mlModel.get("data"), curry(markLineTransform, seriesModel, coordSys, mlModel));
	if (coordSys) optData = filter(optData, curry(markLineFilter, coordSys));
	var dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
	fromData.initData(map(optData, function(item) {
		return item[0];
	}), null, dimValueGetter);
	toData.initData(map(optData, function(item) {
		return item[1];
	}), null, dimValueGetter);
	lineData.initData(map(optData, function(item) {
		return item[2];
	}));
	lineData.hasItemOption = true;
	return {
		from: fromData,
		to: toData,
		line: lineData
	};
}
var MarkLineView_default = MarkLineView;

//#endregion
//#region node_modules/echarts/lib/component/marker/installMarkLine.js
function install$40(registers) {
	registers.registerComponentModel(MarkLineModel_default);
	registers.registerComponentView(MarkLineView_default);
	registers.registerPreprocessor(function(opt) {
		if (checkMarkerInSeries(opt.series, "markLine")) opt.markLine = opt.markLine || {};
	});
}

//#endregion
//#region node_modules/echarts/lib/component/marker/MarkAreaModel.js
var MarkAreaModel = function(_super) {
	__extends(MarkAreaModel$1, _super);
	function MarkAreaModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MarkAreaModel$1.type;
		return _this;
	}
	MarkAreaModel$1.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
		return new MarkAreaModel$1(markerOpt, masterMarkerModel, ecModel);
	};
	MarkAreaModel$1.type = "markArea";
	MarkAreaModel$1.defaultOption = {
		z: 1,
		tooltip: { trigger: "item" },
		animation: false,
		label: {
			show: true,
			position: "top"
		},
		itemStyle: { borderWidth: 0 },
		emphasis: { label: {
			show: true,
			position: "top"
		} }
	};
	return MarkAreaModel$1;
}(MarkerModel_default);
var MarkAreaModel_default = MarkAreaModel;

//#endregion
//#region node_modules/echarts/lib/component/marker/MarkAreaView.js
var inner$2 = makeInner();
var markAreaTransform = function(seriesModel, coordSys, maModel, item) {
	var item0 = item[0];
	var item1 = item[1];
	if (!item0 || !item1) return;
	var lt$1 = dataTransform(seriesModel, item0);
	var rb$1 = dataTransform(seriesModel, item1);
	var ltCoord = lt$1.coord;
	var rbCoord = rb$1.coord;
	ltCoord[0] = retrieve(ltCoord[0], -Infinity);
	ltCoord[1] = retrieve(ltCoord[1], -Infinity);
	rbCoord[0] = retrieve(rbCoord[0], Infinity);
	rbCoord[1] = retrieve(rbCoord[1], Infinity);
	var result = mergeAll([
		{},
		lt$1,
		rb$1
	]);
	result.coord = [lt$1.coord, rb$1.coord];
	result.x0 = lt$1.x;
	result.y0 = lt$1.y;
	result.x1 = rb$1.x;
	result.y1 = rb$1.y;
	return result;
};
function isInfinity(val) {
	return !isNaN(val) && !isFinite(val);
}
function ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
	var otherDimIndex = 1 - dimIndex;
	return isInfinity(fromCoord[otherDimIndex]) && isInfinity(toCoord[otherDimIndex]);
}
function markAreaFilter(coordSys, item) {
	var fromCoord = item.coord[0];
	var toCoord = item.coord[1];
	var item0 = {
		coord: fromCoord,
		x: item.x0,
		y: item.y0
	};
	var item1 = {
		coord: toCoord,
		x: item.x1,
		y: item.y1
	};
	if (isCoordinateSystemType(coordSys, "cartesian2d")) {
		if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord, coordSys))) return true;
		return zoneFilter(coordSys, item0, item1);
	}
	return dataFilter(coordSys, item0) || dataFilter(coordSys, item1);
}
function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
	var coordSys = seriesModel.coordinateSystem;
	var itemModel = data.getItemModel(idx);
	var point;
	var xPx = parsePercent$1(itemModel.get(dims[0]), api.getWidth());
	var yPx = parsePercent$1(itemModel.get(dims[1]), api.getHeight());
	if (!isNaN(xPx) && !isNaN(yPx)) point = [xPx, yPx];
	else {
		if (seriesModel.getMarkerPosition) {
			var pointValue0 = data.getValues(["x0", "y0"], idx);
			var pointValue1 = data.getValues(["x1", "y1"], idx);
			var clampPointValue0 = coordSys.clampData(pointValue0);
			var clampPointValue1 = coordSys.clampData(pointValue1);
			var pointValue = [];
			if (dims[0] === "x0") pointValue[0] = clampPointValue0[0] > clampPointValue1[0] ? pointValue1[0] : pointValue0[0];
			else pointValue[0] = clampPointValue0[0] > clampPointValue1[0] ? pointValue0[0] : pointValue1[0];
			if (dims[1] === "y0") pointValue[1] = clampPointValue0[1] > clampPointValue1[1] ? pointValue1[1] : pointValue0[1];
			else pointValue[1] = clampPointValue0[1] > clampPointValue1[1] ? pointValue0[1] : pointValue1[1];
			point = seriesModel.getMarkerPosition(pointValue, dims, true);
		} else {
			var x = data.get(dims[0], idx);
			var y = data.get(dims[1], idx);
			var pt = [x, y];
			coordSys.clampData && coordSys.clampData(pt, pt);
			point = coordSys.dataToPoint(pt, true);
		}
		if (isCoordinateSystemType(coordSys, "cartesian2d")) {
			var xAxis = coordSys.getAxis("x");
			var yAxis = coordSys.getAxis("y");
			var x = data.get(dims[0], idx);
			var y = data.get(dims[1], idx);
			if (isInfinity(x)) point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === "x0" ? 0 : 1]);
			else if (isInfinity(y)) point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === "y0" ? 0 : 1]);
		}
		if (!isNaN(xPx)) point[0] = xPx;
		if (!isNaN(yPx)) point[1] = yPx;
	}
	return point;
}
var dimPermutations = [
	["x0", "y0"],
	["x1", "y0"],
	["x1", "y1"],
	["x0", "y1"]
];
var MarkAreaView = function(_super) {
	__extends(MarkAreaView$1, _super);
	function MarkAreaView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = MarkAreaView$1.type;
		return _this;
	}
	MarkAreaView$1.prototype.updateTransform = function(markAreaModel, ecModel, api) {
		ecModel.eachSeries(function(seriesModel) {
			var maModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markArea");
			if (maModel) {
				var areaData_1 = maModel.getData();
				areaData_1.each(function(idx) {
					var points$3 = map(dimPermutations, function(dim) {
						return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);
					});
					areaData_1.setItemLayout(idx, points$3);
					areaData_1.getItemGraphicEl(idx).setShape("points", points$3);
				});
			}
		}, this);
	};
	MarkAreaView$1.prototype.renderSeries = function(seriesModel, maModel, ecModel, api) {
		var coordSys = seriesModel.coordinateSystem;
		var seriesId = seriesModel.id;
		var seriesData = seriesModel.getData();
		var areaGroupMap = this.markerGroupMap;
		var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, { group: new Group_default() });
		this.group.add(polygonGroup.group);
		this.markKeep(polygonGroup);
		var areaData = createList(coordSys, seriesModel, maModel);
		maModel.setData(areaData);
		areaData.each(function(idx) {
			var points$3 = map(dimPermutations, function(dim) {
				return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
			});
			var xAxisScale = coordSys.getAxis("x").scale;
			var yAxisScale = coordSys.getAxis("y").scale;
			var xAxisExtent = xAxisScale.getExtent();
			var yAxisExtent = yAxisScale.getExtent();
			var xPointExtent = [xAxisScale.parse(areaData.get("x0", idx)), xAxisScale.parse(areaData.get("x1", idx))];
			var yPointExtent = [yAxisScale.parse(areaData.get("y0", idx)), yAxisScale.parse(areaData.get("y1", idx))];
			asc$1(xPointExtent);
			asc$1(yPointExtent);
			var allClipped = !!(xAxisExtent[0] > xPointExtent[1] || xAxisExtent[1] < xPointExtent[0] || yAxisExtent[0] > yPointExtent[1] || yAxisExtent[1] < yPointExtent[0]);
			areaData.setItemLayout(idx, {
				points: points$3,
				allClipped
			});
			var itemModel = areaData.getItemModel(idx);
			var style = itemModel.getModel("itemStyle").getItemStyle();
			var z2 = itemModel.get("z2");
			var color$2 = getVisualFromData(seriesData, "color");
			if (!style.fill) {
				style.fill = color$2;
				if (isString(style.fill)) style.fill = modifyAlpha(style.fill, .4);
			}
			if (!style.stroke) style.stroke = color$2;
			areaData.setItemVisual(idx, "style", style);
			areaData.setItemVisual(idx, "z2", retrieve2(z2, 0));
		});
		areaData.diff(inner$2(polygonGroup).data).add(function(idx) {
			var layout$3 = areaData.getItemLayout(idx);
			var z2 = areaData.getItemVisual(idx, "z2");
			if (!layout$3.allClipped) {
				var polygon = new Polygon_default({
					z2: retrieve2(z2, 0),
					shape: { points: layout$3.points }
				});
				areaData.setItemGraphicEl(idx, polygon);
				polygonGroup.group.add(polygon);
			}
		}).update(function(newIdx, oldIdx) {
			var polygon = inner$2(polygonGroup).data.getItemGraphicEl(oldIdx);
			var layout$3 = areaData.getItemLayout(newIdx);
			var z2 = areaData.getItemVisual(newIdx, "z2");
			if (!layout$3.allClipped) {
				if (polygon) updateProps(polygon, {
					z2: retrieve2(z2, 0),
					shape: { points: layout$3.points }
				}, maModel, newIdx);
				else polygon = new Polygon_default({ shape: { points: layout$3.points } });
				areaData.setItemGraphicEl(newIdx, polygon);
				polygonGroup.group.add(polygon);
			} else if (polygon) polygonGroup.group.remove(polygon);
		}).remove(function(idx) {
			var polygon = inner$2(polygonGroup).data.getItemGraphicEl(idx);
			polygonGroup.group.remove(polygon);
		}).execute();
		areaData.eachItemGraphicEl(function(polygon, idx) {
			var itemModel = areaData.getItemModel(idx);
			var style = areaData.getItemVisual(idx, "style");
			polygon.useStyle(areaData.getItemVisual(idx, "style"));
			setLabelStyle(polygon, getLabelStatesModels(itemModel), {
				labelFetcher: maModel,
				labelDataIndex: idx,
				defaultText: areaData.getName(idx) || "",
				inheritColor: isString(style.fill) ? modifyAlpha(style.fill, 1) : tokens_default.color.neutral99
			});
			setStatesStylesFromModel(polygon, itemModel);
			toggleHoverEmphasis(polygon, null, null, itemModel.get(["emphasis", "disabled"]));
			getECData(polygon).dataModel = maModel;
		});
		inner$2(polygonGroup).data = areaData;
		polygonGroup.group.silent = maModel.get("silent") || seriesModel.get("silent");
	};
	MarkAreaView$1.type = "markArea";
	return MarkAreaView$1;
}(MarkerView_default);
function createList(coordSys, seriesModel, maModel) {
	var areaData;
	var dataDims;
	var dims = [
		"x0",
		"y0",
		"x1",
		"y1"
	];
	if (coordSys) {
		var coordDimsInfos_1 = map(coordSys && coordSys.dimensions, function(coordDim) {
			var data = seriesModel.getData();
			return extend(extend({}, data.getDimensionInfo(data.mapDimension(coordDim)) || {}), {
				name: coordDim,
				ordinalMeta: null
			});
		});
		dataDims = map(dims, function(dim, idx) {
			return {
				name: dim,
				type: coordDimsInfos_1[idx % 2].type
			};
		});
		areaData = new SeriesData_default(dataDims, maModel);
	} else {
		dataDims = [{
			name: "value",
			type: "float"
		}];
		areaData = new SeriesData_default(dataDims, maModel);
	}
	var optData = map(maModel.get("data"), curry(markAreaTransform, seriesModel, coordSys, maModel));
	if (coordSys) optData = filter(optData, curry(markAreaFilter, coordSys));
	var dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
		var rawVal = item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
		return parseDataValue(rawVal, dataDims[dimIndex]);
	} : function(item, dimName, dataIndex, dimIndex) {
		return parseDataValue(item.value, dataDims[dimIndex]);
	};
	areaData.initData(optData, null, dimValueGetter);
	areaData.hasItemOption = true;
	return areaData;
}
var MarkAreaView_default = MarkAreaView;

//#endregion
//#region node_modules/echarts/lib/component/marker/installMarkArea.js
function install$41(registers) {
	registers.registerComponentModel(MarkAreaModel_default);
	registers.registerComponentView(MarkAreaView_default);
	registers.registerPreprocessor(function(opt) {
		if (checkMarkerInSeries(opt.series, "markArea")) opt.markArea = opt.markArea || {};
	});
}

//#endregion
//#region node_modules/echarts/lib/component/legend/LegendModel.js
var getDefaultSelectorOptions = function(ecModel, type) {
	if (type === "all") return {
		type: "all",
		title: ecModel.getLocaleModel().get([
			"legend",
			"selector",
			"all"
		])
	};
	else if (type === "inverse") return {
		type: "inverse",
		title: ecModel.getLocaleModel().get([
			"legend",
			"selector",
			"inverse"
		])
	};
};
var LegendModel = function(_super) {
	__extends(LegendModel$1, _super);
	function LegendModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = LegendModel$1.type;
		_this.layoutMode = {
			type: "box",
			ignoreSize: true
		};
		return _this;
	}
	LegendModel$1.prototype.init = function(option, parentModel, ecModel) {
		this.mergeDefaultAndTheme(option, ecModel);
		option.selected = option.selected || {};
		this._updateSelector(option);
	};
	LegendModel$1.prototype.mergeOption = function(option, ecModel) {
		_super.prototype.mergeOption.call(this, option, ecModel);
		this._updateSelector(option);
	};
	LegendModel$1.prototype._updateSelector = function(option) {
		var selector$1 = option.selector;
		var ecModel = this.ecModel;
		if (selector$1 === true) selector$1 = option.selector = ["all", "inverse"];
		if (isArray(selector$1)) each(selector$1, function(item, index) {
			isString(item) && (item = { type: item });
			selector$1[index] = merge(item, getDefaultSelectorOptions(ecModel, item.type));
		});
	};
	LegendModel$1.prototype.optionUpdated = function() {
		this._updateData(this.ecModel);
		var legendData = this._data;
		if (legendData[0] && this.get("selectedMode") === "single") {
			var hasSelected = false;
			for (var i$1 = 0; i$1 < legendData.length; i$1++) {
				var name_1 = legendData[i$1].get("name");
				if (this.isSelected(name_1)) {
					this.select(name_1);
					hasSelected = true;
					break;
				}
			}
			!hasSelected && this.select(legendData[0].get("name"));
		}
	};
	LegendModel$1.prototype._updateData = function(ecModel) {
		var potentialData = [];
		var availableNames = [];
		ecModel.eachRawSeries(function(seriesModel) {
			var seriesName = seriesModel.name;
			availableNames.push(seriesName);
			var isPotential;
			if (seriesModel.legendVisualProvider) {
				var names = seriesModel.legendVisualProvider.getAllNames();
				if (!ecModel.isSeriesFiltered(seriesModel)) availableNames = availableNames.concat(names);
				if (names.length) potentialData = potentialData.concat(names);
				else isPotential = true;
			} else isPotential = true;
			if (isPotential && isNameSpecified(seriesModel)) potentialData.push(seriesModel.name);
		});
		/**
		* @type {Array.<string>}
		* @private
		*/
		this._availableNames = availableNames;
		var rawData = this.get("data") || potentialData;
		var legendNameMap = createHashMap();
		var legendData = map(rawData, function(dataItem) {
			if (isString(dataItem) || isNumber(dataItem)) dataItem = { name: dataItem };
			if (legendNameMap.get(dataItem.name)) return null;
			legendNameMap.set(dataItem.name, true);
			return new Model_default(dataItem, this, this.ecModel);
		}, this);
		/**
		* @type {Array.<module:echarts/model/Model>}
		* @private
		*/
		this._data = filter(legendData, function(item) {
			return !!item;
		});
	};
	LegendModel$1.prototype.getData = function() {
		return this._data;
	};
	LegendModel$1.prototype.select = function(name) {
		var selected = this.option.selected;
		if (this.get("selectedMode") === "single") {
			var data = this._data;
			each(data, function(dataItem) {
				selected[dataItem.get("name")] = false;
			});
		}
		selected[name] = true;
	};
	LegendModel$1.prototype.unSelect = function(name) {
		if (this.get("selectedMode") !== "single") this.option.selected[name] = false;
	};
	LegendModel$1.prototype.toggleSelected = function(name) {
		var selected = this.option.selected;
		if (!selected.hasOwnProperty(name)) selected[name] = true;
		this[selected[name] ? "unSelect" : "select"](name);
	};
	LegendModel$1.prototype.allSelect = function() {
		var data = this._data;
		var selected = this.option.selected;
		each(data, function(dataItem) {
			selected[dataItem.get("name", true)] = true;
		});
	};
	LegendModel$1.prototype.inverseSelect = function() {
		var data = this._data;
		var selected = this.option.selected;
		each(data, function(dataItem) {
			var name = dataItem.get("name", true);
			if (!selected.hasOwnProperty(name)) selected[name] = true;
			selected[name] = !selected[name];
		});
	};
	LegendModel$1.prototype.isSelected = function(name) {
		var selected = this.option.selected;
		return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;
	};
	LegendModel$1.prototype.getOrient = function() {
		return this.get("orient") === "vertical" ? {
			index: 1,
			name: "vertical"
		} : {
			index: 0,
			name: "horizontal"
		};
	};
	LegendModel$1.type = "legend.plain";
	LegendModel$1.dependencies = ["series"];
	LegendModel$1.defaultOption = {
		z: 4,
		show: true,
		orient: "horizontal",
		left: "center",
		bottom: tokens_default.size.m,
		align: "auto",
		backgroundColor: tokens_default.color.transparent,
		borderColor: tokens_default.color.border,
		borderRadius: 0,
		borderWidth: 0,
		padding: 5,
		itemGap: 8,
		itemWidth: 25,
		itemHeight: 14,
		symbolRotate: "inherit",
		symbolKeepAspect: true,
		inactiveColor: tokens_default.color.disabled,
		inactiveBorderColor: tokens_default.color.disabled,
		inactiveBorderWidth: "auto",
		itemStyle: {
			color: "inherit",
			opacity: "inherit",
			borderColor: "inherit",
			borderWidth: "auto",
			borderCap: "inherit",
			borderJoin: "inherit",
			borderDashOffset: "inherit",
			borderMiterLimit: "inherit"
		},
		lineStyle: {
			width: "auto",
			color: "inherit",
			inactiveColor: tokens_default.color.disabled,
			inactiveWidth: 2,
			opacity: "inherit",
			type: "inherit",
			cap: "inherit",
			join: "inherit",
			dashOffset: "inherit",
			miterLimit: "inherit"
		},
		textStyle: { color: tokens_default.color.secondary },
		selectedMode: true,
		selector: false,
		selectorLabel: {
			show: true,
			borderRadius: 10,
			padding: [
				3,
				5,
				3,
				5
			],
			fontSize: 12,
			fontFamily: "sans-serif",
			color: tokens_default.color.tertiary,
			borderWidth: 1,
			borderColor: tokens_default.color.border
		},
		emphasis: { selectorLabel: {
			show: true,
			color: tokens_default.color.quaternary
		} },
		selectorPosition: "auto",
		selectorItemGap: 7,
		selectorButtonGap: 10,
		tooltip: { show: false },
		triggerEvent: false
	};
	return LegendModel$1;
}(Component_default);
var LegendModel_default = LegendModel;

//#endregion
//#region node_modules/echarts/lib/component/legend/LegendView.js
var curry$1 = curry;
var each$4 = each;
var Group$1 = Group_default;
var LegendView = function(_super) {
	__extends(LegendView$1, _super);
	function LegendView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = LegendView$1.type;
		_this.newlineDisabled = false;
		return _this;
	}
	LegendView$1.prototype.init = function() {
		this.group.add(this._contentGroup = new Group$1());
		this.group.add(this._selectorGroup = new Group$1());
		this._isFirstRender = true;
	};
	/**
	* @protected
	*/
	LegendView$1.prototype.getContentGroup = function() {
		return this._contentGroup;
	};
	/**
	* @protected
	*/
	LegendView$1.prototype.getSelectorGroup = function() {
		return this._selectorGroup;
	};
	/**
	* @override
	*/
	LegendView$1.prototype.render = function(legendModel, ecModel, api) {
		var isFirstRender = this._isFirstRender;
		this._isFirstRender = false;
		this.resetInner();
		if (!legendModel.get("show", true)) return;
		var itemAlign = legendModel.get("align");
		var orient = legendModel.get("orient");
		if (!itemAlign || itemAlign === "auto") itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
		var selector$1 = legendModel.get("selector", true);
		var selectorPosition = legendModel.get("selectorPosition", true);
		if (selector$1 && (!selectorPosition || selectorPosition === "auto")) selectorPosition = orient === "horizontal" ? "end" : "start";
		this.renderInner(itemAlign, legendModel, ecModel, api, selector$1, orient, selectorPosition);
		var refContainer = createBoxLayoutReference(legendModel, api).refContainer;
		var positionInfo = legendModel.getBoxLayoutParams();
		var padding = legendModel.get("padding");
		var maxSize = getLayoutRect(positionInfo, refContainer, padding);
		var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector$1, selectorPosition);
		var layoutRect = getLayoutRect(defaults({
			width: mainRect.width,
			height: mainRect.height
		}, positionInfo), refContainer, padding);
		this.group.x = layoutRect.x - mainRect.x;
		this.group.y = layoutRect.y - mainRect.y;
		this.group.markRedraw();
		this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
	};
	LegendView$1.prototype.resetInner = function() {
		this.getContentGroup().removeAll();
		this._backgroundEl && this.group.remove(this._backgroundEl);
		this.getSelectorGroup().removeAll();
	};
	LegendView$1.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector$1, orient, selectorPosition) {
		var contentGroup = this.getContentGroup();
		var legendDrawnMap = createHashMap();
		var selectMode = legendModel.get("selectedMode");
		var triggerEvent = legendModel.get("triggerEvent");
		var excludeSeriesId = [];
		ecModel.eachRawSeries(function(seriesModel) {
			!seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
		});
		each$4(legendModel.getData(), function(legendItemModel, dataIndex) {
			var _this = this;
			var name = legendItemModel.get("name");
			if (!this.newlineDisabled && (name === "" || name === "\n")) {
				var g = new Group$1();
				g.newline = true;
				contentGroup.add(g);
				return;
			}
			var seriesModel = ecModel.getSeriesByName(name)[0];
			if (legendDrawnMap.get(name)) return;
			if (seriesModel) {
				var data = seriesModel.getData();
				var lineVisualStyle = data.getVisual("legendLineStyle") || {};
				var legendIcon = data.getVisual("legendIcon");
				/**
				* `data.getVisual('style')` may be the color from the register
				* in series. For example, for line series,
				*/
				var style = data.getVisual("style");
				var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api);
				itemGroup.on("click", curry$1(dispatchSelectAction, name, null, api, excludeSeriesId)).on("mouseover", curry$1(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry$1(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
				if (ecModel.ssr) itemGroup.eachChild(function(child) {
					var ecData = getECData(child);
					ecData.seriesIndex = seriesModel.seriesIndex;
					ecData.dataIndex = dataIndex;
					ecData.ssrType = "legend";
				});
				if (triggerEvent) itemGroup.eachChild(function(child) {
					_this.packEventData(child, legendModel, seriesModel, dataIndex, name);
				});
				legendDrawnMap.set(name, true);
			} else ecModel.eachRawSeries(function(seriesModel$1) {
				var _this$1 = this;
				if (legendDrawnMap.get(name)) return;
				if (seriesModel$1.legendVisualProvider) {
					var provider = seriesModel$1.legendVisualProvider;
					if (!provider.containName(name)) return;
					var idx = provider.indexOfName(name);
					var style$1 = provider.getItemVisual(idx, "style");
					var legendIcon$1 = provider.getItemVisual(idx, "legendIcon");
					var colorArr = parse(style$1.fill);
					if (colorArr && colorArr[3] === 0) {
						colorArr[3] = .2;
						style$1 = extend(extend({}, style$1), { fill: stringify(colorArr, "rgba") });
					}
					var itemGroup$1 = this._createItem(seriesModel$1, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style$1, legendIcon$1, selectMode, api);
					itemGroup$1.on("click", curry$1(dispatchSelectAction, null, name, api, excludeSeriesId)).on("mouseover", curry$1(dispatchHighlightAction, null, name, api, excludeSeriesId)).on("mouseout", curry$1(dispatchDownplayAction, null, name, api, excludeSeriesId));
					if (ecModel.ssr) itemGroup$1.eachChild(function(child) {
						var ecData = getECData(child);
						ecData.seriesIndex = seriesModel$1.seriesIndex;
						ecData.dataIndex = dataIndex;
						ecData.ssrType = "legend";
					});
					if (triggerEvent) itemGroup$1.eachChild(function(child) {
						_this$1.packEventData(child, legendModel, seriesModel$1, dataIndex, name);
					});
					legendDrawnMap.set(name, true);
				}
			}, this);
			if (!legendDrawnMap.get(name)) console.warn(name + " series not exists. Legend data should be same with series name or data name.");
		}, this);
		if (selector$1) this._createSelector(selector$1, legendModel, api, orient, selectorPosition);
	};
	LegendView$1.prototype.packEventData = function(el, legendModel, seriesModel, dataIndex, name) {
		var eventData = {
			componentType: "legend",
			componentIndex: legendModel.componentIndex,
			dataIndex,
			value: name,
			seriesIndex: seriesModel.seriesIndex
		};
		getECData(el).eventData = eventData;
	};
	LegendView$1.prototype._createSelector = function(selector$1, legendModel, api, orient, selectorPosition) {
		var selectorGroup = this.getSelectorGroup();
		each$4(selector$1, function createSelectorButton(selectorItem) {
			var type = selectorItem.type;
			var labelText = new Text_default({
				style: {
					x: 0,
					y: 0,
					align: "center",
					verticalAlign: "middle"
				},
				onclick: function() {
					api.dispatchAction({
						type: type === "all" ? "legendAllSelect" : "legendInverseSelect",
						legendId: legendModel.id
					});
				}
			});
			selectorGroup.add(labelText);
			setLabelStyle(labelText, {
				normal: legendModel.getModel("selectorLabel"),
				emphasis: legendModel.getModel(["emphasis", "selectorLabel"])
			}, { defaultText: selectorItem.title });
			enableHoverEmphasis(labelText);
		});
	};
	LegendView$1.prototype._createItem = function(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api) {
		var drawType = seriesModel.visualDrawType;
		var itemWidth = legendModel.get("itemWidth");
		var itemHeight = legendModel.get("itemHeight");
		var isSelected = legendModel.isSelected(name);
		var iconRotate = legendItemModel.get("symbolRotate");
		var symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
		var legendIconType = legendItemModel.get("icon");
		legendIcon = legendIconType || legendIcon || "roundRect";
		var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api);
		var itemGroup = new Group$1();
		var textStyleModel = legendItemModel.getModel("textStyle");
		if (isFunction(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) itemGroup.add(seriesModel.getLegendIcon({
			itemWidth,
			itemHeight,
			icon: legendIcon,
			iconRotate,
			itemStyle: style.itemStyle,
			lineStyle: style.lineStyle,
			symbolKeepAspect
		}));
		else {
			var rotate$1 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
			itemGroup.add(getDefaultLegendIcon({
				itemWidth,
				itemHeight,
				icon: legendIcon,
				iconRotate: rotate$1,
				itemStyle: style.itemStyle,
				lineStyle: style.lineStyle,
				symbolKeepAspect
			}));
		}
		var textX = itemAlign === "left" ? itemWidth + 5 : -5;
		var textAlign = itemAlign;
		var formatter = legendModel.get("formatter");
		var content = name;
		if (isString(formatter) && formatter) content = formatter.replace("{name}", name != null ? name : "");
		else if (isFunction(formatter)) content = formatter(name);
		var textColor = isSelected ? textStyleModel.getTextColor() : legendItemModel.get("inactiveColor");
		itemGroup.add(new Text_default({ style: createTextStyle(textStyleModel, {
			text: content,
			x: textX,
			y: itemHeight / 2,
			fill: textColor,
			align: textAlign,
			verticalAlign: "middle"
		}, { inheritColor: textColor }) }));
		var hitRect = new Rect_default({
			shape: itemGroup.getBoundingRect(),
			style: { fill: "transparent" }
		});
		var tooltipModel = legendItemModel.getModel("tooltip");
		if (tooltipModel.get("show")) setTooltipConfig({
			el: hitRect,
			componentModel: legendModel,
			itemName: name,
			itemTooltipOption: tooltipModel.option
		});
		itemGroup.add(hitRect);
		itemGroup.eachChild(function(child) {
			child.silent = true;
		});
		hitRect.silent = !selectMode;
		this.getContentGroup().add(itemGroup);
		enableHoverEmphasis(itemGroup);
		itemGroup.__legendDataIndex = dataIndex;
		return itemGroup;
	};
	LegendView$1.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector$1, selectorPosition) {
		var contentGroup = this.getContentGroup();
		var selectorGroup = this.getSelectorGroup();
		box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
		var contentRect = contentGroup.getBoundingRect();
		var contentPos = [-contentRect.x, -contentRect.y];
		selectorGroup.markRedraw();
		contentGroup.markRedraw();
		if (selector$1) {
			box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
			var selectorRect = selectorGroup.getBoundingRect();
			var selectorPos = [-selectorRect.x, -selectorRect.y];
			var selectorButtonGap = legendModel.get("selectorButtonGap", true);
			var orientIdx = legendModel.getOrient().index;
			var wh = orientIdx === 0 ? "width" : "height";
			var hw = orientIdx === 0 ? "height" : "width";
			var yx = orientIdx === 0 ? "y" : "x";
			if (selectorPosition === "end") selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
			else contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
			selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
			selectorGroup.x = selectorPos[0];
			selectorGroup.y = selectorPos[1];
			contentGroup.x = contentPos[0];
			contentGroup.y = contentPos[1];
			var mainRect = {
				x: 0,
				y: 0
			};
			mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
			mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
			mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
			return mainRect;
		} else {
			contentGroup.x = contentPos[0];
			contentGroup.y = contentPos[1];
			return this.group.getBoundingRect();
		}
	};
	/**
	* @protected
	*/
	LegendView$1.prototype.remove = function() {
		this.getContentGroup().removeAll();
		this._isFirstRender = true;
	};
	LegendView$1.type = "legend.plain";
	return LegendView$1;
}(Component_default$1);
function getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api) {
	/**
	* Use series style if is inherit;
	* elsewise, use legend style
	*/
	function handleCommonProps(style, visualStyle) {
		if (style.lineWidth === "auto") style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
		each$4(style, function(propVal, propName) {
			style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
		});
	}
	var itemStyleModel = legendItemModel.getModel("itemStyle");
	var itemStyle = itemStyleModel.getItemStyle();
	var iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
	var decalStyle = itemStyleModel.getShallow("decal");
	itemStyle.decal = !decalStyle || decalStyle === "inherit" ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api);
	if (itemStyle.fill === "inherit")
 /**
	* Series with visualDrawType as 'stroke' should have
	* series stroke as legend fill
	*/
	itemStyle.fill = itemVisualStyle[drawType];
	if (itemStyle.stroke === "inherit")
 /**
	* icon type with "emptyXXX" should use fill color
	* in visual style
	*/
	itemStyle.stroke = itemVisualStyle[iconBrushType];
	if (itemStyle.opacity === "inherit")
 /**
	* Use lineStyle.opacity if drawType is stroke
	*/
	itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
	handleCommonProps(itemStyle, itemVisualStyle);
	var legendLineModel = legendItemModel.getModel("lineStyle");
	var lineStyle = legendLineModel.getLineStyle();
	handleCommonProps(lineStyle, lineVisualStyle);
	itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
	itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
	lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
	if (!isSelected) {
		var borderWidth = legendItemModel.get("inactiveBorderWidth");
		/**
		* Since stroke is set to be inactiveBorderColor, it may occur that
		* there is no border in series but border in legend, so we need to
		* use border only when series has border if is set to be auto
		*/
		var visualHasBorder = itemStyle[iconBrushType];
		itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
		itemStyle.fill = legendItemModel.get("inactiveColor");
		itemStyle.stroke = legendItemModel.get("inactiveBorderColor");
		lineStyle.stroke = legendLineModel.get("inactiveColor");
		lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
	}
	return {
		itemStyle,
		lineStyle
	};
}
function getDefaultLegendIcon(opt) {
	var symboType = opt.icon || "roundRect";
	var icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
	icon.setStyle(opt.itemStyle);
	icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
	icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
	if (symboType.indexOf("empty") > -1) {
		icon.style.stroke = icon.style.fill;
		icon.style.fill = tokens_default.color.neutral00;
		icon.style.lineWidth = 2;
	}
	return icon;
}
function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
	dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
	api.dispatchAction({
		type: "legendToggleSelect",
		name: seriesName != null ? seriesName : dataName
	});
	dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
}
function isUseHoverLayer(api) {
	var list = api.getZr().storage.getDisplayList();
	var emphasisState;
	var i$1 = 0;
	var len$1 = list.length;
	while (i$1 < len$1 && !(emphasisState = list[i$1].states.emphasis)) i$1++;
	return emphasisState && emphasisState.hoverLayer;
}
function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
	if (!isUseHoverLayer(api)) api.dispatchAction({
		type: "highlight",
		seriesName,
		name: dataName,
		excludeSeriesId
	});
}
function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
	if (!isUseHoverLayer(api)) api.dispatchAction({
		type: "downplay",
		seriesName,
		name: dataName,
		excludeSeriesId
	});
}
var LegendView_default = LegendView;

//#endregion
//#region node_modules/echarts/lib/component/legend/legendFilter.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function legendFilter(ecModel) {
	var legendModels = ecModel.findComponents({ mainType: "legend" });
	if (legendModels && legendModels.length) ecModel.filterSeries(function(series) {
		for (var i$1 = 0; i$1 < legendModels.length; i$1++) if (!legendModels[i$1].isSelected(series.name)) return false;
		return true;
	});
}

//#endregion
//#region node_modules/echarts/lib/component/legend/legendAction.js
function legendSelectActionHandler(methodName, payload, ecModel) {
	var isAllSelect = methodName === "allSelect" || methodName === "inverseSelect";
	var selectedMap = {};
	var actionLegendIndices = [];
	ecModel.eachComponent({
		mainType: "legend",
		query: payload
	}, function(legendModel) {
		if (isAllSelect) legendModel[methodName]();
		else legendModel[methodName](payload.name);
		makeSelectedMap(legendModel, selectedMap);
		actionLegendIndices.push(legendModel.componentIndex);
	});
	var allSelectedMap = {};
	ecModel.eachComponent("legend", function(legendModel) {
		each(selectedMap, function(isSelected, name) {
			legendModel[isSelected ? "select" : "unSelect"](name);
		});
		makeSelectedMap(legendModel, allSelectedMap);
	});
	return isAllSelect ? {
		selected: allSelectedMap,
		legendIndex: actionLegendIndices
	} : {
		name: payload.name,
		selected: allSelectedMap
	};
}
function makeSelectedMap(legendModel, out$1) {
	var selectedMap = out$1 || {};
	each(legendModel.getData(), function(model) {
		var name = model.get("name");
		if (name === "\n" || name === "") return;
		var isItemSelected = legendModel.isSelected(name);
		if (hasOwn(selectedMap, name)) selectedMap[name] = selectedMap[name] && isItemSelected;
		else selectedMap[name] = isItemSelected;
	});
	return selectedMap;
}
function installLegendAction(registers) {
	/**
	* @event legendToggleSelect
	* @type {Object}
	* @property {string} type 'legendToggleSelect'
	* @property {string} [from]
	* @property {string} name Series name or data item name
	*/
	registers.registerAction("legendToggleSelect", "legendselectchanged", curry(legendSelectActionHandler, "toggleSelected"));
	registers.registerAction("legendAllSelect", "legendselectall", curry(legendSelectActionHandler, "allSelect"));
	registers.registerAction("legendInverseSelect", "legendinverseselect", curry(legendSelectActionHandler, "inverseSelect"));
	/**
	* @event legendSelect
	* @type {Object}
	* @property {string} type 'legendSelect'
	* @property {string} name Series name or data item name
	*/
	registers.registerAction("legendSelect", "legendselected", curry(legendSelectActionHandler, "select"));
	/**
	* @event legendUnSelect
	* @type {Object}
	* @property {string} type 'legendUnSelect'
	* @property {string} name Series name or data item name
	*/
	registers.registerAction("legendUnSelect", "legendunselected", curry(legendSelectActionHandler, "unSelect"));
}

//#endregion
//#region node_modules/echarts/lib/component/legend/installLegendPlain.js
function install$53(registers) {
	registers.registerComponentModel(LegendModel_default);
	registers.registerComponentView(LegendView_default);
	registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
	registers.registerSubTypeDefaulter("legend", function() {
		return "plain";
	});
	installLegendAction(registers);
}

//#endregion
//#region node_modules/echarts/lib/component/legend/ScrollableLegendModel.js
var ScrollableLegendModel = function(_super) {
	__extends(ScrollableLegendModel$1, _super);
	function ScrollableLegendModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ScrollableLegendModel$1.type;
		return _this;
	}
	/**
	* @param {number} scrollDataIndex
	*/
	ScrollableLegendModel$1.prototype.setScrollDataIndex = function(scrollDataIndex) {
		this.option.scrollDataIndex = scrollDataIndex;
	};
	ScrollableLegendModel$1.prototype.init = function(option, parentModel, ecModel) {
		var inputPositionParams = getLayoutParams(option);
		_super.prototype.init.call(this, option, parentModel, ecModel);
		mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
	};
	/**
	* @override
	*/
	ScrollableLegendModel$1.prototype.mergeOption = function(option, ecModel) {
		_super.prototype.mergeOption.call(this, option, ecModel);
		mergeAndNormalizeLayoutParams(this, this.option, option);
	};
	ScrollableLegendModel$1.type = "legend.scroll";
	ScrollableLegendModel$1.defaultOption = inheritDefaultOption(LegendModel_default.defaultOption, {
		scrollDataIndex: 0,
		pageButtonItemGap: 5,
		pageButtonGap: null,
		pageButtonPosition: "end",
		pageFormatter: "{current}/{total}",
		pageIcons: {
			horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
			vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
		},
		pageIconColor: tokens_default.color.accent50,
		pageIconInactiveColor: tokens_default.color.accent10,
		pageIconSize: 15,
		pageTextStyle: { color: tokens_default.color.tertiary },
		animationDurationUpdate: 800
	});
	return ScrollableLegendModel$1;
}(LegendModel_default);
function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
	var orient = legendModel.getOrient();
	var ignoreSize = [1, 1];
	ignoreSize[orient.index] = 0;
	mergeLayoutParam(target, raw, {
		type: "box",
		ignoreSize: !!ignoreSize
	});
}
var ScrollableLegendModel_default = ScrollableLegendModel;

//#endregion
//#region node_modules/echarts/lib/component/legend/ScrollableLegendView.js
var Group = Group_default;
var WH$1 = ["width", "height"];
var XY$1 = ["x", "y"];
var ScrollableLegendView = function(_super) {
	__extends(ScrollableLegendView$1, _super);
	function ScrollableLegendView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ScrollableLegendView$1.type;
		_this.newlineDisabled = true;
		_this._currentIndex = 0;
		return _this;
	}
	ScrollableLegendView$1.prototype.init = function() {
		_super.prototype.init.call(this);
		this.group.add(this._containerGroup = new Group());
		this._containerGroup.add(this.getContentGroup());
		this.group.add(this._controllerGroup = new Group());
	};
	/**
	* @override
	*/
	ScrollableLegendView$1.prototype.resetInner = function() {
		_super.prototype.resetInner.call(this);
		this._controllerGroup.removeAll();
		this._containerGroup.removeClipPath();
		this._containerGroup.__rectSize = null;
	};
	/**
	* @override
	*/
	ScrollableLegendView$1.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector$1, orient, selectorPosition) {
		var self$1 = this;
		_super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector$1, orient, selectorPosition);
		var controllerGroup = this._controllerGroup;
		var pageIconSize = legendModel.get("pageIconSize", true);
		var pageIconSizeArr = isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
		createPageButton("pagePrev", 0);
		var pageTextStyleModel = legendModel.getModel("pageTextStyle");
		controllerGroup.add(new Text_default({
			name: "pageText",
			style: {
				text: "xx/xx",
				fill: pageTextStyleModel.getTextColor(),
				font: pageTextStyleModel.getFont(),
				verticalAlign: "middle",
				align: "center"
			},
			silent: true
		}));
		createPageButton("pageNext", 1);
		function createPageButton(name, iconIdx) {
			var pageDataIndexName = name + "DataIndex";
			var icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], { onclick: bind(self$1._pageGo, self$1, pageDataIndexName, legendModel, api) }, {
				x: -pageIconSizeArr[0] / 2,
				y: -pageIconSizeArr[1] / 2,
				width: pageIconSizeArr[0],
				height: pageIconSizeArr[1]
			});
			icon.name = name;
			controllerGroup.add(icon);
		}
	};
	/**
	* @override
	*/
	ScrollableLegendView$1.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector$1, selectorPosition) {
		var selectorGroup = this.getSelectorGroup();
		var orientIdx = legendModel.getOrient().index;
		var wh = WH$1[orientIdx];
		var xy = XY$1[orientIdx];
		var hw = WH$1[1 - orientIdx];
		var yx = XY$1[1 - orientIdx];
		selector$1 && box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
		var selectorButtonGap = legendModel.get("selectorButtonGap", true);
		var selectorRect = selectorGroup.getBoundingRect();
		var selectorPos = [-selectorRect.x, -selectorRect.y];
		var processMaxSize = clone(maxSize);
		selector$1 && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
		var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);
		if (selector$1) {
			if (selectorPosition === "end") selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
			else {
				var offset = selectorRect[wh] + selectorButtonGap;
				selectorPos[orientIdx] -= offset;
				mainRect[xy] -= offset;
			}
			mainRect[wh] += selectorRect[wh] + selectorButtonGap;
			selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
			mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
			mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
			selectorGroup.x = selectorPos[0];
			selectorGroup.y = selectorPos[1];
			selectorGroup.markRedraw();
		}
		return mainRect;
	};
	ScrollableLegendView$1.prototype._layoutContentAndController = function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
		var contentGroup = this.getContentGroup();
		var containerGroup = this._containerGroup;
		var controllerGroup = this._controllerGroup;
		box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
		box("horizontal", controllerGroup, legendModel.get("pageButtonItemGap", true));
		var contentRect = contentGroup.getBoundingRect();
		var controllerRect = controllerGroup.getBoundingRect();
		var showController = this._showController = contentRect[wh] > maxSize[wh];
		var contentPos = [-contentRect.x, -contentRect.y];
		if (!isFirstRender) contentPos[orientIdx] = contentGroup[xy];
		var containerPos = [0, 0];
		var controllerPos = [-controllerRect.x, -controllerRect.y];
		var pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
		if (showController) if (legendModel.get("pageButtonPosition", true) === "end") controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
		else containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
		controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
		contentGroup.setPosition(contentPos);
		containerGroup.setPosition(containerPos);
		controllerGroup.setPosition(controllerPos);
		var mainRect = {
			x: 0,
			y: 0
		};
		mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
		mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
		mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
		containerGroup.__rectSize = maxSize[wh];
		if (showController) {
			var clipShape = {
				x: 0,
				y: 0
			};
			clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
			clipShape[hw] = mainRect[hw];
			containerGroup.setClipPath(new Rect_default({ shape: clipShape }));
			containerGroup.__rectSize = clipShape[wh];
		} else controllerGroup.eachChild(function(child) {
			child.attr({
				invisible: true,
				silent: true
			});
		});
		var pageInfo = this._getPageInfo(legendModel);
		pageInfo.pageIndex != null && updateProps(contentGroup, {
			x: pageInfo.contentPosition[0],
			y: pageInfo.contentPosition[1]
		}, showController ? legendModel : null);
		this._updatePageInfoView(legendModel, pageInfo);
		return mainRect;
	};
	ScrollableLegendView$1.prototype._pageGo = function(to, legendModel, api) {
		var scrollDataIndex = this._getPageInfo(legendModel)[to];
		scrollDataIndex != null && api.dispatchAction({
			type: "legendScroll",
			scrollDataIndex,
			legendId: legendModel.id
		});
	};
	ScrollableLegendView$1.prototype._updatePageInfoView = function(legendModel, pageInfo) {
		var controllerGroup = this._controllerGroup;
		each(["pagePrev", "pageNext"], function(name) {
			var canJump = pageInfo[name + "DataIndex"] != null;
			var icon = controllerGroup.childOfName(name);
			if (icon) {
				icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
				icon.cursor = canJump ? "pointer" : "default";
			}
		});
		var pageText = controllerGroup.childOfName("pageText");
		var pageFormatter = legendModel.get("pageFormatter");
		var pageIndex = pageInfo.pageIndex;
		var current = pageIndex != null ? pageIndex + 1 : 0;
		var total = pageInfo.pageCount;
		pageText && pageFormatter && pageText.setStyle("text", isString(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({
			current,
			total
		}));
	};
	/**
	*  contentPosition: Array.<number>, null when data item not found.
	*  pageIndex: number, null when data item not found.
	*  pageCount: number, always be a number, can be 0.
	*  pagePrevDataIndex: number, null when no previous page.
	*  pageNextDataIndex: number, null when no next page.
	* }
	*/
	ScrollableLegendView$1.prototype._getPageInfo = function(legendModel) {
		var scrollDataIndex = legendModel.get("scrollDataIndex", true);
		var contentGroup = this.getContentGroup();
		var containerRectSize = this._containerGroup.__rectSize;
		var orientIdx = legendModel.getOrient().index;
		var wh = WH$1[orientIdx];
		var xy = XY$1[orientIdx];
		var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
		var children = contentGroup.children();
		var targetItem = children[targetItemIndex];
		var itemCount = children.length;
		var pCount = !itemCount ? 0 : 1;
		var result = {
			contentPosition: [contentGroup.x, contentGroup.y],
			pageCount: pCount,
			pageIndex: pCount - 1,
			pagePrevDataIndex: null,
			pageNextDataIndex: null
		};
		if (!targetItem) return result;
		var targetItemInfo = getItemInfo(targetItem);
		result.contentPosition[orientIdx] = -targetItemInfo.s;
		for (var i$1 = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i$1 <= itemCount; ++i$1) {
			currItemInfo = getItemInfo(children[i$1]);
			if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect$1(currItemInfo, winStartItemInfo.s)) {
				if (winEndItemInfo.i > winStartItemInfo.i) winStartItemInfo = winEndItemInfo;
				else winStartItemInfo = currItemInfo;
				if (winStartItemInfo) {
					if (result.pageNextDataIndex == null) result.pageNextDataIndex = winStartItemInfo.i;
					++result.pageCount;
				}
			}
			winEndItemInfo = currItemInfo;
		}
		for (var i$1 = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i$1 >= -1; --i$1) {
			currItemInfo = getItemInfo(children[i$1]);
			if ((!currItemInfo || !intersect$1(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {
				winEndItemInfo = winStartItemInfo;
				if (result.pagePrevDataIndex == null) result.pagePrevDataIndex = winStartItemInfo.i;
				++result.pageCount;
				++result.pageIndex;
			}
			winStartItemInfo = currItemInfo;
		}
		return result;
		function getItemInfo(el) {
			if (el) {
				var itemRect = el.getBoundingRect();
				var start$1 = itemRect[xy] + el[xy];
				return {
					s: start$1,
					e: start$1 + itemRect[wh],
					i: el.__legendDataIndex
				};
			}
		}
		function intersect$1(itemInfo, winStart) {
			return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
		}
	};
	ScrollableLegendView$1.prototype._findTargetItemIndex = function(targetDataIndex) {
		if (!this._showController) return 0;
		var index;
		var contentGroup = this.getContentGroup();
		var defaultIndex;
		contentGroup.eachChild(function(child, idx) {
			var legendDataIdx = child.__legendDataIndex;
			if (defaultIndex == null && legendDataIdx != null) defaultIndex = idx;
			if (legendDataIdx === targetDataIndex) index = idx;
		});
		return index != null ? index : defaultIndex;
	};
	ScrollableLegendView$1.type = "legend.scroll";
	return ScrollableLegendView$1;
}(LegendView_default);
var ScrollableLegendView_default = ScrollableLegendView;

//#endregion
//#region node_modules/echarts/lib/component/legend/scrollableLegendAction.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function installScrollableLegendAction(registers) {
	/**
	* @event legendScroll
	* @type {Object}
	* @property {string} type 'legendScroll'
	* @property {string} scrollDataIndex
	*/
	registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
		var scrollDataIndex = payload.scrollDataIndex;
		scrollDataIndex != null && ecModel.eachComponent({
			mainType: "legend",
			subType: "scroll",
			query: payload
		}, function(legendModel) {
			legendModel.setScrollDataIndex(scrollDataIndex);
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/component/legend/installLegendScroll.js
function install$54(registers) {
	use(install$53);
	registers.registerComponentModel(ScrollableLegendModel_default);
	registers.registerComponentView(ScrollableLegendView_default);
	installScrollableLegendAction(registers);
}

//#endregion
//#region node_modules/echarts/lib/component/legend/install.js
function install$42(registers) {
	use(install$53);
	use(install$54);
}

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js
var InsideZoomModel = function(_super) {
	__extends(InsideZoomModel$1, _super);
	function InsideZoomModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = InsideZoomModel$1.type;
		return _this;
	}
	InsideZoomModel$1.type = "dataZoom.inside";
	InsideZoomModel$1.defaultOption = inheritDefaultOption(DataZoomModel_default.defaultOption, {
		disabled: false,
		zoomLock: false,
		zoomOnMouseWheel: true,
		moveOnMouseMove: true,
		moveOnMouseWheel: false,
		preventDefaultMouseMove: true
	});
	return InsideZoomModel$1;
}(DataZoomModel_default);
var InsideZoomModel_default = InsideZoomModel;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/roams.js
var inner$1 = makeInner();
function setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {
	inner$1(api).coordSysRecordMap.each(function(coordSysRecord) {
		var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);
		if (dzInfo) dzInfo.getRange = getRange;
	});
}
function disposeCoordSysRecordIfNeeded(api, dataZoomModel) {
	var coordSysRecordMap = inner$1(api).coordSysRecordMap;
	var coordSysKeyArr = coordSysRecordMap.keys();
	for (var i$1 = 0; i$1 < coordSysKeyArr.length; i$1++) {
		var coordSysKey = coordSysKeyArr[i$1];
		var coordSysRecord = coordSysRecordMap.get(coordSysKey);
		var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
		if (dataZoomInfoMap) {
			var dzUid = dataZoomModel.uid;
			if (dataZoomInfoMap.get(dzUid)) {
				dataZoomInfoMap.removeKey(dzUid);
				if (!dataZoomInfoMap.keys().length) disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
			}
		}
	}
}
function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
	if (coordSysRecord) {
		coordSysRecordMap.removeKey(coordSysRecord.model.uid);
		var controller = coordSysRecord.controller;
		controller && controller.dispose();
	}
}
function createCoordSysRecord(api, coordSysModel) {
	var coordSysRecord = {
		model: coordSysModel,
		containsPoint: curry(containsPoint, coordSysModel),
		dispatchAction: curry(dispatchAction, api),
		dataZoomInfoMap: null,
		controller: null
	};
	var controller = coordSysRecord.controller = new RoamController_default(api.getZr());
	each([
		"pan",
		"zoom",
		"scrollMove"
	], function(eventName) {
		controller.on(eventName, function(event) {
			var batch = [];
			coordSysRecord.dataZoomInfoMap.each(function(dzInfo) {
				if (!event.isAvailableBehavior(dzInfo.model.option)) return;
				var method = (dzInfo.getRange || {})[eventName];
				var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
				!dzInfo.model.get("disabled", true) && range && batch.push({
					dataZoomId: dzInfo.model.id,
					start: range[0],
					end: range[1]
				});
			});
			batch.length && coordSysRecord.dispatchAction(batch);
		});
	});
	return coordSysRecord;
}
/**
* This action will be throttled.
*/
function dispatchAction(api, batch) {
	if (!api.isDisposed()) api.dispatchAction({
		type: "dataZoom",
		animation: {
			easing: "cubicOut",
			duration: 100
		},
		batch
	});
}
function containsPoint(coordSysModel, e$1, x, y) {
	return coordSysModel.coordinateSystem.containPoint([x, y]);
}
/**
* Merge roamController settings when multiple dataZooms share one roamController.
*/
function mergeControllerParams(dataZoomInfoMap, coordSysRecord, api) {
	var controlType;
	var prefix = "type_";
	var typePriority = {
		"type_true": 2,
		"type_move": 1,
		"type_false": 0,
		"type_undefined": -1
	};
	var preventDefaultMouseMove = true;
	dataZoomInfoMap.each(function(dataZoomInfo) {
		var dataZoomModel = dataZoomInfo.model;
		var oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
		if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) controlType = oneType;
		preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get("preventDefaultMouseMove", true);
	});
	return {
		controlType,
		opt: {
			zoomOnMouseWheel: true,
			moveOnMouseMove: true,
			moveOnMouseWheel: true,
			preventDefaultMouseMove: !!preventDefaultMouseMove,
			api,
			zInfo: { component: coordSysRecord.model },
			triggerInfo: {
				roamTrigger: null,
				isInSelf: coordSysRecord.containsPoint
			}
		}
	};
}
function installDataZoomRoamProcessor(registers) {
	registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function(ecModel, api) {
		var apiInner = inner$1(api);
		var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap());
		coordSysRecordMap.each(function(coordSysRecord) {
			coordSysRecord.dataZoomInfoMap = null;
		});
		ecModel.eachComponent({
			mainType: "dataZoom",
			subType: "inside"
		}, function(dataZoomModel) {
			each(collectReferCoordSysModelInfo(dataZoomModel).infoList, function(dzCoordSysInfo) {
				var coordSysUid = dzCoordSysInfo.model.uid;
				var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));
				(coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap())).set(dataZoomModel.uid, {
					dzReferCoordSysInfo: dzCoordSysInfo,
					model: dataZoomModel,
					getRange: null
				});
			});
		});
		coordSysRecordMap.each(function(coordSysRecord) {
			var controller = coordSysRecord.controller;
			var firstDzInfo;
			var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
			if (dataZoomInfoMap) {
				var firstDzKey = dataZoomInfoMap.keys()[0];
				if (firstDzKey != null) firstDzInfo = dataZoomInfoMap.get(firstDzKey);
			}
			if (!firstDzInfo) {
				disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
				return;
			}
			var controllerParams = mergeControllerParams(dataZoomInfoMap, coordSysRecord, api);
			controller.enable(controllerParams.controlType, controllerParams.opt);
			createOrUpdate(coordSysRecord, "dispatchAction", firstDzInfo.model.get("throttle", true), "fixRate");
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/InsideZoomView.js
var InsideZoomView = function(_super) {
	__extends(InsideZoomView$1, _super);
	function InsideZoomView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "dataZoom.inside";
		return _this;
	}
	InsideZoomView$1.prototype.render = function(dataZoomModel, ecModel, api) {
		_super.prototype.render.apply(this, arguments);
		if (dataZoomModel.noTarget()) {
			this._clear();
			return;
		}
		this.range = dataZoomModel.getPercentRange();
		setViewInfoToCoordSysRecord(api, dataZoomModel, {
			pan: bind(getRangeHandlers.pan, this),
			zoom: bind(getRangeHandlers.zoom, this),
			scrollMove: bind(getRangeHandlers.scrollMove, this)
		});
	};
	InsideZoomView$1.prototype.dispose = function() {
		this._clear();
		_super.prototype.dispose.apply(this, arguments);
	};
	InsideZoomView$1.prototype._clear = function() {
		disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
		this.range = null;
	};
	InsideZoomView$1.type = "dataZoom.inside";
	return InsideZoomView$1;
}(DataZoomView_default);
var getRangeHandlers = {
	zoom: function(coordSysInfo, coordSysMainType, controller, e$1) {
		var lastRange = this.range;
		var range = lastRange.slice();
		var axisModel = coordSysInfo.axisModels[0];
		if (!axisModel) return;
		var directionInfo = getDirectionInfo[coordSysMainType](null, [e$1.originX, e$1.originY], axisModel, controller, coordSysInfo);
		var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
		var scale$3 = Math.max(1 / e$1.scale, 0);
		range[0] = (range[0] - percentPoint) * scale$3 + percentPoint;
		range[1] = (range[1] - percentPoint) * scale$3 + percentPoint;
		var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
		sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
		this.range = range;
		if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) return range;
	},
	pan: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e$1) {
		var directionInfo = getDirectionInfo[coordSysMainType]([e$1.oldX, e$1.oldY], [e$1.newX, e$1.newY], axisModel, controller, coordSysInfo);
		return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
	}),
	scrollMove: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e$1) {
		return getDirectionInfo[coordSysMainType]([0, 0], [e$1.scrollDelta, e$1.scrollDelta], axisModel, controller, coordSysInfo).signal * (range[1] - range[0]) * e$1.scrollDelta;
	})
};
function makeMover(getPercentDelta) {
	return function(coordSysInfo, coordSysMainType, controller, e$1) {
		var lastRange = this.range;
		var range = lastRange.slice();
		var axisModel = coordSysInfo.axisModels[0];
		if (!axisModel) return;
		sliderMove(getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e$1), range, [0, 100], "all");
		this.range = range;
		if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) return range;
	};
}
var getDirectionInfo = {
	grid: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
		var axis = axisModel.axis;
		var ret = {};
		var rect = coordSysInfo.model.coordinateSystem.getRect();
		oldPoint = oldPoint || [0, 0];
		if (axis.dim === "x") {
			ret.pixel = newPoint[0] - oldPoint[0];
			ret.pixelLength = rect.width;
			ret.pixelStart = rect.x;
			ret.signal = axis.inverse ? 1 : -1;
		} else {
			ret.pixel = newPoint[1] - oldPoint[1];
			ret.pixelLength = rect.height;
			ret.pixelStart = rect.y;
			ret.signal = axis.inverse ? -1 : 1;
		}
		return ret;
	},
	polar: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
		var axis = axisModel.axis;
		var ret = {};
		var polar = coordSysInfo.model.coordinateSystem;
		var radiusExtent = polar.getRadiusAxis().getExtent();
		var angleExtent = polar.getAngleAxis().getExtent();
		oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
		newPoint = polar.pointToCoord(newPoint);
		if (axisModel.mainType === "radiusAxis") {
			ret.pixel = newPoint[0] - oldPoint[0];
			ret.pixelLength = radiusExtent[1] - radiusExtent[0];
			ret.pixelStart = radiusExtent[0];
			ret.signal = axis.inverse ? 1 : -1;
		} else {
			ret.pixel = newPoint[1] - oldPoint[1];
			ret.pixelLength = angleExtent[1] - angleExtent[0];
			ret.pixelStart = angleExtent[0];
			ret.signal = axis.inverse ? -1 : 1;
		}
		return ret;
	},
	singleAxis: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
		var axis = axisModel.axis;
		var rect = coordSysInfo.model.coordinateSystem.getRect();
		var ret = {};
		oldPoint = oldPoint || [0, 0];
		if (axis.orient === "horizontal") {
			ret.pixel = newPoint[0] - oldPoint[0];
			ret.pixelLength = rect.width;
			ret.pixelStart = rect.x;
			ret.signal = axis.inverse ? 1 : -1;
		} else {
			ret.pixel = newPoint[1] - oldPoint[1];
			ret.pixelLength = rect.height;
			ret.pixelStart = rect.y;
			ret.signal = axis.inverse ? -1 : 1;
		}
		return ret;
	}
};
var InsideZoomView_default = InsideZoomView;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/installDataZoomInside.js
function install$44(registers) {
	installCommon$1(registers);
	registers.registerComponentModel(InsideZoomModel_default);
	registers.registerComponentView(InsideZoomView_default);
	installDataZoomRoamProcessor(registers);
}

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js
var SliderZoomModel = function(_super) {
	__extends(SliderZoomModel$1, _super);
	function SliderZoomModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SliderZoomModel$1.type;
		return _this;
	}
	SliderZoomModel$1.type = "dataZoom.slider";
	SliderZoomModel$1.layoutMode = "box";
	SliderZoomModel$1.defaultOption = inheritDefaultOption(DataZoomModel_default.defaultOption, {
		show: true,
		right: "ph",
		top: "ph",
		width: "ph",
		height: "ph",
		left: null,
		bottom: null,
		borderColor: tokens_default.color.accent10,
		borderRadius: 0,
		backgroundColor: tokens_default.color.transparent,
		dataBackground: {
			lineStyle: {
				color: tokens_default.color.accent30,
				width: .5
			},
			areaStyle: {
				color: tokens_default.color.accent20,
				opacity: .2
			}
		},
		selectedDataBackground: {
			lineStyle: {
				color: tokens_default.color.accent40,
				width: .5
			},
			areaStyle: {
				color: tokens_default.color.accent20,
				opacity: .3
			}
		},
		fillerColor: "rgba(135,175,274,0.2)",
		handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
		handleSize: "100%",
		handleStyle: {
			color: tokens_default.color.neutral00,
			borderColor: tokens_default.color.accent20
		},
		moveHandleSize: 7,
		moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
		moveHandleStyle: {
			color: tokens_default.color.accent40,
			opacity: .5
		},
		showDetail: true,
		showDataShadow: "auto",
		realtime: true,
		zoomLock: false,
		textStyle: { color: tokens_default.color.tertiary },
		brushSelect: true,
		brushStyle: {
			color: tokens_default.color.accent30,
			opacity: .3
		},
		emphasis: {
			handleLabel: { show: true },
			handleStyle: { borderColor: tokens_default.color.accent40 },
			moveHandleStyle: { opacity: .8 }
		},
		defaultLocationEdgeGap: 15
	});
	return SliderZoomModel$1;
}(DataZoomModel_default);
var SliderZoomModel_default = SliderZoomModel;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/SliderZoomView.js
var Rect = Rect_default;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var DEFAULT_MOVE_HANDLE_SIZE = 7;
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = [
	"line",
	"bar",
	"candlestick",
	"scatter"
];
var REALTIME_ANIMATION_CONFIG = {
	easing: "cubicOut",
	duration: 100,
	delay: 0
};
var SliderZoomView = function(_super) {
	__extends(SliderZoomView$1, _super);
	function SliderZoomView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = SliderZoomView$1.type;
		_this._displayables = {};
		return _this;
	}
	SliderZoomView$1.prototype.init = function(ecModel, api) {
		this.api = api;
		this._onBrush = bind(this._onBrush, this);
		this._onBrushEnd = bind(this._onBrushEnd, this);
	};
	SliderZoomView$1.prototype.render = function(dataZoomModel, ecModel, api, payload) {
		_super.prototype.render.apply(this, arguments);
		createOrUpdate(this, "_dispatchZoomAction", dataZoomModel.get("throttle"), "fixRate");
		this._orient = dataZoomModel.getOrient();
		if (dataZoomModel.get("show") === false) {
			this.group.removeAll();
			return;
		}
		if (dataZoomModel.noTarget()) {
			this._clear();
			this.group.removeAll();
			return;
		}
		if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) this._buildView();
		this._updateView();
	};
	SliderZoomView$1.prototype.dispose = function() {
		this._clear();
		_super.prototype.dispose.apply(this, arguments);
	};
	SliderZoomView$1.prototype._clear = function() {
		clear(this, "_dispatchZoomAction");
		var zr = this.api.getZr();
		zr.off("mousemove", this._onBrush);
		zr.off("mouseup", this._onBrushEnd);
	};
	SliderZoomView$1.prototype._buildView = function() {
		var thisGroup = this.group;
		thisGroup.removeAll();
		this._brushing = false;
		this._displayables.brushRect = null;
		this._resetLocation();
		this._resetInterval();
		var barGroup = this._displayables.sliderGroup = new Group_default();
		this._renderBackground();
		this._renderHandle();
		this._renderDataShadow();
		thisGroup.add(barGroup);
		this._positionGroup();
	};
	SliderZoomView$1.prototype._resetLocation = function() {
		var dataZoomModel = this.dataZoomModel;
		var api = this.api;
		var moveHandleSize = dataZoomModel.get("brushSelect") ? DEFAULT_MOVE_HANDLE_SIZE : 0;
		var refContainer = createBoxLayoutReference(dataZoomModel, api).refContainer;
		var coordRect = this._findCoordRect();
		var edgeGap = dataZoomModel.get("defaultLocationEdgeGap", true) || 0;
		var positionInfo = this._orient === HORIZONTAL ? {
			right: refContainer.width - coordRect.x - coordRect.width,
			top: refContainer.height - DEFAULT_FILLER_SIZE - edgeGap - moveHandleSize,
			width: coordRect.width,
			height: DEFAULT_FILLER_SIZE
		} : {
			right: edgeGap,
			top: coordRect.y,
			width: DEFAULT_FILLER_SIZE,
			height: coordRect.height
		};
		var layoutParams = getLayoutParams(dataZoomModel.option);
		each([
			"right",
			"top",
			"width",
			"height"
		], function(name) {
			if (layoutParams[name] === "ph") layoutParams[name] = positionInfo[name];
		});
		var layoutRect = getLayoutRect(layoutParams, refContainer);
		this._location = {
			x: layoutRect.x,
			y: layoutRect.y
		};
		this._size = [layoutRect.width, layoutRect.height];
		this._orient === VERTICAL && this._size.reverse();
	};
	SliderZoomView$1.prototype._positionGroup = function() {
		var thisGroup = this.group;
		var location = this._location;
		var orient = this._orient;
		var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
		var inverse = targetAxisModel && targetAxisModel.get("inverse");
		var sliderGroup = this._displayables.sliderGroup;
		var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
		sliderGroup.attr(orient === HORIZONTAL && !inverse ? {
			scaleY: otherAxisInverse ? 1 : -1,
			scaleX: 1
		} : orient === HORIZONTAL && inverse ? {
			scaleY: otherAxisInverse ? 1 : -1,
			scaleX: -1
		} : orient === VERTICAL && !inverse ? {
			scaleY: otherAxisInverse ? -1 : 1,
			scaleX: 1,
			rotation: Math.PI / 2
		} : {
			scaleY: otherAxisInverse ? -1 : 1,
			scaleX: -1,
			rotation: Math.PI / 2
		});
		var rect = thisGroup.getBoundingRect([sliderGroup]);
		thisGroup.x = location.x - rect.x;
		thisGroup.y = location.y - rect.y;
		thisGroup.markRedraw();
	};
	SliderZoomView$1.prototype._getViewExtent = function() {
		return [0, this._size[0]];
	};
	SliderZoomView$1.prototype._renderBackground = function() {
		var dataZoomModel = this.dataZoomModel;
		var size = this._size;
		var barGroup = this._displayables.sliderGroup;
		var brushSelect = dataZoomModel.get("brushSelect");
		barGroup.add(new Rect({
			silent: true,
			shape: {
				x: 0,
				y: 0,
				width: size[0],
				height: size[1]
			},
			style: { fill: dataZoomModel.get("backgroundColor") },
			z2: -40
		}));
		var clickPanel = new Rect({
			shape: {
				x: 0,
				y: 0,
				width: size[0],
				height: size[1]
			},
			style: { fill: "transparent" },
			z2: 0,
			onclick: bind(this._onClickPanel, this)
		});
		var zr = this.api.getZr();
		if (brushSelect) {
			clickPanel.on("mousedown", this._onBrushStart, this);
			clickPanel.cursor = "crosshair";
			zr.on("mousemove", this._onBrush);
			zr.on("mouseup", this._onBrushEnd);
		} else {
			zr.off("mousemove", this._onBrush);
			zr.off("mouseup", this._onBrushEnd);
		}
		barGroup.add(clickPanel);
	};
	SliderZoomView$1.prototype._renderDataShadow = function() {
		var info = this._dataShadowInfo = this._prepareDataShadowInfo();
		this._displayables.dataShadowSegs = [];
		if (!info) return;
		var size = this._size;
		var oldSize = this._shadowSize || [];
		var seriesModel = info.series;
		var data = seriesModel.getRawData();
		var candlestickDim = seriesModel.getShadowDim && seriesModel.getShadowDim();
		var otherDim = candlestickDim && data.getDimensionInfo(candlestickDim) ? seriesModel.getShadowDim() : info.otherDim;
		if (otherDim == null) return;
		var polygonPts = this._shadowPolygonPts;
		var polylinePts = this._shadowPolylinePts;
		if (data !== this._shadowData || otherDim !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
			var thisDataExtent_1 = data.getDataExtent(info.thisDim);
			var otherDataExtent_1 = data.getDataExtent(otherDim);
			var otherOffset = (otherDataExtent_1[1] - otherDataExtent_1[0]) * .3;
			otherDataExtent_1 = [otherDataExtent_1[0] - otherOffset, otherDataExtent_1[1] + otherOffset];
			var otherShadowExtent_1 = [0, size[1]];
			var thisShadowExtent = [0, size[0]];
			var areaPoints_1 = [[size[0], 0], [0, 0]];
			var linePoints_1 = [];
			var step_1 = thisShadowExtent[1] / Math.max(1, data.count() - 1);
			var normalizationConstant_1 = size[0] / (thisDataExtent_1[1] - thisDataExtent_1[0]);
			var isTimeAxis_1 = info.thisAxis.type === "time";
			var thisCoord_1 = -step_1;
			var stride_1 = Math.round(data.count() / size[0]);
			var lastIsEmpty_1;
			data.each([info.thisDim, otherDim], function(thisValue, otherValue, index) {
				if (stride_1 > 0 && index % stride_1) {
					if (!isTimeAxis_1) thisCoord_1 += step_1;
					return;
				}
				thisCoord_1 = isTimeAxis_1 ? (+thisValue - thisDataExtent_1[0]) * normalizationConstant_1 : thisCoord_1 + step_1;
				var isEmpty = otherValue == null || isNaN(otherValue) || otherValue === "";
				var otherCoord = isEmpty ? 0 : linearMap$2(otherValue, otherDataExtent_1, otherShadowExtent_1, true);
				if (isEmpty && !lastIsEmpty_1 && index) {
					areaPoints_1.push([areaPoints_1[areaPoints_1.length - 1][0], 0]);
					linePoints_1.push([linePoints_1[linePoints_1.length - 1][0], 0]);
				} else if (!isEmpty && lastIsEmpty_1) {
					areaPoints_1.push([thisCoord_1, 0]);
					linePoints_1.push([thisCoord_1, 0]);
				}
				if (!isEmpty) {
					areaPoints_1.push([thisCoord_1, otherCoord]);
					linePoints_1.push([thisCoord_1, otherCoord]);
				}
				lastIsEmpty_1 = isEmpty;
			});
			polygonPts = this._shadowPolygonPts = areaPoints_1;
			polylinePts = this._shadowPolylinePts = linePoints_1;
		}
		this._shadowData = data;
		this._shadowDim = otherDim;
		this._shadowSize = [size[0], size[1]];
		var dataZoomModel = this.dataZoomModel;
		function createDataShadowGroup(isSelectedArea) {
			var model = dataZoomModel.getModel(isSelectedArea ? "selectedDataBackground" : "dataBackground");
			var group$1 = new Group_default();
			var polygon = new Polygon_default({
				shape: { points: polygonPts },
				segmentIgnoreThreshold: 1,
				style: model.getModel("areaStyle").getAreaStyle(),
				silent: true,
				z2: -20
			});
			var polyline = new Polyline_default({
				shape: { points: polylinePts },
				segmentIgnoreThreshold: 1,
				style: model.getModel("lineStyle").getLineStyle(),
				silent: true,
				z2: -19
			});
			group$1.add(polygon);
			group$1.add(polyline);
			return group$1;
		}
		for (var i$1 = 0; i$1 < 3; i$1++) {
			var group = createDataShadowGroup(i$1 === 1);
			this._displayables.sliderGroup.add(group);
			this._displayables.dataShadowSegs.push(group);
		}
	};
	SliderZoomView$1.prototype._prepareDataShadowInfo = function() {
		var dataZoomModel = this.dataZoomModel;
		var showDataShadow = dataZoomModel.get("showDataShadow");
		if (showDataShadow === false) return;
		var result;
		var ecModel = this.ecModel;
		dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
			each(dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels(), function(seriesModel) {
				if (result) return;
				if (showDataShadow !== true && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) return;
				var thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis;
				var otherDim = getOtherDim(axisDim);
				var otherAxisInverse;
				var coordSys = seriesModel.coordinateSystem;
				if (otherDim != null && coordSys.getOtherAxis) otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
				otherDim = seriesModel.getData().mapDimension(otherDim);
				result = {
					thisAxis,
					series: seriesModel,
					thisDim: seriesModel.getData().mapDimension(axisDim),
					otherDim,
					otherAxisInverse
				};
			}, this);
		}, this);
		return result;
	};
	SliderZoomView$1.prototype._renderHandle = function() {
		var thisGroup = this.group;
		var displayables = this._displayables;
		var handles = displayables.handles = [null, null];
		var handleLabels = displayables.handleLabels = [null, null];
		var sliderGroup = this._displayables.sliderGroup;
		var size = this._size;
		var dataZoomModel = this.dataZoomModel;
		var api = this.api;
		var borderRadius = dataZoomModel.get("borderRadius") || 0;
		var brushSelect = dataZoomModel.get("brushSelect");
		var filler = displayables.filler = new Rect({
			silent: brushSelect,
			style: { fill: dataZoomModel.get("fillerColor") },
			textConfig: { position: "inside" }
		});
		sliderGroup.add(filler);
		sliderGroup.add(new Rect({
			silent: true,
			subPixelOptimize: true,
			shape: {
				x: 0,
				y: 0,
				width: size[0],
				height: size[1],
				r: borderRadius
			},
			style: {
				stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
				lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
				fill: tokens_default.color.transparent
			}
		}));
		each([0, 1], function(handleIndex) {
			var iconStr = dataZoomModel.get("handleIcon");
			if (!symbolBuildProxies[iconStr] && iconStr.indexOf("path://") < 0 && iconStr.indexOf("image://") < 0) {
				iconStr = "path://" + iconStr;
				deprecateLog("handleIcon now needs 'path://' prefix when using a path string");
			}
			var path = createSymbol(iconStr, -1, 0, 2, 2, null, true);
			path.attr({
				cursor: getCursor$1(this._orient),
				draggable: true,
				drift: bind(this._onDragMove, this, handleIndex),
				ondragend: bind(this._onDragEnd, this),
				onmouseover: bind(this._showDataInfo, this, true),
				onmouseout: bind(this._showDataInfo, this, false),
				z2: 5
			});
			var bRect = path.getBoundingRect();
			this._handleHeight = parsePercent$1(dataZoomModel.get("handleSize"), this._size[1]);
			this._handleWidth = bRect.width / bRect.height * this._handleHeight;
			path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
			path.style.strokeNoScale = true;
			path.rectHover = true;
			path.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
			enableHoverEmphasis(path);
			var handleColor = dataZoomModel.get("handleColor");
			if (handleColor != null) path.style.fill = handleColor;
			sliderGroup.add(handles[handleIndex] = path);
			var textStyleModel = dataZoomModel.getModel("textStyle");
			var handleLabelShow = (dataZoomModel.get("handleLabel") || {}).show || false;
			thisGroup.add(handleLabels[handleIndex] = new Text_default({
				silent: true,
				invisible: !handleLabelShow,
				style: createTextStyle(textStyleModel, {
					x: 0,
					y: 0,
					text: "",
					verticalAlign: "middle",
					align: "center",
					fill: textStyleModel.getTextColor(),
					font: textStyleModel.getFont()
				}),
				z2: 10
			}));
		}, this);
		var actualMoveZone = filler;
		if (brushSelect) {
			var moveHandleHeight = parsePercent$1(dataZoomModel.get("moveHandleSize"), size[1]);
			var moveHandle_1 = displayables.moveHandle = new Rect_default({
				style: dataZoomModel.getModel("moveHandleStyle").getItemStyle(),
				silent: true,
				shape: {
					r: [
						0,
						0,
						2,
						2
					],
					y: size[1] - .5,
					height: moveHandleHeight
				}
			});
			var iconSize = moveHandleHeight * .8;
			var moveHandleIcon = displayables.moveHandleIcon = createSymbol(dataZoomModel.get("moveHandleIcon"), -iconSize / 2, -iconSize / 2, iconSize, iconSize, tokens_default.color.neutral00, true);
			moveHandleIcon.silent = true;
			moveHandleIcon.y = size[1] + moveHandleHeight / 2 - .5;
			moveHandle_1.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
			var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));
			actualMoveZone = displayables.moveZone = new Rect_default({
				invisible: true,
				shape: {
					y: size[1] - moveZoneExpandSize,
					height: moveHandleHeight + moveZoneExpandSize
				}
			});
			actualMoveZone.on("mouseover", function() {
				api.enterEmphasis(moveHandle_1);
			}).on("mouseout", function() {
				api.leaveEmphasis(moveHandle_1);
			});
			sliderGroup.add(moveHandle_1);
			sliderGroup.add(moveHandleIcon);
			sliderGroup.add(actualMoveZone);
		}
		actualMoveZone.attr({
			draggable: true,
			cursor: "default",
			drift: bind(this._onDragMove, this, "all"),
			ondragstart: bind(this._showDataInfo, this, true),
			ondragend: bind(this._onDragEnd, this),
			onmouseover: bind(this._showDataInfo, this, true),
			onmouseout: bind(this._showDataInfo, this, false)
		});
	};
	SliderZoomView$1.prototype._resetInterval = function() {
		var range = this._range = this.dataZoomModel.getPercentRange();
		var viewExtent = this._getViewExtent();
		this._handleEnds = [linearMap$2(range[0], [0, 100], viewExtent, true), linearMap$2(range[1], [0, 100], viewExtent, true)];
	};
	SliderZoomView$1.prototype._updateInterval = function(handleIndex, delta) {
		var dataZoomModel = this.dataZoomModel;
		var handleEnds = this._handleEnds;
		var viewExtend = this._getViewExtent();
		var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
		var percentExtent = [0, 100];
		sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap$2(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap$2(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
		var lastRange = this._range;
		var range = this._range = asc$1([linearMap$2(handleEnds[0], viewExtend, percentExtent, true), linearMap$2(handleEnds[1], viewExtend, percentExtent, true)]);
		return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
	};
	SliderZoomView$1.prototype._updateView = function(nonRealtime) {
		var displaybles = this._displayables;
		var handleEnds = this._handleEnds;
		var handleInterval = asc$1(handleEnds.slice());
		var size = this._size;
		each([0, 1], function(handleIndex) {
			var handle = displaybles.handles[handleIndex];
			var handleHeight = this._handleHeight;
			handle.attr({
				scaleX: handleHeight / 2,
				scaleY: handleHeight / 2,
				x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
				y: size[1] / 2 - handleHeight / 2
			});
		}, this);
		displaybles.filler.setShape({
			x: handleInterval[0],
			y: 0,
			width: handleInterval[1] - handleInterval[0],
			height: size[1]
		});
		var viewExtent = {
			x: handleInterval[0],
			width: handleInterval[1] - handleInterval[0]
		};
		if (displaybles.moveHandle) {
			displaybles.moveHandle.setShape(viewExtent);
			displaybles.moveZone.setShape(viewExtent);
			displaybles.moveZone.getBoundingRect();
			displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr("x", viewExtent.x + viewExtent.width / 2);
		}
		var dataShadowSegs = displaybles.dataShadowSegs;
		var segIntervals = [
			0,
			handleInterval[0],
			handleInterval[1],
			size[0]
		];
		for (var i$1 = 0; i$1 < dataShadowSegs.length; i$1++) {
			var segGroup = dataShadowSegs[i$1];
			var clipPath = segGroup.getClipPath();
			if (!clipPath) {
				clipPath = new Rect_default();
				segGroup.setClipPath(clipPath);
			}
			clipPath.setShape({
				x: segIntervals[i$1],
				y: 0,
				width: segIntervals[i$1 + 1] - segIntervals[i$1],
				height: size[1]
			});
		}
		this._updateDataInfo(nonRealtime);
	};
	SliderZoomView$1.prototype._updateDataInfo = function(nonRealtime) {
		var dataZoomModel = this.dataZoomModel;
		var displaybles = this._displayables;
		var handleLabels = displaybles.handleLabels;
		var orient = this._orient;
		var labelTexts = ["", ""];
		if (dataZoomModel.get("showDetail")) {
			var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
			if (axisProxy) {
				var axis = axisProxy.getAxisModel().axis;
				var range = this._range;
				var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
					start: range[0],
					end: range[1]
				}).valueWindow : axisProxy.getDataValueWindow();
				labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
			}
		}
		var orderedHandleEnds = asc$1(this._handleEnds.slice());
		setLabel.call(this, 0);
		setLabel.call(this, 1);
		function setLabel(handleIndex) {
			var barTransform = getTransform$1(displaybles.handles[handleIndex].parent, this.group);
			var direction = transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
			var offset = this._handleWidth / 2 + LABEL_GAP;
			var textPoint = applyTransform$1([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
			handleLabels[handleIndex].setStyle({
				x: textPoint[0],
				y: textPoint[1],
				verticalAlign: orient === HORIZONTAL ? "middle" : direction,
				align: orient === HORIZONTAL ? direction : "center",
				text: labelTexts[handleIndex]
			});
		}
	};
	SliderZoomView$1.prototype._formatLabel = function(value, axis) {
		var dataZoomModel = this.dataZoomModel;
		var labelFormatter = dataZoomModel.get("labelFormatter");
		var labelPrecision = dataZoomModel.get("labelPrecision");
		if (labelPrecision == null || labelPrecision === "auto") labelPrecision = axis.getPixelPrecision();
		var valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel({ value: Math.round(value) }) : value.toFixed(Math.min(labelPrecision, 20));
		return isFunction(labelFormatter) ? labelFormatter(value, valueStr) : isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
	};
	/**
	* @param isEmphasis true: show, false: hide
	*/
	SliderZoomView$1.prototype._showDataInfo = function(isEmphasis) {
		var normalShow = (this.dataZoomModel.get("handleLabel") || {}).show || false;
		var emphasisShow = this.dataZoomModel.getModel(["emphasis", "handleLabel"]).get("show") || false;
		var toShow = isEmphasis || this._dragging ? emphasisShow : normalShow;
		var displayables = this._displayables;
		var handleLabels = displayables.handleLabels;
		handleLabels[0].attr("invisible", !toShow);
		handleLabels[1].attr("invisible", !toShow);
		displayables.moveHandle && this.api[toShow ? "enterEmphasis" : "leaveEmphasis"](displayables.moveHandle, 1);
	};
	SliderZoomView$1.prototype._onDragMove = function(handleIndex, dx, dy, event) {
		this._dragging = true;
		stop(event.event);
		var barTransform = this._displayables.sliderGroup.getLocalTransform();
		var vertex = applyTransform$1([dx, dy], barTransform, true);
		var changed = this._updateInterval(handleIndex, vertex[0]);
		var realtime = this.dataZoomModel.get("realtime");
		this._updateView(!realtime);
		changed && realtime && this._dispatchZoomAction(true);
	};
	SliderZoomView$1.prototype._onDragEnd = function() {
		this._dragging = false;
		this._showDataInfo(false);
		!this.dataZoomModel.get("realtime") && this._dispatchZoomAction(false);
	};
	SliderZoomView$1.prototype._onClickPanel = function(e$1) {
		var size = this._size;
		var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e$1.offsetX, e$1.offsetY);
		if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) return;
		var handleEnds = this._handleEnds;
		var center$2 = (handleEnds[0] + handleEnds[1]) / 2;
		var changed = this._updateInterval("all", localPoint[0] - center$2);
		this._updateView();
		changed && this._dispatchZoomAction(false);
	};
	SliderZoomView$1.prototype._onBrushStart = function(e$1) {
		var x = e$1.offsetX;
		var y = e$1.offsetY;
		this._brushStart = new Point_default(x, y);
		this._brushing = true;
		this._brushStartTime = +/* @__PURE__ */ new Date();
	};
	SliderZoomView$1.prototype._onBrushEnd = function(e$1) {
		if (!this._brushing) return;
		var brushRect = this._displayables.brushRect;
		this._brushing = false;
		if (!brushRect) return;
		brushRect.attr("ignore", true);
		var brushShape = brushRect.shape;
		if (+/* @__PURE__ */ new Date() - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) return;
		var viewExtend = this._getViewExtent();
		var percentExtent = [0, 100];
		var handleEnds = this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];
		var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
		sliderMove(0, handleEnds, viewExtend, 0, minMaxSpan.minSpan != null ? linearMap$2(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap$2(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
		this._range = asc$1([linearMap$2(handleEnds[0], viewExtend, percentExtent, true), linearMap$2(handleEnds[1], viewExtend, percentExtent, true)]);
		this._updateView();
		this._dispatchZoomAction(false);
	};
	SliderZoomView$1.prototype._onBrush = function(e$1) {
		if (this._brushing) {
			stop(e$1.event);
			this._updateBrushRect(e$1.offsetX, e$1.offsetY);
		}
	};
	SliderZoomView$1.prototype._updateBrushRect = function(mouseX, mouseY) {
		var displayables = this._displayables;
		var dataZoomModel = this.dataZoomModel;
		var brushRect = displayables.brushRect;
		if (!brushRect) {
			brushRect = displayables.brushRect = new Rect({
				silent: true,
				style: dataZoomModel.getModel("brushStyle").getItemStyle()
			});
			displayables.sliderGroup.add(brushRect);
		}
		brushRect.attr("ignore", false);
		var brushStart = this._brushStart;
		var sliderGroup = this._displayables.sliderGroup;
		var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
		var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
		var size = this._size;
		endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);
		brushRect.setShape({
			x: startPoint[0],
			y: 0,
			width: endPoint[0] - startPoint[0],
			height: size[1]
		});
	};
	/**
	* This action will be throttled.
	*/
	SliderZoomView$1.prototype._dispatchZoomAction = function(realtime) {
		var range = this._range;
		this.api.dispatchAction({
			type: "dataZoom",
			from: this.uid,
			dataZoomId: this.dataZoomModel.id,
			animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
			start: range[0],
			end: range[1]
		});
	};
	SliderZoomView$1.prototype._findCoordRect = function() {
		var rect;
		var coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
		if (!rect && coordSysInfoList.length) {
			var coordSys = coordSysInfoList[0].model.coordinateSystem;
			rect = coordSys.getRect && coordSys.getRect();
		}
		if (!rect) {
			var width = this.api.getWidth();
			var height = this.api.getHeight();
			rect = {
				x: width * .2,
				y: height * .2,
				width: width * .6,
				height: height * .6
			};
		}
		return rect;
	};
	SliderZoomView$1.type = "dataZoom.slider";
	return SliderZoomView$1;
}(DataZoomView_default);
function getOtherDim(thisDim) {
	return {
		x: "y",
		y: "x",
		radius: "angle",
		angle: "radius"
	}[thisDim];
}
function getCursor$1(orient) {
	return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var SliderZoomView_default = SliderZoomView;

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/installDataZoomSlider.js
function install$45(registers) {
	registers.registerComponentModel(SliderZoomModel_default);
	registers.registerComponentView(SliderZoomView_default);
	installCommon$1(registers);
}

//#endregion
//#region node_modules/echarts/lib/component/dataZoom/install.js
function install$43(registers) {
	use(install$44);
	use(install$45);
}

//#endregion
//#region node_modules/echarts/lib/visual/visualDefault.js
var visualDefault = { get: function(visualType, key$1, isCategory$1) {
	var value = clone((defaultOption[visualType] || {})[key$1]);
	return isCategory$1 ? isArray(value) ? value[value.length - 1] : value : value;
} };
var defaultOption = {
	color: {
		active: ["#006edd", "#e0ffff"],
		inactive: [tokens_default.color.transparent]
	},
	colorHue: {
		active: [0, 360],
		inactive: [0, 0]
	},
	colorSaturation: {
		active: [.3, 1],
		inactive: [0, 0]
	},
	colorLightness: {
		active: [.9, .5],
		inactive: [0, 0]
	},
	colorAlpha: {
		active: [.3, 1],
		inactive: [0, 0]
	},
	opacity: {
		active: [.3, 1],
		inactive: [0, 0]
	},
	symbol: {
		active: [
			"circle",
			"roundRect",
			"diamond"
		],
		inactive: ["none"]
	},
	symbolSize: {
		active: [10, 50],
		inactive: [0, 0]
	}
};
var visualDefault_default = visualDefault;

//#endregion
//#region node_modules/echarts/lib/component/visualMap/VisualMapModel.js
var mapVisual = VisualMapping_default.mapVisual;
var eachVisual = VisualMapping_default.eachVisual;
var isArray$1 = isArray;
var each$3 = each;
var asc = asc$1;
var linearMap$1 = linearMap$2;
var VisualMapModel = function(_super) {
	__extends(VisualMapModel$1, _super);
	function VisualMapModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = VisualMapModel$1.type;
		_this.stateList = ["inRange", "outOfRange"];
		_this.replacableOptionKeys = [
			"inRange",
			"outOfRange",
			"target",
			"controller",
			"color"
		];
		_this.layoutMode = {
			type: "box",
			ignoreSize: true
		};
		/**
		* [lowerBound, upperBound]
		*/
		_this.dataBound = [-Infinity, Infinity];
		_this.targetVisuals = {};
		_this.controllerVisuals = {};
		return _this;
	}
	VisualMapModel$1.prototype.init = function(option, parentModel, ecModel) {
		this.mergeDefaultAndTheme(option, ecModel);
	};
	/**
	* @protected
	*/
	VisualMapModel$1.prototype.optionUpdated = function(newOption, isInit) {
		var thisOption = this.option;
		!isInit && replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
		this.textStyleModel = this.getModel("textStyle");
		this.resetItemSize();
		this.completeVisualOption();
	};
	/**
	* @protected
	*/
	VisualMapModel$1.prototype.resetVisual = function(supplementVisualOption) {
		var stateList = this.stateList;
		supplementVisualOption = bind(supplementVisualOption, this);
		this.controllerVisuals = createVisualMappings(this.option.controller, stateList, supplementVisualOption);
		this.targetVisuals = createVisualMappings(this.option.target, stateList, supplementVisualOption);
	};
	/**
	* @public
	*/
	VisualMapModel$1.prototype.getItemSymbol = function() {
		return null;
	};
	/**
	* @return An array of series indices.
	*/
	VisualMapModel$1.prototype.getTargetSeriesIndices = function() {
		var optionSeriesId = this.option.seriesId;
		var optionSeriesIndex = this.option.seriesIndex;
		if (optionSeriesIndex == null && optionSeriesId == null) optionSeriesIndex = "all";
		var seriesModels = queryReferringComponents(this.ecModel, "series", {
			index: optionSeriesIndex,
			id: optionSeriesId
		}, {
			useDefault: false,
			enableAll: true,
			enableNone: false
		}).models;
		return map(seriesModels, function(seriesModel) {
			return seriesModel.componentIndex;
		});
	};
	/**
	* @public
	*/
	VisualMapModel$1.prototype.eachTargetSeries = function(callback, context) {
		each(this.getTargetSeriesIndices(), function(seriesIndex) {
			var seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);
			if (seriesModel) callback.call(context, seriesModel);
		}, this);
	};
	/**
	* @pubilc
	*/
	VisualMapModel$1.prototype.isTargetSeries = function(seriesModel) {
		var is = false;
		this.eachTargetSeries(function(model) {
			model === seriesModel && (is = true);
		});
		return is;
	};
	/**
	* @example
	* this.formatValueText(someVal); // format single numeric value to text.
	* this.formatValueText(someVal, true); // format single category value to text.
	* this.formatValueText([min, max]); // format numeric min-max to text.
	* this.formatValueText([this.dataBound[0], max]); // using data lower bound.
	* this.formatValueText([min, this.dataBound[1]]); // using data upper bound.
	*
	* @param value Real value, or this.dataBound[0 or 1].
	* @param isCategory Only available when value is number.
	* @param edgeSymbols Open-close symbol when value is interval.
	* @protected
	*/
	VisualMapModel$1.prototype.formatValueText = function(value, isCategory$1, edgeSymbols) {
		var option = this.option;
		var precision = option.precision;
		var dataBound = this.dataBound;
		var formatter = option.formatter;
		var isMinMax;
		edgeSymbols = edgeSymbols || ["<", ">"];
		if (isArray(value)) {
			value = value.slice();
			isMinMax = true;
		}
		var textValue = isCategory$1 ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);
		if (isString(formatter)) return formatter.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue);
		else if (isFunction(formatter)) return isMinMax ? formatter(value[0], value[1]) : formatter(value);
		if (isMinMax) if (value[0] === dataBound[0]) return edgeSymbols[0] + " " + textValue[1];
		else if (value[1] === dataBound[1]) return edgeSymbols[1] + " " + textValue[0];
		else return textValue[0] + " - " + textValue[1];
		else return textValue;
		function toFixed(val) {
			return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
		}
	};
	/**
	* @protected
	*/
	VisualMapModel$1.prototype.resetExtent = function() {
		var thisOption = this.option;
		this._dataExtent = asc([thisOption.min, thisOption.max]);
	};
	/**
	* PENDING:
	* delete this method if no outer usage.
	*
	* Return  Concrete dimension. If null/undefined is returned, no dimension is used.
	*/
	VisualMapModel$1.prototype.getDataDimensionIndex = function(data) {
		var optDim = this.option.dimension;
		if (optDim != null) return data.getDimensionIndex(optDim);
		var dimNames = data.dimensions;
		for (var i$1 = dimNames.length - 1; i$1 >= 0; i$1--) {
			var dimName = dimNames[i$1];
			var dimInfo = data.getDimensionInfo(dimName);
			if (!dimInfo.isCalculationCoord) return dimInfo.storeDimIndex;
		}
	};
	VisualMapModel$1.prototype.getExtent = function() {
		return this._dataExtent.slice();
	};
	VisualMapModel$1.prototype.completeVisualOption = function() {
		var ecModel = this.ecModel;
		var thisOption = this.option;
		var base$1 = {
			inRange: thisOption.inRange,
			outOfRange: thisOption.outOfRange
		};
		var target = thisOption.target || (thisOption.target = {});
		var controller = thisOption.controller || (thisOption.controller = {});
		merge(target, base$1);
		merge(controller, base$1);
		var isCategory$1 = this.isCategory();
		completeSingle.call(this, target);
		completeSingle.call(this, controller);
		completeInactive.call(this, target, "inRange", "outOfRange");
		completeController.call(this, controller);
		function completeSingle(base$2) {
			if (isArray$1(thisOption.color) && !base$2.inRange) base$2.inRange = { color: thisOption.color.slice().reverse() };
			base$2.inRange = base$2.inRange || { color: ecModel.get("gradientColor") };
		}
		function completeInactive(base$2, stateExist, stateAbsent) {
			var optExist = base$2[stateExist];
			var optAbsent = base$2[stateAbsent];
			if (optExist && !optAbsent) {
				optAbsent = base$2[stateAbsent] = {};
				each$3(optExist, function(visualData, visualType) {
					if (!VisualMapping_default.isValidType(visualType)) return;
					var defa = visualDefault_default.get(visualType, "inactive", isCategory$1);
					if (defa != null) {
						optAbsent[visualType] = defa;
						if (visualType === "color" && !optAbsent.hasOwnProperty("opacity") && !optAbsent.hasOwnProperty("colorAlpha")) optAbsent.opacity = [0, 0];
					}
				});
			}
		}
		function completeController(controller$1) {
			var symbolExists = (controller$1.inRange || {}).symbol || (controller$1.outOfRange || {}).symbol;
			var symbolSizeExists = (controller$1.inRange || {}).symbolSize || (controller$1.outOfRange || {}).symbolSize;
			var inactiveColor = this.get("inactiveColor");
			var defaultSymbol = this.getItemSymbol() || "roundRect";
			each$3(this.stateList, function(state) {
				var itemSize = this.itemSize;
				var visuals = controller$1[state];
				if (!visuals) visuals = controller$1[state] = { color: isCategory$1 ? inactiveColor : [inactiveColor] };
				if (visuals.symbol == null) visuals.symbol = symbolExists && clone(symbolExists) || (isCategory$1 ? defaultSymbol : [defaultSymbol]);
				if (visuals.symbolSize == null) visuals.symbolSize = symbolSizeExists && clone(symbolSizeExists) || (isCategory$1 ? itemSize[0] : [itemSize[0], itemSize[0]]);
				visuals.symbol = mapVisual(visuals.symbol, function(symbol) {
					return symbol === "none" ? defaultSymbol : symbol;
				});
				var symbolSize = visuals.symbolSize;
				if (symbolSize != null) {
					var max_1 = -Infinity;
					eachVisual(symbolSize, function(value) {
						value > max_1 && (max_1 = value);
					});
					visuals.symbolSize = mapVisual(symbolSize, function(value) {
						return linearMap$1(value, [0, max_1], [0, itemSize[0]], true);
					});
				}
			}, this);
		}
	};
	VisualMapModel$1.prototype.resetItemSize = function() {
		this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
	};
	VisualMapModel$1.prototype.isCategory = function() {
		return !!this.option.categories;
	};
	/**
	* @public
	* @abstract
	*/
	VisualMapModel$1.prototype.setSelected = function(selected) {};
	VisualMapModel$1.prototype.getSelected = function() {
		return null;
	};
	/**
	* @public
	* @abstract
	*/
	VisualMapModel$1.prototype.getValueState = function(value) {
		return null;
	};
	/**
	* FIXME
	* Do not publish to thirt-part-dev temporarily
	* util the interface is stable. (Should it return
	* a function but not visual meta?)
	*
	* @pubilc
	* @abstract
	* @param getColorVisual
	*        params: value, valueState
	*        return: color
	* @return {Object} visualMeta
	*        should includes {stops, outerColors}
	*        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]
	*/
	VisualMapModel$1.prototype.getVisualMeta = function(getColorVisual$1) {
		return null;
	};
	VisualMapModel$1.type = "visualMap";
	VisualMapModel$1.dependencies = ["series"];
	VisualMapModel$1.defaultOption = {
		show: true,
		z: 4,
		min: 0,
		max: 200,
		left: 0,
		right: null,
		top: null,
		bottom: 0,
		itemWidth: null,
		itemHeight: null,
		inverse: false,
		orient: "vertical",
		backgroundColor: tokens_default.color.transparent,
		borderColor: tokens_default.color.borderTint,
		contentColor: tokens_default.color.theme[0],
		inactiveColor: tokens_default.color.disabled,
		borderWidth: 0,
		padding: tokens_default.size.m,
		textGap: 10,
		precision: 0,
		textStyle: { color: tokens_default.color.secondary }
	};
	return VisualMapModel$1;
}(Component_default);
var VisualMapModel_default = VisualMapModel;

//#endregion
//#region node_modules/echarts/lib/component/visualMap/ContinuousModel.js
var DEFAULT_BAR_BOUND = [20, 140];
var ContinuousModel = function(_super) {
	__extends(ContinuousModel$1, _super);
	function ContinuousModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ContinuousModel$1.type;
		return _this;
	}
	/**
	* @override
	*/
	ContinuousModel$1.prototype.optionUpdated = function(newOption, isInit) {
		_super.prototype.optionUpdated.apply(this, arguments);
		this.resetExtent();
		this.resetVisual(function(mappingOption) {
			mappingOption.mappingMethod = "linear";
			mappingOption.dataExtent = this.getExtent();
		});
		this._resetRange();
	};
	/**
	* @protected
	* @override
	*/
	ContinuousModel$1.prototype.resetItemSize = function() {
		_super.prototype.resetItemSize.apply(this, arguments);
		var itemSize = this.itemSize;
		(itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
		(itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
	};
	/**
	* @private
	*/
	ContinuousModel$1.prototype._resetRange = function() {
		var dataExtent = this.getExtent();
		var range = this.option.range;
		if (!range || range.auto) {
			dataExtent.auto = 1;
			this.option.range = dataExtent;
		} else if (isArray(range)) {
			if (range[0] > range[1]) range.reverse();
			range[0] = Math.max(range[0], dataExtent[0]);
			range[1] = Math.min(range[1], dataExtent[1]);
		}
	};
	/**
	* @protected
	* @override
	*/
	ContinuousModel$1.prototype.completeVisualOption = function() {
		_super.prototype.completeVisualOption.apply(this, arguments);
		each(this.stateList, function(state) {
			var symbolSize = this.option.controller[state].symbolSize;
			if (symbolSize && symbolSize[0] !== symbolSize[1]) symbolSize[0] = symbolSize[1] / 3;
		}, this);
	};
	/**
	* @override
	*/
	ContinuousModel$1.prototype.setSelected = function(selected) {
		this.option.range = selected.slice();
		this._resetRange();
	};
	/**
	* @public
	*/
	ContinuousModel$1.prototype.getSelected = function() {
		var dataExtent = this.getExtent();
		var dataInterval = asc$1((this.get("range") || []).slice());
		dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
		dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
		dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
		dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
		return dataInterval;
	};
	/**
	* @override
	*/
	ContinuousModel$1.prototype.getValueState = function(value) {
		var range = this.option.range;
		var dataExtent = this.getExtent();
		var unboundedRange = retrieve2(this.option.unboundedRange, true);
		return (unboundedRange && range[0] <= dataExtent[0] || range[0] <= value) && (unboundedRange && range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
	};
	ContinuousModel$1.prototype.findTargetDataIndices = function(range) {
		var result = [];
		this.eachTargetSeries(function(seriesModel) {
			var dataIndices = [];
			var data = seriesModel.getData();
			data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
				range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
			}, this);
			result.push({
				seriesId: seriesModel.id,
				dataIndex: dataIndices
			});
		}, this);
		return result;
	};
	/**
	* @implement
	*/
	ContinuousModel$1.prototype.getVisualMeta = function(getColorVisual$1) {
		var oVals = getColorStopValues(this, "outOfRange", this.getExtent());
		var iVals = getColorStopValues(this, "inRange", this.option.range.slice());
		var stops = [];
		function setStop(value, valueState) {
			stops.push({
				value,
				color: getColorVisual$1(value, valueState)
			});
		}
		var iIdx = 0;
		var oIdx = 0;
		var iLen = iVals.length;
		var oLen = oVals.length;
		for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) if (oVals[oIdx] < iVals[iIdx]) setStop(oVals[oIdx], "outOfRange");
		for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
			first && stops.length && setStop(iVals[iIdx], "outOfRange");
			setStop(iVals[iIdx], "inRange");
		}
		for (var first = 1; oIdx < oLen; oIdx++) if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
			if (first) {
				stops.length && setStop(stops[stops.length - 1].value, "outOfRange");
				first = 0;
			}
			setStop(oVals[oIdx], "outOfRange");
		}
		var stopsLen = stops.length;
		return {
			stops,
			outerColors: [stopsLen ? stops[0].color : "transparent", stopsLen ? stops[stopsLen - 1].color : "transparent"]
		};
	};
	ContinuousModel$1.type = "visualMap.continuous";
	ContinuousModel$1.defaultOption = inheritDefaultOption(VisualMapModel_default.defaultOption, {
		align: "auto",
		calculable: false,
		hoverLink: true,
		realtime: true,
		handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
		handleSize: "120%",
		handleStyle: {
			borderColor: tokens_default.color.neutral00,
			borderWidth: 1
		},
		indicatorIcon: "circle",
		indicatorSize: "50%",
		indicatorStyle: {
			borderColor: tokens_default.color.neutral00,
			borderWidth: 2,
			shadowBlur: 2,
			shadowOffsetX: 1,
			shadowOffsetY: 1,
			shadowColor: tokens_default.color.shadow
		}
	});
	return ContinuousModel$1;
}(VisualMapModel_default);
function getColorStopValues(visualMapModel, valueState, dataExtent) {
	if (dataExtent[0] === dataExtent[1]) return dataExtent.slice();
	var count$1 = 200;
	var step = (dataExtent[1] - dataExtent[0]) / count$1;
	var value = dataExtent[0];
	var stopValues = [];
	for (var i$1 = 0; i$1 <= count$1 && value < dataExtent[1]; i$1++) {
		stopValues.push(value);
		value += step;
	}
	stopValues.push(dataExtent[1]);
	return stopValues;
}
var ContinuousModel_default = ContinuousModel;

//#endregion
//#region node_modules/echarts/lib/component/visualMap/VisualMapView.js
var VisualMapView = function(_super) {
	__extends(VisualMapView$1, _super);
	function VisualMapView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = VisualMapView$1.type;
		_this.autoPositionValues = {
			left: 1,
			right: 1,
			top: 1,
			bottom: 1
		};
		return _this;
	}
	VisualMapView$1.prototype.init = function(ecModel, api) {
		this.ecModel = ecModel;
		this.api = api;
	};
	/**
	* @protected
	*/
	VisualMapView$1.prototype.render = function(visualMapModel, ecModel, api, payload) {
		this.visualMapModel = visualMapModel;
		if (visualMapModel.get("show") === false) {
			this.group.removeAll();
			return;
		}
		this.doRender(visualMapModel, ecModel, api, payload);
	};
	/**
	* @protected
	*/
	VisualMapView$1.prototype.renderBackground = function(group) {
		var visualMapModel = this.visualMapModel;
		var padding = normalizeCssArray(visualMapModel.get("padding") || 0);
		var rect = group.getBoundingRect();
		group.add(new Rect_default({
			z2: -1,
			silent: true,
			shape: {
				x: rect.x - padding[3],
				y: rect.y - padding[0],
				width: rect.width + padding[3] + padding[1],
				height: rect.height + padding[0] + padding[2]
			},
			style: {
				fill: visualMapModel.get("backgroundColor"),
				stroke: visualMapModel.get("borderColor"),
				lineWidth: visualMapModel.get("borderWidth")
			}
		}));
	};
	/**
	* @protected
	* @param targetValue can be Infinity or -Infinity
	* @param visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'
	* @param opts
	* @param opts.forceState Specify state, instead of using getValueState method.
	* @param opts.convertOpacityToAlpha For color gradient in controller widget.
	* @return {*} Visual value.
	*/
	VisualMapView$1.prototype.getControllerVisual = function(targetValue, visualCluster, opts) {
		opts = opts || {};
		var forceState = opts.forceState;
		var visualMapModel = this.visualMapModel;
		var visualObj = {};
		if (visualCluster === "color") visualObj.color = visualMapModel.get("contentColor");
		function getter(key$1) {
			return visualObj[key$1];
		}
		function setter(key$1, value) {
			visualObj[key$1] = value;
		}
		var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
		var visualTypes = VisualMapping_default.prepareVisualTypes(mappings);
		each(visualTypes, function(type) {
			var visualMapping = mappings[type];
			if (opts.convertOpacityToAlpha && type === "opacity") {
				type = "colorAlpha";
				visualMapping = mappings.__alphaForOpacity;
			}
			if (VisualMapping_default.dependsOn(type, visualCluster)) visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
		});
		return visualObj[visualCluster];
	};
	VisualMapView$1.prototype.positionGroup = function(group) {
		var model = this.visualMapModel;
		var api = this.api;
		var refContainer = createBoxLayoutReference(model, api).refContainer;
		positionElement(group, model.getBoxLayoutParams(), refContainer);
	};
	VisualMapView$1.prototype.doRender = function(visualMapModel, ecModel, api, payload) {};
	VisualMapView$1.type = "visualMap";
	return VisualMapView$1;
}(Component_default$1);
var VisualMapView_default = VisualMapView;

//#endregion
//#region node_modules/echarts/lib/component/visualMap/helper.js
var paramsSet = [[
	"left",
	"right",
	"width"
], [
	"top",
	"bottom",
	"height"
]];
/**
* @param visualMapModel
* @param api
* @param itemSize always [short, long]
* @return {string} 'left' or 'right' or 'top' or 'bottom'
*/
function getItemAlign(visualMapModel, api, itemSize) {
	var modelOption = visualMapModel.option;
	var itemAlign = modelOption.align;
	if (itemAlign != null && itemAlign !== "auto") return itemAlign;
	var ecSize = {
		width: api.getWidth(),
		height: api.getHeight()
	};
	var realIndex = modelOption.orient === "horizontal" ? 1 : 0;
	var reals = paramsSet[realIndex];
	var fakeValue = [
		0,
		null,
		10
	];
	var layoutInput = {};
	for (var i$1 = 0; i$1 < 3; i$1++) {
		layoutInput[paramsSet[1 - realIndex][i$1]] = fakeValue[i$1];
		layoutInput[reals[i$1]] = i$1 === 2 ? itemSize[0] : modelOption[reals[i$1]];
	}
	var rParam = [[
		"x",
		"width",
		3
	], [
		"y",
		"height",
		0
	]][realIndex];
	var rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
	return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * .5 < ecSize[rParam[1]] * .5 ? 0 : 1];
}
/**
* Prepare dataIndex for outside usage, where dataIndex means rawIndex, and
* dataIndexInside means filtered index.
*/
function makeHighDownBatch(batch, visualMapModel) {
	each(batch || [], function(batchItem) {
		if (batchItem.dataIndex != null) {
			batchItem.dataIndexInside = batchItem.dataIndex;
			batchItem.dataIndex = null;
		}
		batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
	});
	return batch;
}

//#endregion
//#region node_modules/echarts/lib/component/visualMap/ContinuousView.js
var linearMap = linearMap$2;
var each$2 = each;
var mathMin = Math.min;
var mathMax = Math.max;
var HOVER_LINK_SIZE = 12;
var HOVER_LINK_OUT = 6;
var ContinuousView = function(_super) {
	__extends(ContinuousView$1, _super);
	function ContinuousView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ContinuousView$1.type;
		_this._shapes = {};
		_this._dataInterval = [];
		_this._handleEnds = [];
		_this._hoverLinkDataIndices = [];
		return _this;
	}
	ContinuousView$1.prototype.init = function(ecModel, api) {
		_super.prototype.init.call(this, ecModel, api);
		this._hoverLinkFromSeriesMouseOver = bind(this._hoverLinkFromSeriesMouseOver, this);
		this._hideIndicator = bind(this._hideIndicator, this);
	};
	ContinuousView$1.prototype.doRender = function(visualMapModel, ecModel, api, payload) {
		if (!payload || payload.type !== "selectDataRange" || payload.from !== this.uid) this._buildView();
	};
	ContinuousView$1.prototype._buildView = function() {
		this.group.removeAll();
		var visualMapModel = this.visualMapModel;
		var thisGroup = this.group;
		this._orient = visualMapModel.get("orient");
		this._useHandle = visualMapModel.get("calculable");
		this._resetInterval();
		this._renderBar(thisGroup);
		var dataRangeText = visualMapModel.get("text");
		this._renderEndsText(thisGroup, dataRangeText, 0);
		this._renderEndsText(thisGroup, dataRangeText, 1);
		this._updateView(true);
		this.renderBackground(thisGroup);
		this._updateView();
		this._enableHoverLinkToSeries();
		this._enableHoverLinkFromSeries();
		this.positionGroup(thisGroup);
	};
	ContinuousView$1.prototype._renderEndsText = function(group, dataRangeText, endsIndex) {
		if (!dataRangeText) return;
		var text = dataRangeText[1 - endsIndex];
		text = text != null ? text + "" : "";
		var visualMapModel = this.visualMapModel;
		var textGap = visualMapModel.get("textGap");
		var itemSize = visualMapModel.itemSize;
		var barGroup = this._shapes.mainGroup;
		var position$1 = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);
		var align = this._applyTransform(endsIndex === 0 ? "bottom" : "top", barGroup);
		var orient = this._orient;
		var textStyleModel = this.visualMapModel.textStyleModel;
		this.group.add(new Text_default({ style: createTextStyle(textStyleModel, {
			x: position$1[0],
			y: position$1[1],
			verticalAlign: textStyleModel.get("verticalAlign") || (orient === "horizontal" ? "middle" : align),
			align: textStyleModel.get("align") || (orient === "horizontal" ? align : "center"),
			text
		}) }));
	};
	ContinuousView$1.prototype._renderBar = function(targetGroup) {
		var visualMapModel = this.visualMapModel;
		var shapes = this._shapes;
		var itemSize = visualMapModel.itemSize;
		var orient = this._orient;
		var useHandle = this._useHandle;
		var itemAlign = getItemAlign(visualMapModel, this.api, itemSize);
		var mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);
		var gradientBarGroup = new Group_default();
		mainGroup.add(gradientBarGroup);
		gradientBarGroup.add(shapes.outOfRange = createPolygon());
		gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, bind(this._dragHandle, this, "all", false), bind(this._dragHandle, this, "all", true)));
		gradientBarGroup.setClipPath(new Rect_default({ shape: {
			x: 0,
			y: 0,
			width: itemSize[0],
			height: itemSize[1],
			r: 3
		} }));
		var textRect = visualMapModel.textStyleModel.getTextRect("");
		var textSize = mathMax(textRect.width, textRect.height);
		if (useHandle) {
			shapes.handleThumbs = [];
			shapes.handleLabels = [];
			shapes.handleLabelPoints = [];
			this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient);
			this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient);
		}
		this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient);
		targetGroup.add(mainGroup);
	};
	ContinuousView$1.prototype._createHandle = function(visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {
		var onDrift = bind(this._dragHandle, this, handleIndex, false);
		var onDragEnd = bind(this._dragHandle, this, handleIndex, true);
		var handleSize = parsePercent(visualMapModel.get("handleSize"), itemSize[0]);
		var handleThumb = createSymbol(visualMapModel.get("handleIcon"), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);
		var cursor = getCursor(this._orient);
		handleThumb.attr({
			cursor,
			draggable: true,
			drift: onDrift,
			ondragend: onDragEnd,
			onmousemove: function(e$1) {
				stop(e$1.event);
			}
		});
		handleThumb.x = itemSize[0] / 2;
		handleThumb.useStyle(visualMapModel.getModel("handleStyle").getItemStyle());
		handleThumb.setStyle({
			strokeNoScale: true,
			strokeFirst: true
		});
		handleThumb.style.lineWidth *= 2;
		handleThumb.ensureState("emphasis").style = visualMapModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
		setAsHighDownDispatcher(handleThumb, true);
		mainGroup.add(handleThumb);
		var textStyleModel = this.visualMapModel.textStyleModel;
		var handleLabel = new Text_default({
			cursor,
			draggable: true,
			drift: onDrift,
			onmousemove: function(e$1) {
				stop(e$1.event);
			},
			ondragend: onDragEnd,
			style: createTextStyle(textStyleModel, {
				x: 0,
				y: 0,
				text: ""
			})
		});
		handleLabel.ensureState("blur").style = { opacity: .1 };
		handleLabel.stateTransition = { duration: 200 };
		this.group.add(handleLabel);
		var handleLabelPoint = [handleSize, 0];
		var shapes = this._shapes;
		shapes.handleThumbs[handleIndex] = handleThumb;
		shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
		shapes.handleLabels[handleIndex] = handleLabel;
	};
	ContinuousView$1.prototype._createIndicator = function(visualMapModel, mainGroup, itemSize, textSize, orient) {
		var scale$3 = parsePercent(visualMapModel.get("indicatorSize"), itemSize[0]);
		var indicator = createSymbol(visualMapModel.get("indicatorIcon"), -scale$3 / 2, -scale$3 / 2, scale$3, scale$3, null, true);
		indicator.attr({
			cursor: "move",
			invisible: true,
			silent: true,
			x: itemSize[0] / 2
		});
		var indicatorStyle = visualMapModel.getModel("indicatorStyle").getItemStyle();
		if (indicator instanceof Image_default) {
			var pathStyle = indicator.style;
			indicator.useStyle(extend({
				image: pathStyle.image,
				x: pathStyle.x,
				y: pathStyle.y,
				width: pathStyle.width,
				height: pathStyle.height
			}, indicatorStyle));
		} else indicator.useStyle(indicatorStyle);
		mainGroup.add(indicator);
		var textStyleModel = this.visualMapModel.textStyleModel;
		var indicatorLabel = new Text_default({
			silent: true,
			invisible: true,
			style: createTextStyle(textStyleModel, {
				x: 0,
				y: 0,
				text: ""
			})
		});
		this.group.add(indicatorLabel);
		var indicatorLabelPoint = [(orient === "horizontal" ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2, 0];
		var shapes = this._shapes;
		shapes.indicator = indicator;
		shapes.indicatorLabel = indicatorLabel;
		shapes.indicatorLabelPoint = indicatorLabelPoint;
		this._firstShowIndicator = true;
	};
	ContinuousView$1.prototype._dragHandle = function(handleIndex, isEnd, dx, dy) {
		if (!this._useHandle) return;
		this._dragging = !isEnd;
		if (!isEnd) {
			var vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);
			this._updateInterval(handleIndex, vertex[1]);
			this._hideIndicator();
			this._updateView();
		}
		if (isEnd === !this.visualMapModel.get("realtime")) this.api.dispatchAction({
			type: "selectDataRange",
			from: this.uid,
			visualMapId: this.visualMapModel.id,
			selected: this._dataInterval.slice()
		});
		if (isEnd) !this._hovering && this._clearHoverLinkToSeries();
		else if (useHoverLinkOnHandle(this.visualMapModel)) this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
	};
	ContinuousView$1.prototype._resetInterval = function() {
		var visualMapModel = this.visualMapModel;
		var dataInterval = this._dataInterval = visualMapModel.getSelected();
		var dataExtent = visualMapModel.getExtent();
		var sizeExtent = [0, visualMapModel.itemSize[1]];
		this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
	};
	/**
	* @private
	* @param {(number|string)} handleIndex 0 or 1 or 'all'
	* @param {number} dx
	* @param {number} dy
	*/
	ContinuousView$1.prototype._updateInterval = function(handleIndex, delta) {
		delta = delta || 0;
		var visualMapModel = this.visualMapModel;
		var handleEnds = this._handleEnds;
		var sizeExtent = [0, visualMapModel.itemSize[1]];
		sliderMove(delta, handleEnds, sizeExtent, handleIndex, 0);
		var dataExtent = visualMapModel.getExtent();
		this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
	};
	ContinuousView$1.prototype._updateView = function(forSketch) {
		var visualMapModel = this.visualMapModel;
		var dataExtent = visualMapModel.getExtent();
		var shapes = this._shapes;
		var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
		var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
		var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange");
		var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
		shapes.inRange.setStyle({ fill: visualInRange.barColor }).setShape("points", visualInRange.barPoints);
		shapes.outOfRange.setStyle({ fill: visualOutOfRange.barColor }).setShape("points", visualOutOfRange.barPoints);
		this._updateHandle(inRangeHandleEnds, visualInRange);
	};
	ContinuousView$1.prototype._createBarVisual = function(dataInterval, dataExtent, handleEnds, forceState) {
		var opts = {
			forceState,
			convertOpacityToAlpha: true
		};
		var colorStops = this._makeColorGradient(dataInterval, opts);
		var symbolSizes = [this.getControllerVisual(dataInterval[0], "symbolSize", opts), this.getControllerVisual(dataInterval[1], "symbolSize", opts)];
		var barPoints = this._createBarPoints(handleEnds, symbolSizes);
		return {
			barColor: new LinearGradient_default(0, 0, 0, 1, colorStops),
			barPoints,
			handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
		};
	};
	ContinuousView$1.prototype._makeColorGradient = function(dataInterval, opts) {
		var sampleNumber = 100;
		var colorStops = [];
		var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
		colorStops.push({
			color: this.getControllerVisual(dataInterval[0], "color", opts),
			offset: 0
		});
		for (var i$1 = 1; i$1 < sampleNumber; i$1++) {
			var currValue = dataInterval[0] + step * i$1;
			if (currValue > dataInterval[1]) break;
			colorStops.push({
				color: this.getControllerVisual(currValue, "color", opts),
				offset: i$1 / sampleNumber
			});
		}
		colorStops.push({
			color: this.getControllerVisual(dataInterval[1], "color", opts),
			offset: 1
		});
		return colorStops;
	};
	ContinuousView$1.prototype._createBarPoints = function(handleEnds, symbolSizes) {
		var itemSize = this.visualMapModel.itemSize;
		return [
			[itemSize[0] - symbolSizes[0], handleEnds[0]],
			[itemSize[0], handleEnds[0]],
			[itemSize[0], handleEnds[1]],
			[itemSize[0] - symbolSizes[1], handleEnds[1]]
		];
	};
	ContinuousView$1.prototype._createBarGroup = function(itemAlign) {
		var orient = this._orient;
		var inverse = this.visualMapModel.get("inverse");
		return new Group_default(orient === "horizontal" && !inverse ? {
			scaleX: itemAlign === "bottom" ? 1 : -1,
			rotation: Math.PI / 2
		} : orient === "horizontal" && inverse ? {
			scaleX: itemAlign === "bottom" ? -1 : 1,
			rotation: -Math.PI / 2
		} : orient === "vertical" && !inverse ? {
			scaleX: itemAlign === "left" ? 1 : -1,
			scaleY: -1
		} : { scaleX: itemAlign === "left" ? 1 : -1 });
	};
	ContinuousView$1.prototype._updateHandle = function(handleEnds, visualInRange) {
		if (!this._useHandle) return;
		var shapes = this._shapes;
		var visualMapModel = this.visualMapModel;
		var handleThumbs = shapes.handleThumbs;
		var handleLabels = shapes.handleLabels;
		var itemSize = visualMapModel.itemSize;
		var dataExtent = visualMapModel.getExtent();
		var align = this._applyTransform("left", shapes.mainGroup);
		each$2([0, 1], function(handleIndex) {
			var handleThumb = handleThumbs[handleIndex];
			handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]);
			handleThumb.y = handleEnds[handleIndex];
			var val = linearMap(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);
			var symbolSize = this.getControllerVisual(val, "symbolSize");
			handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];
			handleThumb.x = itemSize[0] - symbolSize / 2;
			var textPoint = applyTransform$1(shapes.handleLabelPoints[handleIndex], getTransform$1(handleThumb, this.group));
			if (this._orient === "horizontal") {
				var minimumOffset = align === "left" || align === "top" ? (itemSize[0] - symbolSize) / 2 : (itemSize[0] - symbolSize) / -2;
				textPoint[1] += minimumOffset;
			}
			handleLabels[handleIndex].setStyle({
				x: textPoint[0],
				y: textPoint[1],
				text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
				verticalAlign: "middle",
				align: this._orient === "vertical" ? this._applyTransform("left", shapes.mainGroup) : "center"
			});
		}, this);
	};
	ContinuousView$1.prototype._showIndicator = function(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
		var visualMapModel = this.visualMapModel;
		var dataExtent = visualMapModel.getExtent();
		var itemSize = visualMapModel.itemSize;
		var sizeExtent = [0, itemSize[1]];
		var shapes = this._shapes;
		var indicator = shapes.indicator;
		if (!indicator) return;
		indicator.attr("invisible", false);
		var color$2 = this.getControllerVisual(cursorValue, "color", { convertOpacityToAlpha: true });
		var symbolSize = this.getControllerVisual(cursorValue, "symbolSize");
		var y = linearMap(cursorValue, dataExtent, sizeExtent, true);
		var x = itemSize[0] - symbolSize / 2;
		var oldIndicatorPos = {
			x: indicator.x,
			y: indicator.y
		};
		indicator.y = y;
		indicator.x = x;
		var textPoint = applyTransform$1(shapes.indicatorLabelPoint, getTransform$1(indicator, this.group));
		var indicatorLabel = shapes.indicatorLabel;
		indicatorLabel.attr("invisible", false);
		var align = this._applyTransform("left", shapes.mainGroup);
		var isHorizontal = this._orient === "horizontal";
		indicatorLabel.setStyle({
			text: (rangeSymbol ? rangeSymbol : "") + visualMapModel.formatValueText(textValue),
			verticalAlign: isHorizontal ? align : "middle",
			align: isHorizontal ? "center" : align
		});
		var indicatorNewProps = {
			x,
			y,
			style: { fill: color$2 }
		};
		var labelNewProps = { style: {
			x: textPoint[0],
			y: textPoint[1]
		} };
		if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
			var animationCfg = {
				duration: 100,
				easing: "cubicInOut",
				additive: true
			};
			indicator.x = oldIndicatorPos.x;
			indicator.y = oldIndicatorPos.y;
			indicator.animateTo(indicatorNewProps, animationCfg);
			indicatorLabel.animateTo(labelNewProps, animationCfg);
		} else {
			indicator.attr(indicatorNewProps);
			indicatorLabel.attr(labelNewProps);
		}
		this._firstShowIndicator = false;
		var handleLabels = this._shapes.handleLabels;
		if (handleLabels) for (var i$1 = 0; i$1 < handleLabels.length; i$1++) this.api.enterBlur(handleLabels[i$1]);
	};
	ContinuousView$1.prototype._enableHoverLinkToSeries = function() {
		var self$1 = this;
		this._shapes.mainGroup.on("mousemove", function(e$1) {
			self$1._hovering = true;
			if (!self$1._dragging) {
				var itemSize = self$1.visualMapModel.itemSize;
				var pos = self$1._applyTransform([e$1.offsetX, e$1.offsetY], self$1._shapes.mainGroup, true, true);
				pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]);
				self$1._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
			}
		}).on("mouseout", function() {
			self$1._hovering = false;
			!self$1._dragging && self$1._clearHoverLinkToSeries();
		});
	};
	ContinuousView$1.prototype._enableHoverLinkFromSeries = function() {
		var zr = this.api.getZr();
		if (this.visualMapModel.option.hoverLink) {
			zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
			zr.on("mouseout", this._hideIndicator, this);
		} else this._clearHoverLinkFromSeries();
	};
	ContinuousView$1.prototype._doHoverLinkToSeries = function(cursorPos, hoverOnBar) {
		var visualMapModel = this.visualMapModel;
		var itemSize = visualMapModel.itemSize;
		if (!visualMapModel.option.hoverLink) return;
		var sizeExtent = [0, itemSize[1]];
		var dataExtent = visualMapModel.getExtent();
		cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);
		var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
		var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
		var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
		var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)];
		hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
		hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
		if (hoverOnBar) if (valueRange[0] === -Infinity) this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize);
		else if (valueRange[1] === Infinity) this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize);
		else this._showIndicator(cursorValue, cursorValue, " ", halfHoverLinkSize);
		var oldBatch = this._hoverLinkDataIndices;
		var newBatch = [];
		if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
		var resultBatches = compressBatches(oldBatch, newBatch);
		this._dispatchHighDown("downplay", makeHighDownBatch(resultBatches[0], visualMapModel));
		this._dispatchHighDown("highlight", makeHighDownBatch(resultBatches[1], visualMapModel));
	};
	ContinuousView$1.prototype._hoverLinkFromSeriesMouseOver = function(e$1) {
		var ecData;
		findEventDispatcher(e$1.target, function(target) {
			var currECData = getECData(target);
			if (currECData.dataIndex != null) {
				ecData = currECData;
				return true;
			}
		}, true);
		if (!ecData) return;
		var dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);
		var visualMapModel = this.visualMapModel;
		if (!visualMapModel.isTargetSeries(dataModel)) return;
		var data = dataModel.getData(ecData.dataType);
		var value = data.getStore().get(visualMapModel.getDataDimensionIndex(data), ecData.dataIndex);
		if (!isNaN(value)) this._showIndicator(value, value);
	};
	ContinuousView$1.prototype._hideIndicator = function() {
		var shapes = this._shapes;
		shapes.indicator && shapes.indicator.attr("invisible", true);
		shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", true);
		var handleLabels = this._shapes.handleLabels;
		if (handleLabels) for (var i$1 = 0; i$1 < handleLabels.length; i$1++) this.api.leaveBlur(handleLabels[i$1]);
	};
	ContinuousView$1.prototype._clearHoverLinkToSeries = function() {
		this._hideIndicator();
		var indices = this._hoverLinkDataIndices;
		this._dispatchHighDown("downplay", makeHighDownBatch(indices, this.visualMapModel));
		indices.length = 0;
	};
	ContinuousView$1.prototype._clearHoverLinkFromSeries = function() {
		this._hideIndicator();
		var zr = this.api.getZr();
		zr.off("mouseover", this._hoverLinkFromSeriesMouseOver);
		zr.off("mouseout", this._hideIndicator);
	};
	ContinuousView$1.prototype._applyTransform = function(vertex, element, inverse, global$1) {
		var transform = getTransform$1(element, global$1 ? null : this.group);
		return isArray(vertex) ? applyTransform$1(vertex, transform, inverse) : transformDirection(vertex, transform, inverse);
	};
	ContinuousView$1.prototype._dispatchHighDown = function(type, batch) {
		batch && batch.length && this.api.dispatchAction({
			type,
			batch
		});
	};
	/**
	* @override
	*/
	ContinuousView$1.prototype.dispose = function() {
		this._clearHoverLinkFromSeries();
		this._clearHoverLinkToSeries();
	};
	ContinuousView$1.type = "visualMap.continuous";
	return ContinuousView$1;
}(VisualMapView_default);
function createPolygon(points$3, cursor, onDrift, onDragEnd) {
	return new Polygon_default({
		shape: { points: points$3 },
		draggable: !!onDrift,
		cursor,
		drift: onDrift,
		onmousemove: function(e$1) {
			stop(e$1.event);
		},
		ondragend: onDragEnd
	});
}
function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
	var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
	var hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
	if (hoverLinkDataSize) halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
	return halfHoverLinkSize;
}
function useHoverLinkOnHandle(visualMapModel) {
	var hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
	return !!(hoverLinkOnHandle == null ? visualMapModel.get("realtime") : hoverLinkOnHandle);
}
function getCursor(orient) {
	return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var ContinuousView_default = ContinuousView;

//#endregion
//#region node_modules/echarts/lib/component/visualMap/visualMapAction.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var visualMapActionInfo = {
	type: "selectDataRange",
	event: "dataRangeSelected",
	update: "update"
};
var visualMapActionHander = function(payload, ecModel) {
	ecModel.eachComponent({
		mainType: "visualMap",
		query: payload
	}, function(model) {
		model.setSelected(payload.selected);
	});
};

//#endregion
//#region node_modules/echarts/lib/component/visualMap/visualEncoding.js
var visualMapEncodingHandlers = [{
	createOnAllSeries: true,
	reset: function(seriesModel, ecModel) {
		var resetDefines = [];
		ecModel.eachComponent("visualMap", function(visualMapModel) {
			var pipelineContext = seriesModel.pipelineContext;
			if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) return;
			resetDefines.push(incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimensionIndex(seriesModel.getData())));
		});
		return resetDefines;
	}
}, {
	createOnAllSeries: true,
	reset: function(seriesModel, ecModel) {
		var data = seriesModel.getData();
		var visualMetaList = [];
		ecModel.eachComponent("visualMap", function(visualMapModel) {
			if (visualMapModel.isTargetSeries(seriesModel)) {
				var visualMeta = visualMapModel.getVisualMeta(bind(getColorVisual, null, seriesModel, visualMapModel)) || {
					stops: [],
					outerColors: []
				};
				var dimIdx = visualMapModel.getDataDimensionIndex(data);
				if (dimIdx >= 0) {
					visualMeta.dimension = dimIdx;
					visualMetaList.push(visualMeta);
				}
			}
		});
		seriesModel.getData().setVisual("visualMeta", visualMetaList);
	}
}];
function getColorVisual(seriesModel, visualMapModel, value, valueState) {
	var mappings = visualMapModel.targetVisuals[valueState];
	var visualTypes = VisualMapping_default.prepareVisualTypes(mappings);
	var resultVisual = { color: getVisualFromData(seriesModel.getData(), "color") };
	for (var i$1 = 0, len$1 = visualTypes.length; i$1 < len$1; i$1++) {
		var type = visualTypes[i$1];
		var mapping = mappings[type === "opacity" ? "__alphaForOpacity" : type];
		mapping && mapping.applyVisual(value, getVisual, setVisual);
	}
	return resultVisual.color;
	function getVisual(key$1) {
		return resultVisual[key$1];
	}
	function setVisual(key$1, value$1) {
		resultVisual[key$1] = value$1;
	}
}

//#endregion
//#region node_modules/echarts/lib/component/visualMap/preprocessor.js
var each$1 = each;
function visualMapPreprocessor(option) {
	var visualMap = option && option.visualMap;
	if (!isArray(visualMap)) visualMap = visualMap ? [visualMap] : [];
	each$1(visualMap, function(opt) {
		if (!opt) return;
		if (has(opt, "splitList") && !has(opt, "pieces")) {
			opt.pieces = opt.splitList;
			delete opt.splitList;
		}
		var pieces = opt.pieces;
		if (pieces && isArray(pieces)) each$1(pieces, function(piece) {
			if (isObject(piece)) {
				if (has(piece, "start") && !has(piece, "min")) piece.min = piece.start;
				if (has(piece, "end") && !has(piece, "max")) piece.max = piece.end;
			}
		});
	});
}
function has(obj, name) {
	return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
}

//#endregion
//#region node_modules/echarts/lib/component/visualMap/installCommon.js
var installed = false;
function installCommon(registers) {
	if (installed) return;
	installed = true;
	registers.registerSubTypeDefaulter("visualMap", function(option) {
		return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? "continuous" : "piecewise";
	});
	registers.registerAction(visualMapActionInfo, visualMapActionHander);
	each(visualMapEncodingHandlers, function(handler) {
		registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);
	});
	registers.registerPreprocessor(visualMapPreprocessor);
}

//#endregion
//#region node_modules/echarts/lib/component/visualMap/installVisualMapContinuous.js
function install$47(registers) {
	registers.registerComponentModel(ContinuousModel_default);
	registers.registerComponentView(ContinuousView_default);
	installCommon(registers);
}

//#endregion
//#region node_modules/echarts/lib/component/visualMap/PiecewiseModel.js
var PiecewiseModel = function(_super) {
	__extends(PiecewiseModel$1, _super);
	function PiecewiseModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = PiecewiseModel$1.type;
		/**
		* The order is always [low, ..., high].
		* [{text: string, interval: Array.<number>}, ...]
		*/
		_this._pieceList = [];
		return _this;
	}
	PiecewiseModel$1.prototype.optionUpdated = function(newOption, isInit) {
		_super.prototype.optionUpdated.apply(this, arguments);
		this.resetExtent();
		var mode = this._mode = this._determineMode();
		this._pieceList = [];
		resetMethods[this._mode].call(this, this._pieceList);
		this._resetSelected(newOption, isInit);
		var categories = this.option.categories;
		this.resetVisual(function(mappingOption, state) {
			if (mode === "categories") {
				mappingOption.mappingMethod = "category";
				mappingOption.categories = clone(categories);
			} else {
				mappingOption.dataExtent = this.getExtent();
				mappingOption.mappingMethod = "piecewise";
				mappingOption.pieceList = map(this._pieceList, function(piece) {
					piece = clone(piece);
					if (state !== "inRange") piece.visual = null;
					return piece;
				});
			}
		});
	};
	/**
	* @protected
	* @override
	*/
	PiecewiseModel$1.prototype.completeVisualOption = function() {
		var option = this.option;
		var visualTypesInPieces = {};
		var visualTypes = VisualMapping_default.listVisualTypes();
		var isCategory$1 = this.isCategory();
		each(option.pieces, function(piece) {
			each(visualTypes, function(visualType) {
				if (piece.hasOwnProperty(visualType)) visualTypesInPieces[visualType] = 1;
			});
		});
		each(visualTypesInPieces, function(v, visualType) {
			var exists = false;
			each(this.stateList, function(state) {
				exists = exists || has$2(option, state, visualType) || has$2(option.target, state, visualType);
			}, this);
			!exists && each(this.stateList, function(state) {
				(option[state] || (option[state] = {}))[visualType] = visualDefault_default.get(visualType, state === "inRange" ? "active" : "inactive", isCategory$1);
			});
		}, this);
		function has$2(obj, state, visualType) {
			return obj && obj[state] && obj[state].hasOwnProperty(visualType);
		}
		_super.prototype.completeVisualOption.apply(this, arguments);
	};
	PiecewiseModel$1.prototype._resetSelected = function(newOption, isInit) {
		var thisOption = this.option;
		var pieceList = this._pieceList;
		var selected = (isInit ? thisOption : newOption).selected || {};
		thisOption.selected = selected;
		each(pieceList, function(piece, index) {
			var key$1 = this.getSelectedMapKey(piece);
			if (!selected.hasOwnProperty(key$1)) selected[key$1] = true;
		}, this);
		if (thisOption.selectedMode === "single") {
			var hasSel_1 = false;
			each(pieceList, function(piece, index) {
				var key$1 = this.getSelectedMapKey(piece);
				if (selected[key$1]) hasSel_1 ? selected[key$1] = false : hasSel_1 = true;
			}, this);
		}
	};
	/**
	* @public
	*/
	PiecewiseModel$1.prototype.getItemSymbol = function() {
		return this.get("itemSymbol");
	};
	/**
	* @public
	*/
	PiecewiseModel$1.prototype.getSelectedMapKey = function(piece) {
		return this._mode === "categories" ? piece.value + "" : piece.index + "";
	};
	/**
	* @public
	*/
	PiecewiseModel$1.prototype.getPieceList = function() {
		return this._pieceList;
	};
	/**
	* @return {string}
	*/
	PiecewiseModel$1.prototype._determineMode = function() {
		var option = this.option;
		return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
	};
	/**
	* @override
	*/
	PiecewiseModel$1.prototype.setSelected = function(selected) {
		this.option.selected = clone(selected);
	};
	/**
	* @override
	*/
	PiecewiseModel$1.prototype.getValueState = function(value) {
		var index = VisualMapping_default.findPieceIndex(value, this._pieceList);
		return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? "inRange" : "outOfRange" : "outOfRange";
	};
	/**
	* @public
	* @param pieceIndex piece index in visualMapModel.getPieceList()
	*/
	PiecewiseModel$1.prototype.findTargetDataIndices = function(pieceIndex) {
		var result = [];
		var pieceList = this._pieceList;
		this.eachTargetSeries(function(seriesModel) {
			var dataIndices = [];
			var data = seriesModel.getData();
			data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
				VisualMapping_default.findPieceIndex(value, pieceList) === pieceIndex && dataIndices.push(dataIndex);
			}, this);
			result.push({
				seriesId: seriesModel.id,
				dataIndex: dataIndices
			});
		}, this);
		return result;
	};
	/**
	* @private
	* @param piece piece.value or piece.interval is required.
	* @return  Can be Infinity or -Infinity
	*/
	PiecewiseModel$1.prototype.getRepresentValue = function(piece) {
		var representValue;
		if (this.isCategory()) representValue = piece.value;
		else if (piece.value != null) representValue = piece.value;
		else {
			var pieceInterval = piece.interval || [];
			representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
		}
		return representValue;
	};
	PiecewiseModel$1.prototype.getVisualMeta = function(getColorVisual$1) {
		if (this.isCategory()) return;
		var stops = [];
		var outerColors = ["", ""];
		var visualMapModel = this;
		function setStop(interval, valueState) {
			var representValue = visualMapModel.getRepresentValue({ interval });
			if (!valueState) valueState = visualMapModel.getValueState(representValue);
			var color$2 = getColorVisual$1(representValue, valueState);
			if (interval[0] === -Infinity) outerColors[0] = color$2;
			else if (interval[1] === Infinity) outerColors[1] = color$2;
			else stops.push({
				value: interval[0],
				color: color$2
			}, {
				value: interval[1],
				color: color$2
			});
		}
		var pieceList = this._pieceList.slice();
		if (!pieceList.length) pieceList.push({ interval: [-Infinity, Infinity] });
		else {
			var edge = pieceList[0].interval[0];
			edge !== -Infinity && pieceList.unshift({ interval: [-Infinity, edge] });
			edge = pieceList[pieceList.length - 1].interval[1];
			edge !== Infinity && pieceList.push({ interval: [edge, Infinity] });
		}
		var curr = -Infinity;
		each(pieceList, function(piece) {
			var interval = piece.interval;
			if (interval) {
				interval[0] > curr && setStop([curr, interval[0]], "outOfRange");
				setStop(interval.slice());
				curr = interval[1];
			}
		}, this);
		return {
			stops,
			outerColors
		};
	};
	PiecewiseModel$1.type = "visualMap.piecewise";
	PiecewiseModel$1.defaultOption = inheritDefaultOption(VisualMapModel_default.defaultOption, {
		selected: null,
		minOpen: false,
		maxOpen: false,
		align: "auto",
		itemWidth: 20,
		itemHeight: 14,
		itemSymbol: "roundRect",
		pieces: null,
		categories: null,
		splitNumber: 5,
		selectedMode: "multiple",
		itemGap: 10,
		hoverLink: true
	});
	return PiecewiseModel$1;
}(VisualMapModel_default);
/**
* Key is this._mode
* @type {Object}
* @this {module:echarts/component/viusalMap/PiecewiseMode}
*/
var resetMethods = {
	splitNumber: function(outPieceList) {
		var thisOption = this.option;
		var precision = Math.min(thisOption.precision, 20);
		var dataExtent = this.getExtent();
		var splitNumber = thisOption.splitNumber;
		splitNumber = Math.max(parseInt(splitNumber, 10), 1);
		thisOption.splitNumber = splitNumber;
		var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
		while (+splitStep.toFixed(precision) !== splitStep && precision < 5) precision++;
		thisOption.precision = precision;
		splitStep = +splitStep.toFixed(precision);
		if (thisOption.minOpen) outPieceList.push({
			interval: [-Infinity, dataExtent[0]],
			close: [0, 0]
		});
		for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
			var max$2 = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
			outPieceList.push({
				interval: [curr, max$2],
				close: [1, 1]
			});
		}
		if (thisOption.maxOpen) outPieceList.push({
			interval: [dataExtent[1], Infinity],
			close: [0, 0]
		});
		reformIntervals(outPieceList);
		each(outPieceList, function(piece, index$1) {
			piece.index = index$1;
			piece.text = this.formatValueText(piece.interval);
		}, this);
	},
	categories: function(outPieceList) {
		var thisOption = this.option;
		each(thisOption.categories, function(cate) {
			outPieceList.push({
				text: this.formatValueText(cate, true),
				value: cate
			});
		}, this);
		normalizeReverse(thisOption, outPieceList);
	},
	pieces: function(outPieceList) {
		var thisOption = this.option;
		each(thisOption.pieces, function(pieceListItem, index) {
			if (!isObject(pieceListItem)) pieceListItem = { value: pieceListItem };
			var item = {
				text: "",
				index
			};
			if (pieceListItem.label != null) item.text = pieceListItem.label;
			if (pieceListItem.hasOwnProperty("value")) {
				var value = item.value = pieceListItem.value;
				item.interval = [value, value];
				item.close = [1, 1];
			} else {
				var interval = item.interval = [];
				var close_1 = item.close = [0, 0];
				var closeList = [
					1,
					0,
					1
				];
				var infinityList = [-Infinity, Infinity];
				var useMinMax = [];
				for (var lg = 0; lg < 2; lg++) {
					var names = [[
						"gte",
						"gt",
						"min"
					], [
						"lte",
						"lt",
						"max"
					]][lg];
					for (var i$1 = 0; i$1 < 3 && interval[lg] == null; i$1++) {
						interval[lg] = pieceListItem[names[i$1]];
						close_1[lg] = closeList[i$1];
						useMinMax[lg] = i$1 === 2;
					}
					interval[lg] ?? (interval[lg] = infinityList[lg]);
				}
				useMinMax[0] && interval[1] === Infinity && (close_1[0] = 0);
				useMinMax[1] && interval[0] === -Infinity && (close_1[1] = 0);
				if (interval[0] > interval[1]) console.warn("Piece " + index + "is illegal: " + interval + " lower bound should not greater then uppper bound.");
				if (interval[0] === interval[1] && close_1[0] && close_1[1]) item.value = interval[0];
			}
			item.visual = VisualMapping_default.retrieveVisuals(pieceListItem);
			outPieceList.push(item);
		}, this);
		normalizeReverse(thisOption, outPieceList);
		reformIntervals(outPieceList);
		each(outPieceList, function(piece) {
			var close = piece.close;
			var edgeSymbols = [["<", ""][close[1]], [">", ""][close[0]]];
			piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
		}, this);
	}
};
function normalizeReverse(thisOption, pieceList) {
	var inverse = thisOption.inverse;
	if (thisOption.orient === "vertical" ? !inverse : inverse) pieceList.reverse();
}
var PiecewiseModel_default = PiecewiseModel;

//#endregion
//#region node_modules/echarts/lib/component/visualMap/PiecewiseView.js
var PiecewiseVisualMapView = function(_super) {
	__extends(PiecewiseVisualMapView$1, _super);
	function PiecewiseVisualMapView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = PiecewiseVisualMapView$1.type;
		return _this;
	}
	PiecewiseVisualMapView$1.prototype.doRender = function() {
		var thisGroup = this.group;
		thisGroup.removeAll();
		var visualMapModel = this.visualMapModel;
		var textGap = visualMapModel.get("textGap");
		var textStyleModel = visualMapModel.textStyleModel;
		var itemAlign = this._getItemAlign();
		var itemSize = visualMapModel.itemSize;
		var viewData = this._getViewData();
		var endsText = viewData.endsText;
		var showLabel = retrieve(visualMapModel.get("showLabel", true), !endsText);
		var silent = !visualMapModel.get("selectedMode");
		endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
		each(viewData.viewPieceList, function(item) {
			var piece = item.piece;
			var itemGroup = new Group_default();
			itemGroup.onclick = bind(this._onItemClick, this, piece);
			this._enableHoverLink(itemGroup, item.indexInModelPieceList);
			var representValue = visualMapModel.getRepresentValue(piece);
			this._createItemSymbol(itemGroup, representValue, [
				0,
				0,
				itemSize[0],
				itemSize[1]
			], silent);
			if (showLabel) {
				var visualState = this.visualMapModel.getValueState(representValue);
				var align = textStyleModel.get("align") || itemAlign;
				itemGroup.add(new Text_default({
					style: createTextStyle(textStyleModel, {
						x: align === "right" ? -textGap : itemSize[0] + textGap,
						y: itemSize[1] / 2,
						text: piece.text,
						verticalAlign: textStyleModel.get("verticalAlign") || "middle",
						align,
						opacity: retrieve2(textStyleModel.get("opacity"), visualState === "outOfRange" ? .5 : 1)
					}),
					silent
				}));
			}
			thisGroup.add(itemGroup);
		}, this);
		endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
		box(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap"));
		this.renderBackground(thisGroup);
		this.positionGroup(thisGroup);
	};
	PiecewiseVisualMapView$1.prototype._enableHoverLink = function(itemGroup, pieceIndex) {
		var _this = this;
		itemGroup.on("mouseover", function() {
			return onHoverLink("highlight");
		}).on("mouseout", function() {
			return onHoverLink("downplay");
		});
		var onHoverLink = function(method) {
			var visualMapModel = _this.visualMapModel;
			visualMapModel.option.hoverLink && _this.api.dispatchAction({
				type: method,
				batch: makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
			});
		};
	};
	PiecewiseVisualMapView$1.prototype._getItemAlign = function() {
		var visualMapModel = this.visualMapModel;
		var modelOption = visualMapModel.option;
		if (modelOption.orient === "vertical") return getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
		else {
			var align = modelOption.align;
			if (!align || align === "auto") align = "left";
			return align;
		}
	};
	PiecewiseVisualMapView$1.prototype._renderEndsText = function(group, text, itemSize, showLabel, itemAlign) {
		if (!text) return;
		var itemGroup = new Group_default();
		var textStyleModel = this.visualMapModel.textStyleModel;
		itemGroup.add(new Text_default({ style: createTextStyle(textStyleModel, {
			x: showLabel ? itemAlign === "right" ? itemSize[0] : 0 : itemSize[0] / 2,
			y: itemSize[1] / 2,
			verticalAlign: "middle",
			align: showLabel ? itemAlign : "center",
			text
		}) }));
		group.add(itemGroup);
	};
	/**
	* @private
	* @return {Object} {peiceList, endsText} The order is the same as screen pixel order.
	*/
	PiecewiseVisualMapView$1.prototype._getViewData = function() {
		var visualMapModel = this.visualMapModel;
		var viewPieceList = map(visualMapModel.getPieceList(), function(piece, index) {
			return {
				piece,
				indexInModelPieceList: index
			};
		});
		var endsText = visualMapModel.get("text");
		var orient = visualMapModel.get("orient");
		var inverse = visualMapModel.get("inverse");
		if (orient === "horizontal" ? inverse : !inverse) viewPieceList.reverse();
		else if (endsText) endsText = endsText.slice().reverse();
		return {
			viewPieceList,
			endsText
		};
	};
	PiecewiseVisualMapView$1.prototype._createItemSymbol = function(group, representValue, shapeParam, silent) {
		var itemSymbol = createSymbol(this.getControllerVisual(representValue, "symbol"), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, "color"));
		itemSymbol.silent = silent;
		group.add(itemSymbol);
	};
	PiecewiseVisualMapView$1.prototype._onItemClick = function(piece) {
		var visualMapModel = this.visualMapModel;
		var option = visualMapModel.option;
		var selectedMode = option.selectedMode;
		if (!selectedMode) return;
		var selected = clone(option.selected);
		var newKey = visualMapModel.getSelectedMapKey(piece);
		if (selectedMode === "single" || selectedMode === true) {
			selected[newKey] = true;
			each(selected, function(o, key$1) {
				selected[key$1] = key$1 === newKey;
			});
		} else selected[newKey] = !selected[newKey];
		this.api.dispatchAction({
			type: "selectDataRange",
			from: this.uid,
			visualMapId: this.visualMapModel.id,
			selected
		});
	};
	PiecewiseVisualMapView$1.type = "visualMap.piecewise";
	return PiecewiseVisualMapView$1;
}(VisualMapView_default);
var PiecewiseView_default = PiecewiseVisualMapView;

//#endregion
//#region node_modules/echarts/lib/component/visualMap/installVisualMapPiecewise.js
function install$48(registers) {
	registers.registerComponentModel(PiecewiseModel_default);
	registers.registerComponentView(PiecewiseView_default);
	installCommon(registers);
}

//#endregion
//#region node_modules/echarts/lib/component/visualMap/install.js
function install$46(registers) {
	use(install$47);
	use(install$48);
}

//#endregion
//#region node_modules/echarts/lib/component/thumbnail/ThumbnailBridgeImpl.js
/**
* [CAVEAT]: the call order of `ThumbnailView['render']` and other
*  `ChartView['render']/ComponentView['render']` is not guaranteed.
*/
var ThumbnailBridgeImpl = function() {
	function ThumbnailBridgeImpl$1(thumbnailModel) {
		this._thumbnailModel = thumbnailModel;
	}
	ThumbnailBridgeImpl$1.prototype.reset = function(api) {
		this._renderVersion = api.getMainProcessVersion();
	};
	ThumbnailBridgeImpl$1.prototype.renderContent = function(opt) {
		var thumbnailView = opt.api.getViewOfComponentModel(this._thumbnailModel);
		if (!thumbnailView) return;
		opt.group.silent = true;
		thumbnailView.renderContent({
			group: opt.group,
			targetTrans: opt.targetTrans,
			z2Range: calcZ2Range(opt.group),
			roamType: opt.roamType,
			viewportRect: opt.viewportRect,
			renderVersion: this._renderVersion
		});
	};
	ThumbnailBridgeImpl$1.prototype.updateWindow = function(targetTrans, api) {
		var thumbnailView = api.getViewOfComponentModel(this._thumbnailModel);
		if (!thumbnailView) return;
		thumbnailView.updateWindow({
			targetTrans,
			renderVersion: this._renderVersion
		});
	};
	return ThumbnailBridgeImpl$1;
}();

//#endregion
//#region node_modules/echarts/lib/component/thumbnail/ThumbnailModel.js
var ThumbnailModel = function(_super) {
	__extends(ThumbnailModel$1, _super);
	function ThumbnailModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ThumbnailModel$1.type;
		_this.preventAutoZ = true;
		return _this;
	}
	ThumbnailModel$1.prototype.optionUpdated = function(newCptOption, isInit) {
		this._updateBridge();
	};
	ThumbnailModel$1.prototype._updateBridge = function() {
		var bridge = this._birdge = this._birdge || new ThumbnailBridgeImpl(this);
		this._target = null;
		this.ecModel.eachSeries(function(series) {
			injectThumbnailBridge(series, null);
		});
		if (this.shouldShow()) injectThumbnailBridge(this.getTarget().baseMapProvider, bridge);
	};
	ThumbnailModel$1.prototype.shouldShow = function() {
		return this.getShallow("show", true);
	};
	ThumbnailModel$1.prototype.getBridge = function() {
		return this._birdge;
	};
	ThumbnailModel$1.prototype.getTarget = function() {
		if (this._target) return this._target;
		var series = this.getReferringComponents("series", {
			useDefault: false,
			enableAll: false,
			enableNone: false
		}).models[0];
		if (series) {
			if (series.subType !== "graph") {
				series = null;
				error("series." + series.subType + " is not supported in thumbnail.", true);
			}
		} else series = this.ecModel.queryComponents({
			mainType: "series",
			subType: "graph"
		})[0];
		this._target = { baseMapProvider: series };
		return this._target;
	};
	ThumbnailModel$1.type = "thumbnail";
	ThumbnailModel$1.layoutMode = "box";
	ThumbnailModel$1.dependencies = ["series", "geo"];
	ThumbnailModel$1.defaultOption = {
		show: true,
		right: 1,
		bottom: 1,
		height: "25%",
		width: "25%",
		itemStyle: {
			borderColor: tokens_default.color.border,
			borderWidth: 2
		},
		windowStyle: {
			borderWidth: 1,
			color: tokens_default.color.neutral30,
			borderColor: tokens_default.color.neutral40,
			opacity: .3
		},
		z: 10
	};
	return ThumbnailModel$1;
}(Component_default);

//#endregion
//#region node_modules/echarts/lib/component/thumbnail/ThumbnailView.js
var ThumbnailView = function(_super) {
	__extends(ThumbnailView$1, _super);
	function ThumbnailView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = ThumbnailView$1.type;
		return _this;
	}
	ThumbnailView$1.prototype.render = function(thumbnailModel, ecModel, api) {
		this._api = api;
		this._model = thumbnailModel;
		if (!this._coordSys) this._coordSys = new View_default();
		if (!this._isEnabled()) {
			this._clear();
			return;
		}
		this._renderVersion = api.getMainProcessVersion();
		var group = this.group;
		group.removeAll();
		var itemStyleModel = thumbnailModel.getModel("itemStyle");
		var itemStyle = itemStyleModel.getItemStyle();
		if (itemStyle.fill == null) itemStyle.fill = ecModel.get("backgroundColor") || tokens_default.color.neutral00;
		var refContainer = createBoxLayoutReference(thumbnailModel, api).refContainer;
		var boxRect = getLayoutRect(getBoxLayoutParams(thumbnailModel, true), refContainer);
		var boxBorderWidth = itemStyle.lineWidth || 0;
		var contentRect = this._contentRect = expandOrShrinkRect(boxRect.clone(), boxBorderWidth / 2, true, true);
		var contentGroup = new Group_default();
		group.add(contentGroup);
		contentGroup.setClipPath(new Rect_default({ shape: contentRect.plain() }));
		var targetGroup = this._targetGroup = new Group_default();
		contentGroup.add(targetGroup);
		var borderShape = boxRect.plain();
		borderShape.r = itemStyleModel.getShallow("borderRadius", true);
		group.add(this._bgRect = new Rect_default({
			style: itemStyle,
			shape: borderShape,
			silent: false,
			cursor: "grab"
		}));
		var windowStyleModel = thumbnailModel.getModel("windowStyle");
		var windowR = windowStyleModel.getShallow("borderRadius", true);
		contentGroup.add(this._windowRect = new Rect_default({
			shape: {
				x: 0,
				y: 0,
				width: 0,
				height: 0,
				r: windowR
			},
			style: windowStyleModel.getItemStyle(),
			silent: false,
			cursor: "grab"
		}));
		this._dealRenderContent();
		this._dealUpdateWindow();
		updateZ(thumbnailModel, this);
	};
	/**
	* Can be called asynchronously directly.
	* This method should be idempotent.
	*/
	ThumbnailView$1.prototype.renderContent = function(bridgeRendered) {
		this._bridgeRendered = bridgeRendered;
		if (this._isEnabled()) {
			this._dealRenderContent();
			this._dealUpdateWindow();
			updateZ(this._model, this);
		}
	};
	ThumbnailView$1.prototype._dealRenderContent = function() {
		var bridgeRendered = this._bridgeRendered;
		if (!bridgeRendered || bridgeRendered.renderVersion !== this._renderVersion) return;
		var targetGroup = this._targetGroup;
		var coordSys = this._coordSys;
		var contentRect = this._contentRect;
		targetGroup.removeAll();
		if (!bridgeRendered) return;
		var bridgeGroup = bridgeRendered.group;
		var bridgeRect = bridgeGroup.getBoundingRect();
		targetGroup.add(bridgeGroup);
		this._bgRect.z2 = bridgeRendered.z2Range.min - 10;
		coordSys.setBoundingRect(bridgeRect.x, bridgeRect.y, bridgeRect.width, bridgeRect.height);
		var viewRect$1 = getLayoutRect({
			left: "center",
			top: "center",
			aspect: bridgeRect.width / bridgeRect.height
		}, contentRect);
		coordSys.setViewRect(viewRect$1.x, viewRect$1.y, viewRect$1.width, viewRect$1.height);
		bridgeGroup.attr(coordSys.getTransformInfo().raw);
		this._windowRect.z2 = bridgeRendered.z2Range.max + 10;
		this._resetRoamController(bridgeRendered.roamType);
	};
	/**
	* Can be called from action handler directly.
	* This method should be idempotent.
	*/
	ThumbnailView$1.prototype.updateWindow = function(param) {
		var bridgeRendered = this._bridgeRendered;
		if (bridgeRendered && bridgeRendered.renderVersion === param.renderVersion) bridgeRendered.targetTrans = param.targetTrans;
		if (this._isEnabled()) this._dealUpdateWindow();
	};
	ThumbnailView$1.prototype._dealUpdateWindow = function() {
		var bridgeRendered = this._bridgeRendered;
		if (!bridgeRendered || bridgeRendered.renderVersion !== this._renderVersion) return;
		var invTargetTrans = invert([], bridgeRendered.targetTrans);
		var transTargetToThis = mul([], this._coordSys.transform, invTargetTrans);
		this._transThisToTarget = invert([], transTargetToThis);
		var viewportRect = bridgeRendered.viewportRect;
		if (!viewportRect) viewportRect = new BoundingRect_default(0, 0, this._api.getWidth(), this._api.getHeight());
		else viewportRect = viewportRect.clone();
		viewportRect.applyTransform(transTargetToThis);
		var windowRect = this._windowRect;
		var r = windowRect.shape.r;
		windowRect.setShape(defaults({ r }, viewportRect));
	};
	ThumbnailView$1.prototype._resetRoamController = function(roamType) {
		var _this = this;
		var api = this._api;
		var roamController = this._roamController;
		if (!roamController) roamController = this._roamController = new RoamController_default(api.getZr());
		if (!roamType || !this._isEnabled()) {
			roamController.disable();
			return;
		}
		roamController.enable(roamType, {
			api,
			zInfo: { component: this._model },
			triggerInfo: {
				roamTrigger: null,
				isInSelf: function(e$1, x, y) {
					return _this._contentRect.contain(x, y);
				}
			}
		});
		roamController.off("pan").off("zoom").on("pan", bind(this._onPan, this)).on("zoom", bind(this._onZoom, this));
	};
	ThumbnailView$1.prototype._onPan = function(event) {
		var trans = this._transThisToTarget;
		if (!this._isEnabled() || !trans) return;
		var oldOffset = applyTransform([], [event.oldX, event.oldY], trans);
		var newOffset = applyTransform([], [event.oldX - event.dx, event.oldY - event.dy], trans);
		this._api.dispatchAction(makeRoamPayload(this._model.getTarget().baseMapProvider, {
			dx: newOffset[0] - oldOffset[0],
			dy: newOffset[1] - oldOffset[1]
		}));
	};
	ThumbnailView$1.prototype._onZoom = function(event) {
		var trans = this._transThisToTarget;
		if (!this._isEnabled() || !trans) return;
		var offset = applyTransform([], [event.originX, event.originY], trans);
		this._api.dispatchAction(makeRoamPayload(this._model.getTarget().baseMapProvider, {
			zoom: 1 / event.scale,
			originX: offset[0],
			originY: offset[1]
		}));
	};
	/**
	* This method is also responsible for check enable in asynchronous situation,
	* e.g., in event listeners that is supposed to be outdated but not be removed.
	*/
	ThumbnailView$1.prototype._isEnabled = function() {
		var thumbnailModel = this._model;
		if (!thumbnailModel || !thumbnailModel.shouldShow()) return false;
		if (!thumbnailModel.getTarget().baseMapProvider) return false;
		return true;
	};
	ThumbnailView$1.prototype._clear = function() {
		this.group.removeAll();
		this._bridgeRendered = null;
		if (this._roamController) this._roamController.disable();
	};
	ThumbnailView$1.prototype.remove = function() {
		this._clear();
	};
	ThumbnailView$1.prototype.dispose = function() {
		this._clear();
	};
	ThumbnailView$1.type = "thumbnail";
	return ThumbnailView$1;
}(Component_default$1);
function makeRoamPayload(baseMapProvider, params) {
	var payload = { type: baseMapProvider.mainType === "series" ? baseMapProvider.subType + "Roam" : baseMapProvider.mainType + "Roam" };
	payload[baseMapProvider.mainType + "Id"] = baseMapProvider.id;
	extend(payload, params);
	return payload;
}
function updateZ(thumbnailModel, thumbnailView) {
	var zInfo = retrieveZInfo(thumbnailModel);
	traverseUpdateZ(thumbnailView.group, zInfo.z, zInfo.zlevel);
}

//#endregion
//#region node_modules/echarts/lib/component/thumbnail/install.js
function install$49(registers) {
	registers.registerComponentModel(ThumbnailModel);
	registers.registerComponentView(ThumbnailView);
}

//#endregion
//#region node_modules/echarts/lib/visual/aria.js
var DEFAULT_OPTION = {
	label: { enabled: true },
	decal: { show: false }
};
var inner = makeInner();
var decalPaletteScope = {};
function ariaVisual(ecModel, api) {
	var ariaModel = ecModel.getModel("aria");
	if (!ariaModel.get("enabled")) return;
	var defaultOption$2 = clone(DEFAULT_OPTION);
	merge(defaultOption$2.label, ecModel.getLocaleModel().get("aria"), false);
	merge(ariaModel.option, defaultOption$2, false);
	setDecal();
	setLabel();
	function setDecal() {
		if (ariaModel.getModel("decal").get("show")) {
			var paletteScopeGroupByType_1 = createHashMap();
			ecModel.eachSeries(function(seriesModel) {
				if (seriesModel.isColorBySeries()) return;
				var decalScope = paletteScopeGroupByType_1.get(seriesModel.type);
				if (!decalScope) {
					decalScope = {};
					paletteScopeGroupByType_1.set(seriesModel.type, decalScope);
				}
				inner(seriesModel).scope = decalScope;
			});
			ecModel.eachRawSeries(function(seriesModel) {
				if (ecModel.isSeriesFiltered(seriesModel)) return;
				if (isFunction(seriesModel.enableAriaDecal)) {
					seriesModel.enableAriaDecal();
					return;
				}
				var data = seriesModel.getData();
				if (!seriesModel.isColorBySeries()) {
					var dataAll_1 = seriesModel.getRawData();
					var idxMap_1 = {};
					var decalScope_1 = inner(seriesModel).scope;
					data.each(function(idx) {
						var rawIdx = data.getRawIndex(idx);
						idxMap_1[rawIdx] = idx;
					});
					var dataCount_1 = dataAll_1.count();
					dataAll_1.each(function(rawIdx) {
						var idx = idxMap_1[rawIdx];
						var name = dataAll_1.getName(rawIdx) || rawIdx + "";
						var paletteDecal$1 = getDecalFromPalette(seriesModel.ecModel, name, decalScope_1, dataCount_1);
						var specifiedDecal$1 = data.getItemVisual(idx, "decal");
						data.setItemVisual(idx, "decal", mergeDecal(specifiedDecal$1, paletteDecal$1));
					});
				} else {
					var paletteDecal = getDecalFromPalette(seriesModel.ecModel, seriesModel.name, decalPaletteScope, ecModel.getSeriesCount());
					var specifiedDecal = data.getVisual("decal");
					data.setVisual("decal", mergeDecal(specifiedDecal, paletteDecal));
				}
				function mergeDecal(specifiedDecal$1, paletteDecal$1) {
					var resultDecal = specifiedDecal$1 ? extend(extend({}, paletteDecal$1), specifiedDecal$1) : paletteDecal$1;
					resultDecal.dirty = true;
					return resultDecal;
				}
			});
		}
	}
	function setLabel() {
		var dom = api.getZr().dom;
		if (!dom) return;
		var labelLocale = ecModel.getLocaleModel().get("aria");
		var labelModel = ariaModel.getModel("label");
		labelModel.option = defaults(labelModel.option, labelLocale);
		if (!labelModel.get("enabled")) return;
		dom.setAttribute("role", "img");
		if (labelModel.get("description")) {
			dom.setAttribute("aria-label", labelModel.get("description"));
			return;
		}
		var seriesCnt = ecModel.getSeriesCount();
		var maxDataCnt = labelModel.get(["data", "maxCount"]) || 10;
		var maxSeriesCnt = labelModel.get(["series", "maxCount"]) || 10;
		var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
		var ariaLabel;
		if (seriesCnt < 1) return;
		else {
			var title = getTitle();
			if (title) ariaLabel = replace(labelModel.get(["general", "withTitle"]), { title });
			else ariaLabel = labelModel.get(["general", "withoutTitle"]);
			var seriesLabels_1 = [];
			var prefix = seriesCnt > 1 ? labelModel.get([
				"series",
				"multiple",
				"prefix"
			]) : labelModel.get([
				"series",
				"single",
				"prefix"
			]);
			ariaLabel += replace(prefix, { seriesCount: seriesCnt });
			ecModel.eachSeries(function(seriesModel, idx) {
				if (idx < displaySeriesCnt) {
					var seriesLabel = void 0;
					var withName = seriesModel.get("name") ? "withName" : "withoutName";
					seriesLabel = seriesCnt > 1 ? labelModel.get([
						"series",
						"multiple",
						withName
					]) : labelModel.get([
						"series",
						"single",
						withName
					]);
					seriesLabel = replace(seriesLabel, {
						seriesId: seriesModel.seriesIndex,
						seriesName: seriesModel.get("name"),
						seriesType: getSeriesTypeName(seriesModel.subType)
					});
					var data = seriesModel.getData();
					if (data.count() > maxDataCnt) {
						var partialLabel = labelModel.get(["data", "partialData"]);
						seriesLabel += replace(partialLabel, { displayCnt: maxDataCnt });
					} else seriesLabel += labelModel.get(["data", "allData"]);
					var middleSeparator_1 = labelModel.get([
						"data",
						"separator",
						"middle"
					]);
					var endSeparator_1 = labelModel.get([
						"data",
						"separator",
						"end"
					]);
					var excludeDimensionId_1 = labelModel.get(["data", "excludeDimensionId"]);
					var dataLabels = [];
					for (var i$1 = 0; i$1 < data.count(); i$1++) if (i$1 < maxDataCnt) {
						var name_1 = data.getName(i$1);
						var value = !excludeDimensionId_1 ? data.getValues(i$1) : filter(data.getValues(i$1), function(v, j) {
							return indexOf(excludeDimensionId_1, j) === -1;
						});
						var dataLabel = labelModel.get(["data", name_1 ? "withName" : "withoutName"]);
						dataLabels.push(replace(dataLabel, {
							name: name_1,
							value: value.join(middleSeparator_1)
						}));
					}
					seriesLabel += dataLabels.join(middleSeparator_1) + endSeparator_1;
					seriesLabels_1.push(seriesLabel);
				}
			});
			var separatorModel = labelModel.getModel([
				"series",
				"multiple",
				"separator"
			]);
			var middleSeparator = separatorModel.get("middle");
			var endSeparator = separatorModel.get("end");
			ariaLabel += seriesLabels_1.join(middleSeparator) + endSeparator;
			dom.setAttribute("aria-label", ariaLabel);
		}
	}
	function replace(str, keyValues) {
		if (!isString(str)) return str;
		var result = str;
		each(keyValues, function(value, key$1) {
			result = result.replace(new RegExp("\\{\\s*" + key$1 + "\\s*\\}", "g"), value);
		});
		return result;
	}
	function getTitle() {
		var title = ecModel.get("title");
		if (title && title.length) title = title[0];
		return title && title.text;
	}
	function getSeriesTypeName(type) {
		var typeNames = ecModel.getLocaleModel().get(["series", "typeNames"]);
		return typeNames[type] || typeNames.chart;
	}
}

//#endregion
//#region node_modules/echarts/lib/component/aria/preprocessor.js
function ariaPreprocessor(option) {
	if (!option || !option.aria) return;
	var aria = option.aria;
	if (aria.show != null) aria.enabled = aria.show;
	aria.label = aria.label || {};
	each([
		"description",
		"general",
		"series",
		"data"
	], function(name) {
		if (aria[name] != null) aria.label[name] = aria[name];
	});
}

//#endregion
//#region node_modules/echarts/lib/component/aria/install.js
function install$50(registers) {
	registers.registerPreprocessor(ariaPreprocessor);
	registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, ariaVisual);
}

//#endregion
//#region node_modules/echarts/lib/util/conditionalExpression.js
var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
	value: "eq",
	"<": "lt",
	"<=": "lte",
	">": "gt",
	">=": "gte",
	"=": "eq",
	"!=": "ne",
	"<>": "ne"
};
var RegExpEvaluator = function() {
	function RegExpEvaluator$1(rVal) {
		if ((this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null) == null) {
			var errMsg = "";
			errMsg = makePrintable("Illegal regexp", rVal, "in");
			throwError(errMsg);
		}
	}
	RegExpEvaluator$1.prototype.evaluate = function(lVal) {
		var type = typeof lVal;
		return isString(type) ? this._condVal.test(lVal) : isNumber(type) ? this._condVal.test(lVal + "") : false;
	};
	return RegExpEvaluator$1;
}();
var ConstConditionInternal = function() {
	function ConstConditionInternal$1() {}
	ConstConditionInternal$1.prototype.evaluate = function() {
		return this.value;
	};
	return ConstConditionInternal$1;
}();
var AndConditionInternal = function() {
	function AndConditionInternal$1() {}
	AndConditionInternal$1.prototype.evaluate = function() {
		var children = this.children;
		for (var i$1 = 0; i$1 < children.length; i$1++) if (!children[i$1].evaluate()) return false;
		return true;
	};
	return AndConditionInternal$1;
}();
var OrConditionInternal = function() {
	function OrConditionInternal$1() {}
	OrConditionInternal$1.prototype.evaluate = function() {
		var children = this.children;
		for (var i$1 = 0; i$1 < children.length; i$1++) if (children[i$1].evaluate()) return true;
		return false;
	};
	return OrConditionInternal$1;
}();
var NotConditionInternal = function() {
	function NotConditionInternal$1() {}
	NotConditionInternal$1.prototype.evaluate = function() {
		return !this.child.evaluate();
	};
	return NotConditionInternal$1;
}();
var RelationalConditionInternal = function() {
	function RelationalConditionInternal$1() {}
	RelationalConditionInternal$1.prototype.evaluate = function() {
		var needParse = !!this.valueParser;
		var getValue = this.getValue;
		var tarValRaw = getValue(this.valueGetterParam);
		var tarValParsed = needParse ? this.valueParser(tarValRaw) : null;
		for (var i$1 = 0; i$1 < this.subCondList.length; i$1++) if (!this.subCondList[i$1].evaluate(needParse ? tarValParsed : tarValRaw)) return false;
		return true;
	};
	return RelationalConditionInternal$1;
}();
function parseOption(exprOption, getters) {
	if (exprOption === true || exprOption === false) {
		var cond = new ConstConditionInternal();
		cond.value = exprOption;
		return cond;
	}
	var errMsg = "";
	if (!isObjectNotArray(exprOption)) {
		errMsg = makePrintable("Illegal config. Expect a plain object but actually", exprOption);
		throwError(errMsg);
	}
	if (exprOption.and) return parseAndOrOption("and", exprOption, getters);
	else if (exprOption.or) return parseAndOrOption("or", exprOption, getters);
	else if (exprOption.not) return parseNotOption(exprOption, getters);
	return parseRelationalOption(exprOption, getters);
}
function parseAndOrOption(op, exprOption, getters) {
	var subOptionArr = exprOption[op];
	var errMsg = "";
	errMsg = makePrintable("\"and\"/\"or\" condition should only be `" + op + ": [...]` and must not be empty array.", "Illegal condition:", exprOption);
	if (!isArray(subOptionArr)) throwError(errMsg);
	if (!subOptionArr.length) throwError(errMsg);
	var cond = op === "and" ? new AndConditionInternal() : new OrConditionInternal();
	cond.children = map(subOptionArr, function(subOption) {
		return parseOption(subOption, getters);
	});
	if (!cond.children.length) throwError(errMsg);
	return cond;
}
function parseNotOption(exprOption, getters) {
	var subOption = exprOption.not;
	var errMsg = "";
	errMsg = makePrintable("\"not\" condition should only be `not: {}`.", "Illegal condition:", exprOption);
	if (!isObjectNotArray(subOption)) throwError(errMsg);
	var cond = new NotConditionInternal();
	cond.child = parseOption(subOption, getters);
	if (!cond.child) throwError(errMsg);
	return cond;
}
function parseRelationalOption(exprOption, getters) {
	var errMsg = "";
	var valueGetterParam = getters.prepareGetValue(exprOption);
	var subCondList = [];
	var exprKeys = keys(exprOption);
	var parserName = exprOption.parser;
	var valueParser = parserName ? getRawValueParser(parserName) : null;
	for (var i$1 = 0; i$1 < exprKeys.length; i$1++) {
		var keyRaw = exprKeys[i$1];
		if (keyRaw === "parser" || getters.valueGetterAttrMap.get(keyRaw)) continue;
		var op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;
		var condValueRaw = exprOption[keyRaw];
		var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;
		var evaluator = createFilterComparator(op, condValueParsed) || op === "reg" && new RegExpEvaluator(condValueParsed);
		if (!evaluator) {
			errMsg = makePrintable("Illegal relational operation: \"" + keyRaw + "\" in condition:", exprOption);
			throwError(errMsg);
		}
		subCondList.push(evaluator);
	}
	if (!subCondList.length) {
		errMsg = makePrintable("Relational condition must have at least one operator.", "Illegal condition:", exprOption);
		throwError(errMsg);
	}
	var cond = new RelationalConditionInternal();
	cond.valueGetterParam = valueGetterParam;
	cond.valueParser = valueParser;
	cond.getValue = getters.getValue;
	cond.subCondList = subCondList;
	return cond;
}
function isObjectNotArray(val) {
	return isObject(val) && !isArrayLike(val);
}
var ConditionalExpressionParsed = function() {
	function ConditionalExpressionParsed$1(exprOption, getters) {
		this._cond = parseOption(exprOption, getters);
	}
	ConditionalExpressionParsed$1.prototype.evaluate = function() {
		return this._cond.evaluate();
	};
	return ConditionalExpressionParsed$1;
}();
function parseConditionalExpression(exprOption, getters) {
	return new ConditionalExpressionParsed(exprOption, getters);
}

//#endregion
//#region node_modules/echarts/lib/component/transform/filterTransform.js
var filterTransform = {
	type: "echarts:filter",
	transform: function(params) {
		var upstream = params.upstream;
		var rawItem;
		var condition = parseConditionalExpression(params.config, {
			valueGetterAttrMap: createHashMap({ dimension: true }),
			prepareGetValue: function(exprOption) {
				var errMsg = "";
				var dimLoose = exprOption.dimension;
				if (!hasOwn(exprOption, "dimension")) {
					errMsg = makePrintable("Relation condition must has prop \"dimension\" specified.", "Illegal condition:", exprOption);
					throwError(errMsg);
				}
				var dimInfo = upstream.getDimensionInfo(dimLoose);
				if (!dimInfo) {
					errMsg = makePrintable("Can not find dimension info via: " + dimLoose + ".\n", "Existing dimensions: ", upstream.cloneAllDimensionInfo(), ".\n", "Illegal condition:", exprOption, ".\n");
					throwError(errMsg);
				}
				return { dimIdx: dimInfo.index };
			},
			getValue: function(param) {
				return upstream.retrieveValueFromItem(rawItem, param.dimIdx);
			}
		});
		var resultData = [];
		for (var i$1 = 0, len$1 = upstream.count(); i$1 < len$1; i$1++) {
			rawItem = upstream.getRawDataItem(i$1);
			if (condition.evaluate()) resultData.push(rawItem);
		}
		return { data: resultData };
	}
};

//#endregion
//#region node_modules/echarts/lib/component/transform/sortTransform.js
var sampleLog = "";
sampleLog = [
	"Valid config is like:",
	"{ dimension: \"age\", order: \"asc\" }",
	"or [{ dimension: \"age\", order: \"asc\"], { dimension: \"date\", order: \"desc\" }]"
].join(" ");
var sortTransform = {
	type: "echarts:sort",
	transform: function(params) {
		var upstream = params.upstream;
		var config = params.config;
		var errMsg = "";
		var orderExprList = normalizeToArray(config);
		if (!orderExprList.length) {
			errMsg = "Empty `config` in sort transform.";
			throwError(errMsg);
		}
		var orderDefList = [];
		each(orderExprList, function(orderExpr) {
			var dimLoose = orderExpr.dimension;
			var order = orderExpr.order;
			var parserName = orderExpr.parser;
			var incomparable = orderExpr.incomparable;
			if (dimLoose == null) {
				errMsg = "Sort transform config must has \"dimension\" specified." + sampleLog;
				throwError(errMsg);
			}
			if (order !== "asc" && order !== "desc") {
				errMsg = "Sort transform config must has \"order\" specified." + sampleLog;
				throwError(errMsg);
			}
			if (incomparable && incomparable !== "min" && incomparable !== "max") {
				var errMsg_1 = "";
				errMsg_1 = "incomparable must be \"min\" or \"max\" rather than \"" + incomparable + "\".";
				throwError(errMsg_1);
			}
			if (order !== "asc" && order !== "desc") {
				var errMsg_2 = "";
				errMsg_2 = "order must be \"asc\" or \"desc\" rather than \"" + order + "\".";
				throwError(errMsg_2);
			}
			var dimInfo = upstream.getDimensionInfo(dimLoose);
			if (!dimInfo) {
				errMsg = makePrintable("Can not find dimension info via: " + dimLoose + ".\n", "Existing dimensions: ", upstream.cloneAllDimensionInfo(), ".\n", "Illegal config:", orderExpr, ".\n");
				throwError(errMsg);
			}
			var parser = parserName ? getRawValueParser(parserName) : null;
			if (parserName && !parser) {
				errMsg = makePrintable("Invalid parser name " + parserName + ".\n", "Illegal config:", orderExpr, ".\n");
				throwError(errMsg);
			}
			orderDefList.push({
				dimIdx: dimInfo.index,
				parser,
				comparator: new SortOrderComparator(order, incomparable)
			});
		});
		var sourceFormat = upstream.sourceFormat;
		if (sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
			errMsg = "sourceFormat \"" + sourceFormat + "\" is not supported yet";
			throwError(errMsg);
		}
		var resultData = [];
		for (var i$1 = 0, len$1 = upstream.count(); i$1 < len$1; i$1++) resultData.push(upstream.getRawDataItem(i$1));
		resultData.sort(function(item0, item1) {
			for (var i$2 = 0; i$2 < orderDefList.length; i$2++) {
				var orderDef = orderDefList[i$2];
				var val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx);
				var val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx);
				if (orderDef.parser) {
					val0 = orderDef.parser(val0);
					val1 = orderDef.parser(val1);
				}
				var result = orderDef.comparator.evaluate(val0, val1);
				if (result !== 0) return result;
			}
			return 0;
		});
		return { data: resultData };
	}
};

//#endregion
//#region node_modules/echarts/lib/component/transform/install.js
function install$52(registers) {
	registers.registerTransform(filterTransform);
	registers.registerTransform(sortTransform);
}

//#endregion
//#region node_modules/echarts/lib/component/dataset/install.js
var DatasetModel = function(_super) {
	__extends(DatasetModel$1, _super);
	function DatasetModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "dataset";
		return _this;
	}
	DatasetModel$1.prototype.init = function(option, parentModel, ecModel) {
		_super.prototype.init.call(this, option, parentModel, ecModel);
		this._sourceManager = new SourceManager(this);
		disableTransformOptionMerge(this);
	};
	DatasetModel$1.prototype.mergeOption = function(newOption, ecModel) {
		_super.prototype.mergeOption.call(this, newOption, ecModel);
		disableTransformOptionMerge(this);
	};
	DatasetModel$1.prototype.optionUpdated = function() {
		this._sourceManager.dirty();
	};
	DatasetModel$1.prototype.getSourceManager = function() {
		return this._sourceManager;
	};
	DatasetModel$1.type = "dataset";
	DatasetModel$1.defaultOption = { seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN };
	return DatasetModel$1;
}(Component_default);
var DatasetView = function(_super) {
	__extends(DatasetView$1, _super);
	function DatasetView$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "dataset";
		return _this;
	}
	DatasetView$1.type = "dataset";
	return DatasetView$1;
}(Component_default$1);
function install$51(registers) {
	registers.registerComponentModel(DatasetModel);
	registers.registerComponentView(DatasetView);
}

//#endregion
//#region node_modules/zrender/lib/tool/convertPath.js
var CMD = PathProxy_default.CMD;
function aroundEqual(a, b) {
	return Math.abs(a - b) < 1e-5;
}
function pathToBezierCurves(path) {
	var data = path.data;
	var len$1 = path.len();
	var bezierArrayGroups = [];
	var currentSubpath;
	var xi = 0;
	var yi = 0;
	var x0 = 0;
	var y0 = 0;
	function createNewSubpath(x, y) {
		if (currentSubpath && currentSubpath.length > 2) bezierArrayGroups.push(currentSubpath);
		currentSubpath = [x, y];
	}
	function addLine(x0$1, y0$1, x1$1, y1$1) {
		if (!(aroundEqual(x0$1, x1$1) && aroundEqual(y0$1, y1$1))) currentSubpath.push(x0$1, y0$1, x1$1, y1$1, x1$1, y1$1);
	}
	function addArc(startAngle$1, endAngle$1, cx$1, cy$1, rx$1, ry$1) {
		var delta = Math.abs(endAngle$1 - startAngle$1);
		var len$2 = Math.tan(delta / 4) * 4 / 3;
		var dir$1 = endAngle$1 < startAngle$1 ? -1 : 1;
		var c1 = Math.cos(startAngle$1);
		var s1 = Math.sin(startAngle$1);
		var c2 = Math.cos(endAngle$1);
		var s2 = Math.sin(endAngle$1);
		var x1$1 = c1 * rx$1 + cx$1;
		var y1$1 = s1 * ry$1 + cy$1;
		var x4 = c2 * rx$1 + cx$1;
		var y4 = s2 * ry$1 + cy$1;
		var hx = rx$1 * len$2 * dir$1;
		var hy = ry$1 * len$2 * dir$1;
		currentSubpath.push(x1$1 - hx * s1, y1$1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
	}
	var x1;
	var y1;
	var x2;
	var y2;
	for (var i$1 = 0; i$1 < len$1;) {
		var cmd = data[i$1++];
		var isFirst = i$1 === 1;
		if (isFirst) {
			xi = data[i$1];
			yi = data[i$1 + 1];
			x0 = xi;
			y0 = yi;
			if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) currentSubpath = [x0, y0];
		}
		switch (cmd) {
			case CMD.M:
				xi = x0 = data[i$1++];
				yi = y0 = data[i$1++];
				createNewSubpath(x0, y0);
				break;
			case CMD.L:
				x1 = data[i$1++];
				y1 = data[i$1++];
				addLine(xi, yi, x1, y1);
				xi = x1;
				yi = y1;
				break;
			case CMD.C:
				currentSubpath.push(data[i$1++], data[i$1++], data[i$1++], data[i$1++], xi = data[i$1++], yi = data[i$1++]);
				break;
			case CMD.Q:
				x1 = data[i$1++];
				y1 = data[i$1++];
				x2 = data[i$1++];
				y2 = data[i$1++];
				currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);
				xi = x2;
				yi = y2;
				break;
			case CMD.A:
				var cx = data[i$1++];
				var cy = data[i$1++];
				var rx = data[i$1++];
				var ry = data[i$1++];
				var startAngle = data[i$1++];
				var endAngle = data[i$1++] + startAngle;
				i$1 += 1;
				var anticlockwise = !data[i$1++];
				x1 = Math.cos(startAngle) * rx + cx;
				y1 = Math.sin(startAngle) * ry + cy;
				if (isFirst) {
					x0 = x1;
					y0 = y1;
					createNewSubpath(x0, y0);
				} else addLine(xi, yi, x1, y1);
				xi = Math.cos(endAngle) * rx + cx;
				yi = Math.sin(endAngle) * ry + cy;
				var step = (anticlockwise ? -1 : 1) * Math.PI / 2;
				for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
					var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
					addArc(angle, nextAngle, cx, cy, rx, ry);
				}
				break;
			case CMD.R:
				x0 = xi = data[i$1++];
				y0 = yi = data[i$1++];
				x1 = x0 + data[i$1++];
				y1 = y0 + data[i$1++];
				createNewSubpath(x1, y0);
				addLine(x1, y0, x1, y1);
				addLine(x1, y1, x0, y1);
				addLine(x0, y1, x0, y0);
				addLine(x0, y0, x1, y0);
				break;
			case CMD.Z:
				currentSubpath && addLine(xi, yi, x0, y0);
				xi = x0;
				yi = y0;
				break;
		}
	}
	if (currentSubpath && currentSubpath.length > 2) bezierArrayGroups.push(currentSubpath);
	return bezierArrayGroups;
}
function adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out$1, scale$3) {
	if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {
		out$1.push(x3, y3);
		return;
	}
	var PIXEL_DISTANCE = 2 / scale$3;
	var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;
	var dx = x3 - x0;
	var dy = y3 - y0;
	var d = Math.sqrt(dx * dx + dy * dy);
	dx /= d;
	dy /= d;
	var dx1 = x1 - x0;
	var dy1 = y1 - y0;
	var dx2 = x2 - x3;
	var dy2 = y2 - y3;
	var cp1LenSqr = dx1 * dx1 + dy1 * dy1;
	var cp2LenSqr = dx2 * dx2 + dy2 * dy2;
	if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {
		out$1.push(x3, y3);
		return;
	}
	var projLen1 = dx * dx1 + dy * dy1;
	var projLen2 = -dx * dx2 - dy * dy2;
	var d1Sqr = cp1LenSqr - projLen1 * projLen1;
	var d2Sqr = cp2LenSqr - projLen2 * projLen2;
	if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {
		out$1.push(x3, y3);
		return;
	}
	var tmpSegX = [];
	var tmpSegY = [];
	cubicSubdivide(x0, x1, x2, x3, .5, tmpSegX);
	cubicSubdivide(y0, y1, y2, y3, .5, tmpSegY);
	adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out$1, scale$3);
	adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out$1, scale$3);
}
function pathToPolygons(path, scale$3) {
	var bezierArrayGroups = pathToBezierCurves(path);
	var polygons = [];
	scale$3 = scale$3 || 1;
	for (var i$1 = 0; i$1 < bezierArrayGroups.length; i$1++) {
		var beziers = bezierArrayGroups[i$1];
		var polygon = [];
		var x0 = beziers[0];
		var y0 = beziers[1];
		polygon.push(x0, y0);
		for (var k$1 = 2; k$1 < beziers.length;) {
			var x1 = beziers[k$1++];
			var y1 = beziers[k$1++];
			var x2 = beziers[k$1++];
			var y2 = beziers[k$1++];
			var x3 = beziers[k$1++];
			var y3 = beziers[k$1++];
			adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale$3);
			x0 = x3;
			y0 = y3;
		}
		polygons.push(polygon);
	}
	return polygons;
}

//#endregion
//#region node_modules/zrender/lib/tool/dividePath.js
function getDividingGrids(dimSize, rowDim, count$1) {
	var rowSize = dimSize[rowDim];
	var columnSize = dimSize[1 - rowDim];
	var ratio = Math.abs(rowSize / columnSize);
	var rowCount = Math.ceil(Math.sqrt(ratio * count$1));
	var columnCount = Math.floor(count$1 / rowCount);
	if (columnCount === 0) {
		columnCount = 1;
		rowCount = count$1;
	}
	var grids = [];
	for (var i$1 = 0; i$1 < rowCount; i$1++) grids.push(columnCount);
	var remained = count$1 - rowCount * columnCount;
	if (remained > 0) for (var i$1 = 0; i$1 < remained; i$1++) grids[i$1 % rowCount] += 1;
	return grids;
}
function divideSector(sectorShape, count$1, outShapes) {
	var r0 = sectorShape.r0;
	var r = sectorShape.r;
	var startAngle = sectorShape.startAngle;
	var endAngle = sectorShape.endAngle;
	var angle = Math.abs(endAngle - startAngle);
	var arcLen = angle * r;
	var deltaR = r - r0;
	var isAngleRow = arcLen > Math.abs(deltaR);
	var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count$1);
	var rowSize = (isAngleRow ? angle : deltaR) / grids.length;
	for (var row = 0; row < grids.length; row++) {
		var columnSize = (isAngleRow ? deltaR : angle) / grids[row];
		for (var column = 0; column < grids[row]; column++) {
			var newShape = {};
			if (isAngleRow) {
				newShape.startAngle = startAngle + rowSize * row;
				newShape.endAngle = startAngle + rowSize * (row + 1);
				newShape.r0 = r0 + columnSize * column;
				newShape.r = r0 + columnSize * (column + 1);
			} else {
				newShape.startAngle = startAngle + columnSize * column;
				newShape.endAngle = startAngle + columnSize * (column + 1);
				newShape.r0 = r0 + rowSize * row;
				newShape.r = r0 + rowSize * (row + 1);
			}
			newShape.clockwise = sectorShape.clockwise;
			newShape.cx = sectorShape.cx;
			newShape.cy = sectorShape.cy;
			outShapes.push(newShape);
		}
	}
}
function divideRect(rectShape, count$1, outShapes) {
	var width = rectShape.width;
	var height = rectShape.height;
	var isHorizontalRow = width > height;
	var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count$1);
	var rowSizeDim = isHorizontalRow ? "width" : "height";
	var columnSizeDim = isHorizontalRow ? "height" : "width";
	var rowDim = isHorizontalRow ? "x" : "y";
	var columnDim = isHorizontalRow ? "y" : "x";
	var rowSize = rectShape[rowSizeDim] / grids.length;
	for (var row = 0; row < grids.length; row++) {
		var columnSize = rectShape[columnSizeDim] / grids[row];
		for (var column = 0; column < grids[row]; column++) {
			var newShape = {};
			newShape[rowDim] = row * rowSize;
			newShape[columnDim] = column * columnSize;
			newShape[rowSizeDim] = rowSize;
			newShape[columnSizeDim] = columnSize;
			newShape.x += rectShape.x;
			newShape.y += rectShape.y;
			outShapes.push(newShape);
		}
	}
}
function crossProduct2d(x1, y1, x2, y2) {
	return x1 * y2 - x2 * y1;
}
function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
	var mx = a2x - a1x;
	var my = a2y - a1y;
	var nx = b2x - b1x;
	var ny = b2y - b1y;
	var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
	if (Math.abs(nmCrossProduct) < 1e-6) return null;
	var p = crossProduct2d(a1x - b1x, a1y - b1y, nx, ny) / nmCrossProduct;
	if (p < 0 || p > 1) return null;
	return new Point_default(p * mx + a1x, p * my + a1y);
}
function projPtOnLine(pt, lineA, lineB) {
	var dir$1 = new Point_default();
	Point_default.sub(dir$1, lineB, lineA);
	dir$1.normalize();
	var dir2$1 = new Point_default();
	Point_default.sub(dir2$1, pt, lineA);
	return dir2$1.dot(dir$1);
}
function addToPoly(poly, pt) {
	var last = poly[poly.length - 1];
	if (last && last[0] === pt[0] && last[1] === pt[1]) return;
	poly.push(pt);
}
function splitPolygonByLine(points$3, lineA, lineB) {
	var len$1 = points$3.length;
	var intersections = [];
	for (var i$1 = 0; i$1 < len$1; i$1++) {
		var p0 = points$3[i$1];
		var p1 = points$3[(i$1 + 1) % len$1];
		var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);
		if (intersectionPt) intersections.push({
			projPt: projPtOnLine(intersectionPt, lineA, lineB),
			pt: intersectionPt,
			idx: i$1
		});
	}
	if (intersections.length < 2) return [{ points: points$3 }, { points: points$3 }];
	intersections.sort(function(a, b) {
		return a.projPt - b.projPt;
	});
	var splitPt0 = intersections[0];
	var splitPt1 = intersections[intersections.length - 1];
	if (splitPt1.idx < splitPt0.idx) {
		var tmp = splitPt0;
		splitPt0 = splitPt1;
		splitPt1 = tmp;
	}
	var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];
	var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];
	var newPolyA = [splitPt0Arr];
	var newPolyB = [splitPt1Arr];
	for (var i$1 = splitPt0.idx + 1; i$1 <= splitPt1.idx; i$1++) addToPoly(newPolyA, points$3[i$1].slice());
	addToPoly(newPolyA, splitPt1Arr);
	addToPoly(newPolyA, splitPt0Arr);
	for (var i$1 = splitPt1.idx + 1; i$1 <= splitPt0.idx + len$1; i$1++) addToPoly(newPolyB, points$3[i$1 % len$1].slice());
	addToPoly(newPolyB, splitPt0Arr);
	addToPoly(newPolyB, splitPt1Arr);
	return [{ points: newPolyA }, { points: newPolyB }];
}
function binaryDividePolygon(polygonShape) {
	var points$3 = polygonShape.points;
	var min$2 = [];
	var max$2 = [];
	fromPoints(points$3, min$2, max$2);
	var boundingRect = new BoundingRect_default(min$2[0], min$2[1], max$2[0] - min$2[0], max$2[1] - min$2[1]);
	var width = boundingRect.width;
	var height = boundingRect.height;
	var x = boundingRect.x;
	var y = boundingRect.y;
	var pt0$1 = new Point_default();
	var pt1$1 = new Point_default();
	if (width > height) {
		pt0$1.x = pt1$1.x = x + width / 2;
		pt0$1.y = y;
		pt1$1.y = y + height;
	} else {
		pt0$1.y = pt1$1.y = y + height / 2;
		pt0$1.x = x;
		pt1$1.x = x + width;
	}
	return splitPolygonByLine(points$3, pt0$1, pt1$1);
}
function binaryDivideRecursive(divider, shape, count$1, out$1) {
	if (count$1 === 1) out$1.push(shape);
	else {
		var mid = Math.floor(count$1 / 2);
		var sub$1 = divider(shape);
		binaryDivideRecursive(divider, sub$1[0], mid, out$1);
		binaryDivideRecursive(divider, sub$1[1], count$1 - mid, out$1);
	}
	return out$1;
}
function clone$1(path, count$1) {
	var paths = [];
	for (var i$1 = 0; i$1 < count$1; i$1++) paths.push(clonePath(path));
	return paths;
}
function copyPathProps(source, target) {
	target.setStyle(source.style);
	target.z = source.z;
	target.z2 = source.z2;
	target.zlevel = source.zlevel;
}
function polygonConvert(points$3) {
	var out$1 = [];
	for (var i$1 = 0; i$1 < points$3.length;) out$1.push([points$3[i$1++], points$3[i$1++]]);
	return out$1;
}
function split(path, count$1) {
	var outShapes = [];
	var shape = path.shape;
	var OutShapeCtor;
	switch (path.type) {
		case "rect":
			divideRect(shape, count$1, outShapes);
			OutShapeCtor = Rect_default;
			break;
		case "sector":
			divideSector(shape, count$1, outShapes);
			OutShapeCtor = Sector_default;
			break;
		case "circle":
			divideSector({
				r0: 0,
				r: shape.r,
				startAngle: 0,
				endAngle: Math.PI * 2,
				cx: shape.cx,
				cy: shape.cy
			}, count$1, outShapes);
			OutShapeCtor = Sector_default;
			break;
		default:
			var m$1 = path.getComputedTransform();
			var scale$3 = m$1 ? Math.sqrt(Math.max(m$1[0] * m$1[0] + m$1[1] * m$1[1], m$1[2] * m$1[2] + m$1[3] * m$1[3])) : 1;
			var polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale$3), function(poly) {
				return polygonConvert(poly);
			});
			var polygonCount = polygons.length;
			if (polygonCount === 0) binaryDivideRecursive(binaryDividePolygon, { points: polygons[0] }, count$1, outShapes);
			else if (polygonCount === count$1) for (var i$1 = 0; i$1 < polygonCount; i$1++) outShapes.push({ points: polygons[i$1] });
			else {
				var totalArea_1 = 0;
				var items = map(polygons, function(poly) {
					var min$2 = [];
					var max$2 = [];
					fromPoints(poly, min$2, max$2);
					var area = (max$2[1] - min$2[1]) * (max$2[0] - min$2[0]);
					totalArea_1 += area;
					return {
						poly,
						area
					};
				});
				items.sort(function(a, b) {
					return b.area - a.area;
				});
				var left = count$1;
				for (var i$1 = 0; i$1 < polygonCount; i$1++) {
					var item = items[i$1];
					if (left <= 0) break;
					var selfCount = i$1 === polygonCount - 1 ? left : Math.ceil(item.area / totalArea_1 * count$1);
					if (selfCount < 0) continue;
					binaryDivideRecursive(binaryDividePolygon, { points: item.poly }, selfCount, outShapes);
					left -= selfCount;
				}
			}
			OutShapeCtor = Polygon_default;
			break;
	}
	if (!OutShapeCtor) return clone$1(path, count$1);
	var out$1 = [];
	for (var i$1 = 0; i$1 < outShapes.length; i$1++) {
		var subPath = new OutShapeCtor();
		subPath.setShape(outShapes[i$1]);
		copyPathProps(path, subPath);
		out$1.push(subPath);
	}
	return out$1;
}

//#endregion
//#region node_modules/zrender/lib/tool/morphPath.js
function alignSubpath(subpath1, subpath2) {
	var len1 = subpath1.length;
	var len2 = subpath2.length;
	if (len1 === len2) return [subpath1, subpath2];
	var tmpSegX = [];
	var tmpSegY = [];
	var shorterPath = len1 < len2 ? subpath1 : subpath2;
	var shorterLen = Math.min(len1, len2);
	var diff = Math.abs(len2 - len1) / 6;
	var shorterBezierCount = (shorterLen - 2) / 6;
	var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;
	var newSubpath = [shorterPath[0], shorterPath[1]];
	var remained = diff;
	for (var i$1 = 2; i$1 < shorterLen;) {
		var x0 = shorterPath[i$1 - 2];
		var y0 = shorterPath[i$1 - 1];
		var x1 = shorterPath[i$1++];
		var y1 = shorterPath[i$1++];
		var x2 = shorterPath[i$1++];
		var y2 = shorterPath[i$1++];
		var x3 = shorterPath[i$1++];
		var y3 = shorterPath[i$1++];
		if (remained <= 0) {
			newSubpath.push(x1, y1, x2, y2, x3, y3);
			continue;
		}
		var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;
		for (var k$1 = 1; k$1 <= actualSubDivCount; k$1++) {
			var p = k$1 / actualSubDivCount;
			cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);
			cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);
			x0 = tmpSegX[3];
			y0 = tmpSegY[3];
			newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
			x1 = tmpSegX[5];
			y1 = tmpSegY[5];
			x2 = tmpSegX[6];
			y2 = tmpSegY[6];
		}
		remained -= actualSubDivCount - 1;
	}
	return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpathSubpath, otherSubpath) {
	var len$1 = lastSubpathSubpath.length;
	var lastX = lastSubpathSubpath[len$1 - 2];
	var lastY = lastSubpathSubpath[len$1 - 1];
	var newSubpath = [];
	for (var i$1 = 0; i$1 < otherSubpath.length;) {
		newSubpath[i$1++] = lastX;
		newSubpath[i$1++] = lastY;
	}
	return newSubpath;
}
function alignBezierCurves(array1, array2) {
	var _a$1;
	var lastSubpath1;
	var lastSubpath2;
	var newArray1 = [];
	var newArray2 = [];
	for (var i$1 = 0; i$1 < Math.max(array1.length, array2.length); i$1++) {
		var subpath1 = array1[i$1];
		var subpath2 = array2[i$1];
		var newSubpath1 = void 0;
		var newSubpath2 = void 0;
		if (!subpath1) {
			newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);
			newSubpath2 = subpath2;
		} else if (!subpath2) {
			newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);
			newSubpath1 = subpath1;
		} else {
			_a$1 = alignSubpath(subpath1, subpath2), newSubpath1 = _a$1[0], newSubpath2 = _a$1[1];
			lastSubpath1 = newSubpath1;
			lastSubpath2 = newSubpath2;
		}
		newArray1.push(newSubpath1);
		newArray2.push(newSubpath2);
	}
	return [newArray1, newArray2];
}
function centroid(array) {
	var signedArea = 0;
	var cx = 0;
	var cy = 0;
	var len$1 = array.length;
	for (var i$1 = 0, j = len$1 - 2; i$1 < len$1; j = i$1, i$1 += 2) {
		var x0 = array[j];
		var y0 = array[j + 1];
		var x1 = array[i$1];
		var y1 = array[i$1 + 1];
		var a = x0 * y1 - x1 * y0;
		signedArea += a;
		cx += (x0 + x1) * a;
		cy += (y0 + y1) * a;
	}
	if (signedArea === 0) return [array[0] || 0, array[1] || 0];
	return [
		cx / signedArea / 3,
		cy / signedArea / 3,
		signedArea
	];
}
function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
	var bezierCount = (fromSubBeziers.length - 2) / 6;
	var bestScore = Infinity;
	var bestOffset = 0;
	var len$1 = fromSubBeziers.length;
	var len2 = len$1 - 2;
	for (var offset = 0; offset < bezierCount; offset++) {
		var cursorOffset = offset * 6;
		var score = 0;
		for (var k$1 = 0; k$1 < len$1; k$1 += 2) {
			var idx = k$1 === 0 ? cursorOffset : (cursorOffset + k$1 - 2) % len2 + 2;
			var x0 = fromSubBeziers[idx] - fromCp[0];
			var y0 = fromSubBeziers[idx + 1] - fromCp[1];
			var x1 = toSubBeziers[k$1] - toCp[0];
			var y1 = toSubBeziers[k$1 + 1] - toCp[1];
			var dx = x1 - x0;
			var dy = y1 - y0;
			score += dx * dx + dy * dy;
		}
		if (score < bestScore) {
			bestScore = score;
			bestOffset = offset;
		}
	}
	return bestOffset;
}
function reverse(array) {
	var newArr = [];
	var len$1 = array.length;
	for (var i$1 = 0; i$1 < len$1; i$1 += 2) {
		newArr[i$1] = array[len$1 - i$1 - 2];
		newArr[i$1 + 1] = array[len$1 - i$1 - 1];
	}
	return newArr;
}
function findBestMorphingRotation(fromArr, toArr$1, searchAngleIteration, searchAngleRange) {
	var result = [];
	var fromNeedsReverse;
	for (var i$1 = 0; i$1 < fromArr.length; i$1++) {
		var fromSubpathBezier = fromArr[i$1];
		var toSubpathBezier = toArr$1[i$1];
		var fromCp = centroid(fromSubpathBezier);
		var toCp = centroid(toSubpathBezier);
		if (fromNeedsReverse == null) fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
		var newFromSubpathBezier = [];
		var newToSubpathBezier = [];
		var bestAngle = 0;
		var bestScore = Infinity;
		var tmpArr$1 = [];
		var len$1 = fromSubpathBezier.length;
		if (fromNeedsReverse) fromSubpathBezier = reverse(fromSubpathBezier);
		var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
		var len2 = len$1 - 2;
		for (var k$1 = 0; k$1 < len2; k$1 += 2) {
			var idx = (offset + k$1) % len2 + 2;
			newFromSubpathBezier[k$1 + 2] = fromSubpathBezier[idx] - fromCp[0];
			newFromSubpathBezier[k$1 + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
		}
		newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];
		newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];
		if (searchAngleIteration > 0) {
			var step = searchAngleRange / searchAngleIteration;
			for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
				var sa = Math.sin(angle);
				var ca = Math.cos(angle);
				var score = 0;
				for (var k$1 = 0; k$1 < fromSubpathBezier.length; k$1 += 2) {
					var x0 = newFromSubpathBezier[k$1];
					var y0 = newFromSubpathBezier[k$1 + 1];
					var x1 = toSubpathBezier[k$1] - toCp[0];
					var y1 = toSubpathBezier[k$1 + 1] - toCp[1];
					var newX1 = x1 * ca - y1 * sa;
					var newY1 = x1 * sa + y1 * ca;
					tmpArr$1[k$1] = newX1;
					tmpArr$1[k$1 + 1] = newY1;
					var dx = newX1 - x0;
					var dy = newY1 - y0;
					score += dx * dx + dy * dy;
				}
				if (score < bestScore) {
					bestScore = score;
					bestAngle = angle;
					for (var m$1 = 0; m$1 < tmpArr$1.length; m$1++) newToSubpathBezier[m$1] = tmpArr$1[m$1];
				}
			}
		} else for (var i_1 = 0; i_1 < len$1; i_1 += 2) {
			newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];
			newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];
		}
		result.push({
			from: newFromSubpathBezier,
			to: newToSubpathBezier,
			fromCp,
			toCp,
			rotation: -bestAngle
		});
	}
	return result;
}
function isCombineMorphing(path) {
	return path.__isCombineMorphing;
}
var SAVED_METHOD_PREFIX = "__mOriginal_";
function saveAndModifyMethod(obj, methodName, modifiers) {
	var savedMethodName = SAVED_METHOD_PREFIX + methodName;
	var originalMethod = obj[savedMethodName] || obj[methodName];
	if (!obj[savedMethodName]) obj[savedMethodName] = obj[methodName];
	var replace = modifiers.replace;
	var after = modifiers.after;
	var before = modifiers.before;
	obj[methodName] = function() {
		var args = arguments;
		var res;
		before && before.apply(this, args);
		if (replace) res = replace.apply(this, args);
		else res = originalMethod.apply(this, args);
		after && after.apply(this, args);
		return res;
	};
}
function restoreMethod(obj, methodName) {
	var savedMethodName = SAVED_METHOD_PREFIX + methodName;
	if (obj[savedMethodName]) {
		obj[methodName] = obj[savedMethodName];
		obj[savedMethodName] = null;
	}
}
function applyTransformOnBeziers(bezierCurves, mm) {
	for (var i$1 = 0; i$1 < bezierCurves.length; i$1++) {
		var subBeziers = bezierCurves[i$1];
		for (var k$1 = 0; k$1 < subBeziers.length;) {
			var x = subBeziers[k$1];
			var y = subBeziers[k$1 + 1];
			subBeziers[k$1++] = mm[0] * x + mm[2] * y + mm[4];
			subBeziers[k$1++] = mm[1] * x + mm[3] * y + mm[5];
		}
	}
}
function prepareMorphPath(fromPath, toPath) {
	var fromPathProxy = fromPath.getUpdatedPathProxy();
	var toPathProxy = toPath.getUpdatedPathProxy();
	var _a$1 = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a$1[0], toBezierCurves = _a$1[1];
	var fromPathTransform = fromPath.getComputedTransform();
	var toPathTransform = toPath.getComputedTransform();
	function updateIdentityTransform() {
		this.transform = null;
	}
	fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);
	toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);
	saveAndModifyMethod(toPath, "updateTransform", { replace: updateIdentityTransform });
	toPath.transform = null;
	var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);
	var tmpArr$1 = [];
	saveAndModifyMethod(toPath, "buildPath", { replace: function(path) {
		var t = toPath.__morphT;
		var onet = 1 - t;
		var newCp = [];
		for (var i$1 = 0; i$1 < morphingData.length; i$1++) {
			var item = morphingData[i$1];
			var from = item.from;
			var to = item.to;
			var angle = item.rotation * t;
			var fromCp = item.fromCp;
			var toCp = item.toCp;
			var sa = Math.sin(angle);
			var ca = Math.cos(angle);
			lerp(newCp, fromCp, toCp, t);
			for (var m$1 = 0; m$1 < from.length; m$1 += 2) {
				var x0_1 = from[m$1];
				var y0_1 = from[m$1 + 1];
				var x1 = to[m$1];
				var y1 = to[m$1 + 1];
				var x = x0_1 * onet + x1 * t;
				var y = y0_1 * onet + y1 * t;
				tmpArr$1[m$1] = x * ca - y * sa + newCp[0];
				tmpArr$1[m$1 + 1] = x * sa + y * ca + newCp[1];
			}
			var x0 = tmpArr$1[0];
			var y0 = tmpArr$1[1];
			path.moveTo(x0, y0);
			for (var m$1 = 2; m$1 < from.length;) {
				var x1 = tmpArr$1[m$1++];
				var y1 = tmpArr$1[m$1++];
				var x2 = tmpArr$1[m$1++];
				var y2 = tmpArr$1[m$1++];
				var x3 = tmpArr$1[m$1++];
				var y3 = tmpArr$1[m$1++];
				if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) path.lineTo(x3, y3);
				else path.bezierCurveTo(x1, y1, x2, y2, x3, y3);
				x0 = x3;
				y0 = y3;
			}
		}
	} });
}
function morphPath(fromPath, toPath, animationOpts) {
	if (!fromPath || !toPath) return toPath;
	var oldDone = animationOpts.done;
	var oldDuring = animationOpts.during;
	prepareMorphPath(fromPath, toPath);
	toPath.__morphT = 0;
	function restoreToPath() {
		restoreMethod(toPath, "buildPath");
		restoreMethod(toPath, "updateTransform");
		toPath.__morphT = -1;
		toPath.createPathProxy();
		toPath.dirtyShape();
	}
	toPath.animateTo({ __morphT: 1 }, defaults({
		during: function(p) {
			toPath.dirtyShape();
			oldDuring && oldDuring(p);
		},
		done: function() {
			restoreToPath();
			oldDone && oldDone();
		}
	}, animationOpts));
	return toPath;
}
function hilbert(x, y, minX, minY, maxX, maxY) {
	var bits = 16;
	x = maxX === minX ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));
	y = maxY === minY ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));
	var d = 0;
	var tmp;
	for (var s = (1 << bits) / 2; s > 0; s /= 2) {
		var rx = 0;
		var ry = 0;
		if ((x & s) > 0) rx = 1;
		if ((y & s) > 0) ry = 1;
		d += s * s * (3 * rx ^ ry);
		if (ry === 0) {
			if (rx === 1) {
				x = s - 1 - x;
				y = s - 1 - y;
			}
			tmp = x;
			x = y;
			y = tmp;
		}
	}
	return d;
}
function sortPaths(pathList) {
	var xMin = Infinity;
	var yMin = Infinity;
	var xMax = -Infinity;
	var yMax = -Infinity;
	return map(map(pathList, function(path) {
		var rect = path.getBoundingRect();
		var m$1 = path.getComputedTransform();
		var x = rect.x + rect.width / 2 + (m$1 ? m$1[4] : 0);
		var y = rect.y + rect.height / 2 + (m$1 ? m$1[5] : 0);
		xMin = Math.min(x, xMin);
		yMin = Math.min(y, yMin);
		xMax = Math.max(x, xMax);
		yMax = Math.max(y, yMax);
		return [x, y];
	}), function(cp, idx) {
		return {
			cp,
			z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),
			path: pathList[idx]
		};
	}).sort(function(a, b) {
		return a.z - b.z;
	}).map(function(item) {
		return item.path;
	});
}
function defaultDividePath(param) {
	return split(param.path, param.count);
}
function createEmptyReturn() {
	return {
		fromIndividuals: [],
		toIndividuals: [],
		count: 0
	};
}
function combineMorph(fromList, toPath, animationOpts) {
	var fromPathList = [];
	function addFromPath(fromList$1) {
		for (var i$2 = 0; i$2 < fromList$1.length; i$2++) {
			var from$1 = fromList$1[i$2];
			if (isCombineMorphing(from$1)) addFromPath(from$1.childrenRef());
			else if (from$1 instanceof Path_default) fromPathList.push(from$1);
		}
	}
	addFromPath(fromList);
	var separateCount = fromPathList.length;
	if (!separateCount) return createEmptyReturn();
	var toSubPathList = (animationOpts.dividePath || defaultDividePath)({
		path: toPath,
		count: separateCount
	});
	if (toSubPathList.length !== separateCount) {
		console.error("Invalid morphing: unmatched splitted path");
		return createEmptyReturn();
	}
	fromPathList = sortPaths(fromPathList);
	toSubPathList = sortPaths(toSubPathList);
	var oldDone = animationOpts.done;
	var oldDuring = animationOpts.during;
	var individualDelay = animationOpts.individualDelay;
	var identityTransform = new Transformable_default();
	for (var i$1 = 0; i$1 < separateCount; i$1++) {
		var from = fromPathList[i$1];
		var to = toSubPathList[i$1];
		to.parent = toPath;
		to.copyTransform(identityTransform);
		if (!individualDelay) prepareMorphPath(from, to);
	}
	toPath.__isCombineMorphing = true;
	toPath.childrenRef = function() {
		return toSubPathList;
	};
	function addToSubPathListToZr(zr) {
		for (var i$2 = 0; i$2 < toSubPathList.length; i$2++) toSubPathList[i$2].addSelfToZr(zr);
	}
	saveAndModifyMethod(toPath, "addSelfToZr", { after: function(zr) {
		addToSubPathListToZr(zr);
	} });
	saveAndModifyMethod(toPath, "removeSelfFromZr", { after: function(zr) {
		for (var i$2 = 0; i$2 < toSubPathList.length; i$2++) toSubPathList[i$2].removeSelfFromZr(zr);
	} });
	function restoreToPath() {
		toPath.__isCombineMorphing = false;
		toPath.__morphT = -1;
		toPath.childrenRef = null;
		restoreMethod(toPath, "addSelfToZr");
		restoreMethod(toPath, "removeSelfFromZr");
	}
	var toLen = toSubPathList.length;
	if (individualDelay) {
		var animating_1 = toLen;
		var eachDone = function() {
			animating_1--;
			if (animating_1 === 0) {
				restoreToPath();
				oldDone && oldDone();
			}
		};
		for (var i$1 = 0; i$1 < toLen; i$1++) {
			var indivdualAnimationOpts = individualDelay ? defaults({
				delay: (animationOpts.delay || 0) + individualDelay(i$1, toLen, fromPathList[i$1], toSubPathList[i$1]),
				done: eachDone
			}, animationOpts) : animationOpts;
			morphPath(fromPathList[i$1], toSubPathList[i$1], indivdualAnimationOpts);
		}
	} else {
		toPath.__morphT = 0;
		toPath.animateTo({ __morphT: 1 }, defaults({
			during: function(p) {
				for (var i$2 = 0; i$2 < toLen; i$2++) {
					var child = toSubPathList[i$2];
					child.__morphT = toPath.__morphT;
					child.dirtyShape();
				}
				oldDuring && oldDuring(p);
			},
			done: function() {
				restoreToPath();
				for (var i$2 = 0; i$2 < fromList.length; i$2++) restoreMethod(fromList[i$2], "updateTransform");
				oldDone && oldDone();
			}
		}, animationOpts));
	}
	if (toPath.__zr) addToSubPathListToZr(toPath.__zr);
	return {
		fromIndividuals: fromPathList,
		toIndividuals: toSubPathList,
		count: toLen
	};
}
function separateMorph(fromPath, toPathList, animationOpts) {
	var toLen = toPathList.length;
	var fromPathList = [];
	var dividePath = animationOpts.dividePath || defaultDividePath;
	function addFromPath(fromList) {
		for (var i$2 = 0; i$2 < fromList.length; i$2++) {
			var from = fromList[i$2];
			if (isCombineMorphing(from)) addFromPath(from.childrenRef());
			else if (from instanceof Path_default) fromPathList.push(from);
		}
	}
	if (isCombineMorphing(fromPath)) {
		addFromPath(fromPath.childrenRef());
		var fromLen = fromPathList.length;
		if (fromLen < toLen) {
			var k$1 = 0;
			for (var i$1 = fromLen; i$1 < toLen; i$1++) fromPathList.push(clonePath(fromPathList[k$1++ % fromLen]));
		}
		fromPathList.length = toLen;
	} else {
		fromPathList = dividePath({
			path: fromPath,
			count: toLen
		});
		var fromPathTransform = fromPath.getComputedTransform();
		for (var i$1 = 0; i$1 < fromPathList.length; i$1++) fromPathList[i$1].setLocalTransform(fromPathTransform);
		if (fromPathList.length !== toLen) {
			console.error("Invalid morphing: unmatched splitted path");
			return createEmptyReturn();
		}
	}
	fromPathList = sortPaths(fromPathList);
	toPathList = sortPaths(toPathList);
	var individualDelay = animationOpts.individualDelay;
	for (var i$1 = 0; i$1 < toLen; i$1++) {
		var indivdualAnimationOpts = individualDelay ? defaults({ delay: (animationOpts.delay || 0) + individualDelay(i$1, toLen, fromPathList[i$1], toPathList[i$1]) }, animationOpts) : animationOpts;
		morphPath(fromPathList[i$1], toPathList[i$1], indivdualAnimationOpts);
	}
	return {
		fromIndividuals: fromPathList,
		toIndividuals: toPathList,
		count: toPathList.length
	};
}

//#endregion
//#region node_modules/echarts/lib/animation/morphTransitionHelper.js
function isMultiple(elements) {
	return isArray(elements[0]);
}
function prepareMorphBatches(one, many) {
	var batches = [];
	var batchCount = one.length;
	for (var i$1 = 0; i$1 < batchCount; i$1++) batches.push({
		one: one[i$1],
		many: []
	});
	for (var i$1 = 0; i$1 < many.length; i$1++) {
		var len$1 = many[i$1].length;
		var k$1 = void 0;
		for (k$1 = 0; k$1 < len$1; k$1++) batches[k$1 % batchCount].many.push(many[i$1][k$1]);
	}
	var off = 0;
	for (var i$1 = batchCount - 1; i$1 >= 0; i$1--) if (!batches[i$1].many.length) {
		var moveFrom = batches[off].many;
		if (moveFrom.length <= 1) if (off) off = 0;
		else return batches;
		var len$1 = moveFrom.length;
		var mid = Math.ceil(len$1 / 2);
		batches[i$1].many = moveFrom.slice(mid, len$1);
		batches[off].many = moveFrom.slice(0, mid);
		off++;
	}
	return batches;
}
var pathDividers = {
	clone: function(params) {
		var ret = [];
		var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);
		for (var i$1 = 0; i$1 < params.count; i$1++) {
			var cloned = clonePath(params.path);
			cloned.setStyle("opacity", approxOpacity);
			ret.push(cloned);
		}
		return ret;
	},
	split: null
};
function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {
	if (!from.length || !to.length) return;
	var updateAnimationCfg = getAnimationConfig("update", seriesModel, dataIndex);
	if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) return;
	var animationDelay = seriesModel.getModel("universalTransition").get("delay");
	var animationCfg = Object.assign({ setToFinal: true }, updateAnimationCfg);
	var many;
	var one;
	if (isMultiple(from)) {
		many = from;
		one = to;
	}
	if (isMultiple(to)) {
		many = to;
		one = from;
	}
	function morphOneBatch(batch, fromIsMany$1, animateIndex$1, animateCount$1, forceManyOne) {
		var batchMany = batch.many;
		var batchOne = batch.one;
		if (batchMany.length === 1 && !forceManyOne) {
			var batchFrom = fromIsMany$1 ? batchMany[0] : batchOne;
			var batchTo = fromIsMany$1 ? batchOne : batchMany[0];
			if (isCombineMorphing(batchFrom)) morphOneBatch({
				many: [batchFrom],
				one: batchTo
			}, true, animateIndex$1, animateCount$1, true);
			else {
				var individualAnimationCfg = animationDelay ? defaults({ delay: animationDelay(animateIndex$1, animateCount$1) }, animationCfg) : animationCfg;
				morphPath(batchFrom, batchTo, individualAnimationCfg);
				animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);
			}
		} else {
			var separateAnimationCfg = defaults({
				dividePath: pathDividers[divideShape],
				individualDelay: animationDelay && function(idx, count$2, fromPath, toPath) {
					return animationDelay(idx + animateIndex$1, animateCount$1);
				}
			}, animationCfg);
			var _a$1 = fromIsMany$1 ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg), fromIndividuals = _a$1.fromIndividuals, toIndividuals = _a$1.toIndividuals;
			var count$1 = fromIndividuals.length;
			for (var k$1 = 0; k$1 < count$1; k$1++) {
				var individualAnimationCfg = animationDelay ? defaults({ delay: animationDelay(k$1, count$1) }, animationCfg) : animationCfg;
				animateOtherProps(fromIndividuals[k$1], toIndividuals[k$1], fromIsMany$1 ? batchMany[k$1] : batch.one, fromIsMany$1 ? batch.one : batchMany[k$1], individualAnimationCfg);
			}
		}
	}
	var fromIsMany = many ? many === from : from.length > to.length;
	var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);
	var animateCount = 0;
	for (var i$1 = 0; i$1 < morphBatches.length; i$1++) animateCount += morphBatches[i$1].many.length;
	var animateIndex = 0;
	for (var i$1 = 0; i$1 < morphBatches.length; i$1++) {
		morphOneBatch(morphBatches[i$1], fromIsMany, animateIndex, animateCount);
		animateIndex += morphBatches[i$1].many.length;
	}
}
function getPathList(elements) {
	if (!elements) return [];
	if (isArray(elements)) {
		var pathList_1 = [];
		for (var i$1 = 0; i$1 < elements.length; i$1++) pathList_1.push(getPathList(elements[i$1]));
		return pathList_1;
	}
	var pathList = [];
	elements.traverse(function(el) {
		if (el instanceof Path_default && !el.disableMorphing && !el.invisible && !el.ignore) pathList.push(el);
	});
	return pathList;
}

//#endregion
//#region node_modules/echarts/lib/animation/universalTransition.js
var DATA_COUNT_THRESHOLD = 1e4;
var TRANSITION_NONE = 0;
var TRANSITION_P2C = 1;
var TRANSITION_C2P = 2;
var getUniversalTransitionGlobalStore = makeInner();
function getDimension(data, visualDimension) {
	var dimensions = data.dimensions;
	for (var i$1 = 0; i$1 < dimensions.length; i$1++) {
		var dimInfo = data.getDimensionInfo(dimensions[i$1]);
		if (dimInfo && dimInfo.otherDims[visualDimension] === 0) return dimensions[i$1];
	}
}
function getValueByDimension(data, dataIndex, dimension) {
	var dimInfo = data.getDimensionInfo(dimension);
	var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;
	if (dimInfo) {
		var value = data.get(dimInfo.name, dataIndex);
		if (dimOrdinalMeta) return dimOrdinalMeta.categories[value] || value + "";
		return value + "";
	}
}
function getGroupId(data, dataIndex, dataGroupId, isChild) {
	var groupIdDim = getDimension(data, isChild ? "itemChildGroupId" : "itemGroupId");
	if (groupIdDim) return getValueByDimension(data, dataIndex, groupIdDim);
	var rawDataItem = data.getRawDataItem(dataIndex);
	var property = isChild ? "childGroupId" : "groupId";
	if (rawDataItem && rawDataItem[property]) return rawDataItem[property] + "";
	if (isChild) return;
	return dataGroupId || data.getId(dataIndex);
}
function flattenDataDiffItems(list) {
	var items = [];
	each(list, function(seriesInfo) {
		var data = seriesInfo.data;
		var dataGroupId = seriesInfo.dataGroupId;
		if (data.count() > DATA_COUNT_THRESHOLD) {
			warn("Universal transition is disabled on large data > 10k.");
			return;
		}
		var indices = data.getIndices();
		for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) items.push({
			data,
			groupId: getGroupId(data, dataIndex, dataGroupId, false),
			childGroupId: getGroupId(data, dataIndex, dataGroupId, true),
			divide: seriesInfo.divide,
			dataIndex
		});
	});
	return items;
}
function fadeInElement(newEl$1, newSeries, newIndex) {
	newEl$1.traverse(function(el) {
		if (el instanceof Path_default) initProps(el, { style: { opacity: 0 } }, newSeries, {
			dataIndex: newIndex,
			isFrom: true
		});
	});
}
function removeEl(el) {
	if (el.parent) {
		var computedTransform = el.getComputedTransform();
		el.setLocalTransform(computedTransform);
		el.parent.remove(el);
	}
}
function stopAnimation(el) {
	el.stopAnimation();
	if (el.isGroup) el.traverse(function(child) {
		child.stopAnimation();
	});
}
function animateElementStyles(el, dataIndex, seriesModel) {
	var animationConfig = getAnimationConfig("update", seriesModel, dataIndex);
	animationConfig && el.traverse(function(child) {
		if (child instanceof Displayable_default) {
			var oldStyle = getOldStyle(child);
			if (oldStyle) child.animateFrom({ style: oldStyle }, animationConfig);
		}
	});
}
function isAllIdSame(oldDiffItems, newDiffItems) {
	var len$1 = oldDiffItems.length;
	if (len$1 !== newDiffItems.length) return false;
	for (var i$1 = 0; i$1 < len$1; i$1++) {
		var oldItem = oldDiffItems[i$1];
		var newItem = newDiffItems[i$1];
		if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) return false;
	}
	return true;
}
function transitionBetween(oldList, newList, api) {
	var oldDiffItems = flattenDataDiffItems(oldList);
	var newDiffItems = flattenDataDiffItems(newList);
	function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {
		if (rawFrom || from) to.animateFrom({ style: rawFrom && rawFrom !== from ? extend(extend({}, rawFrom.style), from.style) : from.style }, animationCfg);
	}
	var hasMorphAnimation = false;
	/**
	* With groupId and childGroupId, we can build parent-child relationships between dataItems.
	* However, we should mind the parent-child "direction" between old and new options.
	*
	* For example, suppose we have two dataItems from two series.data:
	*
	* dataA: [                          dataB: [
	*   {                                 {
	*     value: 5,                         value: 3,
	*     groupId: 'creatures',             groupId: 'animals',
	*     childGroupId: 'animals'           childGroupId: 'dogs'
	*   },                                },
	*   ...                               ...
	* ]                                 ]
	*
	* where dataA is belong to optionA and dataB is belong to optionB.
	*
	* When we `setOption(optionB)` from optionA, we choose childGroupId of dataItemA and groupId of
	* dataItemB as keys so the two keys are matched (both are 'animals'), then universalTransition
	* will work. This derection is "parent -> child".
	*
	* If we `setOption(optionA)` from optionB, we also choose groupId of dataItemB and childGroupId
	* of dataItemA as keys and universalTransition will work. This derection is "child -> parent".
	*
	* If there is no childGroupId specified, which means no multiLevelDrillDown/Up is needed and no
	* parent-child relationship exists. This direction is "none".
	*
	* So we need to know whether to use groupId or childGroupId as the key when we call the keyGetter
	* functions. Thus, we need to decide the direction first.
	*
	* The rule is:
	*
	* if (all childGroupIds in oldDiffItems and all groupIds in newDiffItems have common value) {
	*   direction = 'parent -> child';
	* } else if (all groupIds in oldDiffItems and all childGroupIds in newDiffItems have common value) {
	*   direction = 'child -> parent';
	* } else {
	*   direction = 'none';
	* }
	*/
	var direction = TRANSITION_NONE;
	var oldGroupIds = createHashMap();
	var oldChildGroupIds = createHashMap();
	oldDiffItems.forEach(function(item) {
		item.groupId && oldGroupIds.set(item.groupId, true);
		item.childGroupId && oldChildGroupIds.set(item.childGroupId, true);
	});
	for (var i$1 = 0; i$1 < newDiffItems.length; i$1++) {
		var newGroupId = newDiffItems[i$1].groupId;
		if (oldChildGroupIds.get(newGroupId)) {
			direction = TRANSITION_P2C;
			break;
		}
		var newChildGroupId = newDiffItems[i$1].childGroupId;
		if (newChildGroupId && oldGroupIds.get(newChildGroupId)) {
			direction = TRANSITION_C2P;
			break;
		}
	}
	function createKeyGetter(isOld, onlyGetId) {
		return function(diffItem) {
			var data = diffItem.data;
			var dataIndex = diffItem.dataIndex;
			if (onlyGetId) return data.getId(dataIndex);
			if (isOld) return direction === TRANSITION_P2C ? diffItem.childGroupId : diffItem.groupId;
			else return direction === TRANSITION_C2P ? diffItem.childGroupId : diffItem.groupId;
		};
	}
	var useId = isAllIdSame(oldDiffItems, newDiffItems);
	var isElementStillInChart = {};
	if (!useId) for (var i$1 = 0; i$1 < newDiffItems.length; i$1++) {
		var newItem = newDiffItems[i$1];
		var el = newItem.data.getItemGraphicEl(newItem.dataIndex);
		if (el) isElementStillInChart[el.id] = true;
	}
	function updateOneToOne(newIndex, oldIndex) {
		var oldItem = oldDiffItems[oldIndex];
		var newItem$1 = newDiffItems[newIndex];
		var newSeries = newItem$1.data.hostModel;
		var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
		var newEl$1 = newItem$1.data.getItemGraphicEl(newItem$1.dataIndex);
		if (oldEl === newEl$1) {
			newEl$1 && animateElementStyles(newEl$1, newItem$1.dataIndex, newSeries);
			return;
		}
		if (oldEl && isElementStillInChart[oldEl.id]) return;
		if (newEl$1) {
			stopAnimation(newEl$1);
			if (oldEl) {
				stopAnimation(oldEl);
				removeEl(oldEl);
				hasMorphAnimation = true;
				applyMorphAnimation(getPathList(oldEl), getPathList(newEl$1), newItem$1.divide, newSeries, newIndex, updateMorphingPathProps);
			} else fadeInElement(newEl$1, newSeries, newIndex);
		}
	}
	new DataDiffer_default(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, "multiple").update(updateOneToOne).updateManyToOne(function(newIndex, oldIndices) {
		var newItem$1 = newDiffItems[newIndex];
		var newData = newItem$1.data;
		var newSeries = newData.hostModel;
		var newEl$1 = newData.getItemGraphicEl(newItem$1.dataIndex);
		var oldElsList = filter(map(oldIndices, function(idx) {
			return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);
		}), function(oldEl) {
			return oldEl && oldEl !== newEl$1 && !isElementStillInChart[oldEl.id];
		});
		if (newEl$1) {
			stopAnimation(newEl$1);
			if (oldElsList.length) {
				each(oldElsList, function(oldEl) {
					stopAnimation(oldEl);
					removeEl(oldEl);
				});
				hasMorphAnimation = true;
				applyMorphAnimation(getPathList(oldElsList), getPathList(newEl$1), newItem$1.divide, newSeries, newIndex, updateMorphingPathProps);
			} else fadeInElement(newEl$1, newSeries, newItem$1.dataIndex);
		}
	}).updateOneToMany(function(newIndices, oldIndex) {
		var oldItem = oldDiffItems[oldIndex];
		var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
		if (oldEl && isElementStillInChart[oldEl.id]) return;
		var newElsList = filter(map(newIndices, function(idx) {
			return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);
		}), function(el$1) {
			return el$1 && el$1 !== oldEl;
		});
		var newSeris = newDiffItems[newIndices[0]].data.hostModel;
		if (newElsList.length) {
			each(newElsList, function(newEl$1) {
				return stopAnimation(newEl$1);
			});
			if (oldEl) {
				stopAnimation(oldEl);
				removeEl(oldEl);
				hasMorphAnimation = true;
				applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, newSeris, newIndices[0], updateMorphingPathProps);
			} else each(newElsList, function(newEl$1) {
				return fadeInElement(newEl$1, newSeris, newIndices[0]);
			});
		}
	}).updateManyToMany(function(newIndices, oldIndices) {
		new DataDiffer_default(oldIndices, newIndices, function(rawIdx) {
			return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);
		}, function(rawIdx) {
			return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);
		}).update(function(newIndex, oldIndex) {
			updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);
		}).execute();
	}).execute();
	if (hasMorphAnimation) each(newList, function(_a$1) {
		var seriesModel = _a$1.data.hostModel;
		var view = seriesModel && api.getViewOfSeriesModel(seriesModel);
		var animationCfg = getAnimationConfig("update", seriesModel, 0);
		if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) view.group.traverse(function(el$1) {
			if (el$1 instanceof Path_default && !el$1.animators.length) el$1.animateFrom({ style: { opacity: 0 } }, animationCfg);
		});
	});
}
function getSeriesTransitionKey(series) {
	var seriesKey = series.getModel("universalTransition").get("seriesKey");
	if (!seriesKey) return series.id;
	return seriesKey;
}
function convertArraySeriesKeyToString(seriesKey) {
	if (isArray(seriesKey)) return seriesKey.sort().join(",");
	return seriesKey;
}
function getDivideShapeFromData(data) {
	if (data.hostModel) return data.hostModel.getModel("universalTransition").get("divideShape");
}
function findTransitionSeriesBatches(globalStore, params) {
	var updateBatches = createHashMap();
	var oldDataMap = createHashMap();
	var oldDataMapForSplit = createHashMap();
	each(globalStore.oldSeries, function(series, idx) {
		var oldDataGroupId = globalStore.oldDataGroupIds[idx];
		var oldData = globalStore.oldData[idx];
		var transitionKey = getSeriesTransitionKey(series);
		var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
		oldDataMap.set(transitionKeyStr, {
			dataGroupId: oldDataGroupId,
			data: oldData
		});
		if (isArray(transitionKey)) each(transitionKey, function(key$1) {
			oldDataMapForSplit.set(key$1, {
				key: transitionKeyStr,
				dataGroupId: oldDataGroupId,
				data: oldData
			});
		});
	});
	function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {
		if (updateBatches.get(transitionKeyStr)) warn("Duplicated seriesKey in universalTransition " + transitionKeyStr);
	}
	each(params.updatedSeries, function(series) {
		if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {
			var newDataGroupId = series.get("dataGroupId");
			var newData = series.getData();
			var transitionKey = getSeriesTransitionKey(series);
			var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
			var oldData = oldDataMap.get(transitionKeyStr);
			if (oldData) {
				checkTransitionSeriesKeyDuplicated(transitionKeyStr);
				updateBatches.set(transitionKeyStr, {
					oldSeries: [{
						dataGroupId: oldData.dataGroupId,
						divide: getDivideShapeFromData(oldData.data),
						data: oldData.data
					}],
					newSeries: [{
						dataGroupId: newDataGroupId,
						divide: getDivideShapeFromData(newData),
						data: newData
					}]
				});
			} else if (isArray(transitionKey)) {
				checkTransitionSeriesKeyDuplicated(transitionKeyStr);
				var oldSeries_1 = [];
				each(transitionKey, function(key$1) {
					var oldData$1 = oldDataMap.get(key$1);
					if (oldData$1.data) oldSeries_1.push({
						dataGroupId: oldData$1.dataGroupId,
						divide: getDivideShapeFromData(oldData$1.data),
						data: oldData$1.data
					});
				});
				if (oldSeries_1.length) updateBatches.set(transitionKeyStr, {
					oldSeries: oldSeries_1,
					newSeries: [{
						dataGroupId: newDataGroupId,
						data: newData,
						divide: getDivideShapeFromData(newData)
					}]
				});
			} else {
				var oldData_1 = oldDataMapForSplit.get(transitionKey);
				if (oldData_1) {
					var batch = updateBatches.get(oldData_1.key);
					if (!batch) {
						batch = {
							oldSeries: [{
								dataGroupId: oldData_1.dataGroupId,
								data: oldData_1.data,
								divide: getDivideShapeFromData(oldData_1.data)
							}],
							newSeries: []
						};
						updateBatches.set(oldData_1.key, batch);
					}
					batch.newSeries.push({
						dataGroupId: newDataGroupId,
						data: newData,
						divide: getDivideShapeFromData(newData)
					});
				}
			}
		}
	});
	return updateBatches;
}
function querySeries(series, finder) {
	for (var i$1 = 0; i$1 < series.length; i$1++) if (finder.seriesIndex != null && finder.seriesIndex === series[i$1].seriesIndex || finder.seriesId != null && finder.seriesId === series[i$1].id) return i$1;
}
function transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {
	var from = [];
	var to = [];
	each(normalizeToArray(transitionOpt.from), function(finder) {
		var idx = querySeries(globalStore.oldSeries, finder);
		if (idx >= 0) from.push({
			dataGroupId: globalStore.oldDataGroupIds[idx],
			data: globalStore.oldData[idx],
			divide: getDivideShapeFromData(globalStore.oldData[idx]),
			groupIdDim: finder.dimension
		});
	});
	each(normalizeToArray(transitionOpt.to), function(finder) {
		var idx = querySeries(params.updatedSeries, finder);
		if (idx >= 0) {
			var data = params.updatedSeries[idx].getData();
			to.push({
				dataGroupId: globalStore.oldDataGroupIds[idx],
				data,
				divide: getDivideShapeFromData(data),
				groupIdDim: finder.dimension
			});
		}
	});
	if (from.length > 0 && to.length > 0) transitionBetween(from, to, api);
}
function installUniversalTransition(registers) {
	registers.registerUpdateLifecycle("series:beforeupdate", function(ecMOdel, api, params) {
		each(normalizeToArray(params.seriesTransition), function(transOpt) {
			each(normalizeToArray(transOpt.to), function(finder) {
				var series = params.updatedSeries;
				for (var i$1 = 0; i$1 < series.length; i$1++) if (finder.seriesIndex != null && finder.seriesIndex === series[i$1].seriesIndex || finder.seriesId != null && finder.seriesId === series[i$1].id) series[i$1][SERIES_UNIVERSAL_TRANSITION_PROP] = true;
			});
		});
	});
	registers.registerUpdateLifecycle("series:transition", function(ecModel, api, params) {
		var globalStore = getUniversalTransitionGlobalStore(api);
		if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {
			var transitionOpt = params.seriesTransition;
			if (transitionOpt) each(normalizeToArray(transitionOpt), function(opt) {
				transitionSeriesFromOpt(opt, globalStore, params, api);
			});
			else {
				var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);
				each(updateBatches_1.keys(), function(key$1) {
					var batch = updateBatches_1.get(key$1);
					transitionBetween(batch.oldSeries, batch.newSeries, api);
				});
			}
			each(params.updatedSeries, function(series) {
				if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;
			});
		}
		var allSeries = ecModel.getSeries();
		var savedSeries = globalStore.oldSeries = [];
		var savedDataGroupIds = globalStore.oldDataGroupIds = [];
		var savedData = globalStore.oldData = [];
		for (var i$1 = 0; i$1 < allSeries.length; i$1++) {
			var data = allSeries[i$1].getData();
			if (data.count() < DATA_COUNT_THRESHOLD) {
				savedSeries.push(allSeries[i$1]);
				savedDataGroupIds.push(allSeries[i$1].get("dataGroupId"));
				savedData.push(data);
			}
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/scale/breakImpl.js
/**
* @caution
*  Must not export anything except `installScaleBreakHelper`
*/
var ScaleBreakContextImpl = function() {
	function ScaleBreakContextImpl$1() {
		this.breaks = [];
		this._elapsedExtent = [Infinity, -Infinity];
	}
	ScaleBreakContextImpl$1.prototype.setBreaks = function(parsed) {
		this.breaks = parsed.breaks;
	};
	/**
	* [CAVEAT]: Must be called immediately each time scale extent and breaks are updated!
	*/
	ScaleBreakContextImpl$1.prototype.update = function(scaleExtent) {
		updateAxisBreakGapReal(this, scaleExtent);
		var elapsedExtent = this._elapsedExtent;
		elapsedExtent[0] = this.elapse(scaleExtent[0]);
		elapsedExtent[1] = this.elapse(scaleExtent[1]);
	};
	ScaleBreakContextImpl$1.prototype.hasBreaks = function() {
		return !!this.breaks.length;
	};
	/**
	* When iteratively generating ticks by nice interval, currently the `interval`, which is
	* calculated by break-elapsed extent span, is probably very small comparing to the original
	* extent, leading to a large number of iteration and tick generation, even over `safeLimit`.
	* Thus stepping over breaks is necessary in that loop.
	*
	* "Nice" should be ensured on ticks when step over the breaks. Thus this method returns
	* a integer multiple of the "nice tick interval".
	*
	* This method does little work; it is just for unifying and restricting the behavior.
	*/
	ScaleBreakContextImpl$1.prototype.calcNiceTickMultiple = function(tickVal, estimateNiceMultiple) {
		for (var idx = 0; idx < this.breaks.length; idx++) {
			var brk = this.breaks[idx];
			if (brk.vmin < tickVal && tickVal < brk.vmax) {
				var multiple = estimateNiceMultiple(tickVal, brk.vmax);
				assert(multiple >= 0 && Math.round(multiple) === multiple);
				return multiple;
			}
		}
		return 0;
	};
	ScaleBreakContextImpl$1.prototype.getExtentSpan = function() {
		return this._elapsedExtent[1] - this._elapsedExtent[0];
	};
	ScaleBreakContextImpl$1.prototype.normalize = function(val) {
		var elapsedSpan = this._elapsedExtent[1] - this._elapsedExtent[0];
		if (elapsedSpan === 0) return .5;
		return (this.elapse(val) - this._elapsedExtent[0]) / elapsedSpan;
	};
	ScaleBreakContextImpl$1.prototype.scale = function(val) {
		return this.unelapse(val * (this._elapsedExtent[1] - this._elapsedExtent[0]) + this._elapsedExtent[0]);
	};
	/**
	* Suppose:
	*    AXIS_BREAK_LAST_BREAK_END_BASE: 0
	*    AXIS_BREAK_ELAPSED_BASE: 0
	*    breaks: [
	*        {start: -400, end: -300, gap: 27},
	*        {start: -100, end: 100, gap: 10},
	*        {start: 200, end: 400, gap: 300},
	*    ]
	* The mapping will be:
	*        |        |
	*    400 +   ->   +  237
	*     |  |        |   |  (gap: 300)
	*    200 +   ->   + -63
	*        |        |
	*    100 +   ->   + -163
	*     |  |        |   |  (gap: 10)
	*   -100 +   ->   + -173
	*        |        |
	*   -300 +   ->   + -373
	*     |  |        |   |  (gap: 27)
	*   -400 +   ->   + -400
	*        |        |
	*   origianl     elapsed
	*
	* Note:
	*   The mapping has nothing to do with "scale extent".
	*/
	ScaleBreakContextImpl$1.prototype.elapse = function(val) {
		var elapsedVal = AXIS_BREAK_ELAPSED_BASE;
		var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;
		var stillOver = true;
		for (var i$1 = 0; i$1 < this.breaks.length; i$1++) {
			var brk = this.breaks[i$1];
			if (val <= brk.vmax) {
				if (val > brk.vmin) elapsedVal += brk.vmin - lastBreakEnd + (val - brk.vmin) / (brk.vmax - brk.vmin) * brk.gapReal;
				else elapsedVal += val - lastBreakEnd;
				lastBreakEnd = brk.vmax;
				stillOver = false;
				break;
			}
			elapsedVal += brk.vmin - lastBreakEnd + brk.gapReal;
			lastBreakEnd = brk.vmax;
		}
		if (stillOver) elapsedVal += val - lastBreakEnd;
		return elapsedVal;
	};
	ScaleBreakContextImpl$1.prototype.unelapse = function(elapsedVal) {
		var lastElapsedEnd = AXIS_BREAK_ELAPSED_BASE;
		var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;
		var stillOver = true;
		var unelapsedVal = 0;
		for (var i$1 = 0; i$1 < this.breaks.length; i$1++) {
			var brk = this.breaks[i$1];
			var elapsedStart = lastElapsedEnd + brk.vmin - lastBreakEnd;
			var elapsedEnd = elapsedStart + brk.gapReal;
			if (elapsedVal <= elapsedEnd) {
				if (elapsedVal > elapsedStart) unelapsedVal = brk.vmin + (elapsedVal - elapsedStart) / (elapsedEnd - elapsedStart) * (brk.vmax - brk.vmin);
				else unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;
				lastBreakEnd = brk.vmax;
				stillOver = false;
				break;
			}
			lastElapsedEnd = elapsedEnd;
			lastBreakEnd = brk.vmax;
		}
		if (stillOver) unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;
		return unelapsedVal;
	};
	return ScaleBreakContextImpl$1;
}();
function createScaleBreakContext() {
	return new ScaleBreakContextImpl();
}
var AXIS_BREAK_ELAPSED_BASE = 0;
var AXIS_BREAK_LAST_BREAK_END_BASE = 0;
/**
* `gapReal` in brkCtx.breaks will be calculated.
*/
function updateAxisBreakGapReal(brkCtx, scaleExtent) {
	var gapPrctSum = 0;
	var fullyInExtBrksSum = {
		tpAbs: {
			span: 0,
			val: 0
		},
		tpPrct: {
			span: 0,
			val: 0
		}
	};
	var init$3 = function() {
		return {
			has: false,
			span: NaN,
			inExtFrac: NaN,
			val: NaN
		};
	};
	var semiInExtBrk = {
		S: {
			tpAbs: init$3(),
			tpPrct: init$3()
		},
		E: {
			tpAbs: init$3(),
			tpPrct: init$3()
		}
	};
	each(brkCtx.breaks, function(brk) {
		var gapParsed = brk.gapParsed;
		if (gapParsed.type === "tpPrct") gapPrctSum += gapParsed.val;
		var clampedBrk = clampBreakByExtent(brk, scaleExtent);
		if (clampedBrk) {
			var vminClamped = clampedBrk.vmin !== brk.vmin;
			var vmaxClamped = clampedBrk.vmax !== brk.vmax;
			var clampedSpan = clampedBrk.vmax - clampedBrk.vmin;
			if (vminClamped && vmaxClamped) {} else if (vminClamped || vmaxClamped) {
				var sOrE = vminClamped ? "S" : "E";
				semiInExtBrk[sOrE][gapParsed.type].has = true;
				semiInExtBrk[sOrE][gapParsed.type].span = clampedSpan;
				semiInExtBrk[sOrE][gapParsed.type].inExtFrac = clampedSpan / (brk.vmax - brk.vmin);
				semiInExtBrk[sOrE][gapParsed.type].val = gapParsed.val;
			} else {
				fullyInExtBrksSum[gapParsed.type].span += clampedSpan;
				fullyInExtBrksSum[gapParsed.type].val += gapParsed.val;
			}
		}
	});
	var prctBrksGapRealSum = gapPrctSum * (0 + (scaleExtent[1] - scaleExtent[0]) + (fullyInExtBrksSum.tpAbs.val - fullyInExtBrksSum.tpAbs.span) + (semiInExtBrk.S.tpAbs.has ? (semiInExtBrk.S.tpAbs.val - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac : 0) + (semiInExtBrk.E.tpAbs.has ? (semiInExtBrk.E.tpAbs.val - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac : 0) - fullyInExtBrksSum.tpPrct.span - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac : 0)) / (1 - fullyInExtBrksSum.tpPrct.val - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac : 0));
	each(brkCtx.breaks, function(brk) {
		var gapParsed = brk.gapParsed;
		if (gapParsed.type === "tpPrct") brk.gapReal = gapPrctSum !== 0 ? Math.max(prctBrksGapRealSum, 0) * gapParsed.val / gapPrctSum : 0;
		if (gapParsed.type === "tpAbs") brk.gapReal = gapParsed.val;
		if (brk.gapReal == null) brk.gapReal = 0;
	});
}
function pruneTicksByBreak(pruneByBreak, ticks, breaks, getValue, interval, scaleExtent) {
	if (pruneByBreak === "no") return;
	each(breaks, function(brk) {
		var clampedBrk = clampBreakByExtent(brk, scaleExtent);
		if (!clampedBrk) return;
		for (var j = ticks.length - 1; j >= 0; j--) {
			var tick = ticks[j];
			var val = getValue(tick);
			var gap = interval * 3 / 4;
			if (val > clampedBrk.vmin - gap && val < clampedBrk.vmax + gap && (pruneByBreak !== "preserve_extent_bound" || val !== scaleExtent[0] && val !== scaleExtent[1])) ticks.splice(j, 1);
		}
	});
}
function addBreaksToTicks(ticks, breaks, scaleExtent, getTimeProps) {
	each(breaks, function(brk) {
		var clampedBrk = clampBreakByExtent(brk, scaleExtent);
		if (!clampedBrk) return;
		ticks.push({
			value: clampedBrk.vmin,
			"break": {
				type: "vmin",
				parsedBreak: clampedBrk
			},
			time: getTimeProps ? getTimeProps(clampedBrk) : void 0
		});
		ticks.push({
			value: clampedBrk.vmax,
			"break": {
				type: "vmax",
				parsedBreak: clampedBrk
			},
			time: getTimeProps ? getTimeProps(clampedBrk) : void 0
		});
	});
	if (breaks.length) ticks.sort(function(a, b) {
		return a.value - b.value;
	});
}
/**
* If break and extent does not intersect, return null/undefined.
* If the intersection is only a point at scaleExtent[0] or scaleExtent[1], return null/undefined.
*/
function clampBreakByExtent(brk, scaleExtent) {
	var vmin = Math.max(brk.vmin, scaleExtent[0]);
	var vmax = Math.min(brk.vmax, scaleExtent[1]);
	return vmin < vmax || vmin === vmax && vmin > scaleExtent[0] && vmin < scaleExtent[1] ? {
		vmin,
		vmax,
		breakOption: brk.breakOption,
		gapParsed: brk.gapParsed,
		gapReal: brk.gapReal
	} : null;
}
function parseAxisBreakOption(breakOptionList, parse$1, opt) {
	var parsedBreaks = [];
	if (!breakOptionList) return { breaks: parsedBreaks };
	function validatePercent(normalizedPercent, msg) {
		if (normalizedPercent >= 0 && normalizedPercent < .99999) return true;
		error(msg + " must be >= 0 and < 1, rather than " + normalizedPercent + " .");
		return false;
	}
	each(breakOptionList, function(brkOption) {
		if (!brkOption || brkOption.start == null || brkOption.end == null) {
			error("The input axis breaks start/end should not be empty.");
			return;
		}
		if (brkOption.isExpanded) return;
		var parsedBrk = {
			breakOption: clone(brkOption),
			vmin: parse$1(brkOption.start),
			vmax: parse$1(brkOption.end),
			gapParsed: {
				type: "tpAbs",
				val: 0
			},
			gapReal: null
		};
		if (brkOption.gap != null) {
			var isPrct = false;
			if (isString(brkOption.gap)) {
				var trimmedGap = trim(brkOption.gap);
				if (trimmedGap.match(/%$/)) {
					var normalizedPercent = parseFloat(trimmedGap) / 100;
					if (!validatePercent(normalizedPercent, "Percent gap")) normalizedPercent = 0;
					parsedBrk.gapParsed.type = "tpPrct";
					parsedBrk.gapParsed.val = normalizedPercent;
					isPrct = true;
				}
			}
			if (!isPrct) {
				var absolute = parse$1(brkOption.gap);
				if (!isFinite(absolute) || absolute < 0) {
					error("Axis breaks gap must positive finite rather than (" + brkOption.gap + ").");
					absolute = 0;
				}
				parsedBrk.gapParsed.type = "tpAbs";
				parsedBrk.gapParsed.val = absolute;
			}
		}
		if (parsedBrk.vmin === parsedBrk.vmax) {
			parsedBrk.gapParsed.type = "tpAbs";
			parsedBrk.gapParsed.val = 0;
		}
		if (opt && opt.noNegative) each(["vmin", "vmax"], function(se) {
			if (parsedBrk[se] < 0) {
				error("Axis break." + se + " must not be negative.");
				parsedBrk[se] = 0;
			}
		});
		if (parsedBrk.vmin > parsedBrk.vmax) {
			var tmp = parsedBrk.vmax;
			parsedBrk.vmax = parsedBrk.vmin;
			parsedBrk.vmin = tmp;
		}
		parsedBreaks.push(parsedBrk);
	});
	parsedBreaks.sort(function(item1, item2) {
		return item1.vmin - item2.vmin;
	});
	var lastEnd = -Infinity;
	each(parsedBreaks, function(brk, idx) {
		if (lastEnd > brk.vmin) {
			error("Axis breaks must not overlap.");
			parsedBreaks[idx] = null;
		}
		lastEnd = brk.vmax;
	});
	return { breaks: parsedBreaks.filter(function(brk) {
		return !!brk;
	}) };
}
function identifyAxisBreak(brk, identifier) {
	return serializeAxisBreakIdentifier(identifier) === serializeAxisBreakIdentifier(brk);
}
function serializeAxisBreakIdentifier(identifier) {
	return identifier.start + "_\0_" + identifier.end;
}
/**
* - A break pair represents `[vmin, vmax]`,
* - Only both vmin and vmax item exist, they are counted as a pair.
*/
function retrieveAxisBreakPairs(itemList, getVisualAxisBreak, returnIdx) {
	var idxPairList = [];
	each(itemList, function(el, idx) {
		var vBreak = getVisualAxisBreak(el);
		if (vBreak && vBreak.type === "vmin") idxPairList.push([idx]);
	});
	each(itemList, function(el, idx) {
		var vBreak = getVisualAxisBreak(el);
		if (vBreak && vBreak.type === "vmax") {
			var idxPair = find(idxPairList, function(pr) {
				return identifyAxisBreak(getVisualAxisBreak(itemList[pr[0]]).parsedBreak.breakOption, vBreak.parsedBreak.breakOption);
			});
			idxPair && idxPair.push(idx);
		}
	});
	var result = [];
	each(idxPairList, function(idxPair) {
		if (idxPair.length === 2) result.push(returnIdx ? idxPair : [itemList[idxPair[0]], itemList[idxPair[1]]]);
	});
	return result;
}
function getTicksLogTransformBreak(tick, logBase, logOriginalBreaks, fixRoundingError$1) {
	var vBreak;
	var brkRoundingCriterion;
	if (tick["break"]) {
		var brk = tick["break"].parsedBreak;
		var originalBreak = find(logOriginalBreaks, function(brk$1) {
			return identifyAxisBreak(brk$1.breakOption, tick["break"].parsedBreak.breakOption);
		});
		var vmin = fixRoundingError$1(Math.pow(logBase, brk.vmin), originalBreak.vmin);
		var vmax = fixRoundingError$1(Math.pow(logBase, brk.vmax), originalBreak.vmax);
		var gapParsed = {
			type: brk.gapParsed.type,
			val: brk.gapParsed.type === "tpAbs" ? round(Math.pow(logBase, brk.vmin + brk.gapParsed.val)) - vmin : brk.gapParsed.val
		};
		vBreak = {
			type: tick["break"].type,
			parsedBreak: {
				breakOption: brk.breakOption,
				vmin,
				vmax,
				gapParsed,
				gapReal: brk.gapReal
			}
		};
		brkRoundingCriterion = originalBreak[tick["break"].type];
	}
	return {
		brkRoundingCriterion,
		vBreak
	};
}
function logarithmicParseBreaksFromOption(breakOptionList, logBase, parse$1) {
	var opt = { noNegative: true };
	var parsedOriginal = parseAxisBreakOption(breakOptionList, parse$1, opt);
	var parsedLogged = parseAxisBreakOption(breakOptionList, parse$1, opt);
	var loggedBase = Math.log(logBase);
	parsedLogged.breaks = map(parsedLogged.breaks, function(brk) {
		var vmin = Math.log(brk.vmin) / loggedBase;
		return {
			vmin,
			vmax: Math.log(brk.vmax) / loggedBase,
			gapParsed: {
				type: brk.gapParsed.type,
				val: brk.gapParsed.type === "tpAbs" ? Math.log(brk.vmin + brk.gapParsed.val) / loggedBase - vmin : brk.gapParsed.val
			},
			gapReal: brk.gapReal,
			breakOption: brk.breakOption
		};
	});
	return {
		parsedOriginal,
		parsedLogged
	};
}
var BREAK_MIN_MAX_TO_PARAM = {
	vmin: "start",
	vmax: "end"
};
function makeAxisLabelFormatterParamBreak(extraParam, vBreak) {
	if (vBreak) {
		extraParam = extraParam || {};
		extraParam["break"] = {
			type: BREAK_MIN_MAX_TO_PARAM[vBreak.type],
			start: vBreak.parsedBreak.vmin,
			end: vBreak.parsedBreak.vmax
		};
	}
	return extraParam;
}
function installScaleBreakHelper() {
	registerScaleBreakHelperImpl({
		createScaleBreakContext,
		pruneTicksByBreak,
		addBreaksToTicks,
		parseAxisBreakOption,
		identifyAxisBreak,
		serializeAxisBreakIdentifier,
		retrieveAxisBreakPairs,
		getTicksLogTransformBreak,
		logarithmicParseBreaksFromOption,
		makeAxisLabelFormatterParamBreak
	});
}

//#endregion
//#region node_modules/echarts/lib/component/axis/axisBreakHelperImpl.js
/**
* @caution
*  Must not export anything except `installAxisBreakHelper`
*/
/**
* The zigzag shapes for axis breaks are generated according to some random
* factors. It should persist as much as possible to avoid constantly
* changing by every user operation.
*/
var viewCache = makeInner();
function ensureVisualInCache(visualList, targetBreak) {
	var visual = find(visualList, function(item) {
		return getScaleBreakHelper().identifyAxisBreak(item.parsedBreak.breakOption, targetBreak.breakOption);
	});
	if (!visual) visualList.push(visual = {
		zigzagRandomList: [],
		parsedBreak: targetBreak,
		shouldRemove: false
	});
	return visual;
}
function resetCacheVisualRemoveFlag(visualList) {
	each(visualList, function(item) {
		return item.shouldRemove = true;
	});
}
function removeUnusedCacheVisual(visualList) {
	for (var i$1 = visualList.length - 1; i$1 >= 0; i$1--) if (visualList[i$1].shouldRemove) visualList.splice(i$1, 1);
}
function rectCoordBuildBreakAxis(axisGroup, axisView, axisModel, coordSysRect, api) {
	var axis = axisModel.axis;
	if (axis.scale.isBlank() || !getScaleBreakHelper()) return;
	var breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({ breakTicks: "only_break" }), function(tick) {
		return tick["break"];
	}, false);
	if (!breakPairs.length) return;
	var breakAreaModel = axisModel.getModel("breakArea");
	var zigzagAmplitude = breakAreaModel.get("zigzagAmplitude");
	var zigzagMinSpan = breakAreaModel.get("zigzagMinSpan");
	var zigzagMaxSpan = breakAreaModel.get("zigzagMaxSpan");
	zigzagMinSpan = Math.max(2, zigzagMinSpan || 0);
	zigzagMaxSpan = Math.max(zigzagMinSpan, zigzagMaxSpan || 0);
	var expandOnClick = breakAreaModel.get("expandOnClick");
	var zigzagZ = breakAreaModel.get("zigzagZ");
	var itemStyle = breakAreaModel.getModel("itemStyle").getItemStyle();
	var borderColor = itemStyle.stroke;
	var borderWidth = itemStyle.lineWidth;
	var borderType = itemStyle.lineDash;
	var color$2 = itemStyle.fill;
	var group = new Group_default({ ignoreModelZ: true });
	var isAxisHorizontal = axis.isHorizontal();
	var cachedVisualList = viewCache(axisView).visualList || (viewCache(axisView).visualList = []);
	resetCacheVisualRemoveFlag(cachedVisualList);
	var _loop_1 = function(i$2) {
		var parsedBreak = breakPairs[i$2][0]["break"].parsedBreak;
		var coords = [];
		coords[0] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmin, true));
		coords[1] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmax, true));
		if (coords[1] < coords[0]) coords.reverse();
		var cachedVisual = ensureVisualInCache(cachedVisualList, parsedBreak);
		cachedVisual.shouldRemove = false;
		var breakGroup = new Group_default();
		addZigzagShapes(cachedVisual.zigzagRandomList, breakGroup, coords[0], coords[1], isAxisHorizontal, parsedBreak);
		if (expandOnClick) breakGroup.on("click", function() {
			var payload = {
				type: AXIS_BREAK_EXPAND_ACTION_TYPE,
				breaks: [{
					start: parsedBreak.breakOption.start,
					end: parsedBreak.breakOption.end
				}]
			};
			payload[axis.dim + "AxisIndex"] = axisModel.componentIndex;
			api.dispatchAction(payload);
		});
		breakGroup.silent = !expandOnClick;
		group.add(breakGroup);
	};
	for (var i$1 = 0; i$1 < breakPairs.length; i$1++) _loop_1(i$1);
	axisGroup.add(group);
	removeUnusedCacheVisual(cachedVisualList);
	function addZigzagShapes(zigzagRandomList, breakGroup, startCoord, endCoord, isAxisHorizontal$1, trimmedBreak) {
		var polylineStyle = {
			stroke: borderColor,
			lineWidth: borderWidth,
			lineDash: borderType,
			fill: "none"
		};
		var dimBrk = isAxisHorizontal$1 ? 0 : 1;
		var dimZigzag = 1 - dimBrk;
		var zigzagCoordMax = coordSysRect[XY[dimZigzag]] + coordSysRect[WH[dimZigzag]];
		function subPixelOpt(brkCoord) {
			var pBrk = [];
			var dummyP = [];
			pBrk[dimBrk] = dummyP[dimBrk] = brkCoord;
			pBrk[dimZigzag] = coordSysRect[XY[dimZigzag]];
			dummyP[dimZigzag] = zigzagCoordMax;
			var dummyShape = {
				x1: pBrk[0],
				y1: pBrk[1],
				x2: dummyP[0],
				y2: dummyP[1]
			};
			subPixelOptimizeLine(dummyShape, dummyShape, { lineWidth: 1 });
			pBrk[0] = dummyShape.x1;
			pBrk[1] = dummyShape.y1;
			return pBrk[dimBrk];
		}
		startCoord = subPixelOpt(startCoord);
		endCoord = subPixelOpt(endCoord);
		var pointsA = [];
		var pointsB = [];
		var isSwap = true;
		var current = coordSysRect[XY[dimZigzag]];
		for (var idx = 0;; idx++) {
			var isFirstPoint = current === coordSysRect[XY[dimZigzag]];
			var isLastPoint = current >= zigzagCoordMax;
			if (isLastPoint) current = zigzagCoordMax;
			var pA = [];
			var pB = [];
			pA[dimBrk] = startCoord;
			pB[dimBrk] = endCoord;
			if (!isFirstPoint && !isLastPoint) {
				pA[dimBrk] += isSwap ? -zigzagAmplitude : zigzagAmplitude;
				pB[dimBrk] -= !isSwap ? -zigzagAmplitude : zigzagAmplitude;
			}
			pA[dimZigzag] = current;
			pB[dimZigzag] = current;
			pointsA.push(pA);
			pointsB.push(pB);
			var randomVal = void 0;
			if (idx < zigzagRandomList.length) randomVal = zigzagRandomList[idx];
			else {
				randomVal = Math.random();
				zigzagRandomList.push(randomVal);
			}
			current += randomVal * (zigzagMaxSpan - zigzagMinSpan) + zigzagMinSpan;
			isSwap = !isSwap;
			if (isLastPoint) break;
		}
		var anidSuffix = getScaleBreakHelper().serializeAxisBreakIdentifier(trimmedBreak.breakOption);
		breakGroup.add(new Polyline_default({
			anid: "break_a_" + anidSuffix,
			shape: { points: pointsA },
			style: polylineStyle,
			z: zigzagZ
		}));
		if (trimmedBreak.gapReal !== 0) {
			breakGroup.add(new Polyline_default({
				anid: "break_b_" + anidSuffix,
				shape: { points: pointsB },
				style: polylineStyle,
				z: zigzagZ
			}));
			var pointsB2 = pointsB.slice();
			pointsB2.reverse();
			var polygonPoints = pointsA.concat(pointsB2);
			breakGroup.add(new Polygon_default({
				anid: "break_c_" + anidSuffix,
				shape: { points: polygonPoints },
				style: {
					fill: color$2,
					opacity: itemStyle.opacity
				},
				z: zigzagZ
			}));
		}
	}
}
function buildAxisBreakLine(axisModel, group, transformGroup, pathBaseProp) {
	var axis = axisModel.axis;
	var transform = transformGroup.transform;
	assert(pathBaseProp.style);
	var extent = axis.getExtent();
	if (axis.inverse) {
		extent = extent.slice();
		extent.reverse();
	}
	var brkLayoutList = map(getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({ breakTicks: "only_break" }), function(tick) {
		return tick["break"];
	}, false), function(breakPair) {
		var parsedBreak = breakPair[0]["break"].parsedBreak;
		var coordPair = [axis.dataToCoord(parsedBreak.vmin, true), axis.dataToCoord(parsedBreak.vmax, true)];
		coordPair[0] > coordPair[1] && coordPair.reverse();
		return {
			coordPair,
			brkId: getScaleBreakHelper().serializeAxisBreakIdentifier(parsedBreak.breakOption)
		};
	});
	brkLayoutList.sort(function(layout1, layout2) {
		return layout1.coordPair[0] - layout2.coordPair[0];
	});
	var ySegMin = extent[0];
	var lastLayout = null;
	for (var idx = 0; idx < brkLayoutList.length; idx++) {
		var layout$3 = brkLayoutList[idx];
		var brkTirmmedMin = Math.max(layout$3.coordPair[0], extent[0]);
		var brkTirmmedMax = Math.min(layout$3.coordPair[1], extent[1]);
		if (ySegMin <= brkTirmmedMin) addSeg(ySegMin, brkTirmmedMin, lastLayout, layout$3);
		ySegMin = brkTirmmedMax;
		lastLayout = layout$3;
	}
	if (ySegMin <= extent[1]) addSeg(ySegMin, extent[1], lastLayout, null);
	function addSeg(min$2, max$2, layout1, layout2) {
		function trans(p1, p2) {
			if (transform) {
				applyTransform(p1, p1, transform);
				applyTransform(p2, p2, transform);
			}
		}
		function subPixelOptimizePP(p1, p2) {
			var shape = {
				x1: p1[0],
				y1: p1[1],
				x2: p2[0],
				y2: p2[1]
			};
			subPixelOptimizeLine(shape, shape, pathBaseProp.style);
			p1[0] = shape.x1;
			p1[1] = shape.y1;
			p2[0] = shape.x2;
			p2[1] = shape.y2;
		}
		var lineP1 = [min$2, 0];
		var lineP2 = [max$2, 0];
		var dummyTickEnd1 = [min$2, 5];
		var dummyTickEnd2 = [max$2, 5];
		trans(lineP1, dummyTickEnd1);
		subPixelOptimizePP(lineP1, dummyTickEnd1);
		trans(lineP2, dummyTickEnd2);
		subPixelOptimizePP(lineP2, dummyTickEnd2);
		subPixelOptimizePP(lineP1, lineP2);
		var seg = new Line_default(extend({ shape: {
			x1: lineP1[0],
			y1: lineP1[1],
			x2: lineP2[0],
			y2: lineP2[1]
		} }, pathBaseProp));
		group.add(seg);
		seg.anid = "breakLine_" + (layout1 ? layout1.brkId : "\0") + "_\0_" + (layout2 ? layout2.brkId : "\0");
	}
}
/**
* Resolve the overlap of a pair of labels.
*
* [CAUTION] Only label.x/y are allowed to change.
*/
function adjustBreakLabelPair(axisInverse, axisRotation, layoutPair) {
	if (find(layoutPair, function(item) {
		return !item;
	})) return;
	var mtv = new Point_default();
	if (!labelIntersect(layoutPair[0], layoutPair[1], mtv, {
		direction: -(axisInverse ? axisRotation + Math.PI : axisRotation),
		touchThreshold: 0,
		bidirectional: false
	})) return;
	var axisStTrans = create$2();
	rotate(axisStTrans, axisStTrans, -axisRotation);
	var labelPairStTrans = map(layoutPair, function(layout$3) {
		return layout$3.transform ? mul(create$2(), axisStTrans, layout$3.transform) : axisStTrans;
	});
	function isParallelToAxis(whIdx) {
		var localRect = layoutPair[0].localRect;
		var labelVec0 = new Point_default(localRect[WH[whIdx]] * labelPairStTrans[0][0], localRect[WH[whIdx]] * labelPairStTrans[0][1]);
		return Math.abs(labelVec0.y) < 1e-5;
	}
	var k$1 = .5;
	if (isParallelToAxis(0) || isParallelToAxis(1)) {
		var rectSt = map(layoutPair, function(layout$3, idx) {
			var rect = layout$3.localRect.clone();
			rect.applyTransform(labelPairStTrans[idx]);
			return rect;
		});
		var brkCenterSt = new Point_default();
		brkCenterSt.copy(layoutPair[0].label).add(layoutPair[1].label).scale(.5);
		brkCenterSt.transform(axisStTrans);
		var mtvSt = mtv.clone().transform(axisStTrans);
		var qval = (rectSt[0].x + rectSt[1].x + (mtvSt.x >= 0 ? rectSt[0].width : rectSt[1].width) + mtvSt.x) / 2 - brkCenterSt.x;
		var uvalMin = Math.min(qval, qval - mtvSt.x);
		var uvalMax = Math.max(qval, qval - mtvSt.x);
		k$1 = (qval - (uvalMax < 0 ? uvalMax : uvalMin > 0 ? uvalMin : 0)) / mtvSt.x;
	}
	var delta0 = new Point_default();
	var delta1 = new Point_default();
	Point_default.scale(delta0, mtv, -k$1);
	Point_default.scale(delta1, mtv, 1 - k$1);
	labelLayoutApplyTranslation(layoutPair[0], delta0);
	labelLayoutApplyTranslation(layoutPair[1], delta1);
}
function updateModelAxisBreak(model, payload) {
	var result = { breaks: [] };
	each(payload.breaks, function(inputBrk) {
		if (!inputBrk) return;
		var breakOption = find(model.get("breaks", true), function(brkOption) {
			return getScaleBreakHelper().identifyAxisBreak(brkOption, inputBrk);
		});
		if (!breakOption) {
			warn("Can not find axis break by start: " + inputBrk.start + ", end: " + inputBrk.end);
			return;
		}
		var actionType = payload.type;
		var old = { isExpanded: !!breakOption.isExpanded };
		breakOption.isExpanded = actionType === AXIS_BREAK_EXPAND_ACTION_TYPE ? true : actionType === AXIS_BREAK_COLLAPSE_ACTION_TYPE ? false : actionType === AXIS_BREAK_TOGGLE_ACTION_TYPE ? !breakOption.isExpanded : breakOption.isExpanded;
		result.breaks.push({
			start: breakOption.start,
			end: breakOption.end,
			isExpanded: !!breakOption.isExpanded,
			old
		});
	});
	return result;
}
function installAxisBreakHelper() {
	registerAxisBreakHelperImpl({
		adjustBreakLabelPair,
		buildAxisBreakLine,
		rectCoordBuildBreakAxis,
		updateModelAxisBreak
	});
}

//#endregion
//#region node_modules/echarts/lib/component/axis/installBreak.js
function installAxisBreak(registers) {
	registerAction$1(registers);
	installScaleBreakHelper();
	installAxisBreakHelper();
}

//#endregion
//#region node_modules/echarts/lib/coord/cartesian/legacyContainLabel.js
/**
* [CAUTION] Never export methods other than `installLegacyGridContainLabel`.
*/
function installLegacyGridContainLabel() {
	registerLegacyGridContainLabelImpl(legacyLayOutGridByContained);
}
/**
* The input gridRect and axes will be modified.
*/
function legacyLayOutGridByContained(axesList, gridRect) {
	each(axesList, function(axis) {
		if (!axis.model.get(["axisLabel", "inside"])) {
			var labelUnionRect = estimateLabelUnionRect(axis);
			if (labelUnionRect) {
				var dim = axis.isHorizontal() ? "height" : "width";
				var margin = axis.model.get(["axisLabel", "margin"]);
				gridRect[dim] -= labelUnionRect[dim] + margin;
				if (axis.position === "top") gridRect.y += labelUnionRect.height + margin;
				else if (axis.position === "left") gridRect.x += labelUnionRect.width + margin;
			}
		}
	});
}
/**
* @return Be null/undefined if no labels.
*/
function estimateLabelUnionRect(axis) {
	var axisModel = axis.model;
	var scale$3 = axis.scale;
	if (!axisModel.get(["axisLabel", "show"]) || scale$3.isBlank()) return;
	var realNumberScaleTicks;
	var tickCount;
	var categoryScaleExtent = scale$3.getExtent();
	if (scale$3 instanceof Ordinal_default) tickCount = scale$3.count();
	else {
		realNumberScaleTicks = scale$3.getTicks();
		tickCount = realNumberScaleTicks.length;
	}
	var axisLabelModel = axis.getLabelModel();
	var labelFormatter = makeLabelFormatter(axis);
	var rect;
	var step = 1;
	if (tickCount > 40) step = Math.ceil(tickCount / 40);
	for (var i$1 = 0; i$1 < tickCount; i$1 += step) {
		var label = labelFormatter(realNumberScaleTicks ? realNumberScaleTicks[i$1] : { value: categoryScaleExtent[0] + i$1 }, i$1);
		var singleRect = rotateTextRect(axisLabelModel.getTextRect(label), axisLabelModel.get("rotate") || 0);
		rect ? rect.union(singleRect) : rect = singleRect;
	}
	return rect;
	function rotateTextRect(textRect, rotate$1) {
		var rotateRadians = rotate$1 * Math.PI / 180;
		var beforeWidth = textRect.width;
		var beforeHeight = textRect.height;
		var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
		var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
		return new BoundingRect_default(textRect.x, textRect.y, afterWidth, afterHeight);
	}
}

//#endregion
//#region node_modules/echarts/index.js
use([install$1]);
use([install]);
use([
	install$2,
	install$3,
	install$4,
	install$5,
	install$6,
	install$7,
	install$8,
	install$9,
	install$10,
	install$11,
	install$12,
	install$13,
	install$14,
	install$15,
	install$16,
	install$17,
	install$18,
	install$19,
	install$20,
	install$21,
	install$22,
	install$23,
	install$24
]);
use(install$25);
use(install$26);
use(install$27);
use(install$28);
use(install$29);
use(install$30);
use(install$31);
use(install$32);
use(install$33);
use(install$34);
use(install$35);
use(install$36);
use(install$37);
use(install$38);
use(install$39);
use(install$40);
use(install$41);
use(install$42);
use(install$43);
use(install$44);
use(install$45);
use(install$46);
use(install$47);
use(install$48);
use(install$49);
use(install$50);
use(install$52);
use(install$51);
use(installUniversalTransition);
use(installLabelLayout);
use(installAxisBreak);
use(installLegacyGridContainLabel);
use(installScatterJitter);

//#endregion
export { Axis_default as Axis, Chart_default as ChartView, Component_default as ComponentModel, Component_default$1 as ComponentView, SeriesData_default as List, Model_default as Model, PRIORITY, Series_default as SeriesModel, color_exports as color, connect, dataTool, dependencies, disConnect, disconnect, dispose, env_default as env, extendChartView, extendComponentModel, extendComponentView, extendSeriesModel, format_exports as format, getCoordinateSystemDimensions, getInstanceByDom, getInstanceById, getMap, graphic_exports as graphic, helper_exports as helper, init, brushSingle as innerDrawElementOnCanvas, matrix_exports as matrix, number_exports as number, parseGeoJSON, parseGeoJSON as parseGeoJson, registerAction, registerCoordinateSystem, registerCustomSeries, registerLayout, registerLoading, registerLocale, registerMap, registerPostInit, registerPostUpdate, registerPreprocessor, registerProcessor, registerTheme, registerTransform, registerUpdateLifecycle, registerVisual, setCanvasCreator, setPlatformAPI, throttle, time_exports as time, use, util_exports as util, vector_exports as vector, version, util_exports$1 as zrUtil, zrender_exports as zrender };
//# sourceMappingURL=echarts.js.map